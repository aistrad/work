     1→"""
     2→CoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索的智能体
     3→
     4→v6 架构特性：
     5→- Scenario 路由：根据用户消息匹配最佳场景
     6→- PostgreSQL 知识检索：RAG + 案例匹配
     7→- 7 阶段 SOP：P1-P2 强制，P3-P7 LLM 自由发挥
     8→- 工具-卡片映射：标准化工具元数据
     9→"""
    10→import json
    11→import logging
    12→from typing import Optional, List, Dict, Any, AsyncGenerator
    13→from dataclasses import dataclass
    14→from enum import Enum
    15→
    16→from services.llm import LLMClient, get_llm_client
    17→from services.llm.client import LLMMessage
    18→from services.knowledge.repository import get_knowledge_repository, KnowledgeRepository
    19→from .skill_loader import (
    20→    load_skill, load_scenario, get_skill_triggers,
    21→    build_system_prompt, SkillConfig, ScenarioConfig,
    22→    route_scenario as memory_route_scenario,
    23→    get_available_skills, get_skill_scenarios
    24→)
    25→from .sop_engine import SOPEngine, SOPAction, SOPPhase, check_sop_requirements
    26→from .tool_registry import ToolRegistry, ToolContext
    27→
    28→logger = logging.getLogger(__name__)
    29→
    30→
    31→class AgentState(str, Enum):
    32→    """Agent 执行状态"""
    33→    IDLE = "idle"
    34→    THINKING = "thinking"
    35→    TOOL_CALLING = "tool_calling"
    36→    COMPLETED = "completed"
    37→    ERROR = "error"
    38→
    39→
    40→@dataclass
    41→class AgentEvent:
    42→    """Agent 执行事件"""
    43→    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase
    44→    data: Any = None
    45→
    46→
    47→@dataclass
    48→class AgentContext:
    49→    """Agent 执行上下文"""
    50→    user_id: str
    51→    user_tier: str = "free"
    52→    profile: Optional[Dict[str, Any]] = None
    53→    skill_data: Optional[Dict[str, Any]] = None
    54→    history: Optional[List[Dict[str, str]]] = None
    55→    skill: Optional[str] = None
    56→    scenario: Optional[str] = None
    57→    portrait: Optional[str] = None
    58→    conversation_id: Optional[str] = None
    59→    voice_mode: Optional[str] = "warm"
    60→    recent_insights: Optional[List[Any]] = None
    61→
    62→
    63→def build_use_skill_tool() -> Dict[str, Any]:
    64→    """
    65→    动态构建 use_skill 工具定义
    66→
    67→    从 SKILL.md 自动读取：
    68→    - 可用的 Skills 列表
    69→    - 每个 Skill 的触发词
    70→    - 每个 Skill 的场景列表
    71→    """
    72→    # 获取所有可用 Skills 和触发词
    73→    triggers = get_skill_triggers()
    74→    available_skills = [s for s in get_available_skills() if s != "core"]
    75→
    76→    # 构建 Skill 路由说明
    77→    skill_routing = "## Skill 路由\n"
    78→    for skill_id in available_skills:
    79→        skill = load_skill(skill_id)
    80→        if skill and skill.triggers:
    81→            trigger_str = "、".join(skill.triggers[:5])  # 最多显示5个触发词
    82→            skill_routing += f"- {trigger_str} → skill: \"{skill_id}\"\n"
    83→
    84→    # 构建场景目录（只列出主要场景，避免 description 过长）
    85→    scenario_catalog = "\n## 场景目录（常用）\n"
    86→    for skill_id in available_skills:
    87→        scenarios = get_skill_scenarios(skill_id)
    88→        if scenarios:
    89→            # 只列出前5个场景
    90→            top_scenarios = scenarios[:5]
    91→            scenario_catalog += f"\n### {skill_id}\n"
    92→            for s in top_scenarios:
    93→                scenario_catalog += f"- {s}\n"
    94→            if len(scenarios) > 5:
    95→                scenario_catalog += f"- ... (共 {len(scenarios)} 个场景)\n"
    96→
    97→    description = f"""激活专业技能来回答用户问题。一次决定 skill、scenario 和 confidence。
    98→
    99→{skill_routing}
   100→{scenario_catalog}
   101→
   102→## Confidence 说明
   103→- high: 用户意图明确，直接执行
   104→- medium: 基本确定，可能需要追问细节
   105→- low: 不确定，需要向用户确认
   106→
   107→重要：如果用户消息中已经包含了出生信息，设置 birth_info_provided=true。"""
   108→
   109→    return {
   110→        "type": "function",
   111→        "function": {
   112→            "name": "use_skill",
   113→            "description": description,
   114→            "parameters": {
   115→                "type": "object",
   116→                "properties": {
   117→                    "skill": {
   118→                        "type": "string",
   119→                        "enum": available_skills,
   120→                        "description": "要使用的技能"
   121→                    },
   122→                    "scenario": {
   123→                        "type": "string",
   124→                        "description": "场景 ID，参考上方场景目录"
   125→                    },
   126→                    "confidence": {
   127→                        "type": "string",
   128→                        "enum": ["high", "medium", "low"],
   129→                        "description": "路由置信度"
   130→                    },
   131→                    "topic": {
   132→                        "type": "string",
   133→                        "enum": ["career", "relationship", "fortune", "health", "self", "general"],
   134→                        "description": "用户关注的话题类型"
   135→                    },
   136→                    "birth_info_provided": {
   137→                        "type": "boolean",
   138→                        "description": "用户消息中是否已包含出生信息"
   139→                    }
   140→                },
   141→                "required": ["skill", "scenario", "confidence"]
   142→            }
   143→        }
   144→    }
   145→
   146→
   147→# 缓存动态生成的工具定义
   148→_USE_SKILL_TOOL_CACHE: Optional[Dict[str, Any]] = None
   149→
   150→
   151→def get_use_skill_tool() -> Dict[str, Any]:
   152→    """获取 use_skill 工具定义（带缓存）"""
   153→    global _USE_SKILL_TOOL_CACHE
   154→    if _USE_SKILL_TOOL_CACHE is None:
   155→        _USE_SKILL_TOOL_CACHE = build_use_skill_tool()
   156→    return _USE_SKILL_TOOL_CACHE
   157→
   158→
   159→class CoreAgent:
   160→    """
   161→    CoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索
   162→
   163→    Features:
   164→    - Scenario routing via PostgreSQL
   165→    - Knowledge retrieval (RAG + cases)
   166→    - 7-phase SOP execution
   167→    - Tool-card mapping
   168→    """
   169→
   170→    def __init__(
   171→        self,
   172→        llm: Optional[LLMClient] = None,
   173→        max_iterations: int = 10,
   174→        knowledge_repo: Optional[KnowledgeRepository] = None
   175→    ):
   176→        self.llm = llm or get_llm_client()
   177→        self.max_iterations = max_iterations
   178→        self.knowledge_repo = knowledge_repo or get_knowledge_repository()
   179→        self.state = AgentState.IDLE
   180→        self._active_skill: Optional[str] = None
   181→        self._active_scenario: Optional[str] = None
   182→        self._topic: Optional[str] = None
   183→        self._current_message: str = ""
   184→
   185→    @property
   186→    def usage(self) -> Dict[str, int]:
   187→        """获取 LLM 使用统计"""
   188→        return self.llm.usage
   189→
   190→    async def run(
   191→        self,
   192→        message: str,
   193→        context: AgentContext
   194→    ) -> AsyncGenerator[AgentEvent, None]:
   195→        """执行 Agent 循环"""
   196→        self.state = AgentState.IDLE
   197→        self._current_message = message
   198→
   199→        # 使用前端指定的 skill/scenario，或让 LLM 决定
   200→        if context.skill:
   201→            self._active_skill = context.skill
   202→            self._active_scenario = context.scenario or await self._route_scenario(context.skill, message)
   203→        else:
   204→            self._active_skill = None
   205→            self._active_scenario = None
   206→
   207→        # 检查 SOP 要求
   208→        if self._active_skill:
   209→            action, sop_context = check_sop_requirements(
   210→                skill_id=self._active_skill,
   211→                scenario_id=self._active_scenario,
   212→                profile=context.profile,
   213→                skill_data=context.skill_data,
   214→                message=message
   215→            )
   216→
   217→            yield AgentEvent(type="sop_phase", data={
   218→                "skill": self._active_skill,
   219→                "scenario": self._active_scenario,
   220→                "action": action.value,
   221→                "phase": sop_context.get("phase", SOPPhase.ANALYZE).value,
   222→                "context": sop_context
   223→            })
   224→
   225→        # 构建初始消息
   226→        messages = await self._build_initial_messages(message, context)
   227→
   228→        for iteration in range(self.max_iterations):
   229→            self.state = AgentState.THINKING
   230→            yield AgentEvent(type="thinking", data={"iteration": iteration})
   231→
   232→            tools = self._get_current_tools(context)
   233→
   234→            try:
   235→                content_buffer = ""
   236→                tool_calls = []
   237→
   238→                async for chunk in self.llm.stream(
   239→                    messages=messages,
   240→                    tools=tools,
   241→                    tool_choice=None,
   242→                    user_tier=context.user_tier
   243→                ):
   244→                    if chunk["type"] == "content":
   245→                        content_buffer += chunk["content"]
   246→                        yield AgentEvent(type="content", data={"content": chunk["content"]})
   247→                    elif chunk["type"] == "tool_call":
   248→                        tool_calls.append(chunk)
   249→
   250→                if tool_calls:
   251→                    self.state = AgentState.TOOL_CALLING
   252→
   253→                    assistant_tool_calls = []
   254→                    for tc in tool_calls:
   255→                        assistant_tool_calls.append({
   256→                            "id": tc["tool_call_id"],
   257→                            "function": {
   258→                                "name": tc["tool_name"],
   259→                                "arguments": tc["tool_args"]
   260→                            }
   261→                        })
   262→                    messages.append(LLMMessage(
   263→                        role="assistant",
   264→                        content=content_buffer or "",
   265→                        tool_calls=assistant_tool_calls
   266→                    ))
   267→                    content_buffer = ""
   268→
   269→                    tool_results = []
   270→                    for tc in tool_calls:
   271→                        tool_name = tc["tool_name"]
   272→                        tool_args = tc["tool_args"]
   273→                        tool_call_id = tc["tool_call_id"]
   274→
   275→                        yield AgentEvent(type="tool_call", data={
   276→                            "id": tool_call_id,
   277→                            "name": tool_name,
   278→                            "arguments": tool_args
   279→                        })
   280→
   281→                        result = await self._execute_tool(tool_name, tool_args, context)
   282→                        tool_results.append({
   283→                            "tool_call_id": tool_call_id,
   284→                            "result": result
   285→                        })
   286→
   287→                        yield AgentEvent(type="tool_result", data={
   288→                            "id": tool_call_id,
   289→                            "name": tool_name,
   290→                            "result": result
   291→                        })
   292→
   293→                    for tr in tool_results:
   294→                        result_content = tr["result"]
   295→                        if isinstance(result_content, dict):
   296→                            result_content = json.dumps(result_content, ensure_ascii=False)
   297→                        messages.append(LLMMessage(
   298→                            role="tool",
   299→                            content=str(result_content),
   300→                            tool_call_id=tr["tool_call_id"]
   301→                        ))
   302→                else:
   303→                    self.state = AgentState.COMPLETED
   304→                    yield AgentEvent(type="done", data={"content": content_buffer})
   305→                    return
   306→
   307→            except Exception as e:
   308→                self.state = AgentState.ERROR
   309→                logger.error(f"Agent error: {e}")
   310→                yield AgentEvent(type="error", data={"error": str(e)})
   311→                return
   312→
   313→        self.state = AgentState.COMPLETED
   314→        yield AgentEvent(type="done", data={"max_iterations_reached": True})
   315→
   316→    async def _route_scenario(self, skill_id: str, message: str) -> Optional[str]:
   317→        """场景路由 - 根据消息匹配最佳场景"""
   318→        try:
   319→            matches = await self.knowledge_repo.route_scenario(skill_id, message)
   320→            if matches:
   321→                return matches[0].scenario_id
   322→        except Exception as e:
   323→            logger.warning(f"Scenario routing failed: {e}")
   324→
   325→        # 回退到默认场景
   326→        skill = load_skill(skill_id)
   327→        return skill.default_scenario if skill else "basic_reading"
   328→
   329→    async def _build_initial_messages(
   330→        self,
   331→        message: str,
   332→        context: AgentContext
   333→    ) -> List[LLMMessage]:
   334→        """构建初始消息列表"""
   335→        system_prompt = await self._build_system_prompt(message, context)
   336→
   337→        messages = [LLMMessage(role="system", content=system_prompt)]
   338→
   339→        if context.history:
   340→            for msg in context.history[-10:]:
   341→                messages.append(LLMMessage(
   342→                    role=msg.get("role", "user"),
   343→                    content=msg.get("content", "")
   344→                ))
   345→
   346→        messages.append(LLMMessage(role="user", content=message))
   347→        return messages
   348→
   349→    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:
   350→        """构建 System Prompt"""
   351→        parts = []
   352→
   353→        # 基础 prompt
   354→        if self._active_skill:
   355→            # 传递完整 profile，让 skill_loader 自动处理所有字段
   356→            user_ctx = dict(context.profile) if context.profile else {}
   357→            user_ctx["portrait"] = context.portrait
   358→            base_prompt = build_system_prompt(
   359→                self._active_skill,
   360→                self._active_scenario,
   361→                user_ctx
   362→            )
   363→            parts.append(base_prompt)
   364→
   365→            # 知识检索
   366→            try:
   367→                knowledge = await self.knowledge_repo.search_knowledge(
   368→                    self._active_skill, message, top_k=5
   369→                )
   370→                if knowledge:
   371→                    knowledge_text = "\n## 相关知识\n\n"
   372→                    for chunk in knowledge:
   373→                        knowledge_text += f"**{chunk.book_name}** ({chunk.chapter or ''})\n{chunk.chunk_text[:500]}...\n\n"
   374→                    parts.append(knowledge_text)
   375→            except Exception as e:
   376→                logger.warning(f"Knowledge retrieval failed: {e}")
   377→
   378→            # 案例匹配 - 使用智能匹配器
   379→            try:
   380→                from .case_matcher import match_cases_smart
   381→                cases = await match_cases_smart(
   382→                    self.knowledge_repo,
   383→                    skill_id=self._active_skill,
   384→                    scenario_id=self._active_scenario,
   385→                    skill_data=context.skill_data,
   386→                    top_k=2
   387→                )
   388→                if cases:
   389→                    cases_text = "\n## 相关案例\n\n"
   390→                    for case in cases:
   391→                        cases_text += f"**{case.name}**\n{json.dumps(case.conclusion, ensure_ascii=False)}\n\n"
   392→                    parts.append(cases_text)
   393→            except Exception as e:
   394→                logger.warning(f"Case matching failed: {e}")
   395→        else:
   396→            # 无 skill 时，添加触发规则
   397→            triggers = get_skill_triggers()
   398→            if triggers:
   399→                trigger_rules = "## 技能触发规则\n\n当用户消息包含以下关键词时，调用 `use_skill` 工具：\n"
   400→                for skill_name, keywords in triggers.items():
   401→                    trigger_rules += f"- **{skill_name}**: {', '.join(keywords)}\n"
   402→                parts.append(trigger_rules)
   403→
   404→        # 用户命盘数据
   405→        if context.skill_data and self._active_skill:
   406→            skill_data = context.skill_data.get(self._active_skill, {})
   407→            if skill_data:
   408→                parts.append(f"\n## 用户命盘数据\n{json.dumps(skill_data, ensure_ascii=False, indent=2)}")
   409→
   410→        return "\n".join(parts)
   411→
   412→    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:
   413→        """获取当前可用工具 - V6: 从统一注册表获取"""
   414→        if not context.skill and not self._active_skill:
   415→            return [get_use_skill_tool()]
   416→
   417→        skill_id = self._active_skill or context.skill
   418→
   419→        # 从统一注册表获取工具（YAML 为数据源）
   420→        tools = ToolRegistry.get_tools_for_skill(skill_id)
   421→        return tools if tools else [get_use_skill_tool()]
   422→
   423→    async def _execute_tool(
   424→        self,
   425→        tool_name: str,
   426→        tool_args: str,
   427→        context: AgentContext
   428→    ) -> Dict[str, Any]:
   429→        """执行工具调用 - V6.1: 完全使用统一注册表"""
   430→        try:
   431→            args = json.loads(tool_args) if tool_args else {}
   432→        except json.JSONDecodeError:
   433→            args = {}
   434→
   435→        # 特殊处理 use_skill（路由工具）
   436→        if tool_name == "use_skill":
   437→            return await self._handle_use_skill(args, context)
   438→
   439→        # 创建工具上下文
   440→        tool_context = ToolContext(
   441→            user_id=context.user_id,
   442→            user_tier=context.user_tier,
   443→            profile=context.profile or {},
   444→            skill_data=context.skill_data or {},
   445→            skill_id=self._active_skill,
   446→            scenario_id=self._active_scenario,
   447→            conversation_id=context.conversation_id
   448→        )
   449→
   450→        # 使用统一注册表执行工具
   451→        if ToolRegistry.has_handler(tool_name):
   452→            return await ToolRegistry.execute(tool_name, args, tool_context)
   453→
   454→        # 未找到处理器
   455→        logger.warning(f"No handler found for tool: {tool_name}")
   456→        return {"status": "unknown_tool", "tool": tool_name, "message": f"工具 {tool_name} 暂未实现"}
   457→
   458→    async def _handle_search_db(
   459→        self,
   460→        args: Dict[str, Any],
   461→        context: AgentContext
   462→    ) -> Dict[str, Any]:
   463→        """处理 search_db 工具调用"""
   464→        table = args.get("table", "knowledge_chunks")
   465→        query = args.get("query", "")
   466→        filters = args.get("filters", {})
   467→        top_k = args.get("top_k", 5)
   468→
   469→        # 自动添加当前 skill_id 到 filters
   470→        if self._active_skill and "skill_id" not in filters:
   471→            filters["skill_id"] = self._active_skill
   472→        if self._active_scenario and "scenario_id" not in filters:
   473→            filters["scenario_id"] = self._active_scenario
   474→
   475→        results = await self.knowledge_repo.search_db(
   476→            table=table,
   477→            query=query,
   478→            filters=filters,
   479→            top_k=top_k
   480→        )
   481→
   482→        return {
   483→            "status": "success",
   484→            "table": table,
   485→            "query": query,
   486→            "count": len(results),
   487→            "results": results
   488→        }
   489→
   490→    async def _handle_use_skill(
   491→        self,
   492→        args: Dict[str, Any],
   493→        context: AgentContext
   494→    ) -> Dict[str, Any]:
   495→        """处理 skill 选择 - V6: 一次决定 skill + scenario + confidence"""
   496→        skill = args.get("skill")
   497→        scenario = args.get("scenario", "basic_reading")
   498→        confidence = args.get("confidence", "high")
   499→        topic = args.get("topic", "general")
   500→
   501→        if not skill:
   502→            return {"status": "error", "message": "No skill specified"}
   503→
   504→        self._active_skill = skill
   505→        self._active_scenario = scenario
   506→        self._topic = topic
   507→
   508→        # 低置信度时，返回确认请求
   509→        if confidence == "low":
   510→            return {
   511→                "status": "need_confirm",
   512→                "skill": skill,
   513→                "scenario": scenario,
   514→                "confidence": confidence,
   515→                "message": f"我理解您可能想使用 {skill} 的 {scenario} 服务，请确认是否正确？"
   516→            }
   517→
   518→        # 检查是否需要出生信息
   519→        needs_birth = skill in ["bazi", "zodiac"]
   520→        has_birth = context.profile and context.profile.get("birth_info")
   521→        birth_provided = args.get("birth_info_provided", False)
   522→
   523→        if needs_birth and not has_birth and not birth_provided:
   524→            return {
   525→                "status": "need_info",
   526→                "skill": skill,
   527→                "scenario": scenario,
   528→                "confidence": confidence,
   529→                "topic": topic,
   530→                "info_type": "birth",
   531→                "message": "技能已激活。请调用 request_info 工具收集出生信息。"
   532→            }
   533→
   534→        return {
   535→            "status": "activated",
   536→            "skill": skill,
   537→            "scenario": scenario,
   538→            "confidence": confidence,
   539→            "topic": topic,
   540→            "message": f"已激活 {skill} 技能，场景: {scenario}"
   541→        }
   542→
   543→
   544→def create_agent(
   545→    llm: Optional[LLMClient] = None,
   546→    max_iterations: int = 10
   547→) -> CoreAgent:
   548→    """创建 CoreAgent 实例"""
   549→    return CoreAgent(llm=llm, max_iterations=max_iterations)
   550→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
