{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":"Explore the VibeLife agent architecture in /home/aiscend/work/vibelife/apps/api/services/agent/. Focus on:\n1. How the current agent system works (core.py, skill_loader.py)\n2. Tool registration and execution patterns\n3. How skills define and use tools\n\nReturn a summary of the architecture and how tools are currently implemented."},"uuid":"f4deb439-7f5b-45c4-8d84-a8b2c63af2b6","timestamp":"2026-01-18T03:42:34.785Z"}
{"parentUuid":"f4deb439-7f5b-45c4-8d84-a8b2c63af2b6","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01CYMuZXHkLHa1e3Vzu7ehY3","type":"message","role":"assistant","content":[{"type":"text","text":"I'll explore the VibeLife agent architecture to understand how the agent system, tool registration, and skill tools work together."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":27588,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27588,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"}},"requestId":"req_011CXE9nDyT1qJWTrcBuTSn7","type":"assistant","uuid":"fc168aff-5046-480f-8ec8-3647ee36a2e6","timestamp":"2026-01-18T03:42:37.248Z"}
{"parentUuid":"fc168aff-5046-480f-8ec8-3647ee36a2e6","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01CYMuZXHkLHa1e3Vzu7ehY3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BMtiXDPaXoMYjoMc3wDqHn","name":"Glob","input":{"pattern":"/home/aiscend/work/vibelife/apps/api/services/agent/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":27588,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27588,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"}},"requestId":"req_011CXE9nDyT1qJWTrcBuTSn7","type":"assistant","uuid":"6124be34-6bfc-4378-a51d-87677e3d39c7","timestamp":"2026-01-18T03:42:37.494Z"}
{"parentUuid":"6124be34-6bfc-4378-a51d-87677e3d39c7","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01CYMuZXHkLHa1e3Vzu7ehY3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P9iNGqkkNHHmafUronYnf4","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":27588,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27588,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"}},"requestId":"req_011CXE9nDyT1qJWTrcBuTSn7","type":"assistant","uuid":"dbbc4835-7738-48ab-a186-3b605f0b6153","timestamp":"2026-01-18T03:42:37.674Z"}
{"parentUuid":"dbbc4835-7738-48ab-a186-3b605f0b6153","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"EISDIR: illegal operation on a directory, read","is_error":true,"tool_use_id":"toolu_01P9iNGqkkNHHmafUronYnf4"}]},"uuid":"e4a69e28-f938-46fa-b354-cd7fe34edb77","timestamp":"2026-01-18T03:42:37.813Z","toolUseResult":"Error: EISDIR: illegal operation on a directory, read","sourceToolAssistantUUID":"dbbc4835-7738-48ab-a186-3b605f0b6153"}
{"parentUuid":"6124be34-6bfc-4378-a51d-87677e3d39c7","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BMtiXDPaXoMYjoMc3wDqHn","type":"tool_result","content":"/home/aiscend/work/vibelife/apps/api/services/agent/subagent.py\n/home/aiscend/work/vibelife/apps/api/services/agent/sop_engine.py\n/home/aiscend/work/vibelife/apps/api/services/agent/skill_validator.py\n/home/aiscend/work/vibelife/apps/api/services/agent/global_handlers.py\n/home/aiscend/work/vibelife/apps/api/services/agent/tool_schema.py\n/home/aiscend/work/vibelife/apps/api/services/agent/sop_state.py\n/home/aiscend/work/vibelife/apps/api/services/agent/case_matcher.py\n/home/aiscend/work/vibelife/apps/api/services/agent/skill_service_registry.py\n/home/aiscend/work/vibelife/apps/api/services/agent/__init__.py\n/home/aiscend/work/vibelife/apps/api/services/agent/stream_adapter.py\n/home/aiscend/work/vibelife/apps/api/services/agent/usage_tracker.py\n/home/aiscend/work/vibelife/apps/api/services/agent/core.py\n/home/aiscend/work/vibelife/apps/api/services/agent/skill_loader.py\n/home/aiscend/work/vibelife/apps/api/services/agent/tool_registry.py"}]},"uuid":"2ccac0f4-09e9-404f-afcb-4a75e036fd28","timestamp":"2026-01-18T03:42:38.507Z","toolUseResult":{"filenames":["/home/aiscend/work/vibelife/apps/api/services/agent/subagent.py","/home/aiscend/work/vibelife/apps/api/services/agent/sop_engine.py","/home/aiscend/work/vibelife/apps/api/services/agent/skill_validator.py","/home/aiscend/work/vibelife/apps/api/services/agent/global_handlers.py","/home/aiscend/work/vibelife/apps/api/services/agent/tool_schema.py","/home/aiscend/work/vibelife/apps/api/services/agent/sop_state.py","/home/aiscend/work/vibelife/apps/api/services/agent/case_matcher.py","/home/aiscend/work/vibelife/apps/api/services/agent/skill_service_registry.py","/home/aiscend/work/vibelife/apps/api/services/agent/__init__.py","/home/aiscend/work/vibelife/apps/api/services/agent/stream_adapter.py","/home/aiscend/work/vibelife/apps/api/services/agent/usage_tracker.py","/home/aiscend/work/vibelife/apps/api/services/agent/core.py","/home/aiscend/work/vibelife/apps/api/services/agent/skill_loader.py","/home/aiscend/work/vibelife/apps/api/services/agent/tool_registry.py"],"durationMs":734,"numFiles":14,"truncated":false},"sourceToolAssistantUUID":"6124be34-6bfc-4378-a51d-87677e3d39c7"}
{"parentUuid":"2ccac0f4-09e9-404f-afcb-4a75e036fd28","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YqHhVP5XxS57pJtnHQALz","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the key files now:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":41,"cache_creation_input_tokens":848,"cache_read_input_tokens":27588,"cache_creation":{"ephemeral_5m_input_tokens":848,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nVAkUV1Y8SCuw7F63","type":"assistant","uuid":"c934bdf4-7ec0-413e-8e3b-3d6966c1e758","timestamp":"2026-01-18T03:42:39.994Z"}
{"parentUuid":"c934bdf4-7ec0-413e-8e3b-3d6966c1e758","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YqHhVP5XxS57pJtnHQALz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EHfFionr7qtHx5KPb8H4ZB","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/core.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":41,"cache_creation_input_tokens":848,"cache_read_input_tokens":27588,"cache_creation":{"ephemeral_5m_input_tokens":848,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nVAkUV1Y8SCuw7F63","type":"assistant","uuid":"73d54bed-3b12-4e32-8666-c76bc1e67ff7","timestamp":"2026-01-18T03:42:40.191Z"}
{"parentUuid":"73d54bed-3b12-4e32-8666-c76bc1e67ff7","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YqHhVP5XxS57pJtnHQALz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VPS8daTYoFAGsh5hAfem9P","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/skill_loader.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":41,"cache_creation_input_tokens":848,"cache_read_input_tokens":27588,"cache_creation":{"ephemeral_5m_input_tokens":848,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nVAkUV1Y8SCuw7F63","type":"assistant","uuid":"abf0d4dd-5cd8-4182-af8c-50cc35a567a8","timestamp":"2026-01-18T03:42:40.401Z"}
{"parentUuid":"abf0d4dd-5cd8-4182-af8c-50cc35a567a8","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YqHhVP5XxS57pJtnHQALz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H6Kv4eqrd6okmxJQdTJ1Vt","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/tool_registry.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":41,"cache_creation_input_tokens":848,"cache_read_input_tokens":27588,"cache_creation":{"ephemeral_5m_input_tokens":848,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nVAkUV1Y8SCuw7F63","type":"assistant","uuid":"e4dad514-80f7-4acc-8583-52f7e95ccf30","timestamp":"2026-01-18T03:42:40.619Z"}
{"parentUuid":"e4dad514-80f7-4acc-8583-52f7e95ccf30","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YqHhVP5XxS57pJtnHQALz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0124gKGzS6buwoR2p9BA1DKu","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/tool_schema.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":41,"cache_creation_input_tokens":848,"cache_read_input_tokens":27588,"cache_creation":{"ephemeral_5m_input_tokens":848,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nVAkUV1Y8SCuw7F63","type":"assistant","uuid":"8ccc3d6c-635b-4127-bbc5-f55ad5fe5670","timestamp":"2026-01-18T03:42:40.827Z"}
{"parentUuid":"73d54bed-3b12-4e32-8666-c76bc1e67ff7","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EHfFionr7qtHx5KPb8H4ZB","type":"tool_result","content":"     1→\"\"\"\n     2→CoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索的智能体\n     3→\n     4→v6 架构特性：\n     5→- Scenario 路由：根据用户消息匹配最佳场景\n     6→- PostgreSQL 知识检索：RAG + 案例匹配\n     7→- 7 阶段 SOP：P1-P2 强制，P3-P7 LLM 自由发挥\n     8→- 工具-卡片映射：标准化工具元数据\n     9→\"\"\"\n    10→import json\n    11→import logging\n    12→from typing import Optional, List, Dict, Any, AsyncGenerator\n    13→from dataclasses import dataclass\n    14→from enum import Enum\n    15→\n    16→from services.llm import LLMClient, get_llm_client\n    17→from services.llm.client import LLMMessage\n    18→from services.knowledge.repository import get_knowledge_repository, KnowledgeRepository\n    19→from .skill_loader import (\n    20→    load_skill, load_scenario, get_skill_triggers,\n    21→    build_system_prompt, SkillConfig, ScenarioConfig,\n    22→    route_scenario as memory_route_scenario,\n    23→    get_available_skills, get_skill_scenarios\n    24→)\n    25→from .sop_engine import SOPEngine, SOPAction, SOPPhase, check_sop_requirements\n    26→from .tool_registry import ToolRegistry, ToolContext\n    27→\n    28→logger = logging.getLogger(__name__)\n    29→\n    30→\n    31→class AgentState(str, Enum):\n    32→    \"\"\"Agent 执行状态\"\"\"\n    33→    IDLE = \"idle\"\n    34→    THINKING = \"thinking\"\n    35→    TOOL_CALLING = \"tool_calling\"\n    36→    COMPLETED = \"completed\"\n    37→    ERROR = \"error\"\n    38→\n    39→\n    40→@dataclass\n    41→class AgentEvent:\n    42→    \"\"\"Agent 执行事件\"\"\"\n    43→    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase\n    44→    data: Any = None\n    45→\n    46→\n    47→@dataclass\n    48→class AgentContext:\n    49→    \"\"\"Agent 执行上下文\"\"\"\n    50→    user_id: str\n    51→    user_tier: str = \"free\"\n    52→    profile: Optional[Dict[str, Any]] = None\n    53→    skill_data: Optional[Dict[str, Any]] = None\n    54→    history: Optional[List[Dict[str, str]]] = None\n    55→    skill: Optional[str] = None\n    56→    scenario: Optional[str] = None\n    57→    portrait: Optional[str] = None\n    58→    conversation_id: Optional[str] = None\n    59→    voice_mode: Optional[str] = \"warm\"\n    60→    recent_insights: Optional[List[Any]] = None\n    61→\n    62→\n    63→def build_use_skill_tool() -> Dict[str, Any]:\n    64→    \"\"\"\n    65→    动态构建 use_skill 工具定义\n    66→\n    67→    从 SKILL.md 自动读取：\n    68→    - 可用的 Skills 列表\n    69→    - 每个 Skill 的触发词\n    70→    - 每个 Skill 的场景列表\n    71→    \"\"\"\n    72→    # 获取所有可用 Skills 和触发词\n    73→    triggers = get_skill_triggers()\n    74→    available_skills = [s for s in get_available_skills() if s != \"core\"]\n    75→\n    76→    # 构建 Skill 路由说明\n    77→    skill_routing = \"## Skill 路由\\n\"\n    78→    for skill_id in available_skills:\n    79→        skill = load_skill(skill_id)\n    80→        if skill and skill.triggers:\n    81→            trigger_str = \"、\".join(skill.triggers[:5])  # 最多显示5个触发词\n    82→            skill_routing += f\"- {trigger_str} → skill: \\\"{skill_id}\\\"\\n\"\n    83→\n    84→    # 构建场景目录（只列出主要场景，避免 description 过长）\n    85→    scenario_catalog = \"\\n## 场景目录（常用）\\n\"\n    86→    for skill_id in available_skills:\n    87→        scenarios = get_skill_scenarios(skill_id)\n    88→        if scenarios:\n    89→            # 只列出前5个场景\n    90→            top_scenarios = scenarios[:5]\n    91→            scenario_catalog += f\"\\n### {skill_id}\\n\"\n    92→            for s in top_scenarios:\n    93→                scenario_catalog += f\"- {s}\\n\"\n    94→            if len(scenarios) > 5:\n    95→                scenario_catalog += f\"- ... (共 {len(scenarios)} 个场景)\\n\"\n    96→\n    97→    description = f\"\"\"激活专业技能来回答用户问题。一次决定 skill、scenario 和 confidence。\n    98→\n    99→{skill_routing}\n   100→{scenario_catalog}\n   101→\n   102→## Confidence 说明\n   103→- high: 用户意图明确，直接执行\n   104→- medium: 基本确定，可能需要追问细节\n   105→- low: 不确定，需要向用户确认\n   106→\n   107→重要：如果用户消息中已经包含了出生信息，设置 birth_info_provided=true。\"\"\"\n   108→\n   109→    return {\n   110→        \"type\": \"function\",\n   111→        \"function\": {\n   112→            \"name\": \"use_skill\",\n   113→            \"description\": description,\n   114→            \"parameters\": {\n   115→                \"type\": \"object\",\n   116→                \"properties\": {\n   117→                    \"skill\": {\n   118→                        \"type\": \"string\",\n   119→                        \"enum\": available_skills,\n   120→                        \"description\": \"要使用的技能\"\n   121→                    },\n   122→                    \"scenario\": {\n   123→                        \"type\": \"string\",\n   124→                        \"description\": \"场景 ID，参考上方场景目录\"\n   125→                    },\n   126→                    \"confidence\": {\n   127→                        \"type\": \"string\",\n   128→                        \"enum\": [\"high\", \"medium\", \"low\"],\n   129→                        \"description\": \"路由置信度\"\n   130→                    },\n   131→                    \"topic\": {\n   132→                        \"type\": \"string\",\n   133→                        \"enum\": [\"career\", \"relationship\", \"fortune\", \"health\", \"self\", \"general\"],\n   134→                        \"description\": \"用户关注的话题类型\"\n   135→                    },\n   136→                    \"birth_info_provided\": {\n   137→                        \"type\": \"boolean\",\n   138→                        \"description\": \"用户消息中是否已包含出生信息\"\n   139→                    }\n   140→                },\n   141→                \"required\": [\"skill\", \"scenario\", \"confidence\"]\n   142→            }\n   143→        }\n   144→    }\n   145→\n   146→\n   147→# 缓存动态生成的工具定义\n   148→_USE_SKILL_TOOL_CACHE: Optional[Dict[str, Any]] = None\n   149→\n   150→\n   151→def get_use_skill_tool() -> Dict[str, Any]:\n   152→    \"\"\"获取 use_skill 工具定义（带缓存）\"\"\"\n   153→    global _USE_SKILL_TOOL_CACHE\n   154→    if _USE_SKILL_TOOL_CACHE is None:\n   155→        _USE_SKILL_TOOL_CACHE = build_use_skill_tool()\n   156→    return _USE_SKILL_TOOL_CACHE\n   157→\n   158→\n   159→class CoreAgent:\n   160→    \"\"\"\n   161→    CoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索\n   162→\n   163→    Features:\n   164→    - Scenario routing via PostgreSQL\n   165→    - Knowledge retrieval (RAG + cases)\n   166→    - 7-phase SOP execution\n   167→    - Tool-card mapping\n   168→    \"\"\"\n   169→\n   170→    def __init__(\n   171→        self,\n   172→        llm: Optional[LLMClient] = None,\n   173→        max_iterations: int = 10,\n   174→        knowledge_repo: Optional[KnowledgeRepository] = None\n   175→    ):\n   176→        self.llm = llm or get_llm_client()\n   177→        self.max_iterations = max_iterations\n   178→        self.knowledge_repo = knowledge_repo or get_knowledge_repository()\n   179→        self.state = AgentState.IDLE\n   180→        self._active_skill: Optional[str] = None\n   181→        self._active_scenario: Optional[str] = None\n   182→        self._topic: Optional[str] = None\n   183→        self._current_message: str = \"\"\n   184→\n   185→    @property\n   186→    def usage(self) -> Dict[str, int]:\n   187→        \"\"\"获取 LLM 使用统计\"\"\"\n   188→        return self.llm.usage\n   189→\n   190→    async def run(\n   191→        self,\n   192→        message: str,\n   193→        context: AgentContext\n   194→    ) -> AsyncGenerator[AgentEvent, None]:\n   195→        \"\"\"执行 Agent 循环\"\"\"\n   196→        self.state = AgentState.IDLE\n   197→        self._current_message = message\n   198→\n   199→        # 使用前端指定的 skill/scenario，或让 LLM 决定\n   200→        if context.skill:\n   201→            self._active_skill = context.skill\n   202→            self._active_scenario = context.scenario or await self._route_scenario(context.skill, message)\n   203→        else:\n   204→            self._active_skill = None\n   205→            self._active_scenario = None\n   206→\n   207→        # 检查 SOP 要求\n   208→        if self._active_skill:\n   209→            action, sop_context = check_sop_requirements(\n   210→                skill_id=self._active_skill,\n   211→                scenario_id=self._active_scenario,\n   212→                profile=context.profile,\n   213→                skill_data=context.skill_data,\n   214→                message=message\n   215→            )\n   216→\n   217→            yield AgentEvent(type=\"sop_phase\", data={\n   218→                \"skill\": self._active_skill,\n   219→                \"scenario\": self._active_scenario,\n   220→                \"action\": action.value,\n   221→                \"phase\": sop_context.get(\"phase\", SOPPhase.ANALYZE).value,\n   222→                \"context\": sop_context\n   223→            })\n   224→\n   225→        # 构建初始消息\n   226→        messages = await self._build_initial_messages(message, context)\n   227→\n   228→        for iteration in range(self.max_iterations):\n   229→            self.state = AgentState.THINKING\n   230→            yield AgentEvent(type=\"thinking\", data={\"iteration\": iteration})\n   231→\n   232→            tools = self._get_current_tools(context)\n   233→\n   234→            try:\n   235→                content_buffer = \"\"\n   236→                tool_calls = []\n   237→\n   238→                async for chunk in self.llm.stream(\n   239→                    messages=messages,\n   240→                    tools=tools,\n   241→                    tool_choice=None,\n   242→                    user_tier=context.user_tier\n   243→                ):\n   244→                    if chunk[\"type\"] == \"content\":\n   245→                        content_buffer += chunk[\"content\"]\n   246→                        yield AgentEvent(type=\"content\", data={\"content\": chunk[\"content\"]})\n   247→                    elif chunk[\"type\"] == \"tool_call\":\n   248→                        tool_calls.append(chunk)\n   249→\n   250→                if tool_calls:\n   251→                    self.state = AgentState.TOOL_CALLING\n   252→\n   253→                    assistant_tool_calls = []\n   254→                    for tc in tool_calls:\n   255→                        assistant_tool_calls.append({\n   256→                            \"id\": tc[\"tool_call_id\"],\n   257→                            \"function\": {\n   258→                                \"name\": tc[\"tool_name\"],\n   259→                                \"arguments\": tc[\"tool_args\"]\n   260→                            }\n   261→                        })\n   262→                    messages.append(LLMMessage(\n   263→                        role=\"assistant\",\n   264→                        content=content_buffer or \"\",\n   265→                        tool_calls=assistant_tool_calls\n   266→                    ))\n   267→                    content_buffer = \"\"\n   268→\n   269→                    tool_results = []\n   270→                    for tc in tool_calls:\n   271→                        tool_name = tc[\"tool_name\"]\n   272→                        tool_args = tc[\"tool_args\"]\n   273→                        tool_call_id = tc[\"tool_call_id\"]\n   274→\n   275→                        yield AgentEvent(type=\"tool_call\", data={\n   276→                            \"id\": tool_call_id,\n   277→                            \"name\": tool_name,\n   278→                            \"arguments\": tool_args\n   279→                        })\n   280→\n   281→                        result = await self._execute_tool(tool_name, tool_args, context)\n   282→                        tool_results.append({\n   283→                            \"tool_call_id\": tool_call_id,\n   284→                            \"result\": result\n   285→                        })\n   286→\n   287→                        yield AgentEvent(type=\"tool_result\", data={\n   288→                            \"id\": tool_call_id,\n   289→                            \"name\": tool_name,\n   290→                            \"result\": result\n   291→                        })\n   292→\n   293→                    for tr in tool_results:\n   294→                        result_content = tr[\"result\"]\n   295→                        if isinstance(result_content, dict):\n   296→                            result_content = json.dumps(result_content, ensure_ascii=False)\n   297→                        messages.append(LLMMessage(\n   298→                            role=\"tool\",\n   299→                            content=str(result_content),\n   300→                            tool_call_id=tr[\"tool_call_id\"]\n   301→                        ))\n   302→                else:\n   303→                    self.state = AgentState.COMPLETED\n   304→                    yield AgentEvent(type=\"done\", data={\"content\": content_buffer})\n   305→                    return\n   306→\n   307→            except Exception as e:\n   308→                self.state = AgentState.ERROR\n   309→                logger.error(f\"Agent error: {e}\")\n   310→                yield AgentEvent(type=\"error\", data={\"error\": str(e)})\n   311→                return\n   312→\n   313→        self.state = AgentState.COMPLETED\n   314→        yield AgentEvent(type=\"done\", data={\"max_iterations_reached\": True})\n   315→\n   316→    async def _route_scenario(self, skill_id: str, message: str) -> Optional[str]:\n   317→        \"\"\"场景路由 - 根据消息匹配最佳场景\"\"\"\n   318→        try:\n   319→            matches = await self.knowledge_repo.route_scenario(skill_id, message)\n   320→            if matches:\n   321→                return matches[0].scenario_id\n   322→        except Exception as e:\n   323→            logger.warning(f\"Scenario routing failed: {e}\")\n   324→\n   325→        # 回退到默认场景\n   326→        skill = load_skill(skill_id)\n   327→        return skill.default_scenario if skill else \"basic_reading\"\n   328→\n   329→    async def _build_initial_messages(\n   330→        self,\n   331→        message: str,\n   332→        context: AgentContext\n   333→    ) -> List[LLMMessage]:\n   334→        \"\"\"构建初始消息列表\"\"\"\n   335→        system_prompt = await self._build_system_prompt(message, context)\n   336→\n   337→        messages = [LLMMessage(role=\"system\", content=system_prompt)]\n   338→\n   339→        if context.history:\n   340→            for msg in context.history[-10:]:\n   341→                messages.append(LLMMessage(\n   342→                    role=msg.get(\"role\", \"user\"),\n   343→                    content=msg.get(\"content\", \"\")\n   344→                ))\n   345→\n   346→        messages.append(LLMMessage(role=\"user\", content=message))\n   347→        return messages\n   348→\n   349→    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:\n   350→        \"\"\"构建 System Prompt\"\"\"\n   351→        parts = []\n   352→\n   353→        # 基础 prompt\n   354→        if self._active_skill:\n   355→            # 传递完整 profile，让 skill_loader 自动处理所有字段\n   356→            user_ctx = dict(context.profile) if context.profile else {}\n   357→            user_ctx[\"portrait\"] = context.portrait\n   358→            base_prompt = build_system_prompt(\n   359→                self._active_skill,\n   360→                self._active_scenario,\n   361→                user_ctx\n   362→            )\n   363→            parts.append(base_prompt)\n   364→\n   365→            # 知识检索\n   366→            try:\n   367→                knowledge = await self.knowledge_repo.search_knowledge(\n   368→                    self._active_skill, message, top_k=5\n   369→                )\n   370→                if knowledge:\n   371→                    knowledge_text = \"\\n## 相关知识\\n\\n\"\n   372→                    for chunk in knowledge:\n   373→                        knowledge_text += f\"**{chunk.book_name}** ({chunk.chapter or ''})\\n{chunk.chunk_text[:500]}...\\n\\n\"\n   374→                    parts.append(knowledge_text)\n   375→            except Exception as e:\n   376→                logger.warning(f\"Knowledge retrieval failed: {e}\")\n   377→\n   378→            # 案例匹配 - 使用智能匹配器\n   379→            try:\n   380→                from .case_matcher import match_cases_smart\n   381→                cases = await match_cases_smart(\n   382→                    self.knowledge_repo,\n   383→                    skill_id=self._active_skill,\n   384→                    scenario_id=self._active_scenario,\n   385→                    skill_data=context.skill_data,\n   386→                    top_k=2\n   387→                )\n   388→                if cases:\n   389→                    cases_text = \"\\n## 相关案例\\n\\n\"\n   390→                    for case in cases:\n   391→                        cases_text += f\"**{case.name}**\\n{json.dumps(case.conclusion, ensure_ascii=False)}\\n\\n\"\n   392→                    parts.append(cases_text)\n   393→            except Exception as e:\n   394→                logger.warning(f\"Case matching failed: {e}\")\n   395→        else:\n   396→            # 无 skill 时，添加触发规则\n   397→            triggers = get_skill_triggers()\n   398→            if triggers:\n   399→                trigger_rules = \"## 技能触发规则\\n\\n当用户消息包含以下关键词时，调用 `use_skill` 工具：\\n\"\n   400→                for skill_name, keywords in triggers.items():\n   401→                    trigger_rules += f\"- **{skill_name}**: {', '.join(keywords)}\\n\"\n   402→                parts.append(trigger_rules)\n   403→\n   404→        # 用户命盘数据\n   405→        if context.skill_data and self._active_skill:\n   406→            skill_data = context.skill_data.get(self._active_skill, {})\n   407→            if skill_data:\n   408→                parts.append(f\"\\n## 用户命盘数据\\n{json.dumps(skill_data, ensure_ascii=False, indent=2)}\")\n   409→\n   410→        return \"\\n\".join(parts)\n   411→\n   412→    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:\n   413→        \"\"\"获取当前可用工具 - V6: 从统一注册表获取\"\"\"\n   414→        if not context.skill and not self._active_skill:\n   415→            return [get_use_skill_tool()]\n   416→\n   417→        skill_id = self._active_skill or context.skill\n   418→\n   419→        # 从统一注册表获取工具（YAML 为数据源）\n   420→        tools = ToolRegistry.get_tools_for_skill(skill_id)\n   421→        return tools if tools else [get_use_skill_tool()]\n   422→\n   423→    async def _execute_tool(\n   424→        self,\n   425→        tool_name: str,\n   426→        tool_args: str,\n   427→        context: AgentContext\n   428→    ) -> Dict[str, Any]:\n   429→        \"\"\"执行工具调用 - V6.1: 完全使用统一注册表\"\"\"\n   430→        try:\n   431→            args = json.loads(tool_args) if tool_args else {}\n   432→        except json.JSONDecodeError:\n   433→            args = {}\n   434→\n   435→        # 特殊处理 use_skill（路由工具）\n   436→        if tool_name == \"use_skill\":\n   437→            return await self._handle_use_skill(args, context)\n   438→\n   439→        # 创建工具上下文\n   440→        tool_context = ToolContext(\n   441→            user_id=context.user_id,\n   442→            user_tier=context.user_tier,\n   443→            profile=context.profile or {},\n   444→            skill_data=context.skill_data or {},\n   445→            skill_id=self._active_skill,\n   446→            scenario_id=self._active_scenario,\n   447→            conversation_id=context.conversation_id\n   448→        )\n   449→\n   450→        # 使用统一注册表执行工具\n   451→        if ToolRegistry.has_handler(tool_name):\n   452→            return await ToolRegistry.execute(tool_name, args, tool_context)\n   453→\n   454→        # 未找到处理器\n   455→        logger.warning(f\"No handler found for tool: {tool_name}\")\n   456→        return {\"status\": \"unknown_tool\", \"tool\": tool_name, \"message\": f\"工具 {tool_name} 暂未实现\"}\n   457→\n   458→    async def _handle_search_db(\n   459→        self,\n   460→        args: Dict[str, Any],\n   461→        context: AgentContext\n   462→    ) -> Dict[str, Any]:\n   463→        \"\"\"处理 search_db 工具调用\"\"\"\n   464→        table = args.get(\"table\", \"knowledge_chunks\")\n   465→        query = args.get(\"query\", \"\")\n   466→        filters = args.get(\"filters\", {})\n   467→        top_k = args.get(\"top_k\", 5)\n   468→\n   469→        # 自动添加当前 skill_id 到 filters\n   470→        if self._active_skill and \"skill_id\" not in filters:\n   471→            filters[\"skill_id\"] = self._active_skill\n   472→        if self._active_scenario and \"scenario_id\" not in filters:\n   473→            filters[\"scenario_id\"] = self._active_scenario\n   474→\n   475→        results = await self.knowledge_repo.search_db(\n   476→            table=table,\n   477→            query=query,\n   478→            filters=filters,\n   479→            top_k=top_k\n   480→        )\n   481→\n   482→        return {\n   483→            \"status\": \"success\",\n   484→            \"table\": table,\n   485→            \"query\": query,\n   486→            \"count\": len(results),\n   487→            \"results\": results\n   488→        }\n   489→\n   490→    async def _handle_use_skill(\n   491→        self,\n   492→        args: Dict[str, Any],\n   493→        context: AgentContext\n   494→    ) -> Dict[str, Any]:\n   495→        \"\"\"处理 skill 选择 - V6: 一次决定 skill + scenario + confidence\"\"\"\n   496→        skill = args.get(\"skill\")\n   497→        scenario = args.get(\"scenario\", \"basic_reading\")\n   498→        confidence = args.get(\"confidence\", \"high\")\n   499→        topic = args.get(\"topic\", \"general\")\n   500→\n   501→        if not skill:\n   502→            return {\"status\": \"error\", \"message\": \"No skill specified\"}\n   503→\n   504→        self._active_skill = skill\n   505→        self._active_scenario = scenario\n   506→        self._topic = topic\n   507→\n   508→        # 低置信度时，返回确认请求\n   509→        if confidence == \"low\":\n   510→            return {\n   511→                \"status\": \"need_confirm\",\n   512→                \"skill\": skill,\n   513→                \"scenario\": scenario,\n   514→                \"confidence\": confidence,\n   515→                \"message\": f\"我理解您可能想使用 {skill} 的 {scenario} 服务，请确认是否正确？\"\n   516→            }\n   517→\n   518→        # 检查是否需要出生信息\n   519→        needs_birth = skill in [\"bazi\", \"zodiac\"]\n   520→        has_birth = context.profile and context.profile.get(\"birth_info\")\n   521→        birth_provided = args.get(\"birth_info_provided\", False)\n   522→\n   523→        if needs_birth and not has_birth and not birth_provided:\n   524→            return {\n   525→                \"status\": \"need_info\",\n   526→                \"skill\": skill,\n   527→                \"scenario\": scenario,\n   528→                \"confidence\": confidence,\n   529→                \"topic\": topic,\n   530→                \"info_type\": \"birth\",\n   531→                \"message\": \"技能已激活。请调用 request_info 工具收集出生信息。\"\n   532→            }\n   533→\n   534→        return {\n   535→            \"status\": \"activated\",\n   536→            \"skill\": skill,\n   537→            \"scenario\": scenario,\n   538→            \"confidence\": confidence,\n   539→            \"topic\": topic,\n   540→            \"message\": f\"已激活 {skill} 技能，场景: {scenario}\"\n   541→        }\n   542→\n   543→\n   544→def create_agent(\n   545→    llm: Optional[LLMClient] = None,\n   546→    max_iterations: int = 10\n   547→) -> CoreAgent:\n   548→    \"\"\"创建 CoreAgent 实例\"\"\"\n   549→    return CoreAgent(llm=llm, max_iterations=max_iterations)\n   550→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3f3e4ea7-3b54-427d-b7ca-47858835c1e0","timestamp":"2026-01-18T03:42:40.934Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/core.py","content":"\"\"\"\nCoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索的智能体\n\nv6 架构特性：\n- Scenario 路由：根据用户消息匹配最佳场景\n- PostgreSQL 知识检索：RAG + 案例匹配\n- 7 阶段 SOP：P1-P2 强制，P3-P7 LLM 自由发挥\n- 工具-卡片映射：标准化工具元数据\n\"\"\"\nimport json\nimport logging\nfrom typing import Optional, List, Dict, Any, AsyncGenerator\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nfrom services.llm import LLMClient, get_llm_client\nfrom services.llm.client import LLMMessage\nfrom services.knowledge.repository import get_knowledge_repository, KnowledgeRepository\nfrom .skill_loader import (\n    load_skill, load_scenario, get_skill_triggers,\n    build_system_prompt, SkillConfig, ScenarioConfig,\n    route_scenario as memory_route_scenario,\n    get_available_skills, get_skill_scenarios\n)\nfrom .sop_engine import SOPEngine, SOPAction, SOPPhase, check_sop_requirements\nfrom .tool_registry import ToolRegistry, ToolContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass AgentState(str, Enum):\n    \"\"\"Agent 执行状态\"\"\"\n    IDLE = \"idle\"\n    THINKING = \"thinking\"\n    TOOL_CALLING = \"tool_calling\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n\n\n@dataclass\nclass AgentEvent:\n    \"\"\"Agent 执行事件\"\"\"\n    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase\n    data: Any = None\n\n\n@dataclass\nclass AgentContext:\n    \"\"\"Agent 执行上下文\"\"\"\n    user_id: str\n    user_tier: str = \"free\"\n    profile: Optional[Dict[str, Any]] = None\n    skill_data: Optional[Dict[str, Any]] = None\n    history: Optional[List[Dict[str, str]]] = None\n    skill: Optional[str] = None\n    scenario: Optional[str] = None\n    portrait: Optional[str] = None\n    conversation_id: Optional[str] = None\n    voice_mode: Optional[str] = \"warm\"\n    recent_insights: Optional[List[Any]] = None\n\n\ndef build_use_skill_tool() -> Dict[str, Any]:\n    \"\"\"\n    动态构建 use_skill 工具定义\n\n    从 SKILL.md 自动读取：\n    - 可用的 Skills 列表\n    - 每个 Skill 的触发词\n    - 每个 Skill 的场景列表\n    \"\"\"\n    # 获取所有可用 Skills 和触发词\n    triggers = get_skill_triggers()\n    available_skills = [s for s in get_available_skills() if s != \"core\"]\n\n    # 构建 Skill 路由说明\n    skill_routing = \"## Skill 路由\\n\"\n    for skill_id in available_skills:\n        skill = load_skill(skill_id)\n        if skill and skill.triggers:\n            trigger_str = \"、\".join(skill.triggers[:5])  # 最多显示5个触发词\n            skill_routing += f\"- {trigger_str} → skill: \\\"{skill_id}\\\"\\n\"\n\n    # 构建场景目录（只列出主要场景，避免 description 过长）\n    scenario_catalog = \"\\n## 场景目录（常用）\\n\"\n    for skill_id in available_skills:\n        scenarios = get_skill_scenarios(skill_id)\n        if scenarios:\n            # 只列出前5个场景\n            top_scenarios = scenarios[:5]\n            scenario_catalog += f\"\\n### {skill_id}\\n\"\n            for s in top_scenarios:\n                scenario_catalog += f\"- {s}\\n\"\n            if len(scenarios) > 5:\n                scenario_catalog += f\"- ... (共 {len(scenarios)} 个场景)\\n\"\n\n    description = f\"\"\"激活专业技能来回答用户问题。一次决定 skill、scenario 和 confidence。\n\n{skill_routing}\n{scenario_catalog}\n\n## Confidence 说明\n- high: 用户意图明确，直接执行\n- medium: 基本确定，可能需要追问细节\n- low: 不确定，需要向用户确认\n\n重要：如果用户消息中已经包含了出生信息，设置 birth_info_provided=true。\"\"\"\n\n    return {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"use_skill\",\n            \"description\": description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"skill\": {\n                        \"type\": \"string\",\n                        \"enum\": available_skills,\n                        \"description\": \"要使用的技能\"\n                    },\n                    \"scenario\": {\n                        \"type\": \"string\",\n                        \"description\": \"场景 ID，参考上方场景目录\"\n                    },\n                    \"confidence\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"high\", \"medium\", \"low\"],\n                        \"description\": \"路由置信度\"\n                    },\n                    \"topic\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"career\", \"relationship\", \"fortune\", \"health\", \"self\", \"general\"],\n                        \"description\": \"用户关注的话题类型\"\n                    },\n                    \"birth_info_provided\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"用户消息中是否已包含出生信息\"\n                    }\n                },\n                \"required\": [\"skill\", \"scenario\", \"confidence\"]\n            }\n        }\n    }\n\n\n# 缓存动态生成的工具定义\n_USE_SKILL_TOOL_CACHE: Optional[Dict[str, Any]] = None\n\n\ndef get_use_skill_tool() -> Dict[str, Any]:\n    \"\"\"获取 use_skill 工具定义（带缓存）\"\"\"\n    global _USE_SKILL_TOOL_CACHE\n    if _USE_SKILL_TOOL_CACHE is None:\n        _USE_SKILL_TOOL_CACHE = build_use_skill_tool()\n    return _USE_SKILL_TOOL_CACHE\n\n\nclass CoreAgent:\n    \"\"\"\n    CoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索\n\n    Features:\n    - Scenario routing via PostgreSQL\n    - Knowledge retrieval (RAG + cases)\n    - 7-phase SOP execution\n    - Tool-card mapping\n    \"\"\"\n\n    def __init__(\n        self,\n        llm: Optional[LLMClient] = None,\n        max_iterations: int = 10,\n        knowledge_repo: Optional[KnowledgeRepository] = None\n    ):\n        self.llm = llm or get_llm_client()\n        self.max_iterations = max_iterations\n        self.knowledge_repo = knowledge_repo or get_knowledge_repository()\n        self.state = AgentState.IDLE\n        self._active_skill: Optional[str] = None\n        self._active_scenario: Optional[str] = None\n        self._topic: Optional[str] = None\n        self._current_message: str = \"\"\n\n    @property\n    def usage(self) -> Dict[str, int]:\n        \"\"\"获取 LLM 使用统计\"\"\"\n        return self.llm.usage\n\n    async def run(\n        self,\n        message: str,\n        context: AgentContext\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行 Agent 循环\"\"\"\n        self.state = AgentState.IDLE\n        self._current_message = message\n\n        # 使用前端指定的 skill/scenario，或让 LLM 决定\n        if context.skill:\n            self._active_skill = context.skill\n            self._active_scenario = context.scenario or await self._route_scenario(context.skill, message)\n        else:\n            self._active_skill = None\n            self._active_scenario = None\n\n        # 检查 SOP 要求\n        if self._active_skill:\n            action, sop_context = check_sop_requirements(\n                skill_id=self._active_skill,\n                scenario_id=self._active_scenario,\n                profile=context.profile,\n                skill_data=context.skill_data,\n                message=message\n            )\n\n            yield AgentEvent(type=\"sop_phase\", data={\n                \"skill\": self._active_skill,\n                \"scenario\": self._active_scenario,\n                \"action\": action.value,\n                \"phase\": sop_context.get(\"phase\", SOPPhase.ANALYZE).value,\n                \"context\": sop_context\n            })\n\n        # 构建初始消息\n        messages = await self._build_initial_messages(message, context)\n\n        for iteration in range(self.max_iterations):\n            self.state = AgentState.THINKING\n            yield AgentEvent(type=\"thinking\", data={\"iteration\": iteration})\n\n            tools = self._get_current_tools(context)\n\n            try:\n                content_buffer = \"\"\n                tool_calls = []\n\n                async for chunk in self.llm.stream(\n                    messages=messages,\n                    tools=tools,\n                    tool_choice=None,\n                    user_tier=context.user_tier\n                ):\n                    if chunk[\"type\"] == \"content\":\n                        content_buffer += chunk[\"content\"]\n                        yield AgentEvent(type=\"content\", data={\"content\": chunk[\"content\"]})\n                    elif chunk[\"type\"] == \"tool_call\":\n                        tool_calls.append(chunk)\n\n                if tool_calls:\n                    self.state = AgentState.TOOL_CALLING\n\n                    assistant_tool_calls = []\n                    for tc in tool_calls:\n                        assistant_tool_calls.append({\n                            \"id\": tc[\"tool_call_id\"],\n                            \"function\": {\n                                \"name\": tc[\"tool_name\"],\n                                \"arguments\": tc[\"tool_args\"]\n                            }\n                        })\n                    messages.append(LLMMessage(\n                        role=\"assistant\",\n                        content=content_buffer or \"\",\n                        tool_calls=assistant_tool_calls\n                    ))\n                    content_buffer = \"\"\n\n                    tool_results = []\n                    for tc in tool_calls:\n                        tool_name = tc[\"tool_name\"]\n                        tool_args = tc[\"tool_args\"]\n                        tool_call_id = tc[\"tool_call_id\"]\n\n                        yield AgentEvent(type=\"tool_call\", data={\n                            \"id\": tool_call_id,\n                            \"name\": tool_name,\n                            \"arguments\": tool_args\n                        })\n\n                        result = await self._execute_tool(tool_name, tool_args, context)\n                        tool_results.append({\n                            \"tool_call_id\": tool_call_id,\n                            \"result\": result\n                        })\n\n                        yield AgentEvent(type=\"tool_result\", data={\n                            \"id\": tool_call_id,\n                            \"name\": tool_name,\n                            \"result\": result\n                        })\n\n                    for tr in tool_results:\n                        result_content = tr[\"result\"]\n                        if isinstance(result_content, dict):\n                            result_content = json.dumps(result_content, ensure_ascii=False)\n                        messages.append(LLMMessage(\n                            role=\"tool\",\n                            content=str(result_content),\n                            tool_call_id=tr[\"tool_call_id\"]\n                        ))\n                else:\n                    self.state = AgentState.COMPLETED\n                    yield AgentEvent(type=\"done\", data={\"content\": content_buffer})\n                    return\n\n            except Exception as e:\n                self.state = AgentState.ERROR\n                logger.error(f\"Agent error: {e}\")\n                yield AgentEvent(type=\"error\", data={\"error\": str(e)})\n                return\n\n        self.state = AgentState.COMPLETED\n        yield AgentEvent(type=\"done\", data={\"max_iterations_reached\": True})\n\n    async def _route_scenario(self, skill_id: str, message: str) -> Optional[str]:\n        \"\"\"场景路由 - 根据消息匹配最佳场景\"\"\"\n        try:\n            matches = await self.knowledge_repo.route_scenario(skill_id, message)\n            if matches:\n                return matches[0].scenario_id\n        except Exception as e:\n            logger.warning(f\"Scenario routing failed: {e}\")\n\n        # 回退到默认场景\n        skill = load_skill(skill_id)\n        return skill.default_scenario if skill else \"basic_reading\"\n\n    async def _build_initial_messages(\n        self,\n        message: str,\n        context: AgentContext\n    ) -> List[LLMMessage]:\n        \"\"\"构建初始消息列表\"\"\"\n        system_prompt = await self._build_system_prompt(message, context)\n\n        messages = [LLMMessage(role=\"system\", content=system_prompt)]\n\n        if context.history:\n            for msg in context.history[-10:]:\n                messages.append(LLMMessage(\n                    role=msg.get(\"role\", \"user\"),\n                    content=msg.get(\"content\", \"\")\n                ))\n\n        messages.append(LLMMessage(role=\"user\", content=message))\n        return messages\n\n    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:\n        \"\"\"构建 System Prompt\"\"\"\n        parts = []\n\n        # 基础 prompt\n        if self._active_skill:\n            # 传递完整 profile，让 skill_loader 自动处理所有字段\n            user_ctx = dict(context.profile) if context.profile else {}\n            user_ctx[\"portrait\"] = context.portrait\n            base_prompt = build_system_prompt(\n                self._active_skill,\n                self._active_scenario,\n                user_ctx\n            )\n            parts.append(base_prompt)\n\n            # 知识检索\n            try:\n                knowledge = await self.knowledge_repo.search_knowledge(\n                    self._active_skill, message, top_k=5\n                )\n                if knowledge:\n                    knowledge_text = \"\\n## 相关知识\\n\\n\"\n                    for chunk in knowledge:\n                        knowledge_text += f\"**{chunk.book_name}** ({chunk.chapter or ''})\\n{chunk.chunk_text[:500]}...\\n\\n\"\n                    parts.append(knowledge_text)\n            except Exception as e:\n                logger.warning(f\"Knowledge retrieval failed: {e}\")\n\n            # 案例匹配 - 使用智能匹配器\n            try:\n                from .case_matcher import match_cases_smart\n                cases = await match_cases_smart(\n                    self.knowledge_repo,\n                    skill_id=self._active_skill,\n                    scenario_id=self._active_scenario,\n                    skill_data=context.skill_data,\n                    top_k=2\n                )\n                if cases:\n                    cases_text = \"\\n## 相关案例\\n\\n\"\n                    for case in cases:\n                        cases_text += f\"**{case.name}**\\n{json.dumps(case.conclusion, ensure_ascii=False)}\\n\\n\"\n                    parts.append(cases_text)\n            except Exception as e:\n                logger.warning(f\"Case matching failed: {e}\")\n        else:\n            # 无 skill 时，添加触发规则\n            triggers = get_skill_triggers()\n            if triggers:\n                trigger_rules = \"## 技能触发规则\\n\\n当用户消息包含以下关键词时，调用 `use_skill` 工具：\\n\"\n                for skill_name, keywords in triggers.items():\n                    trigger_rules += f\"- **{skill_name}**: {', '.join(keywords)}\\n\"\n                parts.append(trigger_rules)\n\n        # 用户命盘数据\n        if context.skill_data and self._active_skill:\n            skill_data = context.skill_data.get(self._active_skill, {})\n            if skill_data:\n                parts.append(f\"\\n## 用户命盘数据\\n{json.dumps(skill_data, ensure_ascii=False, indent=2)}\")\n\n        return \"\\n\".join(parts)\n\n    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:\n        \"\"\"获取当前可用工具 - V6: 从统一注册表获取\"\"\"\n        if not context.skill and not self._active_skill:\n            return [get_use_skill_tool()]\n\n        skill_id = self._active_skill or context.skill\n\n        # 从统一注册表获取工具（YAML 为数据源）\n        tools = ToolRegistry.get_tools_for_skill(skill_id)\n        return tools if tools else [get_use_skill_tool()]\n\n    async def _execute_tool(\n        self,\n        tool_name: str,\n        tool_args: str,\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"执行工具调用 - V6.1: 完全使用统一注册表\"\"\"\n        try:\n            args = json.loads(tool_args) if tool_args else {}\n        except json.JSONDecodeError:\n            args = {}\n\n        # 特殊处理 use_skill（路由工具）\n        if tool_name == \"use_skill\":\n            return await self._handle_use_skill(args, context)\n\n        # 创建工具上下文\n        tool_context = ToolContext(\n            user_id=context.user_id,\n            user_tier=context.user_tier,\n            profile=context.profile or {},\n            skill_data=context.skill_data or {},\n            skill_id=self._active_skill,\n            scenario_id=self._active_scenario,\n            conversation_id=context.conversation_id\n        )\n\n        # 使用统一注册表执行工具\n        if ToolRegistry.has_handler(tool_name):\n            return await ToolRegistry.execute(tool_name, args, tool_context)\n\n        # 未找到处理器\n        logger.warning(f\"No handler found for tool: {tool_name}\")\n        return {\"status\": \"unknown_tool\", \"tool\": tool_name, \"message\": f\"工具 {tool_name} 暂未实现\"}\n\n    async def _handle_search_db(\n        self,\n        args: Dict[str, Any],\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"处理 search_db 工具调用\"\"\"\n        table = args.get(\"table\", \"knowledge_chunks\")\n        query = args.get(\"query\", \"\")\n        filters = args.get(\"filters\", {})\n        top_k = args.get(\"top_k\", 5)\n\n        # 自动添加当前 skill_id 到 filters\n        if self._active_skill and \"skill_id\" not in filters:\n            filters[\"skill_id\"] = self._active_skill\n        if self._active_scenario and \"scenario_id\" not in filters:\n            filters[\"scenario_id\"] = self._active_scenario\n\n        results = await self.knowledge_repo.search_db(\n            table=table,\n            query=query,\n            filters=filters,\n            top_k=top_k\n        )\n\n        return {\n            \"status\": \"success\",\n            \"table\": table,\n            \"query\": query,\n            \"count\": len(results),\n            \"results\": results\n        }\n\n    async def _handle_use_skill(\n        self,\n        args: Dict[str, Any],\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"处理 skill 选择 - V6: 一次决定 skill + scenario + confidence\"\"\"\n        skill = args.get(\"skill\")\n        scenario = args.get(\"scenario\", \"basic_reading\")\n        confidence = args.get(\"confidence\", \"high\")\n        topic = args.get(\"topic\", \"general\")\n\n        if not skill:\n            return {\"status\": \"error\", \"message\": \"No skill specified\"}\n\n        self._active_skill = skill\n        self._active_scenario = scenario\n        self._topic = topic\n\n        # 低置信度时，返回确认请求\n        if confidence == \"low\":\n            return {\n                \"status\": \"need_confirm\",\n                \"skill\": skill,\n                \"scenario\": scenario,\n                \"confidence\": confidence,\n                \"message\": f\"我理解您可能想使用 {skill} 的 {scenario} 服务，请确认是否正确？\"\n            }\n\n        # 检查是否需要出生信息\n        needs_birth = skill in [\"bazi\", \"zodiac\"]\n        has_birth = context.profile and context.profile.get(\"birth_info\")\n        birth_provided = args.get(\"birth_info_provided\", False)\n\n        if needs_birth and not has_birth and not birth_provided:\n            return {\n                \"status\": \"need_info\",\n                \"skill\": skill,\n                \"scenario\": scenario,\n                \"confidence\": confidence,\n                \"topic\": topic,\n                \"info_type\": \"birth\",\n                \"message\": \"技能已激活。请调用 request_info 工具收集出生信息。\"\n            }\n\n        return {\n            \"status\": \"activated\",\n            \"skill\": skill,\n            \"scenario\": scenario,\n            \"confidence\": confidence,\n            \"topic\": topic,\n            \"message\": f\"已激活 {skill} 技能，场景: {scenario}\"\n        }\n\n\ndef create_agent(\n    llm: Optional[LLMClient] = None,\n    max_iterations: int = 10\n) -> CoreAgent:\n    \"\"\"创建 CoreAgent 实例\"\"\"\n    return CoreAgent(llm=llm, max_iterations=max_iterations)\n","numLines":550,"startLine":1,"totalLines":550}},"sourceToolAssistantUUID":"73d54bed-3b12-4e32-8666-c76bc1e67ff7"}
{"parentUuid":"abf0d4dd-5cd8-4182-af8c-50cc35a567a8","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VPS8daTYoFAGsh5hAfem9P","type":"tool_result","content":"     1→\"\"\"\n     2→SkillLoader v6 - 支持 Scenario 路由的 Skill 加载器\n     3→\n     4→v6 架构：\n     5→- SKILL.md: 核心定义（专家身份、场景目录、伦理边界）\n     6→- scenarios/*.md: MiniSkill 场景文件（SOP、知识检索配置、输出模板）\n     7→- tools/*.py: 工具定义（收集/计算/展示/检索）\n     8→\"\"\"\n     9→import re\n    10→import json\n    11→import logging\n    12→from pathlib import Path\n    13→from dataclasses import dataclass, field\n    14→from typing import Dict, List, Optional, Any\n    15→from functools import lru_cache\n    16→\n    17→logger = logging.getLogger(__name__)\n    18→\n    19→SKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n    20→\n    21→\n    22→# ═══════════════════════════════════════════════════════════════════════════\n    23→# 数据结构\n    24→# ═══════════════════════════════════════════════════════════════════════════\n    25→\n    26→@dataclass\n    27→class SkillConfig:\n    28→    \"\"\"Skill 核心配置（从 SKILL.md 加载）\"\"\"\n    29→    id: str\n    30→    name: str\n    31→    description: str\n    32→    expert_persona: str\n    33→    scenarios: Dict[str, List[str]]  # {entry: [...], standard: [...], professional: [...]}\n    34→    ethics: Dict[str, Any]\n    35→    tools: List[str]\n    36→    default_scenario: str = \"basic_reading\"\n    37→    triggers: List[str] = field(default_factory=list)\n    38→    global_tools: List[str] = field(default_factory=list)  # 需要的全局工具\n    39→\n    40→\n    41→@dataclass\n    42→class ServiceItem:\n    43→    \"\"\"服务项（用于服务目录展示）\"\"\"\n    44→    scenario_id: str\n    45→    name: str\n    46→    icon: str\n    47→    description: str\n    48→    tier: str  # entry/standard/professional\n    49→    billing: str  # 免费/基础/高级\n    50→    highlights: List[str] = field(default_factory=list)  # 价值点\n    51→\n    52→\n    53→@dataclass\n    54→class ScenarioConfig:\n    55→    \"\"\"场景配置（从 scenarios/*.md 加载）\"\"\"\n    56→    id: str\n    57→    name: str\n    58→    level: str  # entry/standard/professional\n    59→    billing: str  # free/basic/premium\n    60→    description: str\n    61→    triggers: Dict[str, List[str]]  # {primary: [...], secondary: [...]}\n    62→    prerequisites: List[str]\n    63→    sop: List[Dict[str, Any]]  # SOP 阶段列表\n    64→    knowledge_config: Dict[str, Any]  # 知识检索配置\n    65→    output_config: Dict[str, Any]  # 输出配置\n    66→    tools: List[str]\n    67→\n    68→\n    69→@dataclass\n    70→class ToolMetadata:\n    71→    \"\"\"工具元数据\"\"\"\n    72→    name: str\n    73→    description: str\n    74→    tool_type: str  # collect/calculate/display/search\n    75→    card_type: Optional[str] = None\n    76→    card_props_schema: Optional[Dict] = None\n    77→    parameters: Dict[str, Any] = field(default_factory=dict)\n    78→    when_to_call: Optional[str] = None\n    79→\n    80→\n    81→# ═══════════════════════════════════════════════════════════════════════════\n    82→# 解析函数\n    83→# ═══════════════════════════════════════════════════════════════════════════\n    84→\n    85→def parse_frontmatter(text: str) -> tuple[Dict, str]:\n    86→    \"\"\"解析 YAML frontmatter\"\"\"\n    87→    pattern = r'^---\\s*\\n(.*?)\\n---\\s*\\n(.*)$'\n    88→    match = re.match(pattern, text, re.DOTALL)\n    89→    if not match:\n    90→        return {}, text\n    91→\n    92→    frontmatter_str, content = match.groups()\n    93→    metadata = {}\n    94→    current_key = None\n    95→    current_list = None\n    96→\n    97→    for line in frontmatter_str.strip().split('\\n'):\n    98→        stripped = line.strip()\n    99→        if not stripped:\n   100→            continue\n   101→        if stripped.startswith('- ') and current_key:\n   102→            if current_list is None:\n   103→                current_list = []\n   104→            current_list.append(stripped[2:].strip())\n   105→            metadata[current_key] = current_list\n   106→        elif ':' in line and not line.startswith(' '):\n   107→            current_list = None\n   108→            key, value = line.split(':', 1)\n   109→            current_key = key.strip()\n   110→            value = value.strip()\n   111→            if value in ('|', ''):\n   112→                continue\n   113→            elif value.lower() == 'true':\n   114→                metadata[current_key] = True\n   115→            elif value.lower() == 'false':\n   116→                metadata[current_key] = False\n   117→            else:\n   118→                metadata[current_key] = value\n   119→\n   120→    return metadata, content.strip()\n   121→\n   122→\n   123→def parse_skill_md(text: str) -> Dict[str, Any]:\n   124→    \"\"\"解析 SKILL.md 内容，提取结构化信息\"\"\"\n   125→    metadata, content = parse_frontmatter(text)\n   126→\n   127→    result = {\n   128→        \"id\": metadata.get(\"id\", \"\"),\n   129→        \"name\": metadata.get(\"name\", \"\"),\n   130→        \"description\": metadata.get(\"description\", \"\"),\n   131→        \"triggers\": metadata.get(\"triggers\", []),\n   132→        \"default_scenario\": metadata.get(\"default_scenario\", \"basic_reading\"),\n   133→        \"global_tools\": metadata.get(\"global_tools\", []),  # 从 frontmatter 读取\n   134→    }\n   135→\n   136→    # 提取专家身份\n   137→    expert_match = re.search(r'## 专家身份\\s*\\n(.*?)(?=\\n## |\\Z)', content, re.DOTALL)\n   138→    result[\"expert_persona\"] = expert_match.group(1).strip() if expert_match else \"\"\n   139→\n   140→    # 提取场景目录\n   141→    scenarios = {\"entry\": [], \"standard\": [], \"professional\": []}\n   142→    for level in scenarios.keys():\n   143→        pattern = rf'### {level.capitalize()}.*?\\n\\|.*?\\n\\|.*?\\n((?:\\|.*?\\n)*)'\n   144→        match = re.search(pattern, content, re.IGNORECASE | re.DOTALL)\n   145→        if match:\n   146→            for row in match.group(1).strip().split('\\n'):\n   147→                cols = [c.strip() for c in row.split('|')[1:-1]]\n   148→                if len(cols) >= 2:\n   149→                    scenarios[level].append(cols[1])  # 文件名\n   150→    result[\"scenarios\"] = scenarios\n   151→\n   152→    # 提取伦理边界\n   153→    ethics = {\"forbidden\": [], \"sensitive\": [], \"principles\": []}\n   154→    forbidden_match = re.search(r'### 绝对禁止\\s*\\n((?:- .*?\\n)*)', content)\n   155→    if forbidden_match:\n   156→        ethics[\"forbidden\"] = [l[2:].strip() for l in forbidden_match.group(1).strip().split('\\n')]\n   157→    result[\"ethics\"] = ethics\n   158→\n   159→    # 提取工具列表\n   160→    tools = []\n   161→    tools_match = re.search(r'## 工具列表\\s*\\n\\|.*?\\n\\|.*?\\n((?:\\|.*?\\n)*)', content)\n   162→    if tools_match:\n   163→        for row in tools_match.group(1).strip().split('\\n'):\n   164→            cols = [c.strip() for c in row.split('|')[1:-1]]\n   165→            if len(cols) >= 1:\n   166→                tools.append(cols[0])\n   167→    result[\"tools\"] = tools\n   168→\n   169→    return result\n   170→\n   171→\n   172→def parse_scenario_md(text: str) -> Dict[str, Any]:\n   173→    \"\"\"解析 scenario.md 内容\"\"\"\n   174→    metadata, content = parse_frontmatter(text)\n   175→\n   176→    result = {\n   177→        \"id\": metadata.get(\"id\", \"\"),\n   178→        \"name\": metadata.get(\"name\", \"\"),\n   179→        \"level\": metadata.get(\"level\", \"entry\"),\n   180→        \"billing\": metadata.get(\"billing\", \"free\"),\n   181→        \"description\": metadata.get(\"description\", \"\"),\n   182→    }\n   183→\n   184→    # 提取触发条件\n   185→    triggers = {\"primary\": [], \"secondary\": []}\n   186→    primary_match = re.search(r'\\*\\*主要触发词\\*\\*:\\s*(.*?)(?:\\n|$)', content)\n   187→    if primary_match:\n   188→        triggers[\"primary\"] = [t.strip() for t in primary_match.group(1).split(',')]\n   189→    secondary_match = re.search(r'\\*\\*次要触发词\\*\\*:\\s*(.*?)(?:\\n|$)', content)\n   190→    if secondary_match:\n   191→        triggers[\"secondary\"] = [t.strip() for t in secondary_match.group(1).split(',')]\n   192→    result[\"triggers\"] = triggers\n   193→\n   194→    # 提取前置要求\n   195→    prereq_match = re.search(r'## 前置要求\\s*\\n((?:- .*?\\n)*)', content)\n   196→    result[\"prerequisites\"] = []\n   197→    if prereq_match:\n   198→        result[\"prerequisites\"] = [l[2:].strip() for l in prereq_match.group(1).strip().split('\\n')]\n   199→\n   200→    # 提取 SOP 阶段\n   201→    sop = []\n   202→    phase_pattern = r'### Phase (\\d+):\\s*(.*?)\\n(.*?)(?=### Phase|\\Z)'\n   203→    for match in re.finditer(phase_pattern, content, re.DOTALL):\n   204→        phase_num, phase_name, phase_content = match.groups()\n   205→        phase = {\n   206→            \"phase\": int(phase_num),\n   207→            \"name\": phase_name.strip(),\n   208→            \"content\": phase_content.strip()\n   209→        }\n   210→        # 提取类型\n   211→        type_match = re.search(r'\\*\\*类型\\*\\*:\\s*(\\w+)', phase_content)\n   212→        if type_match:\n   213→            phase[\"type\"] = type_match.group(1)\n   214→        sop.append(phase)\n   215→    result[\"sop\"] = sop\n   216→\n   217→    # 提取工具列表\n   218→    tools_match = re.search(r'\\*\\*使用工具\\*\\*:\\s*\\n((?:- .*?\\n)*)', content)\n   219→    result[\"tools\"] = []\n   220→    if tools_match:\n   221→        result[\"tools\"] = [l[2:].strip() for l in tools_match.group(1).strip().split('\\n')]\n   222→\n   223→    # 知识检索配置\n   224→    result[\"knowledge_config\"] = {}\n   225→    result[\"output_config\"] = {}\n   226→\n   227→    return result\n   228→\n   229→\n   230→def parse_skill_services(text: str) -> Dict[str, List[Dict[str, Any]]]:\n   231→    \"\"\"解析 SKILL.md 中的服务目录，提取展示信息\"\"\"\n   232→    services = {\"entry\": [], \"standard\": [], \"professional\": []}\n   233→\n   234→    tier_map = {\n   235→        \"entry\": \"entry\",\n   236→        \"standard\": \"standard\",\n   237→        \"professional\": \"professional\"\n   238→    }\n   239→\n   240→    for tier_name, tier_key in tier_map.items():\n   241→        # 匹配表格头和内容\n   242→        pattern = rf'### {tier_name.capitalize()}.*?\\n\\|[^\\n]+\\n\\|[-\\s|]+\\n((?:\\|[^\\n]+\\n)*)'\n   243→        match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n   244→        if not match:\n   245→            continue\n   246→\n   247→        table_content = match.group(1).strip()\n   248→        if not table_content:\n   249→            continue\n   250→\n   251→        for row in table_content.split('\\n'):\n   252→            cols = [c.strip() for c in row.split('|')[1:-1]]\n   253→            if len(cols) < 7:  # 至少需要 7 列（场景、文件、触发词、计费、展示名称、图标、简介）\n   254→                continue\n   255→\n   256→            service = {\n   257→                \"scenario_id\": cols[1].replace('.md', '') if cols[1] else cols[0].lower().replace(' ', '_'),\n   258→                \"name\": cols[4] if len(cols) > 4 and cols[4] else cols[0],\n   259→                \"icon\": cols[5] if len(cols) > 5 and cols[5] else \"📌\",\n   260→                \"description\": cols[6] if len(cols) > 6 and cols[6] else \"\",\n   261→                \"tier\": tier_key,\n   262→                \"billing\": cols[3] if len(cols) > 3 else \"免费\",\n   263→                \"highlights\": []\n   264→            }\n   265→\n   266→            # 解析价值点（第8列，如果存在）\n   267→            if len(cols) > 7 and cols[7]:\n   268→                service[\"highlights\"] = [h.strip() for h in cols[7].split(',')]\n   269→\n   270→            services[tier_key].append(service)\n   271→\n   272→    return services\n   273→\n   274→\n   275→def get_skill_services(skill_id: str) -> Optional[Dict[str, Any]]:\n   276→    \"\"\"获取 Skill 的服务目录数据（用于 show_skill_services 工具）\"\"\"\n   277→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   278→    if not skill_path.exists():\n   279→        return None\n   280→\n   281→    text = skill_path.read_text(encoding='utf-8')\n   282→    metadata, _ = parse_frontmatter(text)\n   283→    services = parse_skill_services(text)\n   284→\n   285→    return {\n   286→        \"skill_id\": skill_id,\n   287→        \"skill_name\": metadata.get(\"name\", skill_id),\n   288→        \"description\": metadata.get(\"description\", \"\"),\n   289→        \"services\": services\n   290→    }\n   291→\n   292→\n   293→# ═══════════════════════════════════════════════════════════════════════════\n   294→# 加载函数\n   295→# ═══════════════════════════════════════════════════════════════════════════\n   296→\n   297→@lru_cache(maxsize=32)\n   298→def load_skill(skill_id: str) -> Optional[SkillConfig]:\n   299→    \"\"\"加载 Skill 核心配置\"\"\"\n   300→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   301→    if not skill_path.exists():\n   302→        return None\n   303→\n   304→    text = skill_path.read_text(encoding='utf-8')\n   305→    data = parse_skill_md(text)\n   306→\n   307→    return SkillConfig(\n   308→        id=data.get(\"id\", skill_id),\n   309→        name=data.get(\"name\", skill_id),\n   310→        description=data.get(\"description\", \"\"),\n   311→        expert_persona=data.get(\"expert_persona\", \"\"),\n   312→        scenarios=data.get(\"scenarios\", {}),\n   313→        ethics=data.get(\"ethics\", {}),\n   314→        tools=data.get(\"tools\", []),\n   315→        default_scenario=data.get(\"default_scenario\", \"basic_reading\"),\n   316→        triggers=data.get(\"triggers\", []),\n   317→        global_tools=data.get(\"global_tools\", [])\n   318→    )\n   319→\n   320→\n   321→@lru_cache(maxsize=64)\n   322→def load_scenario(skill_id: str, scenario_id: str) -> Optional[ScenarioConfig]:\n   323→    \"\"\"加载场景配置\"\"\"\n   324→    scenario_path = SKILLS_DIR / skill_id / \"scenarios\" / f\"{scenario_id}.md\"\n   325→    if not scenario_path.exists():\n   326→        return None\n   327→\n   328→    text = scenario_path.read_text(encoding='utf-8')\n   329→    data = parse_scenario_md(text)\n   330→\n   331→    return ScenarioConfig(\n   332→        id=data.get(\"id\", scenario_id),\n   333→        name=data.get(\"name\", scenario_id),\n   334→        level=data.get(\"level\", \"entry\"),\n   335→        billing=data.get(\"billing\", \"free\"),\n   336→        description=data.get(\"description\", \"\"),\n   337→        triggers=data.get(\"triggers\", {}),\n   338→        prerequisites=data.get(\"prerequisites\", []),\n   339→        sop=data.get(\"sop\", []),\n   340→        knowledge_config=data.get(\"knowledge_config\", {}),\n   341→        output_config=data.get(\"output_config\", {}),\n   342→        tools=data.get(\"tools\", [])\n   343→    )\n   344→\n   345→\n   346→def get_available_skills() -> List[str]:\n   347→    \"\"\"获取所有可用的 Skill\"\"\"\n   348→    if not SKILLS_DIR.exists():\n   349→        return []\n   350→    return [p.name for p in SKILLS_DIR.iterdir()\n   351→            if p.is_dir() and (p / \"SKILL.md\").exists()]\n   352→\n   353→\n   354→def get_skill_scenarios(skill_id: str) -> List[str]:\n   355→    \"\"\"获取 Skill 的所有场景\"\"\"\n   356→    scenarios_dir = SKILLS_DIR / skill_id / \"scenarios\"\n   357→    if not scenarios_dir.exists():\n   358→        return []\n   359→    return [p.stem for p in scenarios_dir.glob(\"*.md\")]\n   360→\n   361→\n   362→def get_skill_triggers() -> Dict[str, List[str]]:\n   363→    \"\"\"获取所有 Skill 的触发词\"\"\"\n   364→    triggers = {}\n   365→    for skill_id in get_available_skills():\n   366→        if skill_id == \"core\":\n   367→            continue\n   368→        skill = load_skill(skill_id)\n   369→        if skill and skill.triggers:\n   370→            triggers[skill_id] = skill.triggers\n   371→    return triggers\n   372→\n   373→\n   374→def get_skill_global_tools(skill_id: str) -> List[str]:\n   375→    \"\"\"获取 Skill 声明需要的全局工具列表\"\"\"\n   376→    skill = load_skill(skill_id)\n   377→    if skill and skill.global_tools:\n   378→        return skill.global_tools\n   379→    # 默认返回所有全局工具（向后兼容）\n   380→    return []\n   381→\n   382→\n   383→# ═══════════════════════════════════════════════════════════════════════════\n   384→# System Prompt 构建\n   385→# ═══════════════════════════════════════════════════════════════════════════\n   386→\n   387→def build_system_prompt(\n   388→    skill_id: str,\n   389→    scenario_id: Optional[str] = None,\n   390→    user_context: Optional[Dict] = None\n   391→) -> str:\n   392→    \"\"\"构建完整的 System Prompt\"\"\"\n   393→    parts = []\n   394→\n   395→    # 加载 Skill\n   396→    skill = load_skill(skill_id)\n   397→    if not skill:\n   398→        return \"\"\n   399→\n   400→    # 专家身份\n   401→    parts.append(f\"# {skill.name}\\n\\n{skill.expert_persona}\")\n   402→\n   403→    # 加载场景\n   404→    if scenario_id:\n   405→        scenario = load_scenario(skill_id, scenario_id)\n   406→        if scenario:\n   407→            parts.append(f\"\\n---\\n\\n## 当前场景: {scenario.name}\\n\\n{scenario.description}\")\n   408→\n   409→            # SOP\n   410→            if scenario.sop:\n   411→                sop_text = \"\\n## 服务流程 (SOP)\\n\\n\"\n   412→                for phase in scenario.sop:\n   413→                    sop_text += f\"### Phase {phase['phase']}: {phase['name']}\\n{phase['content']}\\n\\n\"\n   414→                parts.append(sop_text)\n   415→\n   416→    # 伦理边界\n   417→    if skill.ethics.get(\"forbidden\"):\n   418→        ethics_text = \"\\n## 伦理边界\\n\\n### 绝对禁止\\n\"\n   419→        for item in skill.ethics[\"forbidden\"]:\n   420→            ethics_text += f\"- {item}\\n\"\n   421→        parts.append(ethics_text)\n   422→\n   423→    # 用户上下文 - 自动处理所有字段\n   424→    if user_context:\n   425→        ctx_text = \"\\n## 用户上下文\\n\"\n   426→\n   427→        # 特殊处理 birth_info\n   428→        if user_context.get(\"birth_info\"):\n   429→            birth_info = user_context['birth_info']\n   430→            ctx_text += f\"\\n### 出生信息（已收集，无需再次询问）\\n\"\n   431→            ctx_text += f\"{json.dumps(birth_info, ensure_ascii=False)}\\n\"\n   432→            ctx_text += f\"\\n**重要**: 用户已提供出生信息，可以直接进行排盘和分析，无需调用 collect_bazi_info 工具。\\n\"\n   433→\n   434→        # 特殊处理 portrait\n   435→        if user_context.get(\"portrait\"):\n   436→            ctx_text += f\"\\n### 用户画像\\n{user_context['portrait']}\\n\"\n   437→\n   438→        # 特殊处理 extracted (抽取的用户信息)\n   439→        if user_context.get(\"extracted\"):\n   440→            extracted = user_context['extracted']\n   441→            ctx_text += f\"\\n### 用户信息 (从历史对话中抽取)\\n\"\n   442→            if extracted.get(\"facts\"):\n   443→                ctx_text += f\"**基本信息**: {json.dumps(extracted['facts'], ensure_ascii=False)}\\n\"\n   444→            if extracted.get(\"concerns\"):\n   445→                ctx_text += f\"**关注领域**: {', '.join(extracted['concerns'])}\\n\"\n   446→            if extracted.get(\"goals\"):\n   447→                ctx_text += f\"**当前目标**: {', '.join(extracted['goals'])}\\n\"\n   448→            if extracted.get(\"pain_points\"):\n   449→                ctx_text += f\"**面临困难**: {', '.join(extracted['pain_points'])}\\n\"\n   450→            if extracted.get(\"life_events\"):\n   451→                events = [f\"{e.get('date', '?')}: {e.get('event', '')}\" for e in extracted['life_events'][:5]]\n   452→                ctx_text += f\"**近期事件**: {'; '.join(events)}\\n\"\n   453→\n   454→        # 特殊处理 identity_prism\n   455→        if user_context.get(\"identity_prism\"):\n   456→            prism = user_context['identity_prism']\n   457→            ctx_text += f\"\\n### 身份特征\\n\"\n   458→            if prism.get(\"core\"):\n   459→                ctx_text += f\"**核心特质**: {prism['core']}\\n\"\n   460→            if prism.get(\"inner\"):\n   461→                ctx_text += f\"**内在需求**: {prism['inner']}\\n\"\n   462→            if prism.get(\"outer\"):\n   463→                ctx_text += f\"**外在表现**: {prism['outer']}\\n\"\n   464→\n   465→        # 特殊处理 life_context\n   466→        if user_context.get(\"life_context\"):\n   467→            life_ctx = user_context['life_context']\n   468→            if life_ctx.get(\"concerns\") or life_ctx.get(\"goals\") or life_ctx.get(\"pain_points\"):\n   469→                ctx_text += f\"\\n### 生活背景\\n\"\n   470→                if life_ctx.get(\"concerns\"):\n   471→                    ctx_text += f\"**关注**: {', '.join(life_ctx['concerns'])}\\n\"\n   472→                if life_ctx.get(\"goals\"):\n   473→                    ctx_text += f\"**目标**: {', '.join(life_ctx['goals'])}\\n\"\n   474→                if life_ctx.get(\"pain_points\"):\n   475→                    ctx_text += f\"**困难**: {', '.join(life_ctx['pain_points'])}\\n\"\n   476→\n   477→        parts.append(ctx_text)\n   478→\n   479→    return \"\\n\".join(parts)\n   480→\n   481→\n   482→# ═══════════════════════════════════════════════════════════════════════════\n   483→# 缓存管理\n   484→# ═══════════════════════════════════════════════════════════════════════════\n   485→\n   486→def clear_cache():\n   487→    \"\"\"清除所有缓存\"\"\"\n   488→    load_skill.cache_clear()\n   489→    load_scenario.cache_clear()\n   490→    get_scenario_triggers.cache_clear()\n   491→    logger.info(\"Skill cache cleared\")\n   492→\n   493→\n   494→def reload_skill(skill_id: str) -> Optional[SkillConfig]:\n   495→    \"\"\"重载单个 Skill\"\"\"\n   496→    load_skill.cache_clear()\n   497→    load_scenario.cache_clear()\n   498→    return load_skill(skill_id)\n   499→\n   500→\n   501→# ═══════════════════════════════════════════════════════════════════════════\n   502→# 场景路由 (内存匹配)\n   503→# ═══════════════════════════════════════════════════════════════════════════\n   504→\n   505→def parse_scenario_triggers(text: str) -> Dict[str, Dict[str, List[str]]]:\n   506→    \"\"\"从 SKILL.md 解析场景目录表格，提取触发词\"\"\"\n   507→    triggers = {}  # {scenario_id: {primary: [...], secondary: [...]}}\n   508→\n   509→    # 匹配三个级别的表格\n   510→    for level in [\"entry\", \"standard\", \"professional\"]:\n   511→        pattern = rf'### {level.capitalize()}.*?\\n\\|[^\\n]+\\n\\|[-\\s|]+\\n((?:\\|[^\\n]+\\n)*)'\n   512→        match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n   513→        if not match:\n   514→            continue\n   515→\n   516→        for row in match.group(1).strip().split('\\n'):\n   517→            cols = [c.strip() for c in row.split('|')[1:-1]]\n   518→            if len(cols) >= 3:\n   519→                # cols[1] = 文件名, cols[2] = 触发词\n   520→                scenario_id = cols[1].replace('.md', '')\n   521→                trigger_str = cols[2]\n   522→                # 解析触发词（用顿号或逗号分隔）\n   523→                trigger_words = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]\n   524→                triggers[scenario_id] = {\n   525→                    \"primary\": trigger_words,\n   526→                    \"secondary\": []\n   527→                }\n   528→\n   529→    return triggers\n   530→\n   531→\n   532→@lru_cache(maxsize=32)\n   533→def get_scenario_triggers(skill_id: str) -> Dict[str, Dict[str, List[str]]]:\n   534→    \"\"\"获取 Skill 的场景触发词映射（带缓存）\"\"\"\n   535→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   536→    if not skill_path.exists():\n   537→        return {}\n   538→\n   539→    text = skill_path.read_text(encoding='utf-8')\n   540→    return parse_scenario_triggers(text)\n   541→\n   542→\n   543→def route_scenario(skill_id: str, message: str) -> Optional[str]:\n   544→    \"\"\"\n   545→    内存场景路由 - 根据用户消息匹配最佳场景\n   546→\n   547→    Args:\n   548→        skill_id: Skill ID\n   549→        message: 用户消息\n   550→\n   551→    Returns:\n   552→        匹配的 scenario_id，无匹配则返回 None\n   553→    \"\"\"\n   554→    triggers = get_scenario_triggers(skill_id)\n   555→    if not triggers:\n   556→        return None\n   557→\n   558→    best_match = None\n   559→    best_score = 0\n   560→\n   561→    for scenario_id, trigger_config in triggers.items():\n   562→        score = 0\n   563→        # 主要触发词权重 1.0\n   564→        for word in trigger_config.get(\"primary\", []):\n   565→            if word in message:\n   566→                score += 1.0\n   567→        # 次要触发词权重 0.5\n   568→        for word in trigger_config.get(\"secondary\", []):\n   569→            if word in message:\n   570→                score += 0.5\n   571→\n   572→        if score > best_score:\n   573→            best_score = score\n   574→            best_match = scenario_id\n   575→\n   576→    return best_match\n   577→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"542bae24-efb2-4f19-9162-8d8fe1aefdc4","timestamp":"2026-01-18T03:42:40.934Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/skill_loader.py","content":"\"\"\"\nSkillLoader v6 - 支持 Scenario 路由的 Skill 加载器\n\nv6 架构：\n- SKILL.md: 核心定义（专家身份、场景目录、伦理边界）\n- scenarios/*.md: MiniSkill 场景文件（SOP、知识检索配置、输出模板）\n- tools/*.py: 工具定义（收集/计算/展示/检索）\n\"\"\"\nimport re\nimport json\nimport logging\nfrom pathlib import Path\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional, Any\nfrom functools import lru_cache\n\nlogger = logging.getLogger(__name__)\n\nSKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 数据结构\n# ═══════════════════════════════════════════════════════════════════════════\n\n@dataclass\nclass SkillConfig:\n    \"\"\"Skill 核心配置（从 SKILL.md 加载）\"\"\"\n    id: str\n    name: str\n    description: str\n    expert_persona: str\n    scenarios: Dict[str, List[str]]  # {entry: [...], standard: [...], professional: [...]}\n    ethics: Dict[str, Any]\n    tools: List[str]\n    default_scenario: str = \"basic_reading\"\n    triggers: List[str] = field(default_factory=list)\n    global_tools: List[str] = field(default_factory=list)  # 需要的全局工具\n\n\n@dataclass\nclass ServiceItem:\n    \"\"\"服务项（用于服务目录展示）\"\"\"\n    scenario_id: str\n    name: str\n    icon: str\n    description: str\n    tier: str  # entry/standard/professional\n    billing: str  # 免费/基础/高级\n    highlights: List[str] = field(default_factory=list)  # 价值点\n\n\n@dataclass\nclass ScenarioConfig:\n    \"\"\"场景配置（从 scenarios/*.md 加载）\"\"\"\n    id: str\n    name: str\n    level: str  # entry/standard/professional\n    billing: str  # free/basic/premium\n    description: str\n    triggers: Dict[str, List[str]]  # {primary: [...], secondary: [...]}\n    prerequisites: List[str]\n    sop: List[Dict[str, Any]]  # SOP 阶段列表\n    knowledge_config: Dict[str, Any]  # 知识检索配置\n    output_config: Dict[str, Any]  # 输出配置\n    tools: List[str]\n\n\n@dataclass\nclass ToolMetadata:\n    \"\"\"工具元数据\"\"\"\n    name: str\n    description: str\n    tool_type: str  # collect/calculate/display/search\n    card_type: Optional[str] = None\n    card_props_schema: Optional[Dict] = None\n    parameters: Dict[str, Any] = field(default_factory=dict)\n    when_to_call: Optional[str] = None\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 解析函数\n# ═══════════════════════════════════════════════════════════════════════════\n\ndef parse_frontmatter(text: str) -> tuple[Dict, str]:\n    \"\"\"解析 YAML frontmatter\"\"\"\n    pattern = r'^---\\s*\\n(.*?)\\n---\\s*\\n(.*)$'\n    match = re.match(pattern, text, re.DOTALL)\n    if not match:\n        return {}, text\n\n    frontmatter_str, content = match.groups()\n    metadata = {}\n    current_key = None\n    current_list = None\n\n    for line in frontmatter_str.strip().split('\\n'):\n        stripped = line.strip()\n        if not stripped:\n            continue\n        if stripped.startswith('- ') and current_key:\n            if current_list is None:\n                current_list = []\n            current_list.append(stripped[2:].strip())\n            metadata[current_key] = current_list\n        elif ':' in line and not line.startswith(' '):\n            current_list = None\n            key, value = line.split(':', 1)\n            current_key = key.strip()\n            value = value.strip()\n            if value in ('|', ''):\n                continue\n            elif value.lower() == 'true':\n                metadata[current_key] = True\n            elif value.lower() == 'false':\n                metadata[current_key] = False\n            else:\n                metadata[current_key] = value\n\n    return metadata, content.strip()\n\n\ndef parse_skill_md(text: str) -> Dict[str, Any]:\n    \"\"\"解析 SKILL.md 内容，提取结构化信息\"\"\"\n    metadata, content = parse_frontmatter(text)\n\n    result = {\n        \"id\": metadata.get(\"id\", \"\"),\n        \"name\": metadata.get(\"name\", \"\"),\n        \"description\": metadata.get(\"description\", \"\"),\n        \"triggers\": metadata.get(\"triggers\", []),\n        \"default_scenario\": metadata.get(\"default_scenario\", \"basic_reading\"),\n        \"global_tools\": metadata.get(\"global_tools\", []),  # 从 frontmatter 读取\n    }\n\n    # 提取专家身份\n    expert_match = re.search(r'## 专家身份\\s*\\n(.*?)(?=\\n## |\\Z)', content, re.DOTALL)\n    result[\"expert_persona\"] = expert_match.group(1).strip() if expert_match else \"\"\n\n    # 提取场景目录\n    scenarios = {\"entry\": [], \"standard\": [], \"professional\": []}\n    for level in scenarios.keys():\n        pattern = rf'### {level.capitalize()}.*?\\n\\|.*?\\n\\|.*?\\n((?:\\|.*?\\n)*)'\n        match = re.search(pattern, content, re.IGNORECASE | re.DOTALL)\n        if match:\n            for row in match.group(1).strip().split('\\n'):\n                cols = [c.strip() for c in row.split('|')[1:-1]]\n                if len(cols) >= 2:\n                    scenarios[level].append(cols[1])  # 文件名\n    result[\"scenarios\"] = scenarios\n\n    # 提取伦理边界\n    ethics = {\"forbidden\": [], \"sensitive\": [], \"principles\": []}\n    forbidden_match = re.search(r'### 绝对禁止\\s*\\n((?:- .*?\\n)*)', content)\n    if forbidden_match:\n        ethics[\"forbidden\"] = [l[2:].strip() for l in forbidden_match.group(1).strip().split('\\n')]\n    result[\"ethics\"] = ethics\n\n    # 提取工具列表\n    tools = []\n    tools_match = re.search(r'## 工具列表\\s*\\n\\|.*?\\n\\|.*?\\n((?:\\|.*?\\n)*)', content)\n    if tools_match:\n        for row in tools_match.group(1).strip().split('\\n'):\n            cols = [c.strip() for c in row.split('|')[1:-1]]\n            if len(cols) >= 1:\n                tools.append(cols[0])\n    result[\"tools\"] = tools\n\n    return result\n\n\ndef parse_scenario_md(text: str) -> Dict[str, Any]:\n    \"\"\"解析 scenario.md 内容\"\"\"\n    metadata, content = parse_frontmatter(text)\n\n    result = {\n        \"id\": metadata.get(\"id\", \"\"),\n        \"name\": metadata.get(\"name\", \"\"),\n        \"level\": metadata.get(\"level\", \"entry\"),\n        \"billing\": metadata.get(\"billing\", \"free\"),\n        \"description\": metadata.get(\"description\", \"\"),\n    }\n\n    # 提取触发条件\n    triggers = {\"primary\": [], \"secondary\": []}\n    primary_match = re.search(r'\\*\\*主要触发词\\*\\*:\\s*(.*?)(?:\\n|$)', content)\n    if primary_match:\n        triggers[\"primary\"] = [t.strip() for t in primary_match.group(1).split(',')]\n    secondary_match = re.search(r'\\*\\*次要触发词\\*\\*:\\s*(.*?)(?:\\n|$)', content)\n    if secondary_match:\n        triggers[\"secondary\"] = [t.strip() for t in secondary_match.group(1).split(',')]\n    result[\"triggers\"] = triggers\n\n    # 提取前置要求\n    prereq_match = re.search(r'## 前置要求\\s*\\n((?:- .*?\\n)*)', content)\n    result[\"prerequisites\"] = []\n    if prereq_match:\n        result[\"prerequisites\"] = [l[2:].strip() for l in prereq_match.group(1).strip().split('\\n')]\n\n    # 提取 SOP 阶段\n    sop = []\n    phase_pattern = r'### Phase (\\d+):\\s*(.*?)\\n(.*?)(?=### Phase|\\Z)'\n    for match in re.finditer(phase_pattern, content, re.DOTALL):\n        phase_num, phase_name, phase_content = match.groups()\n        phase = {\n            \"phase\": int(phase_num),\n            \"name\": phase_name.strip(),\n            \"content\": phase_content.strip()\n        }\n        # 提取类型\n        type_match = re.search(r'\\*\\*类型\\*\\*:\\s*(\\w+)', phase_content)\n        if type_match:\n            phase[\"type\"] = type_match.group(1)\n        sop.append(phase)\n    result[\"sop\"] = sop\n\n    # 提取工具列表\n    tools_match = re.search(r'\\*\\*使用工具\\*\\*:\\s*\\n((?:- .*?\\n)*)', content)\n    result[\"tools\"] = []\n    if tools_match:\n        result[\"tools\"] = [l[2:].strip() for l in tools_match.group(1).strip().split('\\n')]\n\n    # 知识检索配置\n    result[\"knowledge_config\"] = {}\n    result[\"output_config\"] = {}\n\n    return result\n\n\ndef parse_skill_services(text: str) -> Dict[str, List[Dict[str, Any]]]:\n    \"\"\"解析 SKILL.md 中的服务目录，提取展示信息\"\"\"\n    services = {\"entry\": [], \"standard\": [], \"professional\": []}\n\n    tier_map = {\n        \"entry\": \"entry\",\n        \"standard\": \"standard\",\n        \"professional\": \"professional\"\n    }\n\n    for tier_name, tier_key in tier_map.items():\n        # 匹配表格头和内容\n        pattern = rf'### {tier_name.capitalize()}.*?\\n\\|[^\\n]+\\n\\|[-\\s|]+\\n((?:\\|[^\\n]+\\n)*)'\n        match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n        if not match:\n            continue\n\n        table_content = match.group(1).strip()\n        if not table_content:\n            continue\n\n        for row in table_content.split('\\n'):\n            cols = [c.strip() for c in row.split('|')[1:-1]]\n            if len(cols) < 7:  # 至少需要 7 列（场景、文件、触发词、计费、展示名称、图标、简介）\n                continue\n\n            service = {\n                \"scenario_id\": cols[1].replace('.md', '') if cols[1] else cols[0].lower().replace(' ', '_'),\n                \"name\": cols[4] if len(cols) > 4 and cols[4] else cols[0],\n                \"icon\": cols[5] if len(cols) > 5 and cols[5] else \"📌\",\n                \"description\": cols[6] if len(cols) > 6 and cols[6] else \"\",\n                \"tier\": tier_key,\n                \"billing\": cols[3] if len(cols) > 3 else \"免费\",\n                \"highlights\": []\n            }\n\n            # 解析价值点（第8列，如果存在）\n            if len(cols) > 7 and cols[7]:\n                service[\"highlights\"] = [h.strip() for h in cols[7].split(',')]\n\n            services[tier_key].append(service)\n\n    return services\n\n\ndef get_skill_services(skill_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"获取 Skill 的服务目录数据（用于 show_skill_services 工具）\"\"\"\n    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n    if not skill_path.exists():\n        return None\n\n    text = skill_path.read_text(encoding='utf-8')\n    metadata, _ = parse_frontmatter(text)\n    services = parse_skill_services(text)\n\n    return {\n        \"skill_id\": skill_id,\n        \"skill_name\": metadata.get(\"name\", skill_id),\n        \"description\": metadata.get(\"description\", \"\"),\n        \"services\": services\n    }\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 加载函数\n# ═══════════════════════════════════════════════════════════════════════════\n\n@lru_cache(maxsize=32)\ndef load_skill(skill_id: str) -> Optional[SkillConfig]:\n    \"\"\"加载 Skill 核心配置\"\"\"\n    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n    if not skill_path.exists():\n        return None\n\n    text = skill_path.read_text(encoding='utf-8')\n    data = parse_skill_md(text)\n\n    return SkillConfig(\n        id=data.get(\"id\", skill_id),\n        name=data.get(\"name\", skill_id),\n        description=data.get(\"description\", \"\"),\n        expert_persona=data.get(\"expert_persona\", \"\"),\n        scenarios=data.get(\"scenarios\", {}),\n        ethics=data.get(\"ethics\", {}),\n        tools=data.get(\"tools\", []),\n        default_scenario=data.get(\"default_scenario\", \"basic_reading\"),\n        triggers=data.get(\"triggers\", []),\n        global_tools=data.get(\"global_tools\", [])\n    )\n\n\n@lru_cache(maxsize=64)\ndef load_scenario(skill_id: str, scenario_id: str) -> Optional[ScenarioConfig]:\n    \"\"\"加载场景配置\"\"\"\n    scenario_path = SKILLS_DIR / skill_id / \"scenarios\" / f\"{scenario_id}.md\"\n    if not scenario_path.exists():\n        return None\n\n    text = scenario_path.read_text(encoding='utf-8')\n    data = parse_scenario_md(text)\n\n    return ScenarioConfig(\n        id=data.get(\"id\", scenario_id),\n        name=data.get(\"name\", scenario_id),\n        level=data.get(\"level\", \"entry\"),\n        billing=data.get(\"billing\", \"free\"),\n        description=data.get(\"description\", \"\"),\n        triggers=data.get(\"triggers\", {}),\n        prerequisites=data.get(\"prerequisites\", []),\n        sop=data.get(\"sop\", []),\n        knowledge_config=data.get(\"knowledge_config\", {}),\n        output_config=data.get(\"output_config\", {}),\n        tools=data.get(\"tools\", [])\n    )\n\n\ndef get_available_skills() -> List[str]:\n    \"\"\"获取所有可用的 Skill\"\"\"\n    if not SKILLS_DIR.exists():\n        return []\n    return [p.name for p in SKILLS_DIR.iterdir()\n            if p.is_dir() and (p / \"SKILL.md\").exists()]\n\n\ndef get_skill_scenarios(skill_id: str) -> List[str]:\n    \"\"\"获取 Skill 的所有场景\"\"\"\n    scenarios_dir = SKILLS_DIR / skill_id / \"scenarios\"\n    if not scenarios_dir.exists():\n        return []\n    return [p.stem for p in scenarios_dir.glob(\"*.md\")]\n\n\ndef get_skill_triggers() -> Dict[str, List[str]]:\n    \"\"\"获取所有 Skill 的触发词\"\"\"\n    triggers = {}\n    for skill_id in get_available_skills():\n        if skill_id == \"core\":\n            continue\n        skill = load_skill(skill_id)\n        if skill and skill.triggers:\n            triggers[skill_id] = skill.triggers\n    return triggers\n\n\ndef get_skill_global_tools(skill_id: str) -> List[str]:\n    \"\"\"获取 Skill 声明需要的全局工具列表\"\"\"\n    skill = load_skill(skill_id)\n    if skill and skill.global_tools:\n        return skill.global_tools\n    # 默认返回所有全局工具（向后兼容）\n    return []\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# System Prompt 构建\n# ═══════════════════════════════════════════════════════════════════════════\n\ndef build_system_prompt(\n    skill_id: str,\n    scenario_id: Optional[str] = None,\n    user_context: Optional[Dict] = None\n) -> str:\n    \"\"\"构建完整的 System Prompt\"\"\"\n    parts = []\n\n    # 加载 Skill\n    skill = load_skill(skill_id)\n    if not skill:\n        return \"\"\n\n    # 专家身份\n    parts.append(f\"# {skill.name}\\n\\n{skill.expert_persona}\")\n\n    # 加载场景\n    if scenario_id:\n        scenario = load_scenario(skill_id, scenario_id)\n        if scenario:\n            parts.append(f\"\\n---\\n\\n## 当前场景: {scenario.name}\\n\\n{scenario.description}\")\n\n            # SOP\n            if scenario.sop:\n                sop_text = \"\\n## 服务流程 (SOP)\\n\\n\"\n                for phase in scenario.sop:\n                    sop_text += f\"### Phase {phase['phase']}: {phase['name']}\\n{phase['content']}\\n\\n\"\n                parts.append(sop_text)\n\n    # 伦理边界\n    if skill.ethics.get(\"forbidden\"):\n        ethics_text = \"\\n## 伦理边界\\n\\n### 绝对禁止\\n\"\n        for item in skill.ethics[\"forbidden\"]:\n            ethics_text += f\"- {item}\\n\"\n        parts.append(ethics_text)\n\n    # 用户上下文 - 自动处理所有字段\n    if user_context:\n        ctx_text = \"\\n## 用户上下文\\n\"\n\n        # 特殊处理 birth_info\n        if user_context.get(\"birth_info\"):\n            birth_info = user_context['birth_info']\n            ctx_text += f\"\\n### 出生信息（已收集，无需再次询问）\\n\"\n            ctx_text += f\"{json.dumps(birth_info, ensure_ascii=False)}\\n\"\n            ctx_text += f\"\\n**重要**: 用户已提供出生信息，可以直接进行排盘和分析，无需调用 collect_bazi_info 工具。\\n\"\n\n        # 特殊处理 portrait\n        if user_context.get(\"portrait\"):\n            ctx_text += f\"\\n### 用户画像\\n{user_context['portrait']}\\n\"\n\n        # 特殊处理 extracted (抽取的用户信息)\n        if user_context.get(\"extracted\"):\n            extracted = user_context['extracted']\n            ctx_text += f\"\\n### 用户信息 (从历史对话中抽取)\\n\"\n            if extracted.get(\"facts\"):\n                ctx_text += f\"**基本信息**: {json.dumps(extracted['facts'], ensure_ascii=False)}\\n\"\n            if extracted.get(\"concerns\"):\n                ctx_text += f\"**关注领域**: {', '.join(extracted['concerns'])}\\n\"\n            if extracted.get(\"goals\"):\n                ctx_text += f\"**当前目标**: {', '.join(extracted['goals'])}\\n\"\n            if extracted.get(\"pain_points\"):\n                ctx_text += f\"**面临困难**: {', '.join(extracted['pain_points'])}\\n\"\n            if extracted.get(\"life_events\"):\n                events = [f\"{e.get('date', '?')}: {e.get('event', '')}\" for e in extracted['life_events'][:5]]\n                ctx_text += f\"**近期事件**: {'; '.join(events)}\\n\"\n\n        # 特殊处理 identity_prism\n        if user_context.get(\"identity_prism\"):\n            prism = user_context['identity_prism']\n            ctx_text += f\"\\n### 身份特征\\n\"\n            if prism.get(\"core\"):\n                ctx_text += f\"**核心特质**: {prism['core']}\\n\"\n            if prism.get(\"inner\"):\n                ctx_text += f\"**内在需求**: {prism['inner']}\\n\"\n            if prism.get(\"outer\"):\n                ctx_text += f\"**外在表现**: {prism['outer']}\\n\"\n\n        # 特殊处理 life_context\n        if user_context.get(\"life_context\"):\n            life_ctx = user_context['life_context']\n            if life_ctx.get(\"concerns\") or life_ctx.get(\"goals\") or life_ctx.get(\"pain_points\"):\n                ctx_text += f\"\\n### 生活背景\\n\"\n                if life_ctx.get(\"concerns\"):\n                    ctx_text += f\"**关注**: {', '.join(life_ctx['concerns'])}\\n\"\n                if life_ctx.get(\"goals\"):\n                    ctx_text += f\"**目标**: {', '.join(life_ctx['goals'])}\\n\"\n                if life_ctx.get(\"pain_points\"):\n                    ctx_text += f\"**困难**: {', '.join(life_ctx['pain_points'])}\\n\"\n\n        parts.append(ctx_text)\n\n    return \"\\n\".join(parts)\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 缓存管理\n# ═══════════════════════════════════════════════════════════════════════════\n\ndef clear_cache():\n    \"\"\"清除所有缓存\"\"\"\n    load_skill.cache_clear()\n    load_scenario.cache_clear()\n    get_scenario_triggers.cache_clear()\n    logger.info(\"Skill cache cleared\")\n\n\ndef reload_skill(skill_id: str) -> Optional[SkillConfig]:\n    \"\"\"重载单个 Skill\"\"\"\n    load_skill.cache_clear()\n    load_scenario.cache_clear()\n    return load_skill(skill_id)\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 场景路由 (内存匹配)\n# ═══════════════════════════════════════════════════════════════════════════\n\ndef parse_scenario_triggers(text: str) -> Dict[str, Dict[str, List[str]]]:\n    \"\"\"从 SKILL.md 解析场景目录表格，提取触发词\"\"\"\n    triggers = {}  # {scenario_id: {primary: [...], secondary: [...]}}\n\n    # 匹配三个级别的表格\n    for level in [\"entry\", \"standard\", \"professional\"]:\n        pattern = rf'### {level.capitalize()}.*?\\n\\|[^\\n]+\\n\\|[-\\s|]+\\n((?:\\|[^\\n]+\\n)*)'\n        match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n        if not match:\n            continue\n\n        for row in match.group(1).strip().split('\\n'):\n            cols = [c.strip() for c in row.split('|')[1:-1]]\n            if len(cols) >= 3:\n                # cols[1] = 文件名, cols[2] = 触发词\n                scenario_id = cols[1].replace('.md', '')\n                trigger_str = cols[2]\n                # 解析触发词（用顿号或逗号分隔）\n                trigger_words = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]\n                triggers[scenario_id] = {\n                    \"primary\": trigger_words,\n                    \"secondary\": []\n                }\n\n    return triggers\n\n\n@lru_cache(maxsize=32)\ndef get_scenario_triggers(skill_id: str) -> Dict[str, Dict[str, List[str]]]:\n    \"\"\"获取 Skill 的场景触发词映射（带缓存）\"\"\"\n    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n    if not skill_path.exists():\n        return {}\n\n    text = skill_path.read_text(encoding='utf-8')\n    return parse_scenario_triggers(text)\n\n\ndef route_scenario(skill_id: str, message: str) -> Optional[str]:\n    \"\"\"\n    内存场景路由 - 根据用户消息匹配最佳场景\n\n    Args:\n        skill_id: Skill ID\n        message: 用户消息\n\n    Returns:\n        匹配的 scenario_id，无匹配则返回 None\n    \"\"\"\n    triggers = get_scenario_triggers(skill_id)\n    if not triggers:\n        return None\n\n    best_match = None\n    best_score = 0\n\n    for scenario_id, trigger_config in triggers.items():\n        score = 0\n        # 主要触发词权重 1.0\n        for word in trigger_config.get(\"primary\", []):\n            if word in message:\n                score += 1.0\n        # 次要触发词权重 0.5\n        for word in trigger_config.get(\"secondary\", []):\n            if word in message:\n                score += 0.5\n\n        if score > best_score:\n            best_score = score\n            best_match = scenario_id\n\n    return best_match\n","numLines":577,"startLine":1,"totalLines":577}},"sourceToolAssistantUUID":"abf0d4dd-5cd8-4182-af8c-50cc35a567a8"}
{"parentUuid":"e4dad514-80f7-4acc-8583-52f7e95ccf30","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H6Kv4eqrd6okmxJQdTJ1Vt","type":"tool_result","content":"     1→\"\"\"\n     2→Unified Tool Registry v6 - 统一工具注册表\n     3→\n     4→解决工具注册的硬编码问题：\n     5→1. 从 YAML 加载工具定义 (Single Source of Truth)\n     6→2. 使用 @tool_handler 装饰器动态注册执行器\n     7→3. 消除 if-elif 分发，使用注册表查找\n     8→\n     9→V6.1 更新：\n    10→- 全局工具从 skills/core/tools/ 加载\n    11→- 移除对 GLOBAL_TOOLS 硬编码的依赖\n    12→\n    13→新增工具只需修改 2 处：\n    14→1. skills/{skill_id}/tools/tools.yaml - 工具定义\n    15→2. skills/{skill_id}/tools/handlers.py - @tool_handler 执行器\n    16→\n    17→用法：\n    18→    from services.agent.tool_registry import tool_handler, ToolRegistry\n    19→\n    20→    @tool_handler(\"show_bazi_chart\")\n    21→    async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:\n    22→        return {\"chart\": ...}\n    23→\n    24→    # CoreAgent 中使用\n    25→    tools = ToolRegistry.get_tools_for_skill(\"bazi\")\n    26→    result = await ToolRegistry.execute(\"show_bazi_chart\", args, context)\n    27→\"\"\"\n    28→import logging\n    29→import importlib\n    30→import asyncio\n    31→from pathlib import Path\n    32→from typing import Dict, Any, List, Optional, Callable, Awaitable, Union\n    33→from dataclasses import dataclass, field\n    34→from functools import wraps\n    35→\n    36→from .tool_schema import ToolDef, load_skill_tools, get_global_tools\n    37→\n    38→logger = logging.getLogger(__name__)\n    39→\n    40→SKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n    41→\n    42→\n    43→@dataclass\n    44→class ToolContext:\n    45→    \"\"\"工具执行上下文\"\"\"\n    46→    user_id: str\n    47→    user_tier: str = \"free\"\n    48→    profile: Dict[str, Any] = field(default_factory=dict)\n    49→    skill_data: Dict[str, Any] = field(default_factory=dict)\n    50→    skill_id: Optional[str] = None\n    51→    scenario_id: Optional[str] = None\n    52→    conversation_id: Optional[str] = None\n    53→\n    54→\n    55→# 工具执行器类型: 同步或异步函数\n    56→ToolHandler = Callable[[Dict[str, Any], ToolContext], Union[Dict[str, Any], Awaitable[Dict[str, Any]]]]\n    57→\n    58→\n    59→class UnifiedToolRegistry:\n    60→    \"\"\"\n    61→    统一工具注册表\n    62→\n    63→    - 工具定义从 YAML 加载\n    64→    - 执行器通过 @tool_handler 装饰器注册\n    65→    - 支持全局工具和 Skill 专属工具\n    66→    \"\"\"\n    67→\n    68→    # 工具定义缓存: {tool_name: ToolDef}\n    69→    _tool_defs: Dict[str, ToolDef] = {}\n    70→\n    71→    # 工具执行器: {tool_name: handler_function}\n    72→    _handlers: Dict[str, ToolHandler] = {}\n    73→\n    74→    # 已加载的 Skill\n    75→    _loaded_skills: set = set()\n    76→\n    77→    # 是否已初始化\n    78→    _initialized: bool = False\n    79→\n    80→    @classmethod\n    81→    def initialize(cls):\n    82→        \"\"\"初始化注册表，加载全局工具\"\"\"\n    83→        if cls._initialized:\n    84→            return\n    85→\n    86→        # 从 core skill 加载全局工具定义\n    87→        global_tools = get_global_tools()\n    88→        for tool in global_tools:\n    89→            tool.is_global = True\n    90→            cls._tool_defs[tool.name] = tool\n    91→\n    92→        # 加载 core skill 的 handlers\n    93→        cls._load_handlers_module(\"core\")\n    94→\n    95→        # 自动发现并加载所有 Skill 的工具\n    96→        cls._auto_discover_skills()\n    97→\n    98→        cls._initialized = True\n    99→        logger.info(f\"ToolRegistry initialized: {len(cls._tool_defs)} tools, {len(cls._handlers)} handlers\")\n   100→\n   101→    @classmethod\n   102→    def _auto_discover_skills(cls):\n   103→        \"\"\"自动发现并加载所有 Skill\"\"\"\n   104→        if not SKILLS_DIR.exists():\n   105→            logger.warning(f\"Skills directory not found: {SKILLS_DIR}\")\n   106→            return\n   107→\n   108→        for skill_dir in SKILLS_DIR.iterdir():\n   109→            if skill_dir.is_dir() and skill_dir.name != \"__pycache__\":\n   110→                skill_id = skill_dir.name\n   111→                cls.load_skill(skill_id)\n   112→\n   113→    @classmethod\n   114→    def load_skill(cls, skill_id: str):\n   115→        \"\"\"加载 Skill 的工具定义和执行器\"\"\"\n   116→        if skill_id in cls._loaded_skills:\n   117→            return\n   118→\n   119→        # 1. 从 YAML 加载工具定义\n   120→        tools = load_skill_tools(skill_id)\n   121→        for tool in tools:\n   122→            tool.skill_id = skill_id  # 标记所属 Skill\n   123→            cls._tool_defs[tool.name] = tool\n   124→\n   125→        # 2. 尝试加载执行器模块\n   126→        cls._load_handlers_module(skill_id)\n   127→\n   128→        cls._loaded_skills.add(skill_id)\n   129→        logger.debug(f\"Loaded skill '{skill_id}': {len(tools)} tools\")\n   130→\n   131→    @classmethod\n   132→    def _load_handlers_module(cls, skill_id: str):\n   133→        \"\"\"加载 Skill 的 handlers 模块\"\"\"\n   134→        handlers_path = SKILLS_DIR / skill_id / \"tools\" / \"handlers.py\"\n   135→        if not handlers_path.exists():\n   136→            logger.debug(f\"No handlers module for skill '{skill_id}'\")\n   137→            return\n   138→\n   139→        try:\n   140→            module_name = f\"skills.{skill_id}.tools.handlers\"\n   141→            importlib.import_module(module_name)\n   142→            logger.debug(f\"Loaded handlers module: {module_name}\")\n   143→        except ImportError as e:\n   144→            logger.warning(f\"Failed to import handlers for '{skill_id}': {e}\")\n   145→\n   146→    @classmethod\n   147→    def register_handler(cls, tool_name: str, handler: ToolHandler):\n   148→        \"\"\"注册工具执行器\"\"\"\n   149→        cls._handlers[tool_name] = handler\n   150→        logger.debug(f\"Registered handler: {tool_name}\")\n   151→\n   152→    @classmethod\n   153→    def get_tool_def(cls, tool_name: str) -> Optional[ToolDef]:\n   154→        \"\"\"获取工具定义\"\"\"\n   155→        cls.initialize()\n   156→        return cls._tool_defs.get(tool_name)\n   157→\n   158→    @classmethod\n   159→    def get_tools_for_skill(cls, skill_id: str) -> List[Dict[str, Any]]:\n   160→        \"\"\"获取 Skill 的所有工具 (OpenAI 格式)\n   161→\n   162→        V6.2 更新：按需加载全局工具\n   163→        - 如果 SKILL.md 中声明了 global_tools，只加载声明的全局工具\n   164→        - 如果没有声明，加载所有全局工具（向后兼容）\n   165→        \"\"\"\n   166→        cls.initialize()\n   167→\n   168→        tools = []\n   169→\n   170→        # 获取 Skill 声明需要的全局工具\n   171→        from .skill_loader import get_skill_global_tools\n   172→        declared_global_tools = get_skill_global_tools(skill_id)\n   173→\n   174→        # 全局工具（从 core skill 加载）\n   175→        all_global_tools = get_global_tools()\n   176→        for tool in all_global_tools:\n   177→            # 如果声明了 global_tools，只加载声明的；否则加载全部\n   178→            if declared_global_tools:\n   179→                if tool.name in declared_global_tools:\n   180→                    tools.append(tool.to_openai_format())\n   181→            else:\n   182→                # 向后兼容：没有声明则加载全部\n   183→                tools.append(tool.to_openai_format())\n   184→\n   185→        # Skill 专属工具（跳过 core，因为已经加载了）\n   186→        if skill_id != \"core\":\n   187→            for name, tool in cls._tool_defs.items():\n   188→                if getattr(tool, 'skill_id', None) == skill_id:\n   189→                    tools.append(tool.to_openai_format())\n   190→\n   191→        return tools\n   192→\n   193→    @classmethod\n   194→    def get_all_tools(cls) -> List[Dict[str, Any]]:\n   195→        \"\"\"获取所有已注册的工具 (OpenAI 格式)\"\"\"\n   196→        cls.initialize()\n   197→        return [tool.to_openai_format() for tool in cls._tool_defs.values()]\n   198→\n   199→    @classmethod\n   200→    def get_card_type(cls, tool_name: str) -> Optional[str]:\n   201→        \"\"\"获取工具对应的卡片类型\"\"\"\n   202→        tool = cls.get_tool_def(tool_name)\n   203→        return tool.card_type if tool else None\n   204→\n   205→    @classmethod\n   206→    def has_handler(cls, tool_name: str) -> bool:\n   207→        \"\"\"检查是否有注册的执行器\"\"\"\n   208→        cls.initialize()\n   209→        return tool_name in cls._handlers\n   210→\n   211→    @classmethod\n   212→    async def execute(\n   213→        cls,\n   214→        tool_name: str,\n   215→        args: Dict[str, Any],\n   216→        context: ToolContext\n   217→    ) -> Dict[str, Any]:\n   218→        \"\"\"执行工具\"\"\"\n   219→        cls.initialize()\n   220→\n   221→        if tool_name not in cls._handlers:\n   222→            logger.warning(f\"No handler for tool: {tool_name}\")\n   223→            return {\"error\": f\"Tool handler not found: {tool_name}\"}\n   224→\n   225→        handler = cls._handlers[tool_name]\n   226→\n   227→        try:\n   228→            # 支持同步和异步处理器\n   229→            result = handler(args, context)\n   230→            if asyncio.iscoroutine(result):\n   231→                result = await result\n   232→            return result\n   233→        except Exception as e:\n   234→            logger.error(f\"Tool execution failed: {tool_name}, error: {e}\")\n   235→            return {\"error\": str(e)}\n   236→\n   237→    @classmethod\n   238→    def get_schema(cls, skill_id: Optional[str] = None) -> Dict[str, Any]:\n   239→        \"\"\"获取工具 Schema (用于前端)\"\"\"\n   240→        cls.initialize()\n   241→\n   242→        global_tool_names = {t.name for t in get_global_tools()}\n   243→\n   244→        tools = []\n   245→        for name, tool in cls._tool_defs.items():\n   246→            if skill_id and getattr(tool, 'skill_id', None) != skill_id:\n   247→                if name not in global_tool_names:\n   248→                    continue\n   249→\n   250→            tools.append({\n   251→                \"name\": tool.name,\n   252→                \"description\": tool.description,\n   253→                \"tool_type\": tool.tool_type,\n   254→                \"card_type\": tool.card_type,\n   255→                \"card_props\": tool.card_props,  # 新增: 表单配置等\n   256→                \"parameters\": [\n   257→                    {\n   258→                        \"name\": p.name,\n   259→                        \"type\": p.type,\n   260→                        \"required\": p.required,\n   261→                        \"description\": p.description,\n   262→                        \"enum\": p.enum,\n   263→                        \"default\": p.default,\n   264→                    }\n   265→                    for p in tool.parameters\n   266→                ],\n   267→                \"when_to_call\": tool.when_to_call,\n   268→            })\n   269→\n   270→        return {\n   271→            \"version\": \"6.1\",\n   272→            \"skill_id\": skill_id,\n   273→            \"tools\": tools,\n   274→        }\n   275→\n   276→    @classmethod\n   277→    def clear(cls):\n   278→        \"\"\"清除所有注册 (用于测试)\"\"\"\n   279→        cls._tool_defs.clear()\n   280→        cls._handlers.clear()\n   281→        cls._loaded_skills.clear()\n   282→        cls._initialized = False\n   283→\n   284→\n   285→def tool_handler(tool_name: str):\n   286→    \"\"\"\n   287→    工具执行器装饰器\n   288→\n   289→    用法:\n   290→        @tool_handler(\"show_bazi_chart\")\n   291→        async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:\n   292→            return {\"chart\": ...}\n   293→    \"\"\"\n   294→    def decorator(func: ToolHandler) -> ToolHandler:\n   295→        @wraps(func)\n   296→        async def wrapper(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   297→            result = func(args, context)\n   298→            if asyncio.iscoroutine(result):\n   299→                return await result\n   300→            return result\n   301→\n   302→        # 注册到 Registry\n   303→        UnifiedToolRegistry.register_handler(tool_name, wrapper)\n   304→        return wrapper\n   305→\n   306→    return decorator\n   307→\n   308→\n   309→# 便捷别名\n   310→ToolRegistry = UnifiedToolRegistry\n   311→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2dc37785-4d95-4e28-9b08-5d4cd107baa5","timestamp":"2026-01-18T03:42:40.935Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/tool_registry.py","content":"\"\"\"\nUnified Tool Registry v6 - 统一工具注册表\n\n解决工具注册的硬编码问题：\n1. 从 YAML 加载工具定义 (Single Source of Truth)\n2. 使用 @tool_handler 装饰器动态注册执行器\n3. 消除 if-elif 分发，使用注册表查找\n\nV6.1 更新：\n- 全局工具从 skills/core/tools/ 加载\n- 移除对 GLOBAL_TOOLS 硬编码的依赖\n\n新增工具只需修改 2 处：\n1. skills/{skill_id}/tools/tools.yaml - 工具定义\n2. skills/{skill_id}/tools/handlers.py - @tool_handler 执行器\n\n用法：\n    from services.agent.tool_registry import tool_handler, ToolRegistry\n\n    @tool_handler(\"show_bazi_chart\")\n    async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:\n        return {\"chart\": ...}\n\n    # CoreAgent 中使用\n    tools = ToolRegistry.get_tools_for_skill(\"bazi\")\n    result = await ToolRegistry.execute(\"show_bazi_chart\", args, context)\n\"\"\"\nimport logging\nimport importlib\nimport asyncio\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Awaitable, Union\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\nfrom .tool_schema import ToolDef, load_skill_tools, get_global_tools\n\nlogger = logging.getLogger(__name__)\n\nSKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n\n\n@dataclass\nclass ToolContext:\n    \"\"\"工具执行上下文\"\"\"\n    user_id: str\n    user_tier: str = \"free\"\n    profile: Dict[str, Any] = field(default_factory=dict)\n    skill_data: Dict[str, Any] = field(default_factory=dict)\n    skill_id: Optional[str] = None\n    scenario_id: Optional[str] = None\n    conversation_id: Optional[str] = None\n\n\n# 工具执行器类型: 同步或异步函数\nToolHandler = Callable[[Dict[str, Any], ToolContext], Union[Dict[str, Any], Awaitable[Dict[str, Any]]]]\n\n\nclass UnifiedToolRegistry:\n    \"\"\"\n    统一工具注册表\n\n    - 工具定义从 YAML 加载\n    - 执行器通过 @tool_handler 装饰器注册\n    - 支持全局工具和 Skill 专属工具\n    \"\"\"\n\n    # 工具定义缓存: {tool_name: ToolDef}\n    _tool_defs: Dict[str, ToolDef] = {}\n\n    # 工具执行器: {tool_name: handler_function}\n    _handlers: Dict[str, ToolHandler] = {}\n\n    # 已加载的 Skill\n    _loaded_skills: set = set()\n\n    # 是否已初始化\n    _initialized: bool = False\n\n    @classmethod\n    def initialize(cls):\n        \"\"\"初始化注册表，加载全局工具\"\"\"\n        if cls._initialized:\n            return\n\n        # 从 core skill 加载全局工具定义\n        global_tools = get_global_tools()\n        for tool in global_tools:\n            tool.is_global = True\n            cls._tool_defs[tool.name] = tool\n\n        # 加载 core skill 的 handlers\n        cls._load_handlers_module(\"core\")\n\n        # 自动发现并加载所有 Skill 的工具\n        cls._auto_discover_skills()\n\n        cls._initialized = True\n        logger.info(f\"ToolRegistry initialized: {len(cls._tool_defs)} tools, {len(cls._handlers)} handlers\")\n\n    @classmethod\n    def _auto_discover_skills(cls):\n        \"\"\"自动发现并加载所有 Skill\"\"\"\n        if not SKILLS_DIR.exists():\n            logger.warning(f\"Skills directory not found: {SKILLS_DIR}\")\n            return\n\n        for skill_dir in SKILLS_DIR.iterdir():\n            if skill_dir.is_dir() and skill_dir.name != \"__pycache__\":\n                skill_id = skill_dir.name\n                cls.load_skill(skill_id)\n\n    @classmethod\n    def load_skill(cls, skill_id: str):\n        \"\"\"加载 Skill 的工具定义和执行器\"\"\"\n        if skill_id in cls._loaded_skills:\n            return\n\n        # 1. 从 YAML 加载工具定义\n        tools = load_skill_tools(skill_id)\n        for tool in tools:\n            tool.skill_id = skill_id  # 标记所属 Skill\n            cls._tool_defs[tool.name] = tool\n\n        # 2. 尝试加载执行器模块\n        cls._load_handlers_module(skill_id)\n\n        cls._loaded_skills.add(skill_id)\n        logger.debug(f\"Loaded skill '{skill_id}': {len(tools)} tools\")\n\n    @classmethod\n    def _load_handlers_module(cls, skill_id: str):\n        \"\"\"加载 Skill 的 handlers 模块\"\"\"\n        handlers_path = SKILLS_DIR / skill_id / \"tools\" / \"handlers.py\"\n        if not handlers_path.exists():\n            logger.debug(f\"No handlers module for skill '{skill_id}'\")\n            return\n\n        try:\n            module_name = f\"skills.{skill_id}.tools.handlers\"\n            importlib.import_module(module_name)\n            logger.debug(f\"Loaded handlers module: {module_name}\")\n        except ImportError as e:\n            logger.warning(f\"Failed to import handlers for '{skill_id}': {e}\")\n\n    @classmethod\n    def register_handler(cls, tool_name: str, handler: ToolHandler):\n        \"\"\"注册工具执行器\"\"\"\n        cls._handlers[tool_name] = handler\n        logger.debug(f\"Registered handler: {tool_name}\")\n\n    @classmethod\n    def get_tool_def(cls, tool_name: str) -> Optional[ToolDef]:\n        \"\"\"获取工具定义\"\"\"\n        cls.initialize()\n        return cls._tool_defs.get(tool_name)\n\n    @classmethod\n    def get_tools_for_skill(cls, skill_id: str) -> List[Dict[str, Any]]:\n        \"\"\"获取 Skill 的所有工具 (OpenAI 格式)\n\n        V6.2 更新：按需加载全局工具\n        - 如果 SKILL.md 中声明了 global_tools，只加载声明的全局工具\n        - 如果没有声明，加载所有全局工具（向后兼容）\n        \"\"\"\n        cls.initialize()\n\n        tools = []\n\n        # 获取 Skill 声明需要的全局工具\n        from .skill_loader import get_skill_global_tools\n        declared_global_tools = get_skill_global_tools(skill_id)\n\n        # 全局工具（从 core skill 加载）\n        all_global_tools = get_global_tools()\n        for tool in all_global_tools:\n            # 如果声明了 global_tools，只加载声明的；否则加载全部\n            if declared_global_tools:\n                if tool.name in declared_global_tools:\n                    tools.append(tool.to_openai_format())\n            else:\n                # 向后兼容：没有声明则加载全部\n                tools.append(tool.to_openai_format())\n\n        # Skill 专属工具（跳过 core，因为已经加载了）\n        if skill_id != \"core\":\n            for name, tool in cls._tool_defs.items():\n                if getattr(tool, 'skill_id', None) == skill_id:\n                    tools.append(tool.to_openai_format())\n\n        return tools\n\n    @classmethod\n    def get_all_tools(cls) -> List[Dict[str, Any]]:\n        \"\"\"获取所有已注册的工具 (OpenAI 格式)\"\"\"\n        cls.initialize()\n        return [tool.to_openai_format() for tool in cls._tool_defs.values()]\n\n    @classmethod\n    def get_card_type(cls, tool_name: str) -> Optional[str]:\n        \"\"\"获取工具对应的卡片类型\"\"\"\n        tool = cls.get_tool_def(tool_name)\n        return tool.card_type if tool else None\n\n    @classmethod\n    def has_handler(cls, tool_name: str) -> bool:\n        \"\"\"检查是否有注册的执行器\"\"\"\n        cls.initialize()\n        return tool_name in cls._handlers\n\n    @classmethod\n    async def execute(\n        cls,\n        tool_name: str,\n        args: Dict[str, Any],\n        context: ToolContext\n    ) -> Dict[str, Any]:\n        \"\"\"执行工具\"\"\"\n        cls.initialize()\n\n        if tool_name not in cls._handlers:\n            logger.warning(f\"No handler for tool: {tool_name}\")\n            return {\"error\": f\"Tool handler not found: {tool_name}\"}\n\n        handler = cls._handlers[tool_name]\n\n        try:\n            # 支持同步和异步处理器\n            result = handler(args, context)\n            if asyncio.iscoroutine(result):\n                result = await result\n            return result\n        except Exception as e:\n            logger.error(f\"Tool execution failed: {tool_name}, error: {e}\")\n            return {\"error\": str(e)}\n\n    @classmethod\n    def get_schema(cls, skill_id: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"获取工具 Schema (用于前端)\"\"\"\n        cls.initialize()\n\n        global_tool_names = {t.name for t in get_global_tools()}\n\n        tools = []\n        for name, tool in cls._tool_defs.items():\n            if skill_id and getattr(tool, 'skill_id', None) != skill_id:\n                if name not in global_tool_names:\n                    continue\n\n            tools.append({\n                \"name\": tool.name,\n                \"description\": tool.description,\n                \"tool_type\": tool.tool_type,\n                \"card_type\": tool.card_type,\n                \"card_props\": tool.card_props,  # 新增: 表单配置等\n                \"parameters\": [\n                    {\n                        \"name\": p.name,\n                        \"type\": p.type,\n                        \"required\": p.required,\n                        \"description\": p.description,\n                        \"enum\": p.enum,\n                        \"default\": p.default,\n                    }\n                    for p in tool.parameters\n                ],\n                \"when_to_call\": tool.when_to_call,\n            })\n\n        return {\n            \"version\": \"6.1\",\n            \"skill_id\": skill_id,\n            \"tools\": tools,\n        }\n\n    @classmethod\n    def clear(cls):\n        \"\"\"清除所有注册 (用于测试)\"\"\"\n        cls._tool_defs.clear()\n        cls._handlers.clear()\n        cls._loaded_skills.clear()\n        cls._initialized = False\n\n\ndef tool_handler(tool_name: str):\n    \"\"\"\n    工具执行器装饰器\n\n    用法:\n        @tool_handler(\"show_bazi_chart\")\n        async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:\n            return {\"chart\": ...}\n    \"\"\"\n    def decorator(func: ToolHandler) -> ToolHandler:\n        @wraps(func)\n        async def wrapper(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n            result = func(args, context)\n            if asyncio.iscoroutine(result):\n                return await result\n            return result\n\n        # 注册到 Registry\n        UnifiedToolRegistry.register_handler(tool_name, wrapper)\n        return wrapper\n\n    return decorator\n\n\n# 便捷别名\nToolRegistry = UnifiedToolRegistry\n","numLines":311,"startLine":1,"totalLines":311}},"sourceToolAssistantUUID":"e4dad514-80f7-4acc-8583-52f7e95ccf30"}
{"parentUuid":"8ccc3d6c-635b-4127-bbc5-f55ad5fe5670","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0124gKGzS6buwoR2p9BA1DKu","type":"tool_result","content":"     1→\"\"\"\n     2→Tool Schema v6 - 统一工具定义系统\n     3→\n     4→从 YAML 文件加载工具定义，自动生成：\n     5→- Python OpenAI 格式工具定义\n     6→- TypeScript 类型定义（可选）\n     7→\n     8→V6.1 更新：\n     9→- 移除 GLOBAL_TOOLS 硬编码\n    10→- 全局工具从 skills/core/tools/tools.yaml 加载\n    11→\"\"\"\n    12→import yaml\n    13→import logging\n    14→from pathlib import Path\n    15→from typing import Dict, Any, List, Optional\n    16→from dataclasses import dataclass, field\n    17→from functools import lru_cache\n    18→\n    19→logger = logging.getLogger(__name__)\n    20→\n    21→SKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n    22→\n    23→\n    24→@dataclass\n    25→class ToolParam:\n    26→    \"\"\"工具参数\"\"\"\n    27→    name: str\n    28→    type: str\n    29→    required: bool = False\n    30→    description: str = \"\"\n    31→    default: Any = None\n    32→    enum: Optional[List[str]] = None\n    33→\n    34→\n    35→@dataclass\n    36→class ToolDef:\n    37→    \"\"\"工具定义\"\"\"\n    38→    name: str\n    39→    description: str\n    40→    tool_type: str  # collect, compute, display, search\n    41→    parameters: List[ToolParam] = field(default_factory=list)\n    42→    card_type: Optional[str] = None\n    43→    card_props: Optional[Dict] = None\n    44→    when_to_call: Optional[str] = None\n    45→    implementation: Optional[str] = None\n    46→    skill_id: Optional[str] = None  # 所属 Skill ID\n    47→    is_global: bool = False  # 是否为全局工具\n    48→\n    49→    def to_openai_format(self) -> Dict[str, Any]:\n    50→        \"\"\"转换为 OpenAI 工具格式\"\"\"\n    51→        properties = {}\n    52→        required = []\n    53→\n    54→        for param in self.parameters:\n    55→            prop = {\"type\": param.type, \"description\": param.description}\n    56→            if param.enum:\n    57→                prop[\"enum\"] = param.enum\n    58→            if param.default is not None:\n    59→                prop[\"default\"] = param.default\n    60→            properties[param.name] = prop\n    61→            if param.required:\n    62→                required.append(param.name)\n    63→\n    64→        return {\n    65→            \"type\": \"function\",\n    66→            \"function\": {\n    67→                \"name\": self.name,\n    68→                \"description\": self.description,\n    69→                \"parameters\": {\n    70→                    \"type\": \"object\",\n    71→                    \"properties\": properties,\n    72→                    \"required\": required\n    73→                }\n    74→            },\n    75→            \"_metadata\": {\n    76→                \"tool_type\": self.tool_type,\n    77→                \"card_type\": self.card_type,\n    78→                \"when_to_call\": self.when_to_call\n    79→            }\n    80→        }\n    81→\n    82→\n    83→def _parse_yaml_tool(tool_data: Dict, tool_type: str) -> ToolDef:\n    84→    \"\"\"解析 YAML 工具定义\"\"\"\n    85→    params = []\n    86→    for p in tool_data.get(\"parameters\", []):\n    87→        params.append(ToolParam(\n    88→            name=p[\"name\"],\n    89→            type=p.get(\"type\", \"string\"),\n    90→            required=p.get(\"required\", False),\n    91→            description=p.get(\"description\", \"\"),\n    92→            default=p.get(\"default\"),\n    93→            enum=p.get(\"enum\")\n    94→        ))\n    95→\n    96→    return ToolDef(\n    97→        name=tool_data[\"name\"],\n    98→        description=tool_data.get(\"description\", \"\"),\n    99→        tool_type=tool_type,\n   100→        parameters=params,\n   101→        card_type=tool_data.get(\"card_type\"),\n   102→        card_props=tool_data.get(\"card_props\"),\n   103→        when_to_call=tool_data.get(\"when_to_call\"),\n   104→        implementation=tool_data.get(\"implementation\")\n   105→    )\n   106→\n   107→\n   108→@lru_cache(maxsize=16)\n   109→def load_skill_tools(skill_id: str) -> List[ToolDef]:\n   110→    \"\"\"从 YAML 加载 Skill 工具定义\"\"\"\n   111→    tools_file = SKILLS_DIR / skill_id / \"tools\" / \"tools.yaml\"\n   112→    if not tools_file.exists():\n   113→        logger.debug(f\"Tools file not found: {tools_file}\")\n   114→        return []\n   115→\n   116→    try:\n   117→        with open(tools_file, \"r\", encoding=\"utf-8\") as f:\n   118→            data = yaml.safe_load(f)\n   119→\n   120→        tools = []\n   121→        for tool_type in [\"collect\", \"compute\", \"display\", \"search\"]:\n   122→            for tool_data in data.get(tool_type, []):\n   123→                tool = _parse_yaml_tool(tool_data, tool_type)\n   124→                tool.skill_id = skill_id\n   125→                tool.is_global = (skill_id == \"core\")\n   126→                tools.append(tool)\n   127→\n   128→        logger.debug(f\"Loaded {len(tools)} tools for skill: {skill_id}\")\n   129→        return tools\n   130→    except Exception as e:\n   131→        logger.error(f\"Failed to load tools for {skill_id}: {e}\")\n   132→        return []\n   133→\n   134→\n   135→@lru_cache(maxsize=1)\n   136→def get_global_tools() -> List[ToolDef]:\n   137→    \"\"\"获取全局工具（从 core skill 加载）\"\"\"\n   138→    return load_skill_tools(\"core\")\n   139→\n   140→\n   141→def get_skill_tools_openai(skill_id: str) -> List[Dict[str, Any]]:\n   142→    \"\"\"获取 Skill 工具的 OpenAI 格式\"\"\"\n   143→    tools = load_skill_tools(skill_id)\n   144→    return [t.to_openai_format() for t in tools]\n   145→\n   146→\n   147→def get_global_tools_openai() -> List[Dict[str, Any]]:\n   148→    \"\"\"获取全局工具的 OpenAI 格式\"\"\"\n   149→    return [t.to_openai_format() for t in get_global_tools()]\n   150→\n   151→\n   152→def get_all_tools_for_skill(skill_id: str) -> List[Dict[str, Any]]:\n   153→    \"\"\"获取 Skill 的所有工具（全局 + Skill 专属）\"\"\"\n   154→    tools = get_global_tools_openai()\n   155→    if skill_id != \"core\":\n   156→        tools.extend(get_skill_tools_openai(skill_id))\n   157→    return tools\n   158→\n   159→\n   160→def get_tool_card_type(tool_name: str, skill_id: Optional[str] = None) -> Optional[str]:\n   161→    \"\"\"获取工具对应的卡片类型\"\"\"\n   162→    # 先查全局工具\n   163→    for tool in get_global_tools():\n   164→        if tool.name == tool_name:\n   165→            return tool.card_type\n   166→\n   167→    # 再查 Skill 工具\n   168→    if skill_id:\n   169→        for tool in load_skill_tools(skill_id):\n   170→            if tool.name == tool_name:\n   171→                return tool.card_type\n   172→\n   173→    return None\n   174→\n   175→\n   176→def clear_tool_cache():\n   177→    \"\"\"清除工具缓存\"\"\"\n   178→    load_skill_tools.cache_clear()\n   179→    get_global_tools.cache_clear()\n   180→    logger.info(\"Tool cache cleared\")\n   181→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"68fbf182-7528-4708-8656-c1bb0c7fe1da","timestamp":"2026-01-18T03:42:40.935Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/tool_schema.py","content":"\"\"\"\nTool Schema v6 - 统一工具定义系统\n\n从 YAML 文件加载工具定义，自动生成：\n- Python OpenAI 格式工具定义\n- TypeScript 类型定义（可选）\n\nV6.1 更新：\n- 移除 GLOBAL_TOOLS 硬编码\n- 全局工具从 skills/core/tools/tools.yaml 加载\n\"\"\"\nimport yaml\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional\nfrom dataclasses import dataclass, field\nfrom functools import lru_cache\n\nlogger = logging.getLogger(__name__)\n\nSKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n\n\n@dataclass\nclass ToolParam:\n    \"\"\"工具参数\"\"\"\n    name: str\n    type: str\n    required: bool = False\n    description: str = \"\"\n    default: Any = None\n    enum: Optional[List[str]] = None\n\n\n@dataclass\nclass ToolDef:\n    \"\"\"工具定义\"\"\"\n    name: str\n    description: str\n    tool_type: str  # collect, compute, display, search\n    parameters: List[ToolParam] = field(default_factory=list)\n    card_type: Optional[str] = None\n    card_props: Optional[Dict] = None\n    when_to_call: Optional[str] = None\n    implementation: Optional[str] = None\n    skill_id: Optional[str] = None  # 所属 Skill ID\n    is_global: bool = False  # 是否为全局工具\n\n    def to_openai_format(self) -> Dict[str, Any]:\n        \"\"\"转换为 OpenAI 工具格式\"\"\"\n        properties = {}\n        required = []\n\n        for param in self.parameters:\n            prop = {\"type\": param.type, \"description\": param.description}\n            if param.enum:\n                prop[\"enum\"] = param.enum\n            if param.default is not None:\n                prop[\"default\"] = param.default\n            properties[param.name] = prop\n            if param.required:\n                required.append(param.name)\n\n        return {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": self.name,\n                \"description\": self.description,\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": properties,\n                    \"required\": required\n                }\n            },\n            \"_metadata\": {\n                \"tool_type\": self.tool_type,\n                \"card_type\": self.card_type,\n                \"when_to_call\": self.when_to_call\n            }\n        }\n\n\ndef _parse_yaml_tool(tool_data: Dict, tool_type: str) -> ToolDef:\n    \"\"\"解析 YAML 工具定义\"\"\"\n    params = []\n    for p in tool_data.get(\"parameters\", []):\n        params.append(ToolParam(\n            name=p[\"name\"],\n            type=p.get(\"type\", \"string\"),\n            required=p.get(\"required\", False),\n            description=p.get(\"description\", \"\"),\n            default=p.get(\"default\"),\n            enum=p.get(\"enum\")\n        ))\n\n    return ToolDef(\n        name=tool_data[\"name\"],\n        description=tool_data.get(\"description\", \"\"),\n        tool_type=tool_type,\n        parameters=params,\n        card_type=tool_data.get(\"card_type\"),\n        card_props=tool_data.get(\"card_props\"),\n        when_to_call=tool_data.get(\"when_to_call\"),\n        implementation=tool_data.get(\"implementation\")\n    )\n\n\n@lru_cache(maxsize=16)\ndef load_skill_tools(skill_id: str) -> List[ToolDef]:\n    \"\"\"从 YAML 加载 Skill 工具定义\"\"\"\n    tools_file = SKILLS_DIR / skill_id / \"tools\" / \"tools.yaml\"\n    if not tools_file.exists():\n        logger.debug(f\"Tools file not found: {tools_file}\")\n        return []\n\n    try:\n        with open(tools_file, \"r\", encoding=\"utf-8\") as f:\n            data = yaml.safe_load(f)\n\n        tools = []\n        for tool_type in [\"collect\", \"compute\", \"display\", \"search\"]:\n            for tool_data in data.get(tool_type, []):\n                tool = _parse_yaml_tool(tool_data, tool_type)\n                tool.skill_id = skill_id\n                tool.is_global = (skill_id == \"core\")\n                tools.append(tool)\n\n        logger.debug(f\"Loaded {len(tools)} tools for skill: {skill_id}\")\n        return tools\n    except Exception as e:\n        logger.error(f\"Failed to load tools for {skill_id}: {e}\")\n        return []\n\n\n@lru_cache(maxsize=1)\ndef get_global_tools() -> List[ToolDef]:\n    \"\"\"获取全局工具（从 core skill 加载）\"\"\"\n    return load_skill_tools(\"core\")\n\n\ndef get_skill_tools_openai(skill_id: str) -> List[Dict[str, Any]]:\n    \"\"\"获取 Skill 工具的 OpenAI 格式\"\"\"\n    tools = load_skill_tools(skill_id)\n    return [t.to_openai_format() for t in tools]\n\n\ndef get_global_tools_openai() -> List[Dict[str, Any]]:\n    \"\"\"获取全局工具的 OpenAI 格式\"\"\"\n    return [t.to_openai_format() for t in get_global_tools()]\n\n\ndef get_all_tools_for_skill(skill_id: str) -> List[Dict[str, Any]]:\n    \"\"\"获取 Skill 的所有工具（全局 + Skill 专属）\"\"\"\n    tools = get_global_tools_openai()\n    if skill_id != \"core\":\n        tools.extend(get_skill_tools_openai(skill_id))\n    return tools\n\n\ndef get_tool_card_type(tool_name: str, skill_id: Optional[str] = None) -> Optional[str]:\n    \"\"\"获取工具对应的卡片类型\"\"\"\n    # 先查全局工具\n    for tool in get_global_tools():\n        if tool.name == tool_name:\n            return tool.card_type\n\n    # 再查 Skill 工具\n    if skill_id:\n        for tool in load_skill_tools(skill_id):\n            if tool.name == tool_name:\n                return tool.card_type\n\n    return None\n\n\ndef clear_tool_cache():\n    \"\"\"清除工具缓存\"\"\"\n    load_skill_tools.cache_clear()\n    get_global_tools.cache_clear()\n    logger.info(\"Tool cache cleared\")\n","numLines":181,"startLine":1,"totalLines":181}},"sourceToolAssistantUUID":"8ccc3d6c-635b-4127-bbc5-f55ad5fe5670"}
{"parentUuid":"68fbf182-7528-4708-8656-c1bb0c7fe1da","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Cn5NzjfNWhEekek7pYBhne","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read additional supporting files to complete the picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":23213,"cache_read_input_tokens":28436,"cache_creation":{"ephemeral_5m_input_tokens":23213,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nga6zUJpjMbcmyTiM","type":"assistant","uuid":"bd42598a-cb2d-470c-ac94-ece8643aad7f","timestamp":"2026-01-18T03:42:43.076Z"}
{"parentUuid":"bd42598a-cb2d-470c-ac94-ece8643aad7f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Cn5NzjfNWhEekek7pYBhne","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018LUmZaVo9eMpdXmnMThgBn","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/sop_engine.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":23213,"cache_read_input_tokens":28436,"cache_creation":{"ephemeral_5m_input_tokens":23213,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nga6zUJpjMbcmyTiM","type":"assistant","uuid":"2d0036fd-4341-42bd-9596-17463a765298","timestamp":"2026-01-18T03:42:43.604Z"}
{"parentUuid":"2d0036fd-4341-42bd-9596-17463a765298","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Cn5NzjfNWhEekek7pYBhne","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YZiWcJsTxbJvDexUJAbrBZ","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/stream_adapter.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":23213,"cache_read_input_tokens":28436,"cache_creation":{"ephemeral_5m_input_tokens":23213,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nga6zUJpjMbcmyTiM","type":"assistant","uuid":"46e8a585-4ce7-4cfb-92f7-47d1c4df92ca","timestamp":"2026-01-18T03:42:43.931Z"}
{"parentUuid":"46e8a585-4ce7-4cfb-92f7-47d1c4df92ca","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Cn5NzjfNWhEekek7pYBhne","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RKZFhg739xx2sx5zXJ8apU","name":"Glob","input":{"pattern":"/home/aiscend/work/vibelife/apps/api/skills/**/tools/*.yaml"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":23213,"cache_read_input_tokens":28436,"cache_creation":{"ephemeral_5m_input_tokens":23213,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nga6zUJpjMbcmyTiM","type":"assistant","uuid":"26155162-e2e8-4f90-a450-f7ee822c37f5","timestamp":"2026-01-18T03:42:44.262Z"}
{"parentUuid":"2d0036fd-4341-42bd-9596-17463a765298","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018LUmZaVo9eMpdXmnMThgBn","type":"tool_result","content":"     1→\"\"\"\n     2→SOPEngine v6 - 7 阶段 SOP 执行引擎\n     3→\n     4→SOP 阶段：\n     5→- P1: Collect (收集) - 强制：检查并收集必要信息\n     6→- P2: Compute (计算) - 强制：调用计算工具生成数据\n     7→- P3: Scan (扫描) - LLM：快速识别模式\n     8→- P4: Proactive (追问) - LLM：主动追问获取更多信息\n     9→- P5: Analyze (分析) - LLM：深度分析，结合知识库\n    10→- P6: Output (输出) - LLM：调用展示工具\n    11→- P7: Discuss (讨论) - LLM：答疑讨论\n    12→\"\"\"\n    13→import logging\n    14→from enum import Enum\n    15→from typing import Dict, Any, Optional, List, Tuple\n    16→from dataclasses import dataclass, field\n    17→\n    18→logger = logging.getLogger(__name__)\n    19→\n    20→\n    21→class SOPPhase(str, Enum):\n    22→    \"\"\"SOP 阶段\"\"\"\n    23→    COLLECT = \"collect\"      # P1: 信息收集\n    24→    COMPUTE = \"compute\"      # P2: 计算排盘\n    25→    SCAN = \"scan\"            # P3: 快速扫描\n    26→    PROACTIVE = \"proactive\"  # P4: 主动追问\n    27→    ANALYZE = \"analyze\"      # P5: 深度分析\n    28→    OUTPUT = \"output\"        # P6: 结果输出\n    29→    DISCUSS = \"discuss\"      # P7: 答疑讨论\n    30→\n    31→\n    32→class SOPAction(str, Enum):\n    33→    \"\"\"SOP 动作\"\"\"\n    34→    NEED_INFO = \"need_info\"           # 需要收集信息\n    35→    NEED_COMPUTE = \"need_compute\"     # 需要计算\n    36→    READY_FOR_LLM = \"ready_for_llm\"   # 准备好让 LLM 处理\n    37→    COMPLETED = \"completed\"           # 已完成\n    38→\n    39→\n    40→@dataclass\n    41→class SOPState:\n    42→    \"\"\"SOP 状态\"\"\"\n    43→    current_phase: SOPPhase\n    44→    skill_id: str\n    45→    scenario_id: Optional[str] = None\n    46→    has_birth_info: bool = False\n    47→    has_chart_data: bool = False\n    48→    has_proactive_asked: bool = False\n    49→    context: Dict[str, Any] = field(default_factory=dict)\n    50→\n    51→\n    52→class SOPEngine:\n    53→    \"\"\"\n    54→    v6 SOP 执行引擎\n    55→\n    56→    强制阶段（代码控制）：\n    57→    - P1 Collect: 检查用户是否有必要信息\n    58→    - P2 Compute: 检查是否已计算\n    59→\n    60→    自由阶段（LLM 控制）：\n    61→    - P3-P7: 由 LLM 根据场景 SOP 描述执行\n    62→    \"\"\"\n    63→\n    64→    # 需要出生信息的 Skill\n    65→    BIRTH_INFO_SKILLS = {\"bazi\", \"zodiac\"}\n    66→\n    67→    # 需要计算的 Skill\n    68→    COMPUTE_SKILLS = {\"bazi\", \"zodiac\", \"tarot\"}\n    69→\n    70→    def __init__(self, skill_id: str, scenario_id: Optional[str] = None):\n    71→        self.skill_id = skill_id\n    72→        self.scenario_id = scenario_id\n    73→        self.state = SOPState(\n    74→            current_phase=SOPPhase.COLLECT,\n    75→            skill_id=skill_id,\n    76→            scenario_id=scenario_id\n    77→        )\n    78→\n    79→    def check_phase(\n    80→        self,\n    81→        profile: Optional[Dict[str, Any]] = None,\n    82→        skill_data: Optional[Dict[str, Any]] = None,\n    83→        message: str = \"\"\n    84→    ) -> Tuple[SOPAction, Dict[str, Any]]:\n    85→        \"\"\"检查当前应该执行的 SOP 阶段\"\"\"\n    86→        self._update_state(profile, skill_data, message)\n    87→\n    88→        # P1: 检查是否需要收集信息\n    89→        if self._needs_collection():\n    90→            return SOPAction.NEED_INFO, {\n    91→                \"phase\": SOPPhase.COLLECT,\n    92→                \"info_type\": \"birth\",\n    93→                \"message\": \"需要收集出生信息\"\n    94→            }\n    95→\n    96→        # P2: 检查是否需要计算\n    97→        if self._needs_computation():\n    98→            return SOPAction.NEED_COMPUTE, {\n    99→                \"phase\": SOPPhase.COMPUTE,\n   100→                \"skill\": self.skill_id,\n   101→                \"message\": \"需要计算命盘数据\"\n   102→            }\n   103→\n   104→        # P3-P7: 交给 LLM 处理\n   105→        return SOPAction.READY_FOR_LLM, {\n   106→            \"phase\": self._determine_llm_phase(message),\n   107→            \"has_chart\": self.state.has_chart_data,\n   108→            \"message\": \"准备好进行分析\"\n   109→        }\n   110→\n   111→    def _update_state(\n   112→        self,\n   113→        profile: Optional[Dict[str, Any]],\n   114→        skill_data: Optional[Dict[str, Any]],\n   115→        message: str\n   116→    ):\n   117→        \"\"\"更新 SOP 状态\"\"\"\n   118→        if profile:\n   119→            birth_info = profile.get(\"birth_info\", {})\n   120→            self.state.has_birth_info = bool(\n   121→                birth_info.get(\"birth_date\") or birth_info.get(\"date\")\n   122→            )\n   123→\n   124→        if skill_data:\n   125→            if self.skill_id == \"bazi\":\n   126→                self.state.has_chart_data = bool(skill_data.get(\"bazi\", {}).get(\"chart\"))\n   127→            elif self.skill_id == \"zodiac\":\n   128→                self.state.has_chart_data = bool(skill_data.get(\"zodiac\", {}).get(\"chart\"))\n   129→            elif self.skill_id == \"tarot\":\n   130→                self.state.has_chart_data = bool(skill_data.get(\"tarot\", {}).get(\"cards\"))\n   131→\n   132→        if self._message_contains_birth_info(message):\n   133→            self.state.context[\"birth_in_message\"] = True\n   134→\n   135→    def _needs_collection(self) -> bool:\n   136→        \"\"\"检查是否需要收集信息\"\"\"\n   137→        if self.skill_id not in self.BIRTH_INFO_SKILLS:\n   138→            return False\n   139→        if self.state.has_birth_info:\n   140→            return False\n   141→        if self.state.context.get(\"birth_in_message\"):\n   142→            return False\n   143→        return True\n   144→\n   145→    def _needs_computation(self) -> bool:\n   146→        \"\"\"检查是否需要计算\"\"\"\n   147→        if self.skill_id not in self.COMPUTE_SKILLS:\n   148→            return False\n   149→        if self.state.has_chart_data:\n   150→            return False\n   151→        if self.skill_id in self.BIRTH_INFO_SKILLS and not self.state.has_birth_info:\n   152→            return False\n   153→        return True\n   154→\n   155→    def _determine_llm_phase(self, message: str) -> SOPPhase:\n   156→        \"\"\"根据消息内容判断 LLM 应该处于哪个阶段\"\"\"\n   157→        # 追问关键词\n   158→        followup_keywords = [\"为什么\", \"怎么\", \"什么意思\", \"详细\", \"解释\", \"再说说\", \"不太懂\"]\n   159→        if any(kw in message for kw in followup_keywords):\n   160→            return SOPPhase.DISCUSS\n   161→\n   162→        # 如果有命盘，进入分析阶段\n   163→        if self.state.has_chart_data:\n   164→            return SOPPhase.ANALYZE\n   165→\n   166→        return SOPPhase.SCAN\n   167→\n   168→    def _message_contains_birth_info(self, message: str) -> bool:\n   169→        \"\"\"检查消息中是否包含出生信息\"\"\"\n   170→        date_patterns = [\"年\", \"月\", \"日\", \"出生\", \"生日\", \"19\", \"20\"]\n   171→        time_patterns = [\"时\", \"点\", \"早上\", \"上午\", \"中午\", \"下午\", \"晚上\", \"凌晨\"]\n   172→\n   173→        has_date = sum(1 for p in date_patterns if p in message) >= 2\n   174→        has_time = any(p in message for p in time_patterns)\n   175→\n   176→        return has_date and has_time\n   177→\n   178→    def get_phase_prompt(self) -> str:\n   179→        \"\"\"获取当前阶段的提示词\"\"\"\n   180→        prompts = {\n   181→            SOPPhase.COLLECT: \"当前阶段：信息收集。请收集用户的出生信息。\",\n   182→            SOPPhase.COMPUTE: \"当前阶段：计算排盘。请调用计算工具生成命盘数据。\",\n   183→            SOPPhase.SCAN: \"当前阶段：快速扫描。请快速识别命盘中的关键模式和特征。\",\n   184→            SOPPhase.PROACTIVE: \"当前阶段：主动追问。根据分析结果，可以向用户提出针对性问题。\",\n   185→            SOPPhase.ANALYZE: \"当前阶段：深度分析。请根据用户问题进行深入分析。\",\n   186→            SOPPhase.OUTPUT: \"当前阶段：结果输出。请调用展示工具呈现分析结果。\",\n   187→            SOPPhase.DISCUSS: \"当前阶段：答疑讨论。请回答用户的追问。\"\n   188→        }\n   189→        return prompts.get(self.state.current_phase, \"\")\n   190→\n   191→\n   192→def create_sop_engine(skill_id: str, scenario_id: Optional[str] = None) -> SOPEngine:\n   193→    \"\"\"创建 SOP 引擎\"\"\"\n   194→    return SOPEngine(skill_id, scenario_id)\n   195→\n   196→\n   197→def check_sop_requirements(\n   198→    skill_id: str,\n   199→    scenario_id: Optional[str] = None,\n   200→    profile: Optional[Dict[str, Any]] = None,\n   201→    skill_data: Optional[Dict[str, Any]] = None,\n   202→    message: str = \"\"\n   203→) -> Tuple[SOPAction, Dict[str, Any]]:\n   204→    \"\"\"快捷函数：检查 SOP 要求\"\"\"\n   205→    engine = create_sop_engine(skill_id, scenario_id)\n   206→    return engine.check_phase(profile, skill_data, message)\n   207→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"777551b1-5dad-461f-9833-9cd23af79f77","timestamp":"2026-01-18T03:42:44.407Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/sop_engine.py","content":"\"\"\"\nSOPEngine v6 - 7 阶段 SOP 执行引擎\n\nSOP 阶段：\n- P1: Collect (收集) - 强制：检查并收集必要信息\n- P2: Compute (计算) - 强制：调用计算工具生成数据\n- P3: Scan (扫描) - LLM：快速识别模式\n- P4: Proactive (追问) - LLM：主动追问获取更多信息\n- P5: Analyze (分析) - LLM：深度分析，结合知识库\n- P6: Output (输出) - LLM：调用展示工具\n- P7: Discuss (讨论) - LLM：答疑讨论\n\"\"\"\nimport logging\nfrom enum import Enum\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom dataclasses import dataclass, field\n\nlogger = logging.getLogger(__name__)\n\n\nclass SOPPhase(str, Enum):\n    \"\"\"SOP 阶段\"\"\"\n    COLLECT = \"collect\"      # P1: 信息收集\n    COMPUTE = \"compute\"      # P2: 计算排盘\n    SCAN = \"scan\"            # P3: 快速扫描\n    PROACTIVE = \"proactive\"  # P4: 主动追问\n    ANALYZE = \"analyze\"      # P5: 深度分析\n    OUTPUT = \"output\"        # P6: 结果输出\n    DISCUSS = \"discuss\"      # P7: 答疑讨论\n\n\nclass SOPAction(str, Enum):\n    \"\"\"SOP 动作\"\"\"\n    NEED_INFO = \"need_info\"           # 需要收集信息\n    NEED_COMPUTE = \"need_compute\"     # 需要计算\n    READY_FOR_LLM = \"ready_for_llm\"   # 准备好让 LLM 处理\n    COMPLETED = \"completed\"           # 已完成\n\n\n@dataclass\nclass SOPState:\n    \"\"\"SOP 状态\"\"\"\n    current_phase: SOPPhase\n    skill_id: str\n    scenario_id: Optional[str] = None\n    has_birth_info: bool = False\n    has_chart_data: bool = False\n    has_proactive_asked: bool = False\n    context: Dict[str, Any] = field(default_factory=dict)\n\n\nclass SOPEngine:\n    \"\"\"\n    v6 SOP 执行引擎\n\n    强制阶段（代码控制）：\n    - P1 Collect: 检查用户是否有必要信息\n    - P2 Compute: 检查是否已计算\n\n    自由阶段（LLM 控制）：\n    - P3-P7: 由 LLM 根据场景 SOP 描述执行\n    \"\"\"\n\n    # 需要出生信息的 Skill\n    BIRTH_INFO_SKILLS = {\"bazi\", \"zodiac\"}\n\n    # 需要计算的 Skill\n    COMPUTE_SKILLS = {\"bazi\", \"zodiac\", \"tarot\"}\n\n    def __init__(self, skill_id: str, scenario_id: Optional[str] = None):\n        self.skill_id = skill_id\n        self.scenario_id = scenario_id\n        self.state = SOPState(\n            current_phase=SOPPhase.COLLECT,\n            skill_id=skill_id,\n            scenario_id=scenario_id\n        )\n\n    def check_phase(\n        self,\n        profile: Optional[Dict[str, Any]] = None,\n        skill_data: Optional[Dict[str, Any]] = None,\n        message: str = \"\"\n    ) -> Tuple[SOPAction, Dict[str, Any]]:\n        \"\"\"检查当前应该执行的 SOP 阶段\"\"\"\n        self._update_state(profile, skill_data, message)\n\n        # P1: 检查是否需要收集信息\n        if self._needs_collection():\n            return SOPAction.NEED_INFO, {\n                \"phase\": SOPPhase.COLLECT,\n                \"info_type\": \"birth\",\n                \"message\": \"需要收集出生信息\"\n            }\n\n        # P2: 检查是否需要计算\n        if self._needs_computation():\n            return SOPAction.NEED_COMPUTE, {\n                \"phase\": SOPPhase.COMPUTE,\n                \"skill\": self.skill_id,\n                \"message\": \"需要计算命盘数据\"\n            }\n\n        # P3-P7: 交给 LLM 处理\n        return SOPAction.READY_FOR_LLM, {\n            \"phase\": self._determine_llm_phase(message),\n            \"has_chart\": self.state.has_chart_data,\n            \"message\": \"准备好进行分析\"\n        }\n\n    def _update_state(\n        self,\n        profile: Optional[Dict[str, Any]],\n        skill_data: Optional[Dict[str, Any]],\n        message: str\n    ):\n        \"\"\"更新 SOP 状态\"\"\"\n        if profile:\n            birth_info = profile.get(\"birth_info\", {})\n            self.state.has_birth_info = bool(\n                birth_info.get(\"birth_date\") or birth_info.get(\"date\")\n            )\n\n        if skill_data:\n            if self.skill_id == \"bazi\":\n                self.state.has_chart_data = bool(skill_data.get(\"bazi\", {}).get(\"chart\"))\n            elif self.skill_id == \"zodiac\":\n                self.state.has_chart_data = bool(skill_data.get(\"zodiac\", {}).get(\"chart\"))\n            elif self.skill_id == \"tarot\":\n                self.state.has_chart_data = bool(skill_data.get(\"tarot\", {}).get(\"cards\"))\n\n        if self._message_contains_birth_info(message):\n            self.state.context[\"birth_in_message\"] = True\n\n    def _needs_collection(self) -> bool:\n        \"\"\"检查是否需要收集信息\"\"\"\n        if self.skill_id not in self.BIRTH_INFO_SKILLS:\n            return False\n        if self.state.has_birth_info:\n            return False\n        if self.state.context.get(\"birth_in_message\"):\n            return False\n        return True\n\n    def _needs_computation(self) -> bool:\n        \"\"\"检查是否需要计算\"\"\"\n        if self.skill_id not in self.COMPUTE_SKILLS:\n            return False\n        if self.state.has_chart_data:\n            return False\n        if self.skill_id in self.BIRTH_INFO_SKILLS and not self.state.has_birth_info:\n            return False\n        return True\n\n    def _determine_llm_phase(self, message: str) -> SOPPhase:\n        \"\"\"根据消息内容判断 LLM 应该处于哪个阶段\"\"\"\n        # 追问关键词\n        followup_keywords = [\"为什么\", \"怎么\", \"什么意思\", \"详细\", \"解释\", \"再说说\", \"不太懂\"]\n        if any(kw in message for kw in followup_keywords):\n            return SOPPhase.DISCUSS\n\n        # 如果有命盘，进入分析阶段\n        if self.state.has_chart_data:\n            return SOPPhase.ANALYZE\n\n        return SOPPhase.SCAN\n\n    def _message_contains_birth_info(self, message: str) -> bool:\n        \"\"\"检查消息中是否包含出生信息\"\"\"\n        date_patterns = [\"年\", \"月\", \"日\", \"出生\", \"生日\", \"19\", \"20\"]\n        time_patterns = [\"时\", \"点\", \"早上\", \"上午\", \"中午\", \"下午\", \"晚上\", \"凌晨\"]\n\n        has_date = sum(1 for p in date_patterns if p in message) >= 2\n        has_time = any(p in message for p in time_patterns)\n\n        return has_date and has_time\n\n    def get_phase_prompt(self) -> str:\n        \"\"\"获取当前阶段的提示词\"\"\"\n        prompts = {\n            SOPPhase.COLLECT: \"当前阶段：信息收集。请收集用户的出生信息。\",\n            SOPPhase.COMPUTE: \"当前阶段：计算排盘。请调用计算工具生成命盘数据。\",\n            SOPPhase.SCAN: \"当前阶段：快速扫描。请快速识别命盘中的关键模式和特征。\",\n            SOPPhase.PROACTIVE: \"当前阶段：主动追问。根据分析结果，可以向用户提出针对性问题。\",\n            SOPPhase.ANALYZE: \"当前阶段：深度分析。请根据用户问题进行深入分析。\",\n            SOPPhase.OUTPUT: \"当前阶段：结果输出。请调用展示工具呈现分析结果。\",\n            SOPPhase.DISCUSS: \"当前阶段：答疑讨论。请回答用户的追问。\"\n        }\n        return prompts.get(self.state.current_phase, \"\")\n\n\ndef create_sop_engine(skill_id: str, scenario_id: Optional[str] = None) -> SOPEngine:\n    \"\"\"创建 SOP 引擎\"\"\"\n    return SOPEngine(skill_id, scenario_id)\n\n\ndef check_sop_requirements(\n    skill_id: str,\n    scenario_id: Optional[str] = None,\n    profile: Optional[Dict[str, Any]] = None,\n    skill_data: Optional[Dict[str, Any]] = None,\n    message: str = \"\"\n) -> Tuple[SOPAction, Dict[str, Any]]:\n    \"\"\"快捷函数：检查 SOP 要求\"\"\"\n    engine = create_sop_engine(skill_id, scenario_id)\n    return engine.check_phase(profile, skill_data, message)\n","numLines":207,"startLine":1,"totalLines":207}},"sourceToolAssistantUUID":"2d0036fd-4341-42bd-9596-17463a765298"}
{"parentUuid":"46e8a585-4ce7-4cfb-92f7-47d1c4df92ca","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YZiWcJsTxbJvDexUJAbrBZ","type":"tool_result","content":"     1→\"\"\"\n     2→Stream Adapter - 将 CoreAgent 内部事件转换为前端协议格式\n     3→\n     4→设计原则：\n     5→- CoreAgent 输出统一的内部事件格式（AgentEvent）\n     6→- StreamAdapter 负责转换为特定前端协议\n     7→- 未来换前端方案只需写新的 Adapter，不改 CoreAgent\n     8→\n     9→支持的协议：\n    10→- AI SDK 6 Data Stream Protocol (Vercel)\n    11→- 可扩展支持其他协议\n    12→\"\"\"\n    13→import json\n    14→from typing import AsyncGenerator, Dict, Any\n    15→from uuid import uuid4\n    16→from dataclasses import dataclass\n    17→\n    18→from .core import AgentEvent\n    19→\n    20→\n    21→@dataclass\n    22→class StreamConfig:\n    23→    \"\"\"流配置\"\"\"\n    24→    protocol: str = \"ai-sdk-6\"  # ai-sdk-6, sse-legacy, custom\n    25→    include_step_events: bool = True\n    26→\n    27→\n    28→class BaseStreamAdapter:\n    29→    \"\"\"基础流适配器\"\"\"\n    30→\n    31→    def __init__(self, config: StreamConfig = None):\n    32→        self.config = config or StreamConfig()\n    33→\n    34→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n    35→        \"\"\"将内部事件转换为协议格式\"\"\"\n    36→        raise NotImplementedError\n    37→\n    38→\n    39→class AISDKv6Adapter(BaseStreamAdapter):\n    40→    \"\"\"\n    41→    AI SDK 6 Data Stream Protocol 适配器\n    42→\n    43→    协议格式：\n    44→    - data: {\"type\":\"start\",\"messageId\":\"...\"}\\n\\n\n    45→    - data: {\"type\":\"text-delta\",\"id\":\"...\",\"delta\":\"...\"}\\n\\n\n    46→    - data: {\"type\":\"finish\"}\\n\\n\n    47→    - data: [DONE]\\n\\n\n    48→\n    49→    参考: https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol\n    50→    \"\"\"\n    51→\n    52→    def __init__(self, config: StreamConfig = None):\n    53→        super().__init__(config)\n    54→        self.message_id = f\"msg_{uuid4().hex[:24]}\"\n    55→        self.text_id = f\"text_{uuid4().hex[:12]}\"\n    56→        self._text_started = False\n    57→\n    58→    def _format(self, data: Dict[str, Any] | str) -> Dict[str, str]:\n    59→        \"\"\"格式化为 SSE 事件 (sse-starlette 格式)\"\"\"\n    60→        if isinstance(data, str):\n    61→            return {\"data\": data}\n    62→        return {\"data\": json.dumps(data, ensure_ascii=False)}\n    63→\n    64→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[Dict[str, str], None]:\n    65→        \"\"\"将 AgentEvent 转换为 AI SDK 6 格式 (sse-starlette dict 格式)\"\"\"\n    66→\n    67→        # 1. 消息开始\n    68→        yield self._format({\"type\": \"start\", \"messageId\": self.message_id})\n    69→\n    70→        # 2. 步骤开始\n    71→        if self.config.include_step_events:\n    72→            yield self._format({\"type\": \"start-step\"})\n    73→\n    74→        async for event in events:\n    75→            if event.type == \"thinking\":\n    76→                # thinking 事件不输出到前端\n    77→                pass\n    78→\n    79→            elif event.type == \"content\":\n    80→                # 文本增量\n    81→                if not self._text_started:\n    82→                    yield self._format({\"type\": \"text-start\", \"id\": self.text_id})\n    83→                    self._text_started = True\n    84→\n    85→                content = event.data.get(\"content\", \"\")\n    86→                if content:\n    87→                    yield self._format({\n    88→                        \"type\": \"text-delta\",\n    89→                        \"id\": self.text_id,\n    90→                        \"delta\": content\n    91→                    })\n    92→\n    93→            elif event.type == \"tool_call\":\n    94→                # 结束之前的文本块\n    95→                if self._text_started:\n    96→                    yield self._format({\"type\": \"text-end\", \"id\": self.text_id})\n    97→                    self._text_started = False\n    98→                    # 为下一个文本块生成新 ID\n    99→                    self.text_id = f\"text_{uuid4().hex[:12]}\"\n   100→\n   101→                # 工具调用\n   102→                tool_call_id = event.data.get(\"id\")\n   103→                tool_name = event.data.get(\"name\")\n   104→                args_str = event.data.get(\"arguments\", \"{}\")\n   105→\n   106→                try:\n   107→                    args = json.loads(args_str) if isinstance(args_str, str) else args_str\n   108→                except json.JSONDecodeError:\n   109→                    args = {}\n   110→\n   111→                yield self._format({\n   112→                    \"type\": \"tool-input-start\",\n   113→                    \"toolCallId\": tool_call_id,\n   114→                    \"toolName\": tool_name\n   115→                })\n   116→                yield self._format({\n   117→                    \"type\": \"tool-input-available\",\n   118→                    \"toolCallId\": tool_call_id,\n   119→                    \"toolName\": tool_name,\n   120→                    \"input\": args\n   121→                })\n   122→\n   123→            elif event.type == \"tool_result\":\n   124→                # 工具结果\n   125→                yield self._format({\n   126→                    \"type\": \"tool-output-available\",\n   127→                    \"toolCallId\": event.data.get(\"id\"),\n   128→                    \"output\": event.data.get(\"result\")\n   129→                })\n   130→\n   131→            elif event.type == \"error\":\n   132→                # 错误\n   133→                yield self._format({\n   134→                    \"type\": \"error\",\n   135→                    \"errorText\": str(event.data.get(\"error\", \"Unknown error\"))\n   136→                })\n   137→\n   138→            elif event.type == \"done\":\n   139→                # 完成信号在循环结束后统一处理\n   140→                pass\n   141→\n   142→        # 3. 结束文本块（如果还有）\n   143→        if self._text_started:\n   144→            yield self._format({\"type\": \"text-end\", \"id\": self.text_id})\n   145→\n   146→        # 4. 步骤结束\n   147→        if self.config.include_step_events:\n   148→            yield self._format({\"type\": \"finish-step\"})\n   149→\n   150→        # 5. 消息结束\n   151→        yield self._format({\"type\": \"finish\"})\n   152→\n   153→        # 6. 流终止\n   154→        yield self._format(\"[DONE]\")\n   155→\n   156→\n   157→class LegacySSEAdapter(BaseStreamAdapter):\n   158→    \"\"\"\n   159→    AI SDK 4.x Data Stream Protocol 适配器\n   160→\n   161→    格式 (参考 https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol):\n   162→    - 0:\"text\"                                    - Text Part\n   163→    - 9:{toolCallId, toolName, args}              - Tool Call Part\n   164→    - a:{toolCallId, result}                      - Tool Result Part\n   165→    - e:{finishReason, usage, isContinued}        - Finish Step Part\n   166→    - d:{finishReason, usage}                     - Finish Message Part\n   167→    \"\"\"\n   168→\n   169→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n   170→        async for event in events:\n   171→            if event.type == \"content\":\n   172→                content = event.data.get(\"content\", \"\")\n   173→                if content:\n   174→                    yield f'0:{json.dumps(content, ensure_ascii=False)}\\n'\n   175→\n   176→            elif event.type == \"tool_call\":\n   177→                tool_call_id = event.data.get(\"id\")\n   178→                tool_name = event.data.get(\"name\")\n   179→                args_str = event.data.get(\"arguments\", \"{}\")\n   180→                try:\n   181→                    args = json.loads(args_str) if isinstance(args_str, str) else args_str\n   182→                except json.JSONDecodeError:\n   183→                    args = {}\n   184→\n   185→                yield f'9:{json.dumps({\"toolCallId\": tool_call_id, \"toolName\": tool_name, \"args\": args}, ensure_ascii=False)}\\n'\n   186→\n   187→            elif event.type == \"tool_result\":\n   188→                yield f'a:{json.dumps({\"toolCallId\": event.data.get(\"id\"), \"result\": event.data.get(\"result\")}, ensure_ascii=False)}\\n'\n   189→\n   190→            elif event.type == \"error\":\n   191→                yield f'3:{json.dumps(str(event.data.get(\"error\", \"Unknown error\")))}\\n'\n   192→\n   193→        # Finish Step Part (必需，让 AI SDK 正确解析 parts)\n   194→        yield f'e:{json.dumps({\"finishReason\": \"stop\", \"usage\": {\"promptTokens\": 0, \"completionTokens\": 0}, \"isContinued\": False})}\\n'\n   195→        # Finish Message Part\n   196→        yield f'd:{json.dumps({\"finishReason\": \"stop\", \"usage\": {\"promptTokens\": 0, \"completionTokens\": 0}})}\\n'\n   197→\n   198→\n   199→class OpenAIAdapter(BaseStreamAdapter):\n   200→    \"\"\"\n   201→    OpenAI 兼容格式适配器\n   202→\n   203→    输出标准 OpenAI Chat Completions SSE 格式，兼容 AI SDK 4.x useChat\n   204→\n   205→    格式：\n   206→    data: {\"id\":\"chatcmpl-xxx\",\"choices\":[{\"delta\":{\"content\":\"...\"}}]}\n   207→    data: {\"id\":\"chatcmpl-xxx\",\"choices\":[{\"delta\":{\"tool_calls\":[...]}}]}\n   208→    data: [DONE]\n   209→    \"\"\"\n   210→\n   211→    def __init__(self, config: StreamConfig = None):\n   212→        super().__init__(config)\n   213→        self.completion_id = f\"chatcmpl-{uuid4().hex[:24]}\"\n   214→        self._tool_call_index = 0\n   215→\n   216→    def _format(self, data: Dict[str, Any] | str) -> Dict[str, str]:\n   217→        \"\"\"格式化为 SSE 事件\"\"\"\n   218→        if isinstance(data, str):\n   219→            return {\"data\": data}\n   220→        return {\"data\": json.dumps(data, ensure_ascii=False)}\n   221→\n   222→    def _make_chunk(self, delta: Dict[str, Any], finish_reason: str = None) -> Dict[str, Any]:\n   223→        \"\"\"构建 OpenAI 格式的 chunk\"\"\"\n   224→        return {\n   225→            \"id\": self.completion_id,\n   226→            \"object\": \"chat.completion.chunk\",\n   227→            \"created\": int(__import__(\"time\").time()),\n   228→            \"model\": \"vibelife-agent\",\n   229→            \"choices\": [{\n   230→                \"index\": 0,\n   231→                \"delta\": delta,\n   232→                \"finish_reason\": finish_reason\n   233→            }]\n   234→        }\n   235→\n   236→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[Dict[str, str], None]:\n   237→        \"\"\"将 AgentEvent 转换为 OpenAI 兼容格式\"\"\"\n   238→\n   239→        # 发送 role 标识\n   240→        yield self._format(self._make_chunk({\"role\": \"assistant\"}))\n   241→\n   242→        async for event in events:\n   243→            if event.type == \"thinking\":\n   244→                # thinking 事件不输出\n   245→                pass\n   246→\n   247→            elif event.type == \"content\":\n   248→                content = event.data.get(\"content\", \"\")\n   249→                if content:\n   250→                    yield self._format(self._make_chunk({\"content\": content}))\n   251→\n   252→            elif event.type == \"tool_call\":\n   253→                tool_call_id = event.data.get(\"id\")\n   254→                tool_name = event.data.get(\"name\")\n   255→                args_str = event.data.get(\"arguments\", \"{}\")\n   256→\n   257→                # OpenAI tool_calls 格式\n   258→                tool_call = {\n   259→                    \"index\": self._tool_call_index,\n   260→                    \"id\": tool_call_id,\n   261→                    \"type\": \"function\",\n   262→                    \"function\": {\n   263→                        \"name\": tool_name,\n   264→                        \"arguments\": args_str if isinstance(args_str, str) else json.dumps(args_str)\n   265→                    }\n   266→                }\n   267→                yield self._format(self._make_chunk({\"tool_calls\": [tool_call]}))\n   268→                self._tool_call_index += 1\n   269→\n   270→            elif event.type == \"tool_result\":\n   271→                # OpenAI 格式中，tool_result 通常不在流中返回\n   272→                # 但我们可以作为特殊内容发送，让前端知道工具执行完成\n   273→                result = event.data.get(\"result\", {})\n   274→                # 将工具结果作为特殊格式发送（前端可以解析）\n   275→                yield self._format({\n   276→                    \"id\": self.completion_id,\n   277→                    \"object\": \"chat.completion.chunk\",\n   278→                    \"choices\": [{\n   279→                        \"index\": 0,\n   280→                        \"delta\": {},\n   281→                        \"finish_reason\": None\n   282→                    }],\n   283→                    \"tool_result\": {\n   284→                        \"tool_call_id\": event.data.get(\"id\"),\n   285→                        \"result\": result\n   286→                    }\n   287→                })\n   288→\n   289→            elif event.type == \"error\":\n   290→                # 错误作为内容发送\n   291→                error_msg = str(event.data.get(\"error\", \"Unknown error\"))\n   292→                yield self._format(self._make_chunk({\"content\": f\"\\n\\n❌ Error: {error_msg}\"}))\n   293→\n   294→        # 发送完成信号\n   295→        yield self._format(self._make_chunk({}, finish_reason=\"stop\"))\n   296→        yield self._format(\"[DONE]\")\n   297→\n   298→\n   299→class TextStreamAdapter(BaseStreamAdapter):\n   300→    \"\"\"\n   301→    纯文本流适配器 (AI SDK streamProtocol: 'text')\n   302→\n   303→    只输出纯文本内容，不包含任何格式化。\n   304→    适用于 AI SDK 4.x/6.x 的 streamProtocol: 'text' 模式。\n   305→    \"\"\"\n   306→\n   307→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n   308→        \"\"\"将 AgentEvent 转换为纯文本流\"\"\"\n   309→        async for event in events:\n   310→            if event.type == \"content\":\n   311→                content = event.data.get(\"content\", \"\")\n   312→                if content:\n   313→                    yield content\n   314→\n   315→            elif event.type == \"error\":\n   316→                error_msg = str(event.data.get(\"error\", \"Unknown error\"))\n   317→                yield f\"\\n\\n❌ Error: {error_msg}\"\n   318→\n   319→\n   320→class SimpleToolAdapter(BaseStreamAdapter):\n   321→    \"\"\"\n   322→    简单工具标记适配器\n   323→\n   324→    在文本流中嵌入 [[TOOL:toolName:jsonData]] 标记，\n   325→    前端解析后渲染对应的工具卡片。\n   326→\n   327→    格式：\n   328→    - 0:\"text\" - 普通文本\n   329→    - 0:\"[[TOOL:show_bazi_chart:{...}]]\" - 工具结果标记\n   330→    - d:{finishReason} - 结束\n   331→    \"\"\"\n   332→\n   333→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n   334→        async for event in events:\n   335→            if event.type == \"content\":\n   336→                content = event.data.get(\"content\", \"\")\n   337→                if content:\n   338→                    yield f'0:{json.dumps(content, ensure_ascii=False)}\\n'\n   339→\n   340→            elif event.type == \"tool_result\":\n   341→                # 将工具结果嵌入文本流作为特殊标记\n   342→                tool_name = event.data.get(\"name\", \"unknown\")\n   343→                result = event.data.get(\"result\", {})\n   344→                marker = f'[[TOOL:{tool_name}:{json.dumps(result, ensure_ascii=False)}]]'\n   345→                yield f'0:{json.dumps(marker, ensure_ascii=False)}\\n'\n   346→\n   347→            elif event.type == \"error\":\n   348→                yield f'3:{json.dumps(str(event.data.get(\"error\", \"Unknown error\")))}\\n'\n   349→\n   350→        # Finish Message Part\n   351→        yield f'd:{json.dumps({\"finishReason\": \"stop\", \"usage\": {\"promptTokens\": 0, \"completionTokens\": 0}})}\\n'\n   352→\n   353→\n   354→def get_adapter(protocol: str = \"openai\") -> BaseStreamAdapter:\n   355→    \"\"\"获取适配器实例\"\"\"\n   356→    adapters = {\n   357→        \"openai\": OpenAIAdapter,\n   358→        \"text\": TextStreamAdapter,\n   359→        \"ai-sdk-6\": AISDKv6Adapter,\n   360→        \"legacy\": LegacySSEAdapter,\n   361→        \"simple\": SimpleToolAdapter,\n   362→    }\n   363→    adapter_class = adapters.get(protocol, OpenAIAdapter)\n   364→    return adapter_class()\n   365→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"6bf3ed80-c113-46ac-a6c7-92ede496b36a","timestamp":"2026-01-18T03:42:44.407Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/stream_adapter.py","content":"\"\"\"\nStream Adapter - 将 CoreAgent 内部事件转换为前端协议格式\n\n设计原则：\n- CoreAgent 输出统一的内部事件格式（AgentEvent）\n- StreamAdapter 负责转换为特定前端协议\n- 未来换前端方案只需写新的 Adapter，不改 CoreAgent\n\n支持的协议：\n- AI SDK 6 Data Stream Protocol (Vercel)\n- 可扩展支持其他协议\n\"\"\"\nimport json\nfrom typing import AsyncGenerator, Dict, Any\nfrom uuid import uuid4\nfrom dataclasses import dataclass\n\nfrom .core import AgentEvent\n\n\n@dataclass\nclass StreamConfig:\n    \"\"\"流配置\"\"\"\n    protocol: str = \"ai-sdk-6\"  # ai-sdk-6, sse-legacy, custom\n    include_step_events: bool = True\n\n\nclass BaseStreamAdapter:\n    \"\"\"基础流适配器\"\"\"\n\n    def __init__(self, config: StreamConfig = None):\n        self.config = config or StreamConfig()\n\n    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n        \"\"\"将内部事件转换为协议格式\"\"\"\n        raise NotImplementedError\n\n\nclass AISDKv6Adapter(BaseStreamAdapter):\n    \"\"\"\n    AI SDK 6 Data Stream Protocol 适配器\n\n    协议格式：\n    - data: {\"type\":\"start\",\"messageId\":\"...\"}\\n\\n\n    - data: {\"type\":\"text-delta\",\"id\":\"...\",\"delta\":\"...\"}\\n\\n\n    - data: {\"type\":\"finish\"}\\n\\n\n    - data: [DONE]\\n\\n\n\n    参考: https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol\n    \"\"\"\n\n    def __init__(self, config: StreamConfig = None):\n        super().__init__(config)\n        self.message_id = f\"msg_{uuid4().hex[:24]}\"\n        self.text_id = f\"text_{uuid4().hex[:12]}\"\n        self._text_started = False\n\n    def _format(self, data: Dict[str, Any] | str) -> Dict[str, str]:\n        \"\"\"格式化为 SSE 事件 (sse-starlette 格式)\"\"\"\n        if isinstance(data, str):\n            return {\"data\": data}\n        return {\"data\": json.dumps(data, ensure_ascii=False)}\n\n    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[Dict[str, str], None]:\n        \"\"\"将 AgentEvent 转换为 AI SDK 6 格式 (sse-starlette dict 格式)\"\"\"\n\n        # 1. 消息开始\n        yield self._format({\"type\": \"start\", \"messageId\": self.message_id})\n\n        # 2. 步骤开始\n        if self.config.include_step_events:\n            yield self._format({\"type\": \"start-step\"})\n\n        async for event in events:\n            if event.type == \"thinking\":\n                # thinking 事件不输出到前端\n                pass\n\n            elif event.type == \"content\":\n                # 文本增量\n                if not self._text_started:\n                    yield self._format({\"type\": \"text-start\", \"id\": self.text_id})\n                    self._text_started = True\n\n                content = event.data.get(\"content\", \"\")\n                if content:\n                    yield self._format({\n                        \"type\": \"text-delta\",\n                        \"id\": self.text_id,\n                        \"delta\": content\n                    })\n\n            elif event.type == \"tool_call\":\n                # 结束之前的文本块\n                if self._text_started:\n                    yield self._format({\"type\": \"text-end\", \"id\": self.text_id})\n                    self._text_started = False\n                    # 为下一个文本块生成新 ID\n                    self.text_id = f\"text_{uuid4().hex[:12]}\"\n\n                # 工具调用\n                tool_call_id = event.data.get(\"id\")\n                tool_name = event.data.get(\"name\")\n                args_str = event.data.get(\"arguments\", \"{}\")\n\n                try:\n                    args = json.loads(args_str) if isinstance(args_str, str) else args_str\n                except json.JSONDecodeError:\n                    args = {}\n\n                yield self._format({\n                    \"type\": \"tool-input-start\",\n                    \"toolCallId\": tool_call_id,\n                    \"toolName\": tool_name\n                })\n                yield self._format({\n                    \"type\": \"tool-input-available\",\n                    \"toolCallId\": tool_call_id,\n                    \"toolName\": tool_name,\n                    \"input\": args\n                })\n\n            elif event.type == \"tool_result\":\n                # 工具结果\n                yield self._format({\n                    \"type\": \"tool-output-available\",\n                    \"toolCallId\": event.data.get(\"id\"),\n                    \"output\": event.data.get(\"result\")\n                })\n\n            elif event.type == \"error\":\n                # 错误\n                yield self._format({\n                    \"type\": \"error\",\n                    \"errorText\": str(event.data.get(\"error\", \"Unknown error\"))\n                })\n\n            elif event.type == \"done\":\n                # 完成信号在循环结束后统一处理\n                pass\n\n        # 3. 结束文本块（如果还有）\n        if self._text_started:\n            yield self._format({\"type\": \"text-end\", \"id\": self.text_id})\n\n        # 4. 步骤结束\n        if self.config.include_step_events:\n            yield self._format({\"type\": \"finish-step\"})\n\n        # 5. 消息结束\n        yield self._format({\"type\": \"finish\"})\n\n        # 6. 流终止\n        yield self._format(\"[DONE]\")\n\n\nclass LegacySSEAdapter(BaseStreamAdapter):\n    \"\"\"\n    AI SDK 4.x Data Stream Protocol 适配器\n\n    格式 (参考 https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol):\n    - 0:\"text\"                                    - Text Part\n    - 9:{toolCallId, toolName, args}              - Tool Call Part\n    - a:{toolCallId, result}                      - Tool Result Part\n    - e:{finishReason, usage, isContinued}        - Finish Step Part\n    - d:{finishReason, usage}                     - Finish Message Part\n    \"\"\"\n\n    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n        async for event in events:\n            if event.type == \"content\":\n                content = event.data.get(\"content\", \"\")\n                if content:\n                    yield f'0:{json.dumps(content, ensure_ascii=False)}\\n'\n\n            elif event.type == \"tool_call\":\n                tool_call_id = event.data.get(\"id\")\n                tool_name = event.data.get(\"name\")\n                args_str = event.data.get(\"arguments\", \"{}\")\n                try:\n                    args = json.loads(args_str) if isinstance(args_str, str) else args_str\n                except json.JSONDecodeError:\n                    args = {}\n\n                yield f'9:{json.dumps({\"toolCallId\": tool_call_id, \"toolName\": tool_name, \"args\": args}, ensure_ascii=False)}\\n'\n\n            elif event.type == \"tool_result\":\n                yield f'a:{json.dumps({\"toolCallId\": event.data.get(\"id\"), \"result\": event.data.get(\"result\")}, ensure_ascii=False)}\\n'\n\n            elif event.type == \"error\":\n                yield f'3:{json.dumps(str(event.data.get(\"error\", \"Unknown error\")))}\\n'\n\n        # Finish Step Part (必需，让 AI SDK 正确解析 parts)\n        yield f'e:{json.dumps({\"finishReason\": \"stop\", \"usage\": {\"promptTokens\": 0, \"completionTokens\": 0}, \"isContinued\": False})}\\n'\n        # Finish Message Part\n        yield f'd:{json.dumps({\"finishReason\": \"stop\", \"usage\": {\"promptTokens\": 0, \"completionTokens\": 0}})}\\n'\n\n\nclass OpenAIAdapter(BaseStreamAdapter):\n    \"\"\"\n    OpenAI 兼容格式适配器\n\n    输出标准 OpenAI Chat Completions SSE 格式，兼容 AI SDK 4.x useChat\n\n    格式：\n    data: {\"id\":\"chatcmpl-xxx\",\"choices\":[{\"delta\":{\"content\":\"...\"}}]}\n    data: {\"id\":\"chatcmpl-xxx\",\"choices\":[{\"delta\":{\"tool_calls\":[...]}}]}\n    data: [DONE]\n    \"\"\"\n\n    def __init__(self, config: StreamConfig = None):\n        super().__init__(config)\n        self.completion_id = f\"chatcmpl-{uuid4().hex[:24]}\"\n        self._tool_call_index = 0\n\n    def _format(self, data: Dict[str, Any] | str) -> Dict[str, str]:\n        \"\"\"格式化为 SSE 事件\"\"\"\n        if isinstance(data, str):\n            return {\"data\": data}\n        return {\"data\": json.dumps(data, ensure_ascii=False)}\n\n    def _make_chunk(self, delta: Dict[str, Any], finish_reason: str = None) -> Dict[str, Any]:\n        \"\"\"构建 OpenAI 格式的 chunk\"\"\"\n        return {\n            \"id\": self.completion_id,\n            \"object\": \"chat.completion.chunk\",\n            \"created\": int(__import__(\"time\").time()),\n            \"model\": \"vibelife-agent\",\n            \"choices\": [{\n                \"index\": 0,\n                \"delta\": delta,\n                \"finish_reason\": finish_reason\n            }]\n        }\n\n    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[Dict[str, str], None]:\n        \"\"\"将 AgentEvent 转换为 OpenAI 兼容格式\"\"\"\n\n        # 发送 role 标识\n        yield self._format(self._make_chunk({\"role\": \"assistant\"}))\n\n        async for event in events:\n            if event.type == \"thinking\":\n                # thinking 事件不输出\n                pass\n\n            elif event.type == \"content\":\n                content = event.data.get(\"content\", \"\")\n                if content:\n                    yield self._format(self._make_chunk({\"content\": content}))\n\n            elif event.type == \"tool_call\":\n                tool_call_id = event.data.get(\"id\")\n                tool_name = event.data.get(\"name\")\n                args_str = event.data.get(\"arguments\", \"{}\")\n\n                # OpenAI tool_calls 格式\n                tool_call = {\n                    \"index\": self._tool_call_index,\n                    \"id\": tool_call_id,\n                    \"type\": \"function\",\n                    \"function\": {\n                        \"name\": tool_name,\n                        \"arguments\": args_str if isinstance(args_str, str) else json.dumps(args_str)\n                    }\n                }\n                yield self._format(self._make_chunk({\"tool_calls\": [tool_call]}))\n                self._tool_call_index += 1\n\n            elif event.type == \"tool_result\":\n                # OpenAI 格式中，tool_result 通常不在流中返回\n                # 但我们可以作为特殊内容发送，让前端知道工具执行完成\n                result = event.data.get(\"result\", {})\n                # 将工具结果作为特殊格式发送（前端可以解析）\n                yield self._format({\n                    \"id\": self.completion_id,\n                    \"object\": \"chat.completion.chunk\",\n                    \"choices\": [{\n                        \"index\": 0,\n                        \"delta\": {},\n                        \"finish_reason\": None\n                    }],\n                    \"tool_result\": {\n                        \"tool_call_id\": event.data.get(\"id\"),\n                        \"result\": result\n                    }\n                })\n\n            elif event.type == \"error\":\n                # 错误作为内容发送\n                error_msg = str(event.data.get(\"error\", \"Unknown error\"))\n                yield self._format(self._make_chunk({\"content\": f\"\\n\\n❌ Error: {error_msg}\"}))\n\n        # 发送完成信号\n        yield self._format(self._make_chunk({}, finish_reason=\"stop\"))\n        yield self._format(\"[DONE]\")\n\n\nclass TextStreamAdapter(BaseStreamAdapter):\n    \"\"\"\n    纯文本流适配器 (AI SDK streamProtocol: 'text')\n\n    只输出纯文本内容，不包含任何格式化。\n    适用于 AI SDK 4.x/6.x 的 streamProtocol: 'text' 模式。\n    \"\"\"\n\n    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n        \"\"\"将 AgentEvent 转换为纯文本流\"\"\"\n        async for event in events:\n            if event.type == \"content\":\n                content = event.data.get(\"content\", \"\")\n                if content:\n                    yield content\n\n            elif event.type == \"error\":\n                error_msg = str(event.data.get(\"error\", \"Unknown error\"))\n                yield f\"\\n\\n❌ Error: {error_msg}\"\n\n\nclass SimpleToolAdapter(BaseStreamAdapter):\n    \"\"\"\n    简单工具标记适配器\n\n    在文本流中嵌入 [[TOOL:toolName:jsonData]] 标记，\n    前端解析后渲染对应的工具卡片。\n\n    格式：\n    - 0:\"text\" - 普通文本\n    - 0:\"[[TOOL:show_bazi_chart:{...}]]\" - 工具结果标记\n    - d:{finishReason} - 结束\n    \"\"\"\n\n    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:\n        async for event in events:\n            if event.type == \"content\":\n                content = event.data.get(\"content\", \"\")\n                if content:\n                    yield f'0:{json.dumps(content, ensure_ascii=False)}\\n'\n\n            elif event.type == \"tool_result\":\n                # 将工具结果嵌入文本流作为特殊标记\n                tool_name = event.data.get(\"name\", \"unknown\")\n                result = event.data.get(\"result\", {})\n                marker = f'[[TOOL:{tool_name}:{json.dumps(result, ensure_ascii=False)}]]'\n                yield f'0:{json.dumps(marker, ensure_ascii=False)}\\n'\n\n            elif event.type == \"error\":\n                yield f'3:{json.dumps(str(event.data.get(\"error\", \"Unknown error\")))}\\n'\n\n        # Finish Message Part\n        yield f'd:{json.dumps({\"finishReason\": \"stop\", \"usage\": {\"promptTokens\": 0, \"completionTokens\": 0}})}\\n'\n\n\ndef get_adapter(protocol: str = \"openai\") -> BaseStreamAdapter:\n    \"\"\"获取适配器实例\"\"\"\n    adapters = {\n        \"openai\": OpenAIAdapter,\n        \"text\": TextStreamAdapter,\n        \"ai-sdk-6\": AISDKv6Adapter,\n        \"legacy\": LegacySSEAdapter,\n        \"simple\": SimpleToolAdapter,\n    }\n    adapter_class = adapters.get(protocol, OpenAIAdapter)\n    return adapter_class()\n","numLines":365,"startLine":1,"totalLines":365}},"sourceToolAssistantUUID":"46e8a585-4ce7-4cfb-92f7-47d1c4df92ca"}
{"parentUuid":"26155162-e2e8-4f90-a450-f7ee822c37f5","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RKZFhg739xx2sx5zXJ8apU","type":"tool_result","content":"/home/aiscend/work/vibelife/apps/api/skills/zodiac/tools/tools.yaml\n/home/aiscend/work/vibelife/apps/api/skills/tarot/tools/tools.yaml\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml\n/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/tools.yaml\n/home/aiscend/work/vibelife/apps/api/skills/career/tools/tools.yaml\n/home/aiscend/work/vibelife/apps/api/skills/vibe_id/tools/tools.yaml"}]},"uuid":"b2dade8e-396f-4e2e-8da1-e7c3f7faf7ee","timestamp":"2026-01-18T03:42:45.110Z","toolUseResult":{"filenames":["/home/aiscend/work/vibelife/apps/api/skills/zodiac/tools/tools.yaml","/home/aiscend/work/vibelife/apps/api/skills/tarot/tools/tools.yaml","/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml","/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/tools.yaml","/home/aiscend/work/vibelife/apps/api/skills/career/tools/tools.yaml","/home/aiscend/work/vibelife/apps/api/skills/vibe_id/tools/tools.yaml"],"durationMs":734,"numFiles":6,"truncated":false},"sourceToolAssistantUUID":"26155162-e2e8-4f90-a450-f7ee822c37f5"}
{"parentUuid":"b2dade8e-396f-4e2e-8da1-e7c3f7faf7ee","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019kNaVhyz795Eqy1wcRAs6C","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check a couple of tool definition examples and handler implementations:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9156,"cache_read_input_tokens":51649,"cache_creation":{"ephemeral_5m_input_tokens":9156,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nycXsUxtHTbX5BdYJ","type":"assistant","uuid":"696c8649-c323-4fe6-a0b7-b913bf930863","timestamp":"2026-01-18T03:42:47.131Z"}
{"parentUuid":"696c8649-c323-4fe6-a0b7-b913bf930863","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019kNaVhyz795Eqy1wcRAs6C","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012Q3pAuicRm2hgPwfh2jebP","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9156,"cache_read_input_tokens":51649,"cache_creation":{"ephemeral_5m_input_tokens":9156,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nycXsUxtHTbX5BdYJ","type":"assistant","uuid":"0f628881-6f89-4170-9047-0a7889c2154f","timestamp":"2026-01-18T03:42:47.307Z"}
{"parentUuid":"0f628881-6f89-4170-9047-0a7889c2154f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019kNaVhyz795Eqy1wcRAs6C","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Li7LCQC8yhPZMEznSfCeqZ","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/tools.yaml"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9156,"cache_read_input_tokens":51649,"cache_creation":{"ephemeral_5m_input_tokens":9156,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nycXsUxtHTbX5BdYJ","type":"assistant","uuid":"ca014b30-5ffa-4f1a-ba18-ae67b8687565","timestamp":"2026-01-18T03:42:47.546Z"}
{"parentUuid":"ca014b30-5ffa-4f1a-ba18-ae67b8687565","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019kNaVhyz795Eqy1wcRAs6C","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KiEAQU8U9rzVDis6FNdUhb","name":"Glob","input":{"pattern":"/home/aiscend/work/vibelife/apps/api/skills/*/tools/handlers.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9156,"cache_read_input_tokens":51649,"cache_creation":{"ephemeral_5m_input_tokens":9156,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9nycXsUxtHTbX5BdYJ","type":"assistant","uuid":"b811d49e-2304-4797-91cb-3888edcbe2af","timestamp":"2026-01-18T03:42:47.808Z"}
{"parentUuid":"0f628881-6f89-4170-9047-0a7889c2154f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012Q3pAuicRm2hgPwfh2jebP","type":"tool_result","content":"     1→version: \"1.0\"\n     2→skill_id: core\n     3→description: 全局工具 - 所有 Skill 共享\n     4→\n     5→# 搜索型工具\n     6→search:\n     7→  - name: search_db\n     8→    description: |\n     9→      从数据库检索知识或案例。\n    10→      - table='knowledge_chunks': 检索专业知识\n    11→      - table='cases': 检索参考案例\n    12→      LLM 根据 SOP 自己判断何时需要检索。\n    13→    parameters:\n    14→      - name: table\n    15→        type: string\n    16→        required: true\n    17→        description: 要查询的表\n    18→        enum:\n    19→          - knowledge_chunks\n    20→          - cases\n    21→      - name: query\n    22→        type: string\n    23→        required: true\n    24→        description: 检索查询词\n    25→      - name: filters\n    26→        type: object\n    27→        required: false\n    28→        description: 可选过滤条件，如 skill_id, scenario_id, tags 等\n    29→      - name: top_k\n    30→        type: integer\n    31→        required: false\n    32→        description: 返回结果数量\n    33→        default: 5\n    34→\n    35→# 收集型工具\n    36→collect:\n    37→  - name: ask_user_question\n    38→    description: |\n    39→      主动向用户提问以获取更多信息。\n    40→      何时调用：\n    41→      - 用户意图不明确，需要澄清\n    42→      - 需要用户做出选择\n    43→      - 缺少必要信息无法继续\n    44→      提问原则：\n    45→      - 问题要具体、明确\n    46→      - 提供选项时不超过4个\n    47→      - 避免连续追问\n    48→    card_type: question_card\n    49→    parameters:\n    50→      - name: question\n    51→        type: string\n    52→        required: true\n    53→        description: 要问用户的问题\n    54→      - name: options\n    55→        type: array\n    56→        required: false\n    57→        description: 可选的选项列表（最多4个）\n    58→\n    59→  - name: request_info\n    60→    description: |\n    61→      向用户请求信息。当需要收集出生信息或其他必要信息时调用。\n    62→    card_type: collect_form\n    63→    parameters:\n    64→      - name: info_type\n    65→        type: string\n    66→        required: true\n    67→        description: 信息类型\n    68→        enum:\n    69→          - birth\n    70→          - context\n    71→          - goals\n    72→          - concerns\n    73→      - name: question\n    74→        type: string\n    75→        required: false\n    76→        description: 自定义问题\n    77→\n    78→# 展示型工具\n    79→display:\n    80→  - name: show_service_menu\n    81→    description: |\n    82→      展示服务目录卡片。\n    83→      何时调用：\n    84→      - 新用户首次进入\n    85→      - 用户询问\"有什么服务\"\n    86→      - 用户表现出不知道如何开始\n    87→    card_type: service_menu\n    88→    when_to_call: 新用户首次进入或询问有什么服务时\n    89→    parameters:\n    90→      - name: services\n    91→        type: array\n    92→        required: false\n    93→        description: 服务列表（可选，默认显示所有服务）\n    94→\n    95→  - name: show_skill_services\n    96→    description: |\n    97→      展示当前 Skill 的服务目录。\n    98→      何时调用：\n    99→      - 用户主动选择进入某个 Skill 时\n   100→      - 用户询问\"你能做什么\"、\"有什么服务\"时\n   101→      - 用户表现出不知道如何开始时\n   102→      何时不调用：\n   103→      - 用户已经有明确需求时（如\"帮我看看命盘\"）\n   104→      - 对话已经在进行中时\n   105→    card_type: skill_services\n   106→    when_to_call: 用户主动进入 Skill 或询问有什么服务时\n   107→    parameters:\n   108→      - name: skill_id\n   109→        type: string\n   110→        required: true\n   111→        description: Skill ID (bazi/zodiac/tarot/career)\n   112→\n   113→  - name: recommend_service\n   114→    description: |\n   115→      根据对话上下文，向用户推荐相关的升级服务。\n   116→      何时调用：\n   117→      - 完成一个 entry 级别服务后，检测到用户可能需要更深入分析\n   118→      - 用户表现出对某个话题的持续关注\n   119→      - 用户的问题超出当前服务范围\n   120→      推荐原则：\n   121→      - 一次只推荐一个最相关的服务\n   122→      - 推荐要自然，不能太商业化\n   123→    card_type: service_recommendation\n   124→    when_to_call: 完成基础服务后推荐升级服务\n   125→    parameters:\n   126→      - name: scenario_id\n   127→        type: string\n   128→        required: true\n   129→        description: 推荐的场景 ID\n   130→      - name: reason\n   131→        type: string\n   132→        required: true\n   133→        description: 推荐理由（对用户可见）\n   134→      - name: highlights\n   135→        type: array\n   136→        required: false\n   137→        description: 服务亮点（2-3个）\n   138→\n   139→  - name: show_insight\n   140→    description: |\n   141→      展示洞察卡片。当需要突出关键发现或建议时调用。\n   142→    card_type: insight_card\n   143→    when_to_call: 需要突出关键发现或建议时\n   144→    parameters:\n   145→      - name: insight_type\n   146→        type: string\n   147→        required: true\n   148→        description: 洞察类型\n   149→        enum:\n   150→          - career\n   151→          - relationship\n   152→          - fortune\n   153→          - health\n   154→          - general\n   155→      - name: title\n   156→        type: string\n   157→        required: true\n   158→        description: 洞察标题\n   159→      - name: content\n   160→        type: string\n   161→        required: true\n   162→        description: 洞察内容\n   163→\n   164→  - name: show_report\n   165→    description: |\n   166→      展示完整报告。当用户想查看详细分析报告时调用。\n   167→    card_type: report_card\n   168→    when_to_call: 用户想查看详细分析报告时\n   169→    parameters:\n   170→      - name: report_type\n   171→        type: string\n   172→        required: false\n   173→        description: 报告类型\n   174→        default: lite\n   175→        enum:\n   176→          - lite\n   177→          - full\n   178→\n   179→  - name: show_relationship\n   180→    description: |\n   181→      展示关系分析结果。当用户想分析与他人的关系兼容性时调用。\n   182→    card_type: relationship_card\n   183→    when_to_call: 用户想分析与他人的关系兼容性时\n   184→    parameters:\n   185→      - name: partner_info\n   186→        type: object\n   187→        required: false\n   188→        description: 对方信息（姓名、出生日期等）\n   189→      - name: relationship_type\n   190→        type: string\n   191→        required: false\n   192→        description: 关系类型\n   193→        enum:\n   194→          - romantic\n   195→          - friendship\n   196→          - family\n   197→          - work\n   198→          - general\n   199→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f5f3a471-cdd8-4eea-847d-5af380f91c8d","timestamp":"2026-01-18T03:42:47.904Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml","content":"version: \"1.0\"\nskill_id: core\ndescription: 全局工具 - 所有 Skill 共享\n\n# 搜索型工具\nsearch:\n  - name: search_db\n    description: |\n      从数据库检索知识或案例。\n      - table='knowledge_chunks': 检索专业知识\n      - table='cases': 检索参考案例\n      LLM 根据 SOP 自己判断何时需要检索。\n    parameters:\n      - name: table\n        type: string\n        required: true\n        description: 要查询的表\n        enum:\n          - knowledge_chunks\n          - cases\n      - name: query\n        type: string\n        required: true\n        description: 检索查询词\n      - name: filters\n        type: object\n        required: false\n        description: 可选过滤条件，如 skill_id, scenario_id, tags 等\n      - name: top_k\n        type: integer\n        required: false\n        description: 返回结果数量\n        default: 5\n\n# 收集型工具\ncollect:\n  - name: ask_user_question\n    description: |\n      主动向用户提问以获取更多信息。\n      何时调用：\n      - 用户意图不明确，需要澄清\n      - 需要用户做出选择\n      - 缺少必要信息无法继续\n      提问原则：\n      - 问题要具体、明确\n      - 提供选项时不超过4个\n      - 避免连续追问\n    card_type: question_card\n    parameters:\n      - name: question\n        type: string\n        required: true\n        description: 要问用户的问题\n      - name: options\n        type: array\n        required: false\n        description: 可选的选项列表（最多4个）\n\n  - name: request_info\n    description: |\n      向用户请求信息。当需要收集出生信息或其他必要信息时调用。\n    card_type: collect_form\n    parameters:\n      - name: info_type\n        type: string\n        required: true\n        description: 信息类型\n        enum:\n          - birth\n          - context\n          - goals\n          - concerns\n      - name: question\n        type: string\n        required: false\n        description: 自定义问题\n\n# 展示型工具\ndisplay:\n  - name: show_service_menu\n    description: |\n      展示服务目录卡片。\n      何时调用：\n      - 新用户首次进入\n      - 用户询问\"有什么服务\"\n      - 用户表现出不知道如何开始\n    card_type: service_menu\n    when_to_call: 新用户首次进入或询问有什么服务时\n    parameters:\n      - name: services\n        type: array\n        required: false\n        description: 服务列表（可选，默认显示所有服务）\n\n  - name: show_skill_services\n    description: |\n      展示当前 Skill 的服务目录。\n      何时调用：\n      - 用户主动选择进入某个 Skill 时\n      - 用户询问\"你能做什么\"、\"有什么服务\"时\n      - 用户表现出不知道如何开始时\n      何时不调用：\n      - 用户已经有明确需求时（如\"帮我看看命盘\"）\n      - 对话已经在进行中时\n    card_type: skill_services\n    when_to_call: 用户主动进入 Skill 或询问有什么服务时\n    parameters:\n      - name: skill_id\n        type: string\n        required: true\n        description: Skill ID (bazi/zodiac/tarot/career)\n\n  - name: recommend_service\n    description: |\n      根据对话上下文，向用户推荐相关的升级服务。\n      何时调用：\n      - 完成一个 entry 级别服务后，检测到用户可能需要更深入分析\n      - 用户表现出对某个话题的持续关注\n      - 用户的问题超出当前服务范围\n      推荐原则：\n      - 一次只推荐一个最相关的服务\n      - 推荐要自然，不能太商业化\n    card_type: service_recommendation\n    when_to_call: 完成基础服务后推荐升级服务\n    parameters:\n      - name: scenario_id\n        type: string\n        required: true\n        description: 推荐的场景 ID\n      - name: reason\n        type: string\n        required: true\n        description: 推荐理由（对用户可见）\n      - name: highlights\n        type: array\n        required: false\n        description: 服务亮点（2-3个）\n\n  - name: show_insight\n    description: |\n      展示洞察卡片。当需要突出关键发现或建议时调用。\n    card_type: insight_card\n    when_to_call: 需要突出关键发现或建议时\n    parameters:\n      - name: insight_type\n        type: string\n        required: true\n        description: 洞察类型\n        enum:\n          - career\n          - relationship\n          - fortune\n          - health\n          - general\n      - name: title\n        type: string\n        required: true\n        description: 洞察标题\n      - name: content\n        type: string\n        required: true\n        description: 洞察内容\n\n  - name: show_report\n    description: |\n      展示完整报告。当用户想查看详细分析报告时调用。\n    card_type: report_card\n    when_to_call: 用户想查看详细分析报告时\n    parameters:\n      - name: report_type\n        type: string\n        required: false\n        description: 报告类型\n        default: lite\n        enum:\n          - lite\n          - full\n\n  - name: show_relationship\n    description: |\n      展示关系分析结果。当用户想分析与他人的关系兼容性时调用。\n    card_type: relationship_card\n    when_to_call: 用户想分析与他人的关系兼容性时\n    parameters:\n      - name: partner_info\n        type: object\n        required: false\n        description: 对方信息（姓名、出生日期等）\n      - name: relationship_type\n        type: string\n        required: false\n        description: 关系类型\n        enum:\n          - romantic\n          - friendship\n          - family\n          - work\n          - general\n","numLines":199,"startLine":1,"totalLines":199}},"sourceToolAssistantUUID":"0f628881-6f89-4170-9047-0a7889c2154f"}
{"parentUuid":"ca014b30-5ffa-4f1a-ba18-ae67b8687565","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Li7LCQC8yhPZMEznSfCeqZ","type":"tool_result","content":"     1→version: \"1.0\"\n     2→skill_id: bazi\n     3→\n     4→# 收集型工具\n     5→collect:\n     6→  - name: collect_bazi_info\n     7→    description: |\n     8→      收集用户的出生信息以进行八字分析。\n     9→      当用户想要进行八字分析但尚未提供出生信息时调用。\n    10→    card_type: bazi_form\n    11→    card_props:\n    12→      form_fields:\n    13→        - name: birth_date\n    14→          type: date\n    15→          required: true\n    16→          label: 出生日期\n    17→        - name: birth_time\n    18→          type: time\n    19→          required: true\n    20→          label: 出生时间（时辰）\n    21→        - name: birth_location\n    22→          type: location\n    23→          required: false\n    24→          label: 出生地点\n    25→        - name: gender\n    26→          type: select\n    27→          required: true\n    28→          label: 性别\n    29→          options:\n    30→            - value: male\n    31→              label: 男\n    32→            - value: female\n    33→              label: 女\n    34→      allow_text_input: true\n    35→      text_input_placeholder: 请描述你当前的困惑或问题...\n    36→    parameters:\n    37→      - name: question\n    38→        type: string\n    39→        required: false\n    40→        description: 用户的问题或困惑\n    41→    when_to_call: 用户想进行八字分析但没有提供出生信息时\n    42→\n    43→# 计算型工具\n    44→compute:\n    45→  - name: calculate_bazi\n    46→    description: |\n    47→      根据出生信息计算八字命盘。\n    48→      包括四柱、日主、五行分布、十神关系、大运流年。\n    49→    implementation: tools.bazi.calculate_bazi_chart\n    50→    parameters:\n    51→      - name: birth_date\n    52→        type: string\n    53→        required: true\n    54→        description: 出生日期 (YYYY-MM-DD)\n    55→      - name: birth_time\n    56→        type: string\n    57→        required: true\n    58→        description: 出生时间 (HH:MM)\n    59→      - name: birth_location\n    60→        type: string\n    61→        required: false\n    62→        description: 出生地点\n    63→      - name: gender\n    64→        type: string\n    65→        required: true\n    66→        description: 性别 (male/female)\n    67→    returns:\n    68→      type: object\n    69→      description: |\n    70→        包含四柱、日主、五行分布、十神、大运等完整命盘数据\n    71→\n    72→# 展示型工具\n    73→display:\n    74→  - name: show_bazi_chart\n    75→    description: |\n    76→      展示用户的八字命盘，包括四柱、日主、五行分布和十神关系。\n    77→      当用户想要查看自己的八字、命盘或想了解基本命理信息时调用此工具。\n    78→    card_type: bazi_chart\n    79→    when_to_call: |\n    80→      - 用户说\"看看我的命盘\"\n    81→      - 用户说\"我的八字是什么\"\n    82→      - 用户想了解基本命理信息\n    83→    parameters:\n    84→      - name: showDetails\n    85→        type: boolean\n    86→        required: false\n    87→        description: 是否显示详细分析\n    88→        default: true\n    89→\n    90→  - name: show_bazi_fortune\n    91→    description: |\n    92→      展示用户的大运流年分析，包括：\n    93→      - 当前所处的十年大运周期（大运天干地支、五行属性、起运年龄）\n    94→      - 指定年份的流年运势分析\n    95→      - 大运与流年的组合影响\n    96→      - 关键建议和注意事项\n    97→\n    98→      【重要】当用户问以下问题时必须调用此工具：\n    99→      - \"大运\"、\"十年运\"、\"走什么运\"\n   100→      - \"今年运势\"、\"明年运势\"、\"流年\"\n   101→      - 特定年份运势（如\"2027年运势\"）\n   102→    card_type: bazi_fortune\n   103→    when_to_call: |\n   104→      - 用户问\"我现在走什么大运\"\n   105→      - 用户问\"大运\"、\"十年运\"\n   106→      - 用户问\"今年运势怎么样\"\n   107→      - 用户问\"2026年运势\"\n   108→      - 用户问\"流年\"\n   109→      - 用户想了解特定年份运势\n   110→    parameters:\n   111→      - name: year\n   112→        type: integer\n   113→        required: false\n   114→        description: 要分析的年份（默认当前年）\n   115→      - name: includePast\n   116→        type: boolean\n   117→        required: false\n   118→        description: 是否包含过去的大运\n   119→        default: false\n   120→\n   121→  - name: show_bazi_kline\n   122→    description: |\n   123→      展示用户的运势 K 线图，可视化展示运势变化趋势。\n   124→      当用户想要查看运势变化趋势时调用。\n   125→    card_type: bazi_kline\n   126→    when_to_call: |\n   127→      - 用户说\"看看运势趋势\"\n   128→      - 用户说\"运势K线\"\n   129→      - 用户想可视化查看运势变化\n   130→    parameters:\n   131→      - name: startYear\n   132→        type: integer\n   133→        required: false\n   134→        description: 起始年份\n   135→      - name: endYear\n   136→        type: integer\n   137→        required: false\n   138→        description: 结束年份\n   139→\n   140→# 注意: show_report 和 show_insight 已在 core/tools/tools.yaml 中定义为全局工具，无需重复定义\n   141→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a777e782-e3f4-4c4a-91f1-eb2b5f3986b5","timestamp":"2026-01-18T03:42:47.905Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/tools.yaml","content":"version: \"1.0\"\nskill_id: bazi\n\n# 收集型工具\ncollect:\n  - name: collect_bazi_info\n    description: |\n      收集用户的出生信息以进行八字分析。\n      当用户想要进行八字分析但尚未提供出生信息时调用。\n    card_type: bazi_form\n    card_props:\n      form_fields:\n        - name: birth_date\n          type: date\n          required: true\n          label: 出生日期\n        - name: birth_time\n          type: time\n          required: true\n          label: 出生时间（时辰）\n        - name: birth_location\n          type: location\n          required: false\n          label: 出生地点\n        - name: gender\n          type: select\n          required: true\n          label: 性别\n          options:\n            - value: male\n              label: 男\n            - value: female\n              label: 女\n      allow_text_input: true\n      text_input_placeholder: 请描述你当前的困惑或问题...\n    parameters:\n      - name: question\n        type: string\n        required: false\n        description: 用户的问题或困惑\n    when_to_call: 用户想进行八字分析但没有提供出生信息时\n\n# 计算型工具\ncompute:\n  - name: calculate_bazi\n    description: |\n      根据出生信息计算八字命盘。\n      包括四柱、日主、五行分布、十神关系、大运流年。\n    implementation: tools.bazi.calculate_bazi_chart\n    parameters:\n      - name: birth_date\n        type: string\n        required: true\n        description: 出生日期 (YYYY-MM-DD)\n      - name: birth_time\n        type: string\n        required: true\n        description: 出生时间 (HH:MM)\n      - name: birth_location\n        type: string\n        required: false\n        description: 出生地点\n      - name: gender\n        type: string\n        required: true\n        description: 性别 (male/female)\n    returns:\n      type: object\n      description: |\n        包含四柱、日主、五行分布、十神、大运等完整命盘数据\n\n# 展示型工具\ndisplay:\n  - name: show_bazi_chart\n    description: |\n      展示用户的八字命盘，包括四柱、日主、五行分布和十神关系。\n      当用户想要查看自己的八字、命盘或想了解基本命理信息时调用此工具。\n    card_type: bazi_chart\n    when_to_call: |\n      - 用户说\"看看我的命盘\"\n      - 用户说\"我的八字是什么\"\n      - 用户想了解基本命理信息\n    parameters:\n      - name: showDetails\n        type: boolean\n        required: false\n        description: 是否显示详细分析\n        default: true\n\n  - name: show_bazi_fortune\n    description: |\n      展示用户的大运流年分析，包括：\n      - 当前所处的十年大运周期（大运天干地支、五行属性、起运年龄）\n      - 指定年份的流年运势分析\n      - 大运与流年的组合影响\n      - 关键建议和注意事项\n\n      【重要】当用户问以下问题时必须调用此工具：\n      - \"大运\"、\"十年运\"、\"走什么运\"\n      - \"今年运势\"、\"明年运势\"、\"流年\"\n      - 特定年份运势（如\"2027年运势\"）\n    card_type: bazi_fortune\n    when_to_call: |\n      - 用户问\"我现在走什么大运\"\n      - 用户问\"大运\"、\"十年运\"\n      - 用户问\"今年运势怎么样\"\n      - 用户问\"2026年运势\"\n      - 用户问\"流年\"\n      - 用户想了解特定年份运势\n    parameters:\n      - name: year\n        type: integer\n        required: false\n        description: 要分析的年份（默认当前年）\n      - name: includePast\n        type: boolean\n        required: false\n        description: 是否包含过去的大运\n        default: false\n\n  - name: show_bazi_kline\n    description: |\n      展示用户的运势 K 线图，可视化展示运势变化趋势。\n      当用户想要查看运势变化趋势时调用。\n    card_type: bazi_kline\n    when_to_call: |\n      - 用户说\"看看运势趋势\"\n      - 用户说\"运势K线\"\n      - 用户想可视化查看运势变化\n    parameters:\n      - name: startYear\n        type: integer\n        required: false\n        description: 起始年份\n      - name: endYear\n        type: integer\n        required: false\n        description: 结束年份\n\n# 注意: show_report 和 show_insight 已在 core/tools/tools.yaml 中定义为全局工具，无需重复定义\n","numLines":141,"startLine":1,"totalLines":141}},"sourceToolAssistantUUID":"ca014b30-5ffa-4f1a-ba18-ae67b8687565"}
{"parentUuid":"b811d49e-2304-4797-91cb-3888edcbe2af","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KiEAQU8U9rzVDis6FNdUhb","type":"tool_result","content":"No files found"}]},"uuid":"d34bf56b-9a42-4dfb-bb31-bd0a8059c9be","timestamp":"2026-01-18T03:42:48.608Z","toolUseResult":{"filenames":[],"durationMs":720,"numFiles":0,"truncated":false},"sourceToolAssistantUUID":"b811d49e-2304-4797-91cb-3888edcbe2af"}
{"parentUuid":"d34bf56b-9a42-4dfb-bb31-bd0a8059c9be","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01U983RQruB5dh9k9ycxZ3Qn","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check if there are handler implementations:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4930,"cache_read_input_tokens":60805,"cache_creation":{"ephemeral_5m_input_tokens":4930,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9oEn6R5onMFV7MZL5i","type":"assistant","uuid":"1341a7d3-5100-4217-82f0-26da3b07b5cc","timestamp":"2026-01-18T03:42:50.481Z"}
{"parentUuid":"1341a7d3-5100-4217-82f0-26da3b07b5cc","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01U983RQruB5dh9k9ycxZ3Qn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P9b3TQ4q6VwhhU9ZKPhhHo","name":"Bash","input":{"command":"find /home/aiscend/work/vibelife/apps/api/skills -name \"handlers.py\" -type f 2>/dev/null"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4930,"cache_read_input_tokens":60805,"cache_creation":{"ephemeral_5m_input_tokens":4930,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9oEn6R5onMFV7MZL5i","type":"assistant","uuid":"4031e9c8-a13e-4ff5-9f8c-9cac96af2962","timestamp":"2026-01-18T03:42:51.014Z"}
{"parentUuid":"4031e9c8-a13e-4ff5-9f8c-9cac96af2962","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01U983RQruB5dh9k9ycxZ3Qn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CqdFHVtQnNSA8Nw4kTbWuC","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/__init__.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4930,"cache_read_input_tokens":60805,"cache_creation":{"ephemeral_5m_input_tokens":4930,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9oEn6R5onMFV7MZL5i","type":"assistant","uuid":"6eb2a3d8-478f-447c-8f4d-156b0c18c95b","timestamp":"2026-01-18T03:42:51.385Z"}
{"parentUuid":"6eb2a3d8-478f-447c-8f4d-156b0c18c95b","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CqdFHVtQnNSA8Nw4kTbWuC","type":"tool_result","content":"     1→\"\"\"\n     2→Agent Framework - V6 Architecture\n     3→CoreAgent with LLM-based skill selection (Claude Agent SDK style)\n     4→\n     5→V6 Changes:\n     6→- CoreAgent replaces Orchestrator + SkillAgents\n     7→- LLM-based skill selection (no keyword matching)\n     8→- SkillLoader loads SKILL.md files\n     9→- Unified tool schema from YAML\n    10→- SOP state persistence with Redis\n    11→- Skill validation for CI\n    12→\"\"\"\n    13→\n    14→# Core Agent\n    15→from .core import CoreAgent, AgentContext, AgentEvent, AgentState, create_agent\n    16→from .skill_loader import load_skill, build_system_prompt, get_available_skills, SkillConfig\n    17→from .subagent import SkillSubAgent\n    18→\n    19→# Tier limits (简化版，完整配额管理使用 model_router.quota)\n    20→TIER_LIMITS = {\n    21→    \"free\": {\"calls\": 50, \"tokens\": 100000},\n    22→    \"paid\": {\"calls\": 500, \"tokens\": 1000000},\n    23→    \"vip\": {\"calls\": -1, \"tokens\": -1},\n    24→}\n    25→\n    26→\n    27→class QuotaTracker:\n    28→    \"\"\"简化配额追踪 - 委托到 UsageService\"\"\"\n    29→\n    30→    @classmethod\n    31→    async def check(cls, user_id: str, tier: str):\n    32→        \"\"\"检查配额\"\"\"\n    33→        if tier == \"vip\":\n    34→            return True, \"\"\n    35→\n    36→        from services.usage import UsageService\n    37→        from uuid import UUID\n    38→\n    39→        try:\n    40→            usage = await UsageService.get_monthly_usage(UUID(user_id))\n    41→            limits = TIER_LIMITS.get(tier, TIER_LIMITS[\"free\"])\n    42→\n    43→            if limits[\"calls\"] > 0 and usage[\"llm_calls\"] >= limits[\"calls\"]:\n    44→                return False, \"本月对话次数已用完\"\n    45→            return True, \"\"\n    46→        except Exception:\n    47→            return True, \"\"\n    48→\n    49→    @classmethod\n    50→    async def record(cls, user_id: str, usage: dict):\n    51→        \"\"\"记录用量 - 已由 UsageService 处理\"\"\"\n    52→        pass\n    53→\n    54→# Stream Adapters\n    55→from .stream_adapter import (\n    56→    BaseStreamAdapter,\n    57→    AISDKv6Adapter,\n    58→    LegacySSEAdapter,\n    59→    StreamConfig,\n    60→    get_adapter,\n    61→)\n    62→\n    63→# V6 新增: 统一工具定义\n    64→from .tool_schema import (\n    65→    ToolDef,\n    66→    ToolParam,\n    67→    load_skill_tools,\n    68→    get_skill_tools_openai,\n    69→    get_global_tools_openai,\n    70→    get_all_tools_for_skill,\n    71→    get_tool_card_type,\n    72→)\n    73→\n    74→# V6 新增: 统一工具注册表\n    75→from .tool_registry import (\n    76→    ToolRegistry,\n    77→    ToolContext,\n    78→    tool_handler,\n    79→)\n    80→\n    81→# V6 新增: SOP 状态持久化\n    82→from .sop_state import (\n    83→    SOPState,\n    84→    SOPStateManager,\n    85→    get_sop_manager,\n    86→)\n    87→\n    88→# V6 新增: SOP 引擎\n    89→from .sop_engine import (\n    90→    SOPEngine,\n    91→    SOPPhase,\n    92→    SOPAction,\n    93→    create_sop_engine,\n    94→    check_sop_requirements,\n    95→)\n    96→\n    97→# V6 新增: Skill 校验\n    98→from .skill_validator import (\n    99→    validate_skill,\n   100→    validate_all_skills,\n   101→    ValidationResult,\n   102→    ValidationError,\n   103→)\n   104→\n   105→__all__ = [\n   106→    # Core Agent\n   107→    \"CoreAgent\",\n   108→    \"AgentContext\",\n   109→    \"AgentEvent\",\n   110→    \"AgentState\",\n   111→    \"SkillConfig\",\n   112→    \"SkillSubAgent\",\n   113→    \"QuotaTracker\",\n   114→    \"TIER_LIMITS\",\n   115→    \"create_agent\",\n   116→    \"load_skill\",\n   117→    \"build_system_prompt\",\n   118→    \"get_available_skills\",\n   119→    # Stream Adapters\n   120→    \"BaseStreamAdapter\",\n   121→    \"AISDKv6Adapter\",\n   122→    \"LegacySSEAdapter\",\n   123→    \"StreamConfig\",\n   124→    \"get_adapter\",\n   125→    # Tool Schema\n   126→    \"ToolDef\",\n   127→    \"ToolParam\",\n   128→    \"load_skill_tools\",\n   129→    \"get_skill_tools_openai\",\n   130→    \"get_global_tools_openai\",\n   131→    \"get_all_tools_for_skill\",\n   132→    \"get_tool_card_type\",\n   133→    # Tool Registry\n   134→    \"ToolRegistry\",\n   135→    \"ToolContext\",\n   136→    \"tool_handler\",\n   137→    # SOP State\n   138→    \"SOPState\",\n   139→    \"SOPStateManager\",\n   140→    \"get_sop_manager\",\n   141→    # SOP Engine\n   142→    \"SOPEngine\",\n   143→    \"SOPPhase\",\n   144→    \"SOPAction\",\n   145→    \"create_sop_engine\",\n   146→    \"check_sop_requirements\",\n   147→    # Skill Validator\n   148→    \"validate_skill\",\n   149→    \"validate_all_skills\",\n   150→    \"ValidationResult\",\n   151→    \"ValidationError\",\n   152→]\n   153→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"02dfbc5e-5d5e-4848-bd36-fd9ecf1e4893","timestamp":"2026-01-18T03:42:51.582Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/__init__.py","content":"\"\"\"\nAgent Framework - V6 Architecture\nCoreAgent with LLM-based skill selection (Claude Agent SDK style)\n\nV6 Changes:\n- CoreAgent replaces Orchestrator + SkillAgents\n- LLM-based skill selection (no keyword matching)\n- SkillLoader loads SKILL.md files\n- Unified tool schema from YAML\n- SOP state persistence with Redis\n- Skill validation for CI\n\"\"\"\n\n# Core Agent\nfrom .core import CoreAgent, AgentContext, AgentEvent, AgentState, create_agent\nfrom .skill_loader import load_skill, build_system_prompt, get_available_skills, SkillConfig\nfrom .subagent import SkillSubAgent\n\n# Tier limits (简化版，完整配额管理使用 model_router.quota)\nTIER_LIMITS = {\n    \"free\": {\"calls\": 50, \"tokens\": 100000},\n    \"paid\": {\"calls\": 500, \"tokens\": 1000000},\n    \"vip\": {\"calls\": -1, \"tokens\": -1},\n}\n\n\nclass QuotaTracker:\n    \"\"\"简化配额追踪 - 委托到 UsageService\"\"\"\n\n    @classmethod\n    async def check(cls, user_id: str, tier: str):\n        \"\"\"检查配额\"\"\"\n        if tier == \"vip\":\n            return True, \"\"\n\n        from services.usage import UsageService\n        from uuid import UUID\n\n        try:\n            usage = await UsageService.get_monthly_usage(UUID(user_id))\n            limits = TIER_LIMITS.get(tier, TIER_LIMITS[\"free\"])\n\n            if limits[\"calls\"] > 0 and usage[\"llm_calls\"] >= limits[\"calls\"]:\n                return False, \"本月对话次数已用完\"\n            return True, \"\"\n        except Exception:\n            return True, \"\"\n\n    @classmethod\n    async def record(cls, user_id: str, usage: dict):\n        \"\"\"记录用量 - 已由 UsageService 处理\"\"\"\n        pass\n\n# Stream Adapters\nfrom .stream_adapter import (\n    BaseStreamAdapter,\n    AISDKv6Adapter,\n    LegacySSEAdapter,\n    StreamConfig,\n    get_adapter,\n)\n\n# V6 新增: 统一工具定义\nfrom .tool_schema import (\n    ToolDef,\n    ToolParam,\n    load_skill_tools,\n    get_skill_tools_openai,\n    get_global_tools_openai,\n    get_all_tools_for_skill,\n    get_tool_card_type,\n)\n\n# V6 新增: 统一工具注册表\nfrom .tool_registry import (\n    ToolRegistry,\n    ToolContext,\n    tool_handler,\n)\n\n# V6 新增: SOP 状态持久化\nfrom .sop_state import (\n    SOPState,\n    SOPStateManager,\n    get_sop_manager,\n)\n\n# V6 新增: SOP 引擎\nfrom .sop_engine import (\n    SOPEngine,\n    SOPPhase,\n    SOPAction,\n    create_sop_engine,\n    check_sop_requirements,\n)\n\n# V6 新增: Skill 校验\nfrom .skill_validator import (\n    validate_skill,\n    validate_all_skills,\n    ValidationResult,\n    ValidationError,\n)\n\n__all__ = [\n    # Core Agent\n    \"CoreAgent\",\n    \"AgentContext\",\n    \"AgentEvent\",\n    \"AgentState\",\n    \"SkillConfig\",\n    \"SkillSubAgent\",\n    \"QuotaTracker\",\n    \"TIER_LIMITS\",\n    \"create_agent\",\n    \"load_skill\",\n    \"build_system_prompt\",\n    \"get_available_skills\",\n    # Stream Adapters\n    \"BaseStreamAdapter\",\n    \"AISDKv6Adapter\",\n    \"LegacySSEAdapter\",\n    \"StreamConfig\",\n    \"get_adapter\",\n    # Tool Schema\n    \"ToolDef\",\n    \"ToolParam\",\n    \"load_skill_tools\",\n    \"get_skill_tools_openai\",\n    \"get_global_tools_openai\",\n    \"get_all_tools_for_skill\",\n    \"get_tool_card_type\",\n    # Tool Registry\n    \"ToolRegistry\",\n    \"ToolContext\",\n    \"tool_handler\",\n    # SOP State\n    \"SOPState\",\n    \"SOPStateManager\",\n    \"get_sop_manager\",\n    # SOP Engine\n    \"SOPEngine\",\n    \"SOPPhase\",\n    \"SOPAction\",\n    \"create_sop_engine\",\n    \"check_sop_requirements\",\n    # Skill Validator\n    \"validate_skill\",\n    \"validate_all_skills\",\n    \"ValidationResult\",\n    \"ValidationError\",\n]\n","numLines":153,"startLine":1,"totalLines":153}},"sourceToolAssistantUUID":"6eb2a3d8-478f-447c-8f4d-156b0c18c95b"}
{"parentUuid":"4031e9c8-a13e-4ff5-9f8c-9cac96af2962","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P9b3TQ4q6VwhhU9ZKPhhHo","type":"tool_result","content":"/home/aiscend/work/vibelife/apps/api/skills/tarot/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/zodiac/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/vibe_id/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/career/tools/handlers.py","is_error":false}]},"uuid":"37373b0f-326d-4b5a-b402-e2fbd468872d","timestamp":"2026-01-18T03:42:51.623Z","toolUseResult":{"stdout":"/home/aiscend/work/vibelife/apps/api/skills/tarot/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/zodiac/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/vibe_id/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py\n/home/aiscend/work/vibelife/apps/api/skills/career/tools/handlers.py","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"4031e9c8-a13e-4ff5-9f8c-9cac96af2962"}
{"parentUuid":"37373b0f-326d-4b5a-b402-e2fbd468872d","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0177Y5qkZQf6Ukd8ATbk3WqG","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read a handler example to complete the picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1802,"cache_creation_input_tokens":393,"cache_read_input_tokens":65735,"cache_creation":{"ephemeral_5m_input_tokens":393,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXE9oUni337WXGsttqQ8v","type":"assistant","uuid":"95febd37-d31f-494d-98ad-7f54cfd2926e","timestamp":"2026-01-18T03:42:53.636Z"}
{"parentUuid":"95febd37-d31f-494d-98ad-7f54cfd2926e","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0177Y5qkZQf6Ukd8ATbk3WqG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T4Sm221o1HpNNJEnhBRksc","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1802,"cache_creation_input_tokens":393,"cache_read_input_tokens":65735,"cache_creation":{"ephemeral_5m_input_tokens":393,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXE9oUni337WXGsttqQ8v","type":"assistant","uuid":"df78df39-a5df-44b6-8a17-282f8c9eb249","timestamp":"2026-01-18T03:42:54.251Z"}
{"parentUuid":"df78df39-a5df-44b6-8a17-282f8c9eb249","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0177Y5qkZQf6Ukd8ATbk3WqG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RRJtARf6yioZUrzojW6Rj1","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/handlers.py","limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1802,"cache_creation_input_tokens":393,"cache_read_input_tokens":65735,"cache_creation":{"ephemeral_5m_input_tokens":393,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXE9oUni337WXGsttqQ8v","type":"assistant","uuid":"5325967c-ec15-439d-a50d-f3a89ae0eadc","timestamp":"2026-01-18T03:42:54.589Z"}
{"parentUuid":"df78df39-a5df-44b6-8a17-282f8c9eb249","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T4Sm221o1HpNNJEnhBRksc","type":"tool_result","content":"     1→\"\"\"\n     2→Core Skill Tool Handlers - 全局工具执行器\n     3→\n     4→所有 Skill 共享的工具执行器。\n     5→使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。\n     6→\"\"\"\n     7→import logging\n     8→from datetime import datetime\n     9→from typing import Dict, Any, List\n    10→\n    11→from services.agent.tool_registry import tool_handler, ToolContext\n    12→\n    13→logger = logging.getLogger(__name__)\n    14→\n    15→\n    16→# ═══════════════════════════════════════════════════════════════════════════\n    17→# 搜索型工具\n    18→# ═══════════════════════════════════════════════════════════════════════════\n    19→\n    20→@tool_handler(\"search_db\")\n    21→async def execute_search_db(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    22→    \"\"\"从数据库检索知识或案例\"\"\"\n    23→    from services.knowledge.repository import get_knowledge_repository\n    24→\n    25→    table = args.get(\"table\", \"knowledge_chunks\")\n    26→    query = args.get(\"query\", \"\")\n    27→    filters = args.get(\"filters\", {})\n    28→    top_k = args.get(\"top_k\", 5)\n    29→\n    30→    # 自动添加当前 skill_id 到 filters\n    31→    if context.skill_id and \"skill_id\" not in filters:\n    32→        filters[\"skill_id\"] = context.skill_id\n    33→    if context.scenario_id and \"scenario_id\" not in filters:\n    34→        filters[\"scenario_id\"] = context.scenario_id\n    35→\n    36→    try:\n    37→        repo = get_knowledge_repository()\n    38→        results = await repo.search_db(\n    39→            table=table,\n    40→            query=query,\n    41→            filters=filters,\n    42→            top_k=top_k\n    43→        )\n    44→\n    45→        return {\n    46→            \"status\": \"success\",\n    47→            \"table\": table,\n    48→            \"query\": query,\n    49→            \"count\": len(results),\n    50→            \"results\": results\n    51→        }\n    52→    except Exception as e:\n    53→        logger.error(f\"search_db failed: {e}\")\n    54→        return {\n    55→            \"status\": \"error\",\n    56→            \"error\": str(e),\n    57→            \"results\": []\n    58→        }\n    59→\n    60→\n    61→# ═══════════════════════════════════════════════════════════════════════════\n    62→# 收集型工具\n    63→# ═══════════════════════════════════════════════════════════════════════════\n    64→\n    65→@tool_handler(\"ask_user_question\")\n    66→async def execute_ask_user_question(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    67→    \"\"\"主动向用户提问\"\"\"\n    68→    question = args.get(\"question\", \"\")\n    69→    options = args.get(\"options\", [])\n    70→\n    71→    return {\n    72→        \"status\": \"asking\",\n    73→        \"cardType\": \"question_card\",\n    74→        \"question\": question,\n    75→        \"options\": options[:4] if options else [],  # 最多4个选项\n    76→    }\n    77→\n    78→\n    79→@tool_handler(\"request_info\")\n    80→async def execute_request_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    81→    \"\"\"向用户请求信息\"\"\"\n    82→    info_type = args.get(\"info_type\", \"birth\")\n    83→    question = args.get(\"question\")\n    84→\n    85→    fields_map = {\n    86→        \"birth\": [\n    87→            {\"id\": \"birthDate\", \"label\": \"出生日期\", \"type\": \"date\", \"required\": True, \"placeholder\": \"\"},\n    88→            {\"id\": \"birthTime\", \"label\": \"出生时间\", \"type\": \"time\", \"required\": True, \"placeholder\": \"\"},\n    89→            {\"id\": \"birthPlace\", \"label\": \"出生地点\", \"type\": \"text\", \"required\": False, \"placeholder\": \"城市名\"},\n    90→            {\"id\": \"gender\", \"label\": \"性别\", \"type\": \"select\", \"required\": True, \"options\": [\n    91→                {\"value\": \"male\", \"label\": \"男\"},\n    92→                {\"value\": \"female\", \"label\": \"女\"},\n    93→            ]},\n    94→        ],\n    95→        \"context\": [\n    96→            {\"id\": \"situation\", \"label\": \"当前情况\", \"type\": \"textarea\", \"required\": True, \"placeholder\": \"描述你目前面临的情况\"},\n    97→        ],\n    98→        \"goals\": [\n    99→            {\"id\": \"goals\", \"label\": \"你的目标\", \"type\": \"textarea\", \"required\": True, \"placeholder\": \"你想达成什么\"},\n   100→        ],\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a37fab4b-b373-4981-af87-daae2293df02","timestamp":"2026-01-18T03:42:54.668Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py","content":"\"\"\"\nCore Skill Tool Handlers - 全局工具执行器\n\n所有 Skill 共享的工具执行器。\n使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。\n\"\"\"\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any, List\n\nfrom services.agent.tool_registry import tool_handler, ToolContext\n\nlogger = logging.getLogger(__name__)\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 搜索型工具\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"search_db\")\nasync def execute_search_db(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"从数据库检索知识或案例\"\"\"\n    from services.knowledge.repository import get_knowledge_repository\n\n    table = args.get(\"table\", \"knowledge_chunks\")\n    query = args.get(\"query\", \"\")\n    filters = args.get(\"filters\", {})\n    top_k = args.get(\"top_k\", 5)\n\n    # 自动添加当前 skill_id 到 filters\n    if context.skill_id and \"skill_id\" not in filters:\n        filters[\"skill_id\"] = context.skill_id\n    if context.scenario_id and \"scenario_id\" not in filters:\n        filters[\"scenario_id\"] = context.scenario_id\n\n    try:\n        repo = get_knowledge_repository()\n        results = await repo.search_db(\n            table=table,\n            query=query,\n            filters=filters,\n            top_k=top_k\n        )\n\n        return {\n            \"status\": \"success\",\n            \"table\": table,\n            \"query\": query,\n            \"count\": len(results),\n            \"results\": results\n        }\n    except Exception as e:\n        logger.error(f\"search_db failed: {e}\")\n        return {\n            \"status\": \"error\",\n            \"error\": str(e),\n            \"results\": []\n        }\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 收集型工具\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"ask_user_question\")\nasync def execute_ask_user_question(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"主动向用户提问\"\"\"\n    question = args.get(\"question\", \"\")\n    options = args.get(\"options\", [])\n\n    return {\n        \"status\": \"asking\",\n        \"cardType\": \"question_card\",\n        \"question\": question,\n        \"options\": options[:4] if options else [],  # 最多4个选项\n    }\n\n\n@tool_handler(\"request_info\")\nasync def execute_request_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"向用户请求信息\"\"\"\n    info_type = args.get(\"info_type\", \"birth\")\n    question = args.get(\"question\")\n\n    fields_map = {\n        \"birth\": [\n            {\"id\": \"birthDate\", \"label\": \"出生日期\", \"type\": \"date\", \"required\": True, \"placeholder\": \"\"},\n            {\"id\": \"birthTime\", \"label\": \"出生时间\", \"type\": \"time\", \"required\": True, \"placeholder\": \"\"},\n            {\"id\": \"birthPlace\", \"label\": \"出生地点\", \"type\": \"text\", \"required\": False, \"placeholder\": \"城市名\"},\n            {\"id\": \"gender\", \"label\": \"性别\", \"type\": \"select\", \"required\": True, \"options\": [\n                {\"value\": \"male\", \"label\": \"男\"},\n                {\"value\": \"female\", \"label\": \"女\"},\n            ]},\n        ],\n        \"context\": [\n            {\"id\": \"situation\", \"label\": \"当前情况\", \"type\": \"textarea\", \"required\": True, \"placeholder\": \"描述你目前面临的情况\"},\n        ],\n        \"goals\": [\n            {\"id\": \"goals\", \"label\": \"你的目标\", \"type\": \"textarea\", \"required\": True, \"placeholder\": \"你想达成什么\"},\n        ],","numLines":100,"startLine":1,"totalLines":389}},"sourceToolAssistantUUID":"df78df39-a5df-44b6-8a17-282f8c9eb249"}
{"parentUuid":"5325967c-ec15-439d-a50d-f3a89ae0eadc","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RRJtARf6yioZUrzojW6Rj1","type":"tool_result","content":"     1→\"\"\"\n     2→Bazi Skill Tool Handlers - 八字工具执行器\n     3→\n     4→v2.0 更新：使用 BaziComputer 替代旧的 fortune 服务\n     5→\n     6→使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。\n     7→\"\"\"\n     8→import logging\n     9→from datetime import datetime\n    10→from typing import Dict, Any, Optional\n    11→from uuid import UUID\n    12→\n    13→from services.agent.tool_registry import tool_handler, ToolContext\n    14→from skills.bazi.services import BaziComputer\n    15→\n    16→logger = logging.getLogger(__name__)\n    17→\n    18→# 单例 BaziComputer\n    19→_bazi_computer: Optional[BaziComputer] = None\n    20→\n    21→\n    22→def get_bazi_computer() -> BaziComputer:\n    23→    global _bazi_computer\n    24→    if _bazi_computer is None:\n    25→        _bazi_computer = BaziComputer()\n    26→    return _bazi_computer\n    27→\n    28→\n    29→@tool_handler(\"collect_bazi_info\")\n    30→async def execute_collect_bazi_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    31→    \"\"\"收集用户出生信息\"\"\"\n    32→    include_question = args.get(\"include_question\", True)\n    33→\n    34→    fields = [\n    35→        {\"id\": \"birthDate\", \"label\": \"出生日期\", \"type\": \"date\", \"required\": True, \"placeholder\": \"\"},\n    36→        {\"id\": \"birthTime\", \"label\": \"出生时间\", \"type\": \"time\", \"required\": True, \"placeholder\": \"\"},\n    37→        {\"id\": \"birthPlace\", \"label\": \"出生地点\", \"type\": \"text\", \"required\": False, \"placeholder\": \"城市名（可选）\"},\n    38→        {\"id\": \"gender\", \"label\": \"性别\", \"type\": \"select\", \"required\": True, \"options\": [\n    39→            {\"value\": \"male\", \"label\": \"男\"},\n    40→            {\"value\": \"female\", \"label\": \"女\"},\n    41→        ]},\n    42→    ]\n    43→\n    44→    if include_question:\n    45→        fields.append({\n    46→            \"id\": \"question\",\n    47→            \"label\": \"你想了解什么\",\n    48→            \"type\": \"textarea\",\n    49→            \"required\": False,\n    50→            \"placeholder\": \"描述你当前的困惑或想了解的问题...\"\n    51→        })\n    52→\n    53→    return {\n    54→        \"status\": \"collecting\",\n    55→        \"cardType\": \"collect_form\",\n    56→        \"formType\": \"birth_info\",\n    57→        \"title\": \"请填写出生信息\",\n    58→        \"description\": \"准确的出生时间有助于更精确的命盘分析\",\n    59→        \"fields\": fields,\n    60→    }\n    61→\n    62→\n    63→@tool_handler(\"calculate_bazi\")\n    64→async def execute_calculate_bazi(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    65→    \"\"\"计算八字命盘\"\"\"\n    66→    from skills.bazi.services import calculate_bazi\n    67→\n    68→    profile = context.profile or {}\n    69→    birth_info = profile.get(\"birth_info\", {})\n    70→\n    71→    # 从 args 或 profile 获取出生信息\n    72→    birth_date = (args.get(\"birth_date\") or args.get(\"birthDate\") or\n    73→                  birth_info.get(\"date\") or birth_info.get(\"birth_date\"))\n    74→    birth_time = (args.get(\"birth_time\") or args.get(\"birthTime\") or\n    75→                  birth_info.get(\"time\") or birth_info.get(\"birth_time\") or \"12:00\")\n    76→    gender = args.get(\"gender\") or birth_info.get(\"gender\") or \"unknown\"\n    77→\n    78→    if not birth_date:\n    79→        return {\n    80→            \"status\": \"error\",\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1be6d94f-c70c-48aa-916a-4b3a23d89610","timestamp":"2026-01-18T03:42:54.668Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/handlers.py","content":"\"\"\"\nBazi Skill Tool Handlers - 八字工具执行器\n\nv2.0 更新：使用 BaziComputer 替代旧的 fortune 服务\n\n使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。\n\"\"\"\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\nfrom uuid import UUID\n\nfrom services.agent.tool_registry import tool_handler, ToolContext\nfrom skills.bazi.services import BaziComputer\n\nlogger = logging.getLogger(__name__)\n\n# 单例 BaziComputer\n_bazi_computer: Optional[BaziComputer] = None\n\n\ndef get_bazi_computer() -> BaziComputer:\n    global _bazi_computer\n    if _bazi_computer is None:\n        _bazi_computer = BaziComputer()\n    return _bazi_computer\n\n\n@tool_handler(\"collect_bazi_info\")\nasync def execute_collect_bazi_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"收集用户出生信息\"\"\"\n    include_question = args.get(\"include_question\", True)\n\n    fields = [\n        {\"id\": \"birthDate\", \"label\": \"出生日期\", \"type\": \"date\", \"required\": True, \"placeholder\": \"\"},\n        {\"id\": \"birthTime\", \"label\": \"出生时间\", \"type\": \"time\", \"required\": True, \"placeholder\": \"\"},\n        {\"id\": \"birthPlace\", \"label\": \"出生地点\", \"type\": \"text\", \"required\": False, \"placeholder\": \"城市名（可选）\"},\n        {\"id\": \"gender\", \"label\": \"性别\", \"type\": \"select\", \"required\": True, \"options\": [\n            {\"value\": \"male\", \"label\": \"男\"},\n            {\"value\": \"female\", \"label\": \"女\"},\n        ]},\n    ]\n\n    if include_question:\n        fields.append({\n            \"id\": \"question\",\n            \"label\": \"你想了解什么\",\n            \"type\": \"textarea\",\n            \"required\": False,\n            \"placeholder\": \"描述你当前的困惑或想了解的问题...\"\n        })\n\n    return {\n        \"status\": \"collecting\",\n        \"cardType\": \"collect_form\",\n        \"formType\": \"birth_info\",\n        \"title\": \"请填写出生信息\",\n        \"description\": \"准确的出生时间有助于更精确的命盘分析\",\n        \"fields\": fields,\n    }\n\n\n@tool_handler(\"calculate_bazi\")\nasync def execute_calculate_bazi(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"计算八字命盘\"\"\"\n    from skills.bazi.services import calculate_bazi\n\n    profile = context.profile or {}\n    birth_info = profile.get(\"birth_info\", {})\n\n    # 从 args 或 profile 获取出生信息\n    birth_date = (args.get(\"birth_date\") or args.get(\"birthDate\") or\n                  birth_info.get(\"date\") or birth_info.get(\"birth_date\"))\n    birth_time = (args.get(\"birth_time\") or args.get(\"birthTime\") or\n                  birth_info.get(\"time\") or birth_info.get(\"birth_time\") or \"12:00\")\n    gender = args.get(\"gender\") or birth_info.get(\"gender\") or \"unknown\"\n\n    if not birth_date:\n        return {\n            \"status\": \"error\",","numLines":80,"startLine":1,"totalLines":253}},"sourceToolAssistantUUID":"5325967c-ec15-439d-a50d-f3a89ae0eadc"}
{"parentUuid":"1be6d94f-c70c-48aa-916a-4b3a23d89610","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"c8c22c05-8208-49a6-9c7a-6d46e9ef5f13","version":"2.1.12","gitBranch":"master","agentId":"ab26d38","slug":"idempotent-baking-quill","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012pEPDv1odUA63SEtJG9WQd","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I now have a comprehensive understanding of the VibeLife agent architecture. Let me create a detailed summary report.\n\n## VibeLife Agent Architecture Summary\n\nBased on my exploration of `/home/aiscend/work/vibelife/apps/api/services/agent/`, here's a comprehensive overview of how the agent system works:\n\n---\n\n### 1. CORE AGENT SYSTEM (core.py)\n\n**CoreAgent v6** is the central orchestrator using a 7-phase SOP (Standard Operating Procedure) with two distinct execution patterns:\n\n- **Forced Phases (Code-Controlled)**:\n  - **P1 Collect**: Validates and collects required information (e.g., birth data)\n  - **P2 Compute**: Runs calculations to generate necessary data (charts, readings)\n\n- **Free Phases (LLM-Controlled)**:\n  - **P3-P7**: LLM autonomously decides when to:\n    - Scan (identify patterns)\n    - Proactively ask questions\n    - Analyze data\n    - Output results via tools\n    - Discuss/answer follow-ups\n\n**Key Flow**:\n```\nUser Message → Skill/Scenario Routing → SOP Phase Check → \nBuild System Prompt → LLM Loop (thinking → tool calls → tool execution) → \nStream Events to Frontend\n```\n\n**Tool Execution Architecture**:\n- CoreAgent calls `_execute_tool()` which delegates to `ToolRegistry.execute()`\n- Special handling for `use_skill` (routing tool) that activates skill/scenario\n- Creates `ToolContext` containing user profile, skill data, conversation state\n- Returns tool results to LLM for next iteration\n\n---\n\n### 2. SKILL LOADING SYSTEM (skill_loader.py)\n\n**Skills define themselves** through a two-tier file structure:\n\n**Tier 1: SKILL.md** (Skill Core Definition)\n- Frontmatter metadata: `id`, `name`, `triggers`, `default_scenario`, `global_tools`\n- Expert persona section\n- Scenario directory (entry/standard/professional levels)\n- Ethics boundaries\n- Tool requirements list\n\n**Tier 2: scenarios/*.md** (MiniSkill Implementations)\n- Each scenario has its own SOP configuration\n- Knowledge retrieval settings\n- Output templates\n- Trigger conditions\n- Prerequisites\n\n**Skill Loading Process**:\n```python\nload_skill(\"bazi\") → Reads skills/bazi/SKILL.md\n                  → Caches SkillConfig with scenarios, tools, triggers\n                  \nload_scenario(\"bazi\", \"basic_reading\") \n                  → Reads skills/bazi/scenarios/basic_reading.md\n                  → Parses SOP phases, knowledge config\n```\n\n**System Prompt Construction**:\n```\nExpert Persona + Scenario Description + SOP Phases +\nEthics Boundaries + User Context + Skill Data + Knowledge + Cases\n```\n\n---\n\n### 3. UNIFIED TOOL REGISTRY & SCHEMA (tool_registry.py, tool_schema.py)\n\n**Problem Solved**: Eliminates hardcoded tool lists and if-elif dispatch chains.\n\n**Single Source of Truth**: YAML-based tool definitions\n- **Location**: `skills/{skill_id}/tools/tools.yaml`\n- **Organization**: Tools categorized as `collect`, `compute`, `display`, `search`\n- **Format**: OpenAI-compatible function definitions with metadata\n\n**Tool Lifecycle**:\n\n1. **Definition** (YAML):\n   ```yaml\n   compute:\n     - name: calculate_bazi\n       description: \"Calculate bazi chart\"\n       parameters:\n         - name: birth_date\n           type: string\n           required: true\n   ```\n\n2. **Registration** (Python handler):\n   ```python\n   @tool_handler(\"calculate_bazi\")\n   async def execute_calculate_bazi(args: Dict, context: ToolContext) -> Dict:\n       return {\"chart\": ...}\n   ```\n\n3. **Discovery & Loading**:\n   - `ToolRegistry.initialize()` loads global tools from `core/tools/tools.yaml`\n   - `ToolRegistry.load_skill(skill_id)` dynamically loads skill-specific tools\n   - Auto-discovers all handlers modules via importlib\n\n4. **Execution**:\n   ```python\n   tools = ToolRegistry.get_tools_for_skill(\"bazi\")  # Returns OpenAI format\n   result = await ToolRegistry.execute(tool_name, args, context)\n   ```\n\n**Tool Types**:\n- **Collect**: Forms to gather user info (inherit fields schema)\n- **Compute**: Calculations (bazi charts, readings)\n- **Display**: Show results as cards (bazi_chart, report, insight)\n- **Search**: Database queries for knowledge/cases\n\n**ToolContext** carries:\n- `user_id`, `user_tier`, `profile`, `skill_data`\n- `skill_id`, `scenario_id` (current execution context)\n- `conversation_id` (for tracking)\n\n---\n\n### 4. SOP ENGINE (sop_engine.py)\n\n**State Machine** for controlling execution flow:\n\n```\nSOPPhase: COLLECT → COMPUTE → SCAN → PROACTIVE → ANALYZE → OUTPUT → DISCUSS\nSOPAction: NEED_INFO | NEED_COMPUTE | READY_FOR_LLM | COMPLETED\n```\n\n**Mandatory Checks** (before LLM involvement):\n- Does skill need birth info? Check profile\n- Does skill need computation? Check skill_data for existing chart\n- Return `NEED_INFO` or `NEED_COMPUTE` if missing\n\n**LLM Phase Determination**:\n- If user asks follow-up questions → `DISCUSS`\n- If chart exists → `ANALYZE`\n- Otherwise → `SCAN`\n\n---\n\n### 5. TOOL INTEGRATION EXAMPLES\n\n**Global Tools** (skills/core/tools/):\n- `search_db`: Query knowledge_chunks or cases\n- `ask_user_question`: Present multiple choice\n- `request_info`: Collect structured data (birth, context, goals)\n- `show_service_menu`, `show_skill_services`: Catalog display\n- `show_insight`, `show_report`: Result presentation\n\n**Skill-Specific Tools** (skills/bazi/tools/):\n- `collect_bazi_info`: Birth date/time form with card_type: bazi_form\n- `calculate_bazi`: Compute chart using BaziComputer service\n- `show_bazi_chart`: Display pillars, stems/branches, relationships\n- `show_bazi_fortune`: Display 10-year cycles and yearly predictions\n- `show_bazi_kline`: K-line visualization of fortune trends\n\n**Handler Pattern**:\n```python\n@tool_handler(\"show_bazi_chart\")\nasync def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:\n    # Access user data via context\n    skill_data = context.skill_data.get(context.skill_id, {})\n    \n    # Call service layer\n    computer = get_bazi_computer()\n    chart = computer.get_chart(skill_data)\n    \n    # Return structured result\n    return {\n        \"status\": \"success\",\n        \"cardType\": \"bazi_chart\",\n        \"data\": chart\n    }\n```\n\n---\n\n### 6. SKILL ROUTING & SELECTION\n\n**Dynamic Routing** (build_use_skill_tool):\n- LLM chooses skill, scenario, confidence level, topic\n- Frontmatter defines trigger words for each skill\n- Scenarios listed in SKILL.md table provide options\n- Low confidence triggers confirmation prompt\n- Missing birth info triggers `request_info` tool\n\n---\n\n### 7. STREAM ADAPTATION (stream_adapter.py)\n\n**Protocol-Agnostic Output**:\n- CoreAgent emits internal `AgentEvent` objects\n- Adapters transform to frontend protocols:\n  - **AI SDK 6**: SSE with text-delta, tool-input, tool-output\n  - **OpenAI**: Standard chat completions format\n  - **Text**: Plain streaming\n  - **Legacy SSE**: AI SDK 4.x compatibility\n\n**Example Event Flow**:\n```\nAgentEvent(type=\"content\", data={\"content\": \"分析中...\"})\n→ AISDKv6Adapter\n→ {\"type\": \"text-delta\", \"delta\": \"分析中...\", ...}\n→ Frontend renders real-time text\n```\n\n---\n\n### KEY ARCHITECTURAL INSIGHTS\n\n1. **Separation of Concerns**:\n   - SKILL.md = metadata + expert guidance\n   - tools.yaml = interface definitions\n   - handlers.py = execution logic\n   - Services = business logic (BaziComputer, KnowledgeRepository)\n\n2. **Extensibility**:\n   - Add new skill: Create skills/{skill_id}/ with SKILL.md + scenarios/ + tools/\n   - Add new tool: 1) Define in tools.yaml, 2) Register handler with @tool_handler\n   - No changes to CoreAgent needed\n\n3. **LLM-First Design**:\n   - Agent doesn't hardcode routing logic\n   - LLM reads skill triggers and scenarios in system prompt\n   - LLM autonomously selects best skill/scenario\n   - Confidence levels allow graceful degradation\n\n4. **Performance Optimizations**:\n   - LRU caching for skill/scenario loading\n   - Tool definition caching\n   - Lazy handler module imports\n   - Knowledge retrieval (RAG) only when LLM requests\n\n5. **Data Flow**:\n   ```\n   Profile (birth_info, identity_prism, extracted)\n   Skill Data (commands executed: bazi.chart, zodiac.chart)\n   → System Prompt enrichment\n   → LLM context\n   → Tool decisions\n   → Result cards\n   ```\n\n---\n\n### CURRENT TOOL IMPLEMENTATION STATUS\n\n**Implemented Tools**:\n- Core (6): search_db, ask_user_question, request_info, show_service_menu, show_skill_services, show_insight\n- Bazi (5): collect_bazi_info, calculate_bazi, show_bazi_chart, show_bazi_fortune, show_bazi_kline\n- Zodiac, Tarot, Career, Vibe_ID: Similar patterns with domain-specific handlers\n\n**Pattern**: Every tool follows the `@tool_handler` decorator pattern with async execution, error handling, and structured response format for card rendering."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5115,"cache_read_input_tokens":66128,"cache_creation":{"ephemeral_5m_input_tokens":5115,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXE9ogzBkWB3yrqkn1baV","type":"assistant","uuid":"5050d9a3-f64e-44b0-8e23-11cc0b3dd797","timestamp":"2026-01-18T03:43:21.171Z"}
