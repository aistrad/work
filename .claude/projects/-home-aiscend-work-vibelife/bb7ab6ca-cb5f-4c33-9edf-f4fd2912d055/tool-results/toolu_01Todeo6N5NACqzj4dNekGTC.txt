     1→"""
     2→Notification API Routes
     3→"""
     4→from typing import Optional
     5→from uuid import UUID
     6→from fastapi import APIRouter, Depends, HTTPException, Query
     7→
     8→from stores.db import get_db
     9→from services.reminder.notification import NotificationService
    10→from services.identity import get_current_user, get_optional_user, CurrentUser
    11→
    12→router = APIRouter(prefix="/notifications", tags=["notifications"])
    13→
    14→
    15→def get_notification_service():
    16→    return NotificationService()
    17→
    18→
    19→@router.get("")
    20→async def get_notifications(
    21→    user_id: Optional[UUID] = Query(None, description="User ID (optional if authenticated)"),
    22→    limit: int = Query(50, ge=1, le=100),
    23→    svc: NotificationService = Depends(get_notification_service),
    24→    current_user: Optional[CurrentUser] = Depends(get_optional_user),
    25→):
    26→    """Get user notifications. Uses authenticated user if user_id not provided."""
    27→    # 优先使用认证用户的ID
    28→    effective_user_id = user_id
    29→    if not effective_user_id and current_user:
    30→        effective_user_id = current_user.user_id
    31→
    32→    if not effective_user_id:
    33→        raise HTTPException(status_code=401, detail="Authentication required")
    34→
    35→    result = await svc.get_all(effective_user_id, limit)
    36→    # 确保返回格式与前端期望一致
    37→    if isinstance(result, dict):
    38→        return result
    39→    return {"items": result, "unread_count": len([n for n in result if not n.get("is_read", True)])}
    40→
    41→
    42→@router.get("/unread")
    43→async def get_unread_notifications(
    44→    user_id: Optional[UUID] = Query(None),
    45→    limit: int = Query(20, ge=1, le=100),
    46→    svc: NotificationService = Depends(get_notification_service),
    47→    current_user: Optional[CurrentUser] = Depends(get_optional_user),
    48→):
    49→    """Get unread notifications"""
    50→    effective_user_id = user_id
    51→    if not effective_user_id and current_user:
    52→        effective_user_id = current_user.user_id
    53→
    54→    if not effective_user_id:
    55→        raise HTTPException(status_code=401, detail="Authentication required")
    56→
    57→    return await svc.get_unread(effective_user_id, limit)
    58→
    59→
    60→@router.post("/{notification_id}/read")
    61→async def mark_notification_read(
    62→    notification_id: UUID,
    63→    svc: NotificationService = Depends(get_notification_service),
    64→):
    65→    """Mark notification as read"""
    66→    success = await svc.mark_read(notification_id)
    67→    if not success:
    68→        raise HTTPException(status_code=404, detail="Notification not found")
    69→    return {"success": True}
    70→
    71→
    72→@router.get("/daily")
    73→async def get_today_daily(
    74→    user_id: Optional[UUID] = Query(None),
    75→    svc: NotificationService = Depends(get_notification_service),
    76→    current_user: Optional[CurrentUser] = Depends(get_optional_user),
    77→):
    78→    """Get today's daily fortune"""
    79→    effective_user_id = user_id
    80→    if not effective_user_id and current_user:
    81→        effective_user_id = current_user.user_id
    82→
    83→    if not effective_user_id:
    84→        raise HTTPException(status_code=401, detail="Authentication required")
    85→
    86→    result = await svc.get_today_daily(effective_user_id)
    87→    if not result:
    88→        raise HTTPException(status_code=404, detail="No daily fortune for today")
    89→    return result
    90→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
