     1→"""
     2→Knowledge Builder API Routes
     3→
     4→REST API endpoints for knowledge building pipeline.
     5→"""
     6→from fastapi import APIRouter, HTTPException, BackgroundTasks
     7→from pydantic import BaseModel
     8→from typing import Optional, List
     9→import logging
    10→
    11→logger = logging.getLogger(__name__)
    12→
    13→router = APIRouter(prefix="/api/knowledge", tags=["knowledge"])
    14→
    15→
    16→# ─────────────────────────────────────────────────────────────────
    17→# Request/Response Models
    18→# ─────────────────────────────────────────────────────────────────
    19→
    20→class BuildRequest(BaseModel):
    21→    skill_id: str
    22→    stages: str = "all"  # all, 0, 1-3, 4a, 4b, 5, 6
    23→    limit: int = 100
    24→
    25→
    26→class BuildResponse(BaseModel):
    27→    status: str
    28→    message: str
    29→    task_id: Optional[str] = None
    30→
    31→
    32→class CaseExtractRequest(BaseModel):
    33→    skill_id: str
    34→    limit: int = 100
    35→
    36→
    37→class QualityCheckRequest(BaseModel):
    38→    skill_id: str
    39→    save_report: bool = True
    40→
    41→
    42→class QualityReportResponse(BaseModel):
    43→    skill_id: str
    44→    overall_score: float
    45→    coverage_score: float
    46→    distribution_score: float
    47→    retrieval_score: float
    48→    warnings: List[str]
    49→    recommendations: List[str]
    50→
    51→
    52→# ─────────────────────────────────────────────────────────────────
    53→# Background Task Storage
    54→# ─────────────────────────────────────────────────────────────────
    55→
    56→_build_tasks = {}
    57→
    58→
    59→async def _run_build_pipeline(task_id: str, skill_id: str, stages: str, limit: int):
    60→    """Background task for running build pipeline"""
    61→    from scripts.build_knowledge import KnowledgeBuilder
    62→
    63→    try:
    64→        _build_tasks[task_id] = {"status": "running", "skill_id": skill_id}
    65→
    66→        builder = KnowledgeBuilder(skill_id)
    67→
    68→        if stages == "all":
    69→            results = await builder.run_all()
    70→        else:
    71→            results = {}
    72→            stage_list = [s.strip() for s in stages.split(",")]
    73→
    74→            for stage in stage_list:
    75→                if stage == "0":
    76→                    results["stage_0"] = await builder.run_stage_0()
    77→                elif stage in ("1", "2", "3", "1-3"):
    78→                    results["stages_1_3"] = await builder.run_stages_1_2_3()
    79→                elif stage == "4a":
    80→                    results["stage_4a"] = await builder.run_stage_4a(limit)
    81→                elif stage == "4b":
    82→                    results["stage_4b"] = await builder.run_stage_4b(limit)
    83→                elif stage == "5":
    84→                    results["stage_5"] = await builder.run_stage_5(interactive=False)
    85→                elif stage == "6":
    86→                    results["stage_6"] = await builder.run_stage_6()
    87→
    88→        _build_tasks[task_id] = {
    89→            "status": "completed",
    90→            "skill_id": skill_id,
    91→            "results": results,
    92→        }
    93→
    94→    except Exception as e:
    95→        logger.error(f"Build pipeline failed: {e}")
    96→        _build_tasks[task_id] = {
    97→            "status": "failed",
    98→            "skill_id": skill_id,
    99→            "error": str(e),
   100→        }
   101→
   102→
   103→# ─────────────────────────────────────────────────────────────────
   104→# API Endpoints
   105→# ─────────────────────────────────────────────────────────────────
   106→
   107→@router.post("/build", response_model=BuildResponse)
   108→async def start_build(request: BuildRequest, background_tasks: BackgroundTasks):
   109→    """
   110→    Start knowledge building pipeline.
   111→
   112→    Runs in background and returns task ID for status checking.
   113→    """
   114→    import uuid
   115→
   116→    task_id = f"build_{request.skill_id}_{uuid.uuid4().hex[:8]}"
   117→
   118→    background_tasks.add_task(
   119→        _run_build_pipeline,
   120→        task_id,
   121→        request.skill_id,
   122→        request.stages,
   123→        request.limit,
   124→    )
   125→
   126→    return BuildResponse(
   127→        status="started",
   128→        message=f"Build pipeline started for {request.skill_id}",
   129→        task_id=task_id,
   130→    )
   131→
   132→
   133→@router.get("/build/{task_id}")
   134→async def get_build_status(task_id: str):
   135→    """Get status of a build task"""
   136→    if task_id not in _build_tasks:
   137→        raise HTTPException(status_code=404, detail="Task not found")
   138→
   139→    return _build_tasks[task_id]
   140→
   141→
   142→@router.post("/cases/extract")
   143→async def extract_cases(request: CaseExtractRequest):
   144→    """
   145→    Extract cases from knowledge chunks.
   146→    """
   147→    from workers.case_extractor import CaseExtractor
   148→    from stores.db import get_connection
   149→
   150→    async with get_connection() as conn:
   151→        rows = await conn.fetch(
   152→            """
   153→            SELECT id, chunk_text as content
   154→            FROM knowledge_chunks
   155→            WHERE skill_id = $1
   156→            LIMIT $2
   157→            """,
   158→            request.skill_id,
   159→            request.limit,
   160→        )
   161→        chunks = [dict(row) for row in rows]
   162→
   163→    if not chunks:
   164→        return {"status": "no_chunks", "extracted": 0, "saved": 0}
   165→
   166→    extractor = CaseExtractor()
   167→    cases = await extractor.extract_from_chunks(chunks, request.skill_id)
   168→    saved = await extractor.save_cases(cases)
   169→
   170→    return {
   171→        "status": "completed",
   172→        "extracted": len(cases),
   173→        "saved": saved,
   174→    }
   175→
   176→
   177→@router.post("/quality/check", response_model=QualityReportResponse)
   178→async def run_quality_check(request: QualityCheckRequest):
   179→    """
   180→    Run quality check and generate report.
   181→    """
   182→    from workers.quality_checker import QualityChecker
   183→
   184→    checker = QualityChecker()
   185→    report = await checker.generate_report(request.skill_id)
   186→
   187→    if request.save_report:
   188→        await checker.save_report(report)
   189→
   190→    return QualityReportResponse(
   191→        skill_id=report.skill_id,
   192→        overall_score=report.overall_score,
   193→        coverage_score=report.coverage.coverage_score,
   194→        distribution_score=report.distribution.balance_score,
   195→        retrieval_score=report.retrieval.retrieval_score,
   196→        warnings=report.warnings,
   197→        recommendations=report.recommendations,
   198→    )
   199→
   200→
   201→@router.get("/stats/{skill_id}")
   202→async def get_skill_stats(skill_id: str):
   203→    """
   204→    Get statistics for a skill's knowledge base.
   205→    """
   206→    from stores.db import get_connection
   207→    from pathlib import Path
   208→
   209→    async with get_connection() as conn:
   210→        # Chunk stats
   211→        chunk_count = await conn.fetchval(
   212→            "SELECT COUNT(*) FROM knowledge_chunks WHERE skill_id = $1",
   213→            skill_id,
   214→        )
   215→
   216→        # Case stats (approved only)
   217→        case_count = await conn.fetchval(
   218→            "SELECT COUNT(*) FROM cases WHERE skill_id = $1 AND status = 'approved'",
   219→            skill_id,
   220→        )
   221→
   222→        # Pending cases
   223→        pending_cases = await conn.fetchval(
   224→            "SELECT COUNT(*) FROM cases WHERE skill_id = $1 AND status = 'pending'",
   225→            skill_id,
   226→        )
   227→
   228→    # Scenario stats from file system
   229→    scenarios_dir = Path(__file__).parent.parent / "skills" / skill_id / "scenarios"
   230→    scenario_count = len(list(scenarios_dir.glob("*.md"))) if scenarios_dir.exists() else 0
   231→
   232→    return {
   233→        "skill_id": skill_id,
   234→        "chunks": chunk_count or 0,
   235→        "cases_approved": case_count or 0,
   236→        "cases_pending": pending_cases or 0,
   237→        "scenarios": scenario_count,
   238→    }
   239→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
