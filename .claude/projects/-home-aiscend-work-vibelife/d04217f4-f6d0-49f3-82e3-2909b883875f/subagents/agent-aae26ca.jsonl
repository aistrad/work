{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":"请分析 /home/aiscend/work/vibelife/apps/api/services/agent/core.py 文件，对比 Claude Agent SDK Python 的标准实现：\n\n1. 核心 Agent 类的实现是否符合 SDK 规范？\n2. Agentic Loop（run 方法）是否遵循最佳实践？\n3. Tool Use Pattern 是否正确？\n4. 与 Agent SDK 标准实现的主要差异是什么？\n\n请重点关注：\n- 消息历史管理\n- 工具执行流程\n- 状态管理\n- 错误处理\n\n输出对比分析报告。"},"uuid":"bcf05eb0-34f0-49ad-ac2e-7856c201a126","timestamp":"2026-01-20T17:17:02.815Z"}
{"parentUuid":"bcf05eb0-34f0-49ad-ac2e-7856c201a126","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_011ChP4erV4Fuuo8P1eaN7Go","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to analyze a specific file and compare it against the official Python Agent SDK implementation. They want to know:\n\n1. Whether the core Agent class implementation follows SDK specifications\n2. Whether the Agentic Loop (run method) follows best practices\n3. Whether Tool Use patterns are correct\n4. What are the main differences from standard Agent SDK implementation\n\nThey want me to focus on:\n- Message history management\n- Tool execution flow\n- State management\n- Error handling\n\nFirst, I should:\n1. Read the file they mentioned\n2. Fetch the official Python Agent SDK documentation\n3. Compare the implementation against official patterns\n4. Provide a comprehensive analysis report\n\nLet me start by reading the file and fetching the SDK documentation.","signature":"EqIHCkgICxACGAIqQFO74J0nZy7OK88TVwWtbqN0q3QBZ114ejAtgbdSSFmhr78ygNa3Y0wBxqr6Ca+ZNTS1HmxKj6yazRkU5tJO2YMSDCH+g8JT4I3Ly5OrAxoMbS8Zkul1k4RVI05+IjBwCh70HQ0zFKxST281svVwhXGDqFL1sz7+CPXQKYXQ9r7Tgkob6B9VupXhfzvjWN0qhwaUbP8UZkOVkObOxHEMVMy6d2v5nZvuKjIs0KI8YtCqE9PysfTTd7s09gjJo/BHMKo1eduDSbuzpliWTWwcMasIbUMCwtaOYmF3qFH4ImvL3HILvJTzIrngwgnxncJ2IzUKm2S+/fbOpjHYBdW2hSdIbbwYFQCMQVC7E1QvsSfiA/J7uOBpU9sz7xieZTJM/Vm7S8oUONqutxOe2cnrEesdmHnX1WBJwmKn0Ox9cQ/2ZyxESvUiaPc0RFo2w20Tbc3hpxT60zog01MWSeq4kHT5Fjk0U4LTXb7Cj/diHyBPR3+/O8BbnQInhMbURRt9AfjOZ1spqmceb85OHxA2qTTtEo5JBNoNJIelwFmU9nOQqzw6cVsaIJs2RjWojF2BIVfjeTp4N4KzVPXY9DzLWtQg/egCi2gUXKqSU6Aas3M5eVio0MZjXl/BFWG6raDhVFnIYsmycp9meVJf7kT61OCdPawj9LHkMhWrPRgjSkXNv3uvNSl1yxEs1BxmD/7j5DmSa3t+Z+Mohu1jcQcD1zUwVPvi39zx0QeV/8cRDorWNhPksGpruc+vmWLaKGmeif+EqB3K7P6mpkuxhDmnxgSZIscwnD7sq4kv+P5OKSQKvHlsOTBoob/OmoZUFWEEBvxcXY/hfeMBhN0CCUqqy9cu27dPGwQLjDH3oM1fZzjDd0TbNaXcu1guESLJMZL1GPC+d4e8Kxo8IR7Sbn3hf2Hw8ruTBheHzK6nqbUshywXfqdt1VY9iEbZBTOLiXG3xwt5R8dQsE4dKZ6sFbUu4+IElKzBnH9OPD4JwYCD1NWLquwZq4tSBa4FyTnWwliFa2bJv67wzTz3VK+QCFb6vKwQX46EEHhcrTDmcBgdmYWyrX/zcHLR/fIMUDMax9+EMkvavEOkCbC++z/GDR2EDf81Hj+muhOJ1r9JXwMTl7pzGjDxGNBxY+vuvCpO+cfn9QWgkly1l5tZX2YqzhXJ4O3ht+oV9TCC/msqC+aVZPOkF3+Rq45hPc9RFWn6ROt0J85Km/hXwDgJGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":28226,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":28226,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"requestId":"req_vrtx_011CXK1WN6F5SEeF71SQGB5A","type":"assistant","uuid":"00eebc9a-5670-42ff-b8d2-6793b1fa2af6","timestamp":"2026-01-20T17:17:08.931Z"}
{"parentUuid":"00eebc9a-5670-42ff-b8d2-6793b1fa2af6","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_011ChP4erV4Fuuo8P1eaN7Go","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the core.py file and compare it against the official Python Agent SDK documentation to provide you with a comprehensive verification report."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":28226,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":28226,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"requestId":"req_vrtx_011CXK1WN6F5SEeF71SQGB5A","type":"assistant","uuid":"43e1c3c7-09b4-4a63-9551-d9a3622b6fe7","timestamp":"2026-01-20T17:17:09.464Z"}
{"parentUuid":"43e1c3c7-09b4-4a63-9551-d9a3622b6fe7","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_011ChP4erV4Fuuo8P1eaN7Go","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_vrtx_01Tsaymro8DVdtW1Zsk2DffW","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/core.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":28226,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":28226,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"requestId":"req_vrtx_011CXK1WN6F5SEeF71SQGB5A","type":"assistant","uuid":"2e3f01f9-43ae-4a8d-810c-e0ff462cabf0","timestamp":"2026-01-20T17:17:10.247Z"}
{"parentUuid":"2e3f01f9-43ae-4a8d-810c-e0ff462cabf0","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_011ChP4erV4Fuuo8P1eaN7Go","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_vrtx_01Ters59g6ikCWFz8C8rLDsM","name":"WebFetch","input":{"url":"https://docs.claude.com/en/api/agent-sdk/python","prompt":"Extract the complete documentation for Python Agent SDK including: 1) Agent class initialization and configuration, 2) Agentic loop implementation and run method patterns, 3) Tool use and tool execution patterns, 4) Message history management, 5) State management, 6) Error handling patterns, 7) Best practices and recommendations"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":28226,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":28226,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"requestId":"req_vrtx_011CXK1WN6F5SEeF71SQGB5A","type":"assistant","uuid":"e49698f8-b545-488a-85db-72c5b719e217","timestamp":"2026-01-20T17:17:12.065Z"}
{"parentUuid":"e49698f8-b545-488a-85db-72c5b719e217","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01Ters59g6ikCWFz8C8rLDsM","type":"tool_result","content":"REDIRECT DETECTED: The URL redirects to a different host.\n\nOriginal URL: https://docs.claude.com/en/api/agent-sdk/python\nRedirect URL: https://platform.claude.com/docs/en/api/agent-sdk/python\nStatus: 302 Found\n\nTo complete your request, I need to fetch content from the redirected URL. Please use WebFetch again with these parameters:\n- url: \"https://platform.claude.com/docs/en/api/agent-sdk/python\"\n- prompt: \"Extract the complete documentation for Python Agent SDK including: 1) Agent class initialization and configuration, 2) Agentic loop implementation and run method patterns, 3) Tool use and tool execution patterns, 4) Message history management, 5) State management, 6) Error handling patterns, 7) Best practices and recommendations\""}]},"uuid":"d721d6a8-54d7-466c-b9c1-f150617fab7b","timestamp":"2026-01-20T17:17:13.430Z","toolUseResult":{"bytes":743,"code":302,"codeText":"Found","result":"REDIRECT DETECTED: The URL redirects to a different host.\n\nOriginal URL: https://docs.claude.com/en/api/agent-sdk/python\nRedirect URL: https://platform.claude.com/docs/en/api/agent-sdk/python\nStatus: 302 Found\n\nTo complete your request, I need to fetch content from the redirected URL. Please use WebFetch again with these parameters:\n- url: \"https://platform.claude.com/docs/en/api/agent-sdk/python\"\n- prompt: \"Extract the complete documentation for Python Agent SDK including: 1) Agent class initialization and configuration, 2) Agentic loop implementation and run method patterns, 3) Tool use and tool execution patterns, 4) Message history management, 5) State management, 6) Error handling patterns, 7) Best practices and recommendations\"","durationMs":848,"url":"https://docs.claude.com/en/api/agent-sdk/python"},"sourceToolAssistantUUID":"e49698f8-b545-488a-85db-72c5b719e217"}
{"parentUuid":"2e3f01f9-43ae-4a8d-810c-e0ff462cabf0","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01Tsaymro8DVdtW1Zsk2DffW","type":"tool_result","content":"     1→\"\"\"\n     2→CoreAgent v9 - Agentic 架构重构\n     3→\n     4→v9 架构特性：\n     5→- Phase 1 提供所有路由工具，LLM 一次性决策\n     6→- 移除 Python 硬编码决策逻辑（confidence/birth_info 判断）\n     7→- 工具即行为：activate_skill, show_protocol_invitation, show_skill_intro, recommend_skills\n     8→- scenario → rule 概念统一（进行中）\n     9→\n    10→v8 架构特性（保留）：\n    11→- 分阶段上下文加载：Phase 1 (Skill 选择) / Phase 2 (Skill 执行)\n    12→- use_skill 同轮重载：激活 skill 后同一轮内重新构建上下文\n    13→- 历史消息从数据库获取（不依赖前端传入）\n    14→- Case 倒排索引匹配\n    15→- LLM 驱动的 SOP 执行\n    16→\"\"\"\n    17→import json\n    18→import logging\n    19→import time\n    20→from typing import Optional, List, Dict, Any, AsyncGenerator\n    21→from dataclasses import dataclass\n    22→from enum import Enum\n    23→\n    24→from services.llm import LLMClient, get_llm_client\n    25→from services.llm.client import LLMMessage\n    26→from .case_index import get_case_index, extract_features, CaseIndex\n    27→from .skill_loader import (\n    28→    load_skill, get_skill_triggers,\n    29→    build_system_prompt,\n    30→    get_available_skills, get_skill_scenarios,\n    31→    skill_requires_birth_info,\n    32→    skill_requires_compute,\n    33→    get_skill_compute_type,\n    34→    get_skill_compute_tool,\n    35→    get_skill_collect_tool,\n    36→    load_rule, get_skill_rules,\n    37→)\n    38→from .tool_registry import ToolRegistry, ToolContext\n    39→\n    40→logger = logging.getLogger(__name__)\n    41→\n    42→\n    43→class AgentState(str, Enum):\n    44→    \"\"\"Agent 执行状态\"\"\"\n    45→    IDLE = \"idle\"\n    46→    THINKING = \"thinking\"\n    47→    TOOL_CALLING = \"tool_calling\"\n    48→    COMPLETED = \"completed\"\n    49→    ERROR = \"error\"\n    50→\n    51→\n    52→@dataclass\n    53→class AgentEvent:\n    54→    \"\"\"Agent 执行事件\"\"\"\n    55→    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase\n    56→    data: Any = None\n    57→\n    58→\n    59→@dataclass\n    60→class AgentContext:\n    61→    \"\"\"Agent 执行上下文\n    62→\n    63→    v8 更新：\n    64→    - 删除 portrait 和 recent_insights（已废弃，数据从 profile.extracted 获取）\n    65→    - history 从数据库获取，不再依赖前端传入\n    66→    - profile 和 skill_data 分阶段加载\n    67→    - 新增 protocol_prompt 支持协议模式\n    68→    \"\"\"\n    69→    user_id: str\n    70→    user_tier: str = \"free\"\n    71→    profile: Optional[Dict[str, Any]] = None      # Phase 2 才加载\n    72→    skill_data: Optional[Dict[str, Any]] = None   # Phase 2 才加载，只含当前 skill\n    73→    history: Optional[List[Dict[str, str]]] = None  # 从数据库获取\n    74→    skill: Optional[str] = None\n    75→    scenario: Optional[str] = None\n    76→    conversation_id: Optional[str] = None\n    77→    voice_mode: Optional[str] = \"warm\"\n    78→    protocol_prompt: Optional[str] = None  # 协议模式专用 prompt\n    79→\n    80→\n    81→def build_phase1_tools() -> List[Dict[str, Any]]:\n    82→    \"\"\"\n    83→    构建 Phase 1 路由工具集 - v9: Agentic 重构\n    84→\n    85→    v9 架构：\n    86→    - 所有路由工具在 Phase 1 提供，LLM 一次性决策\n    87→    - 移除 Python 硬编码决策逻辑，让 LLM 自己判断\n    88→    - 工具即行为：每个用户意图对应一个工具\n    89→\n    90→    工具列表：\n    91→    1. activate_skill - 激活 skill 并切换上下文\n    92→    2. show_protocol_invitation - 展示协议邀请卡片（lifecoach 专用）\n    93→    3. show_skill_intro - 展示 skill 介绍卡片\n    94→    4. recommend_skills - 推荐相关 skills\n    95→    \"\"\"\n    96→    available_skills = [s for s in get_available_skills() if s != \"core\"]\n    97→\n    98→    # 构建 Skill 描述（用于 activate_skill 工具）\n    99→    skill_descriptions = []\n   100→    for skill_id in available_skills:\n   101→        skill = load_skill(skill_id)\n   102→        if skill:\n   103→            desc = skill.description\n   104→            if \"触发词\" in desc:\n   105→                desc = desc.split(\"触发词\")[0].strip().rstrip(\"。\")\n   106→            if len(desc) > 80:\n   107→                desc = desc[:80] + \"...\"\n   108→            triggers = \"、\".join(skill.triggers[:3]) if skill.triggers else \"\"\n   109→            skill_descriptions.append(f\"- {skill_id}: {desc}（{triggers}）\")\n   110→\n   111→    skill_list_text = \"\\n\".join(skill_descriptions)\n   112→\n   113→    # 工具 1: activate_skill - 激活专业技能\n   114→    activate_skill_tool = {\n   115→        \"type\": \"function\",\n   116→        \"function\": {\n   117→            \"name\": \"activate_skill\",\n   118→            \"description\": f\"\"\"激活专业技能来回答用户问题。\n   119→\n   120→## 可用技能\n   121→{skill_list_text}\n   122→\n   123→## 何时调用\n   124→- 用户明确需要某个专业领域的帮助\n   125→- 用户提到了技能相关的关键词\n   126→\n   127→## 示例\n   128→- 用户说\"帮我算算命\" → activate_skill(skill=\"bazi\")\n   129→- 用户说\"看看我的星盘\" → activate_skill(skill=\"zodiac\")\n   130→- 用户说\"我想做职业规划\" → activate_skill(skill=\"career\")\"\"\",\n   131→            \"parameters\": {\n   132→                \"type\": \"object\",\n   133→                \"properties\": {\n   134→                    \"skill\": {\n   135→                        \"type\": \"string\",\n   136→                        \"enum\": available_skills,\n   137→                        \"description\": \"要激活的技能 ID\"\n   138→                    },\n   139→                    \"rule\": {\n   140→                        \"type\": \"string\",\n   141→                        \"description\": \"可选的规则 ID，用于指定具体场景\"\n   142→                    }\n   143→                },\n   144→                \"required\": [\"skill\"]\n   145→            }\n   146→        }\n   147→    }\n   148→\n   149→    # 工具 2: show_protocol_invitation - 展示协议邀请卡片\n   150→    show_protocol_invitation_tool = {\n   151→        \"type\": \"function\",\n   152→        \"function\": {\n   153→            \"name\": \"show_protocol_invitation\",\n   154→            \"description\": \"\"\"展示协议邀请卡片，引导用户进入结构化协议流程。\n   155→\n   156→## 可用协议\n   157→| protocol_id | 名称 | 适用场景 | 时长 |\n   158→|-------------|------|---------|------|\n   159→| dankoe | Dan Koe 快速重置 | 迷茫、想改变、人生重构 | 10分钟 |\n   160→| covey | Covey 七个习惯 | 角色平衡、时间管理、周计划 | 15分钟 |\n   161→| yangming | 王阳明心学 | 知行不一、内心冲突、致良知 | 12分钟 |\n   162→| liaofan | 了凡四训 | 改变命运、积善改过、功过格 | 15分钟 |\n   163→\n   164→## 何时调用（必须！）\n   165→- 用户说\"人生重构\"、\"快速重置\"、\"帮我用 Dan Koe 方法\" → dankoe\n   166→- 用户说\"七个习惯\"、\"角色平衡\"、\"大石头\" → covey\n   167→- 用户说\"知行合一\"、\"致良知\"、\"王阳明\" → yangming\n   168→- 用户说\"改命\"、\"功过格\"、\"了凡四训\" → liaofan\n   169→\n   170→## 重要\n   171→匹配到协议关键词时，必须调用此工具！不要用文字描述协议内容！\"\"\",\n   172→            \"parameters\": {\n   173→                \"type\": \"object\",\n   174→                \"properties\": {\n   175→                    \"protocol_id\": {\n   176→                        \"type\": \"string\",\n   177→                        \"enum\": [\"dankoe\", \"covey\", \"yangming\", \"liaofan\"],\n   178→                        \"description\": \"协议 ID\"\n   179→                    },\n   180→                    \"title\": {\n   181→                        \"type\": \"string\",\n   182→                        \"description\": \"协议标题，如 'Dan Koe 快速重置'\"\n   183→                    },\n   184→                    \"description\": {\n   185→                        \"type\": \"string\",\n   186→                        \"description\": \"协议描述，一句话说明价值\"\n   187→                    },\n   188→                    \"estimated_time\": {\n   189→                        \"type\": \"string\",\n   190→                        \"description\": \"预计时长，如 '10分钟'\"\n   191→                    },\n   192→                    \"total_steps\": {\n   193→                        \"type\": \"integer\",\n   194→                        \"description\": \"总步骤数\"\n   195→                    }\n   196→                },\n   197→                \"required\": [\"protocol_id\", \"title\", \"description\"]\n   198→            }\n   199→        }\n   200→    }\n   201→\n   202→    # 工具 3: show_skill_intro - 展示 skill 介绍卡片\n   203→    show_skill_intro_tool = {\n   204→        \"type\": \"function\",\n   205→        \"function\": {\n   206→            \"name\": \"show_skill_intro\",\n   207→            \"description\": \"\"\"展示 Skill 介绍卡片，帮助用户了解功能。\n   208→\n   209→## 何时调用\n   210→- 用户首次使用某个 Skill\n   211→- 用户问\"这个能做什么\"、\"有什么功能\"\n   212→- 只确定 skill 但不确定具体需求\n   213→\n   214→## 示例\n   215→- 用户说\"lifecoach 是什么\" → show_skill_intro(skill=\"lifecoach\")\n   216→- 用户说\"我想了解八字\" → show_skill_intro(skill=\"bazi\")\"\"\",\n   217→            \"parameters\": {\n   218→                \"type\": \"object\",\n   219→                \"properties\": {\n   220→                    \"skill\": {\n   221→                        \"type\": \"string\",\n   222→                        \"enum\": available_skills,\n   223→                        \"description\": \"要介绍的技能 ID\"\n   224→                    },\n   225→                    \"reason\": {\n   226→                        \"type\": \"string\",\n   227→                        \"description\": \"展示原因，如 '首次使用'、'功能介绍'\"\n   228→                    }\n   229→                },\n   230→                \"required\": [\"skill\"]\n   231→            }\n   232→        }\n   233→    }\n   234→\n   235→    # 工具 4: recommend_skills - 推荐相关 skills\n   236→    recommend_skills_tool = {\n   237→        \"type\": \"function\",\n   238→        \"function\": {\n   239→            \"name\": \"recommend_skills\",\n   240→            \"description\": \"\"\"推荐相关的 Skills，帮助用户选择。\n   241→\n   242→## 何时调用\n   243→- 不确定用户想用哪个 skill\n   244→- 用户的需���可能涉及多个 skill\n   245→- 用户说\"帮帮我\"、\"有什么推荐\"\n   246→\n   247→## 示例\n   248→- 用户说\"我最近不太顺\" → recommend_skills(skills=[\"bazi\", \"lifecoach\"], reason=\"...\")\"\"\",\n   249→            \"parameters\": {\n   250→                \"type\": \"object\",\n   251→                \"properties\": {\n   252→                    \"skills\": {\n   253→                        \"type\": \"array\",\n   254→                        \"items\": {\"type\": \"string\", \"enum\": available_skills},\n   255→                        \"description\": \"推荐的技能列表（2-3个）\"\n   256→                    },\n   257→                    \"reason\": {\n   258→                        \"type\": \"string\",\n   259→                        \"description\": \"推荐理由\"\n   260→                    }\n   261→                },\n   262→                \"required\": [\"skills\", \"reason\"]\n   263→            }\n   264→        }\n   265→    }\n   266→\n   267→    return [\n   268→        activate_skill_tool,\n   269→        show_protocol_invitation_tool,\n   270→        show_skill_intro_tool,\n   271→        recommend_skills_tool\n   272→    ]\n   273→\n   274→\n   275→# 缓存动态生成的工具定义\n   276→_PHASE1_TOOLS_CACHE: Optional[List[Dict[str, Any]]] = None\n   277→\n   278→\n   279→def get_phase1_tools() -> List[Dict[str, Any]]:\n   280→    \"\"\"获取 Phase 1 工具定义（带缓存）\"\"\"\n   281→    global _PHASE1_TOOLS_CACHE\n   282→    if _PHASE1_TOOLS_CACHE is None:\n   283→        _PHASE1_TOOLS_CACHE = build_phase1_tools()\n   284→    return _PHASE1_TOOLS_CACHE\n   285→\n   286→\n   287→class CoreAgent:\n   288→    \"\"\"\n   289→    CoreAgent v8 - 分阶段渐进式加载的智能体\n   290→\n   291→    Features:\n   292→    - 分阶段上下文加载：Phase 1 轻量，Phase 2 完整\n   293→    - use_skill 同轮重载：激活后立即重新构建上下文\n   294→    - Case 倒排索引匹配（替代向量检索）\n   295→    - LLM 驱动的 SOP 执行\n   296→    - Tool-card mapping\n   297→    \"\"\"\n   298→\n   299→    def __init__(\n   300→        self,\n   301→        llm: Optional[LLMClient] = None,\n   302→        max_iterations: int = 10,\n   303→        case_index: Optional[CaseIndex] = None\n   304→    ):\n   305→        self.llm = llm or get_llm_client()\n   306→        self.max_iterations = max_iterations\n   307→        self.case_index = case_index or get_case_index()\n   308→        self.state = AgentState.IDLE\n   309→        self._active_skill: Optional[str] = None\n   310→        self._active_scenario: Optional[str] = None\n   311→        self._topic: Optional[str] = None\n   312→        self._current_message: str = \"\"\n   313→        # v8: 用于同轮重载\n   314→        self._context: Optional[AgentContext] = None\n   315→        self._messages: Optional[List[LLMMessage]] = None\n   316→        self._perf_log: Dict[str, Any] = {}  # v8: 初始化性能日志，避免 AttributeError\n   317→\n   318→    @property\n   319→    def usage(self) -> Dict[str, int]:\n   320→        \"\"\"获取 LLM 使用统计\"\"\"\n   321→        return self.llm.usage\n   322→\n   323→    async def run(\n   324→        self,\n   325→        message: str,\n   326→        context: AgentContext\n   327→    ) -> AsyncGenerator[AgentEvent, None]:\n   328→        \"\"\"执行 Agent 循环\"\"\"\n   329→        self.state = AgentState.IDLE\n   330→        self._current_message = message\n   331→        self._context = context  # v8: 保存引用用于同轮重载\n   332→        self._perf_log = {\"iterations\": 0, \"llm_calls\": [], \"phase\": \"phase1\" if not context.skill else \"phase2\"}\n   333→\n   334→        # 使用前端指定的 skill/scenario，或让 LLM 决定\n   335→        if context.skill:\n   336→            self._active_skill = context.skill\n   337→            self._active_scenario = context.scenario or await self._route_scenario(context.skill, message)\n   338→        else:\n   339→            self._active_skill = None\n   340→            self._active_scenario = None\n   341→\n   342→        # v7.2: 移除 SOPEngine，改为 LLM 驱动\n   343→        # SOP 规则和状态将通过 System Prompt 传达给 LLM\n   344→        # LLM 自主决定是否需要收集信息或计算\n   345→        if self._active_skill:\n   346→            # 计算当前状态，用于前端显示和 Prompt 构建\n   347→            sop_status = self._compute_sop_status(context)\n   348→\n   349→            yield AgentEvent(type=\"sop_phase\", data={\n   350→                \"skill\": self._active_skill,\n   351→                \"scenario\": self._active_scenario,\n   352→                \"status\": sop_status,\n   353→                \"message\": \"LLM 驱动模式\"\n   354→            })\n   355→\n   356→        # [PERF T6] 构建初始消息\n   357→        t_prompt_start = time.time()\n   358→        messages = await self._build_initial_messages(message, context)\n   359→        self._messages = messages  # v8: 保存引用用于同轮重载\n   360→        self._perf_log[\"prompt_build_ms\"] = int((time.time() - t_prompt_start) * 1000)\n   361→        self._perf_log[\"system_prompt_len\"] = len(messages[0].content) if messages else 0\n   362→        logger.info(f\"[PERF Agent] Prompt built: {self._perf_log['prompt_build_ms']}ms, len={self._perf_log['system_prompt_len']}, phase={self._perf_log['phase']}\")\n   363→\n   364→        for iteration in range(self.max_iterations):\n   365→            self.state = AgentState.THINKING\n   366→            yield AgentEvent(type=\"thinking\", data={\"iteration\": iteration})\n   367→            self._perf_log[\"iterations\"] = iteration + 1\n   368→\n   369→            tools = self._get_current_tools(context)\n   370→\n   371→            try:\n   372→                content_buffer = \"\"\n   373→                tool_calls = []\n   374→\n   375→                # [PERF T7/T9] LLM 调用\n   376→                t_llm_start = time.time()\n   377→                first_token_time = None\n   378→\n   379→                async for chunk in self.llm.stream(\n   380→                    messages=messages,\n   381→                    tools=tools,\n   382→                    tool_choice=None,\n   383→                    user_tier=context.user_tier\n   384→                ):\n   385→                    # 记录首 token 时间\n   386→                    if first_token_time is None:\n   387→                        first_token_time = time.time()\n   388→                        ttft = int((first_token_time - t_llm_start) * 1000)\n   389→                        logger.info(f\"[PERF Agent] LLM #{iteration+1} TTFT: {ttft}ms\")\n   390→\n   391→                    if chunk[\"type\"] == \"content\":\n   392→                        content_buffer += chunk[\"content\"]\n   393→                        yield AgentEvent(type=\"content\", data={\"content\": chunk[\"content\"]})\n   394→                    elif chunk[\"type\"] == \"tool_call\":\n   395→                        tool_calls.append(chunk)\n   396→\n   397→                # [PERF] LLM 调用完成\n   398→                llm_total = int((time.time() - t_llm_start) * 1000)\n   399→                self._perf_log[\"llm_calls\"].append({\n   400→                    \"iteration\": iteration + 1,\n   401→                    \"ttft_ms\": int((first_token_time - t_llm_start) * 1000) if first_token_time else 0,\n   402→                    \"total_ms\": llm_total,\n   403→                    \"has_tools\": len(tool_calls) > 0\n   404→                })\n   405→                logger.info(f\"[PERF Agent] LLM #{iteration+1} total: {llm_total}ms, tools={len(tool_calls)}\")\n   406→\n   407→                if tool_calls:\n   408→                    self.state = AgentState.TOOL_CALLING\n   409→\n   410→                    assistant_tool_calls = []\n   411→                    for tc in tool_calls:\n   412→                        assistant_tool_calls.append({\n   413→                            \"id\": tc[\"tool_call_id\"],\n   414→                            \"function\": {\n   415→                                \"name\": tc[\"tool_name\"],\n   416→                                \"arguments\": tc[\"tool_args\"]\n   417→                            }\n   418→                        })\n   419→                    messages.append(LLMMessage(\n   420→                        role=\"assistant\",\n   421→                        content=content_buffer or \"\",\n   422→                        tool_calls=assistant_tool_calls\n   423→                    ))\n   424→                    content_buffer = \"\"\n   425→\n   426→                    # [PERF T8] 工具执行\n   427→                    t_tools_start = time.time()\n   428→                    tool_results = []\n   429→                    for tc in tool_calls:\n   430→                        tool_name = tc[\"tool_name\"]\n   431→                        tool_args = tc[\"tool_args\"]\n   432→                        tool_call_id = tc[\"tool_call_id\"]\n   433→\n   434→                        yield AgentEvent(type=\"tool_call\", data={\n   435→                            \"id\": tool_call_id,\n   436→                            \"name\": tool_name,\n   437→                            \"arguments\": tool_args\n   438→                        })\n   439→\n   440→                        t_tool_start = time.time()\n   441→                        result = await self._execute_tool(tool_name, tool_args, context)\n   442→                        tool_exec_ms = int((time.time() - t_tool_start) * 1000)\n   443→                        logger.info(f\"[PERF Agent] Tool {tool_name}: {tool_exec_ms}ms\")\n   444→\n   445→                        tool_results.append({\n   446→                            \"tool_call_id\": tool_call_id,\n   447→                            \"result\": result\n   448→                        })\n   449→\n   450→                        yield AgentEvent(type=\"tool_result\", data={\n   451→                            \"id\": tool_call_id,\n   452→                            \"name\": tool_name,\n   453→                            \"result\": result\n   454→                        })\n   455→\n   456→                    tools_total = int((time.time() - t_tools_start) * 1000)\n   457→                    logger.info(f\"[PERF Agent] All tools: {tools_total}ms\")\n   458→\n   459→                    for tr in tool_results:\n   460→                        result_content = tr[\"result\"]\n   461→                        if isinstance(result_content, dict):\n   462→                            result_content = json.dumps(result_content, ensure_ascii=False)\n   463→                        messages.append(LLMMessage(\n   464→                            role=\"tool\",\n   465→                            content=str(result_content),\n   466→                            tool_call_id=tr[\"tool_call_id\"]\n   467→                        ))\n   468→                else:\n   469→                    self.state = AgentState.COMPLETED\n   470→                    logger.info(f\"[PERF Agent] Done: {self._perf_log}\")\n   471→                    yield AgentEvent(type=\"done\", data={\"content\": content_buffer})\n   472→                    return\n   473→\n   474→            except Exception as e:\n   475→                self.state = AgentState.ERROR\n   476→                logger.error(f\"Agent error: {e}\")\n   477→                yield AgentEvent(type=\"error\", data={\"error\": str(e)})\n   478→                return\n   479→\n   480→        self.state = AgentState.COMPLETED\n   481→        yield AgentEvent(type=\"done\", data={\"max_iterations_reached\": True})\n   482→\n   483→    def _filter_valid_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   484→        \"\"\"\n   485→        过滤历史消息，确保 tool 消息配对完整。\n   486→\n   487→        Anthropic API 要求每个 tool_result 必须有对应的 tool_use。\n   488→        如果历史消息不完整（如只有 tool 消息没有对应的 assistant tool_calls），\n   489→        需要过滤掉这些孤立的消息。\n   490→        \"\"\"\n   491→        if not history:\n   492→            return []\n   493→\n   494→        # 收集所有有效的 tool_call_ids（来自 assistant 的 tool_calls）\n   495→        valid_tool_ids = set()\n   496→        for msg in history:\n   497→            if msg.get(\"role\") == \"assistant\" and msg.get(\"tool_calls\"):\n   498→                for tc in msg[\"tool_calls\"]:\n   499→                    tc_id = tc.get(\"id\")\n   500→                    if tc_id:\n   501→                        valid_tool_ids.add(tc_id)\n   502→\n   503→        # 过滤消息\n   504→        filtered = []\n   505→        for msg in history:\n   506→            role = msg.get(\"role\", \"user\")\n   507→\n   508→            # tool 消息需要检查是否有对应的 tool_use\n   509→            if role == \"tool\":\n   510→                tool_call_id = msg.get(\"tool_call_id\")\n   511→                if tool_call_id and tool_call_id in valid_tool_ids:\n   512→                    filtered.append(msg)\n   513→                else:\n   514→                    # 孤立的 tool 消息，跳过\n   515→                    logger.warning(f\"Skipping orphan tool message: {tool_call_id}\")\n   516→            else:\n   517→                # user/assistant 消息直接保留\n   518→                filtered.append(msg)\n   519→\n   520→        return filtered\n   521→\n   522→    async def _route_scenario(self, skill_id: str, message: str) -> Optional[str]:\n   523→        \"\"\"场景路由 - 基于 tags 匹配最佳 rule\n   524→\n   525→        v8.1: 实现 tags 匹配路由\n   526→        1. 遍历 skill 的所有 rules\n   527→        2. 检查 message 是否包含 rule 的 tags\n   528→        3. 返回匹配的 rule，或默认 scenario\n   529→        \"\"\"\n   530→        skill = load_skill(skill_id)\n   531→        if not skill:\n   532→            return None\n   533→\n   534→        # 获取所有 rules\n   535→        rules = get_skill_rules(skill_id)\n   536→        if not rules:\n   537→            return skill.default_scenario\n   538→\n   539→        message_lower = message.lower()\n   540→\n   541→        # 遍历 rules，检查 tags 匹配\n   542→        for rule_id in rules:\n   543→            rule = load_rule(skill_id, rule_id)\n   544→            if rule and rule.tags:\n   545→                for tag in rule.tags:\n   546→                    if tag.lower() in message_lower:\n   547→                        logger.info(f\"[Scenario] Matched rule '{rule_id}' via tag '{tag}'\")\n   548→                        return rule_id\n   549→\n   550→        return skill.default_scenario\n   551→\n   552→    async def _build_initial_messages(\n   553→        self,\n   554→        message: str,\n   555→        context: AgentContext\n   556→    ) -> List[LLMMessage]:\n   557→        \"\"\"构建初始消息列表\"\"\"\n   558→        system_prompt = await self._build_system_prompt(message, context)\n   559→\n   560→        messages = [LLMMessage(role=\"system\", content=system_prompt)]\n   561→\n   562→        if context.history:\n   563→            # 过滤并验证历史消息，确保 tool 消息配对完整\n   564→            filtered_history = self._filter_valid_history(context.history[-10:])\n   565→            for msg in filtered_history:\n   566→                messages.append(LLMMessage(\n   567→                    role=msg.get(\"role\", \"user\"),\n   568→                    content=msg.get(\"content\", \"\"),\n   569→                    tool_call_id=msg.get(\"tool_call_id\"),\n   570→                    tool_calls=msg.get(\"tool_calls\")\n   571→                ))\n   572→\n   573→        messages.append(LLMMessage(role=\"user\", content=message))\n   574→        return messages\n   575→\n   576→    def _compute_sop_status(self, context: AgentContext) -> Dict[str, Any]:\n   577→        \"\"\"\n   578→        v7.2: 计算 SOP 状态（替代 SOPEngine）\n   579→\n   580→        返回当前状态信息，用于：\n   581→        1. 前端显示\n   582→        2. System Prompt 构建\n   583→        \"\"\"\n   584→        skill_id = self._active_skill\n   585→\n   586→        # 检查是否需要出生信息\n   587→        needs_birth = skill_requires_birth_info(skill_id) if skill_id else False\n   588→        birth_info = context.profile.get(\"birth_info\", {}) if context.profile else {}\n   589→        has_birth = bool(\n   590→            birth_info.get(\"birth_date\") or birth_info.get(\"date\")\n   591→        )\n   592→\n   593→        # 检查是否需要计算\n   594→        needs_compute = skill_requires_compute(skill_id) if skill_id else False\n   595→        compute_type = get_skill_compute_type(skill_id) if skill_id else None\n   596→        actual_compute_type = compute_type or skill_id\n   597→\n   598→        # 检查是否有命盘数据\n   599→        has_chart = False\n   600→        if context.skill_data and actual_compute_type:\n   601→            skill_data = context.skill_data.get(actual_compute_type, {})\n   602→            # 通用检查：chart 或 cards\n   603→            has_chart = bool(skill_data.get(\"chart\") or skill_data.get(\"cards\"))\n   604→\n   605→        return {\n   606→            \"skill_id\": skill_id,\n   607→            \"needs_birth_info\": needs_birth,\n   608→            \"has_birth_info\": has_birth,\n   609→            \"needs_compute\": needs_compute,\n   610→            \"has_chart_data\": has_chart,\n   611→            \"compute_type\": actual_compute_type,\n   612→            \"ready_for_analysis\": (not needs_birth or has_birth) and (not needs_compute or has_chart)\n   613→        }\n   614→\n   615→    def _build_sop_rules(self, context: AgentContext) -> str:\n   616→        \"\"\"\n   617→        v7.2: 构建 SOP 规则（替代 SOPEngine）\n   618→\n   619→        将 SOP 规则通过 System Prompt 传达给 LLM，\n   620→        让 LLM 自主决定执行流程。\n   621→        \"\"\"\n   622→        skill_id = self._active_skill\n   623→        if not skill_id:\n   624→            return \"\"\n   625→\n   626→        # 获取配置\n   627→        needs_birth = skill_requires_birth_info(skill_id)\n   628→        needs_compute = skill_requires_compute(skill_id)\n   629→        compute_type = get_skill_compute_type(skill_id) or skill_id\n   630→\n   631→        # 计算当前状态\n   632→        status = self._compute_sop_status(context)\n   633→\n   634→        rules = \"\\n## SOP 执行规则（必须遵守）\\n\\n\"\n   635→\n   636→        # P1: 信息收集\n   637→        if needs_birth:\n   638→            if not status[\"has_birth_info\"]:\n   639→                # v7.3: 从 SKILL.md 配置读取 collect_tool，不再硬编码\n   640→                collect_tool = get_skill_collect_tool(skill_id)\n   641→                if not collect_tool:\n   642→                    # 默认约定：request_info\n   643→                    collect_tool = \"request_info\"\n   644→\n   645→                rules += f\"\"\"### P1: 信息收集 ⚠️ 需要执行\n   646→用户尚未提供出生信息。你必须：\n   647→1. 首先调用 `{collect_tool}` 工具展示收集表单\n   648→2. 不要用文字询问，必须使用工具\n   649→3. 收集到信息后再进行下一步\n   650→\n   651→\"\"\"\n   652→            else:\n   653→                rules += \"\"\"### P1: 信息收集 ✅ 已完成\n   654→用户已提供出生信息。\n   655→\n   656→\"\"\"\n   657→\n   658→        # P2: 计算排盘\n   659→        if needs_compute:\n   660→            if not status[\"has_chart_data\"]:\n   661→                # v7.3: 从 SKILL.md 配置读取 compute_tool，不再硬编码\n   662→                compute_tool = get_skill_compute_tool(skill_id)\n   663→                if not compute_tool:\n   664→                    # 默认约定：calculate_{compute_type}\n   665→                    compute_tool = f\"calculate_{compute_type}\"\n   666→\n   667→                rules += f\"\"\"### P2: 计算排盘 ⚠️ 需要执行\n   668→用户尚未有命盘数据。你必须：\n   669→1. 调用 `{compute_tool}` 工具生成命盘数据\n   670→2. 计算完成后再进行分析\n   671→\n   672→\"\"\"\n   673→            else:\n   674→                rules += \"\"\"### P2: 计算排盘 ✅ 已完成\n   675→用户已有命盘数据。\n   676→\n   677→\"\"\"\n   678→\n   679→        # P3-P7: LLM 自由发挥\n   680→        rules += \"\"\"### P3-P7: 分析与输出\n   681→完成信息收集和计算后，按以下流程执行：\n   682→1. **扫描**: 快速识别命盘中的关键模式和特征\n   683→2. **追问**: 根据需要向用户提出针对性问题\n   684→3. **分析**: 深度分析，结合知识库检索结果\n   685→4. **输出**: 调用展示工具（show_xxx）呈现分析结果\n   686→5. **讨论**: 回答用户的追问\n   687→\n   688→\"\"\"\n   689→\n   690→        # 当前状态摘要\n   691→        rules += \"### 当前状态\\n\"\n   692→        rules += f\"- 出生信息: {'✅ 已有' if status['has_birth_info'] else '❌ 未收集'}\\n\"\n   693→        rules += f\"- 命盘数据: {'✅ 已计算' if status['has_chart_data'] else '❌ 未计算'}\\n\"\n   694→        rules += f\"- 可以分析: {'✅ 是' if status['ready_for_analysis'] else '❌ 否，请先完成上述步骤'}\\n\"\n   695→\n   696→        return rules\n   697→\n   698→    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:\n   699→        \"\"\"\n   700→        构建 System Prompt - v8: 分阶段加载\n   701→\n   702→        Phase 1 (无 skill): 轻量级 prompt，只包含 Core 人格和 use_skill 工具\n   703→        Phase 2 (有 skill): 完整 prompt，包含专家身份、SOP、Cases、用户数据\n   704→        Protocol Mode: 使用协议专用 prompt\n   705→        \"\"\"\n   706→        parts = []\n   707→\n   708→        # ═══════════════════════════════════════════════════════════════\n   709→        # 协议模式：使用协议专用 prompt\n   710→        # ═══════════════════════════════════════════════════════════════\n   711→        if context.protocol_prompt:\n   712→            # 协议模式下，使用 chat_v5.py 构建的 protocol_prompt\n   713→            # 加上基础的 lifecoach 人格\n   714→            skill = load_skill(\"lifecoach\")\n   715→            if skill:\n   716→                parts.append(f\"# {skill.name}\\n\\n{skill.expert_persona}\")\n   717→            parts.append(\"\\n---\\n\")\n   718→            parts.append(context.protocol_prompt)\n   719→            return \"\\n\".join(parts)\n   720→\n   721→        if self._active_skill:\n   722→            # ═══════════════════════════════════════════════════════════════\n   723→            # Phase 2: Skill 执行阶段 - 完整上下文\n   724→            # ═══════════════════════════════════════════════════════════════\n   725→\n   726→            # 传递完整 profile，让 skill_loader 自动处理所有字段\n   727→            user_ctx = dict(context.profile) if context.profile else {}\n   728→            base_prompt = build_system_prompt(\n   729→                self._active_skill,\n   730→                self._active_scenario,\n   731→                user_ctx\n   732→            )\n   733→            parts.append(base_prompt)\n   734→\n   735→            # v7.2: 添加 SOP 规则（替代 SOPEngine）\n   736→            sop_rules = self._build_sop_rules(context)\n   737→            if sop_rules:\n   738→                parts.append(sop_rules)\n   739→\n   740→            # v7: 案例匹配 - 使用倒排索引（只在 Phase 2 执行）\n   741→            try:\n   742→                if context.skill_data:\n   743→                    features = extract_features(context.skill_data)\n   744→                    if features:\n   745→                        cases = await self.case_index.get_matched_cases(\n   746→                            self._active_skill,\n   747→                            features,\n   748→                            top_k=2\n   749→                        )\n   750→                        if cases:\n   751→                            cases_text = \"\\n## 相关案例\\n\\n\"\n   752→                            for case in cases:\n   753→                                cases_text += f\"### {case.name}\\n{case.content}\\n\\n\"\n   754→                            parts.append(cases_text)\n   755→            except Exception as e:\n   756→                logger.warning(f\"Case matching failed: {e}\")\n   757→\n   758→            # 用户数据（使用 compute_type 读取，支持跨 skill 复用）\n   759→            if context.skill_data:\n   760→                compute_type = get_skill_compute_type(self._active_skill) or self._active_skill\n   761→                skill_data = context.skill_data.get(compute_type, {})\n   762→                if skill_data:\n   763→                    parts.append(f\"\\n## 用户数据\\n{json.dumps(skill_data, ensure_ascii=False, indent=2)}\")\n   764→\n   765→        else:\n   766→            # ═══════════════════════════════════════════════════════════════\n   767→            # Phase 1: Skill 选择阶段 - v9 Agentic 重构\n   768→            # ═══════════════════════════════════════════════════════════════\n   769→\n   770→            core_prompt = \"\"\"# Vibe - 生命对话者\n   771→\n   772→你是 Vibe，一个生命对话者。你的任务是理解用户意图，并调用合适的工具。\n   773→\n   774→## 你的能力\n   775→- 深度倾听和情绪感知\n   776→- 理解用户的真实需求\n   777→- 调用工具激活专业技能或展示卡片\n   778→\n   779→## 工具调用规则（必须遵守！）\n   780→\n   781→**重要：识别到用户意图后，必须立即调用对应工具，不要用文字回复。**\n   782→\n   783→### 协议类（优先匹配 - lifecoach 专属）\n   784→\n   785→| 用户说 | 必须调用 |\n   786→|-------|---------|\n   787→| 人生重构、Dan Koe、快速重置、迷茫想改变 | `show_protocol_invitation(protocol_id=\"dankoe\", title=\"Dan Koe 快速重置\", description=\"10分钟完成人生重置\", estimated_time=\"10分钟\", total_steps=6)` |\n   788→| Covey、七个习惯、角色平衡、大石头、周计划 | `show_protocol_invitation(protocol_id=\"covey\", title=\"Covey 七个习惯\", description=\"角色平衡与时间管理\", estimated_time=\"15分钟\", total_steps=8)` |\n   789→| 王阳明、心学、知行合一、致良知 | `show_protocol_invitation(protocol_id=\"yangming\", title=\"王阳明心学\", description=\"致良知与知行合一\", estimated_time=\"12分钟\", total_steps=6)` |\n   790→| 了凡四训、改命、功过格、积善 | `show_protocol_invitation(protocol_id=\"liaofan\", title=\"了凡四训\", description=\"立命改过积善\", estimated_time=\"15分钟\", total_steps=7)` |\n   791→\n   792→### Skill 类\n   793→\n   794→| 用户说 | 必须调用 |\n   795→|-------|---------|\n   796→| 八字、命理、生辰、算命、看命 | `activate_skill(skill=\"bazi\")` |\n   797→| 星座、星盘、占星、上升、月亮 | `activate_skill(skill=\"zodiac\")` |\n   798→| 塔罗、牌阵、占卜、抽牌 | `activate_skill(skill=\"tarot\")` |\n   799→| 职业、工作、跳槽、面试、简历 | `activate_skill(skill=\"career\")` |\n   800→| 人生规划、目标、习惯（非协议关键词） | `activate_skill(skill=\"lifecoach\")` |\n   801→\n   802→### 不确定时\n   803→\n   804→| 情况 | 必须调用 |\n   805→|-----|---------|\n   806→| 用户问\"这个能做什么\"、想了解功能 | `show_skill_intro(skill=\"xxx\")` |\n   807→| 不确定用哪个 skill | `recommend_skills(skills=[\"xxx\", \"yyy\"], reason=\"...\")` |\n   808→\n   809→### 示例\n   810→\n   811→1. 用户: \"帮我用 Dan Koe 方法做一次人生重置\"\n   812→   → 调用 `show_protocol_invitation(protocol_id=\"dankoe\", ...)`\n   813→\n   814→2. 用户: \"我想算算命\"\n   815→   → 调用 `activate_skill(skill=\"bazi\")`\n   816→\n   817→3. 用户: \"lifecoach 有什么功能\"\n   818→   → 调用 `show_skill_intro(skill=\"lifecoach\")`\n   819→\n   820→4. 用户: \"我最近很迷茫\"\n   821→   → 调用 `show_protocol_invitation(protocol_id=\"dankoe\", ...)` （迷茫 = 协议关键词）\n   822→\n   823→5. 用户: \"帮帮我\"\n   824→   → 可以直接对话探索，或调用 `recommend_skills`\n   825→\n   826→## 对话原则\n   827→\n   828→- 如果用户只是打招呼或闲聊，可以直接回复，不需要调用工具\n   829→- 如果用户表达了具体困境但没有明确要求，可以先共情再探索\n   830→- 一旦识别到专业需求或协议关键词，必须调用工具\n   831→\"\"\"\n   832→            parts.append(core_prompt)\n   833→\n   834→        return \"\\n\".join(parts)\n   835→\n   836→    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:\n   837→        \"\"\"\n   838→        获取当前可用工具 - v9.1: SOP 工具集限制\n   839→\n   840→        Phase 1 (无 skill): 返回所有路由工具\n   841→        Phase 2 (有 skill): 根据 SOP 状态返回受限工具集\n   842→          - P1 阶段（需要收集信息）: 只返回收集工具\n   843→          - P2 阶段（需要计算）: 只返回计算工具\n   844→          - P3+ 阶段（可以分析）: 返回完整工具集\n   845→        \"\"\"\n   846→        if not context.skill and not self._active_skill:\n   847→            # Phase 1: 返回所有路由工具（LLM 一次性决策）\n   848→            return get_phase1_tools()\n   849→\n   850→        skill_id = self._active_skill or context.skill\n   851→\n   852→        # 计算 SOP 状态\n   853→        status = self._compute_sop_status(context)\n   854→\n   855→        # ═══════════════════════════════════════════════════════════════\n   856→        # v9.1: SOP 工具集限制 - 用工具集强制 SOP 流程\n   857→        # ═══════════════════════════════════════════════════════════════\n   858→\n   859→        # P1: 需要收集信息但尚未收集 → 只提供收集工具\n   860→        if status[\"needs_birth_info\"] and not status[\"has_birth_info\"]:\n   861→            collect_tool_name = get_skill_collect_tool(skill_id) or \"request_info\"\n   862→            tool_def = ToolRegistry.get_tool_def(collect_tool_name)\n   863→            if tool_def:\n   864→                logger.info(f\"[SOP] P1 阶段: 只提供收集工具 {collect_tool_name}\")\n   865→                return [tool_def.to_openai_format()]\n   866→            # fallback: 如果找不到收集工具，返回完整工具集\n   867→            logger.warning(f\"[SOP] 收集工具 {collect_tool_name} 未找到，返回完整���具集\")\n   868→\n   869→        # P2: 需要计算但尚未计算 → 只提供计算工具\n   870→        if status[\"needs_compute\"] and not status[\"has_chart_data\"]:\n   871→            compute_type = get_skill_compute_type(skill_id) or skill_id\n   872→            compute_tool_name = get_skill_compute_tool(skill_id) or f\"calculate_{compute_type}\"\n   873→            tool_def = ToolRegistry.get_tool_def(compute_tool_name)\n   874→            if tool_def:\n   875→                logger.info(f\"[SOP] P2 阶段: 只提供计算工具 {compute_tool_name}\")\n   876→                return [tool_def.to_openai_format()]\n   877→            # fallback: 如果找不到计算工具，返回完整工具集\n   878→            logger.warning(f\"[SOP] 计算工具 {compute_tool_name} 未找到，返回完整工具集\")\n   879→\n   880→        # P3+: 可以分析 → 返回完整工具集\n   881→        tools = ToolRegistry.get_tools_for_skill(skill_id)\n   882→        return tools if tools else get_phase1_tools()\n   883→\n   884→    async def _execute_tool(\n   885→        self,\n   886→        tool_name: str,\n   887→        tool_args: str,\n   888→        context: AgentContext\n   889→    ) -> Dict[str, Any]:\n   890→        \"\"\"执行工具调用 - v9: 支持新的路由工具\"\"\"\n   891→        try:\n   892→            args = json.loads(tool_args) if tool_args else {}\n   893→        except json.JSONDecodeError:\n   894→            args = {}\n   895→\n   896→        # ═══════════════════════════════════════════════════════════════\n   897→        # v9: Phase 1 路由工具处理\n   898→        # ═══════════════════════════════════════════════════════════════\n   899→\n   900→        # 工具 1: activate_skill - 激活 skill\n   901→        if tool_name == \"activate_skill\":\n   902→            return await self._handle_activate_skill(args, context)\n   903→\n   904→        # 工具 2: show_protocol_invitation - 展示协议邀请（直接返回卡片数据）\n   905→        if tool_name == \"show_protocol_invitation\":\n   906→            return await self._handle_show_protocol_invitation(args, context)\n   907→\n   908→        # 工具 3: show_skill_intro - 展示 skill 介绍（直接返回卡片数据）\n   909→        if tool_name == \"show_skill_intro\":\n   910→            return await self._handle_show_skill_intro(args, context)\n   911→\n   912→        # 工具 4: recommend_skills - 推荐 skills\n   913→        if tool_name == \"recommend_skills\":\n   914→            return await self._handle_recommend_skills(args, context)\n   915→\n   916→        # 兼容旧的 use_skill 工具（逐步废弃）\n   917→        if tool_name == \"use_skill\":\n   918→            return await self._handle_use_skill(args, context)\n   919→\n   920→        # 创建工具上下文\n   921→        tool_context = ToolContext(\n   922→            user_id=context.user_id,\n   923→            user_tier=context.user_tier,\n   924→            profile=context.profile or {},\n   925→            skill_data=context.skill_data or {},\n   926→            skill_id=self._active_skill,\n   927→            scenario_id=self._active_scenario,\n   928→            conversation_id=context.conversation_id\n   929→        )\n   930→\n   931→        # 使用统一注册表执行工具\n   932→        if ToolRegistry.has_handler(tool_name):\n   933→            return await ToolRegistry.execute(tool_name, args, tool_context)\n   934→\n   935→        # 未找到处理器\n   936→        logger.warning(f\"No handler found for tool: {tool_name}\")\n   937→        return {\"status\": \"unknown_tool\", \"tool\": tool_name, \"message\": f\"工具 {tool_name} 暂未实现\"}\n   938→\n   939→    async def _handle_activate_skill(\n   940→        self,\n   941→        args: Dict[str, Any],\n   942→        context: AgentContext\n   943→    ) -> Dict[str, Any]:\n   944→        \"\"\"\n   945→        v9: 激活 skill - 简化版，移除硬编码决策逻辑\n   946→\n   947→        只做一件事：切换上下文，让 LLM 继续决策\n   948→        \"\"\"\n   949→        skill = args.get(\"skill\")\n   950→        rule = args.get(\"rule\")  # v9: scenario → rule\n   951→\n   952→        if not skill:\n   953→            return {\"status\": \"error\", \"message\": \"No skill specified\"}\n   954→\n   955→        self._active_skill = skill\n   956→\n   957→        # 如果没有指定 rule，尝试自动匹配\n   958→        if not rule and self._current_message:\n   959→            rule = await self._route_scenario(skill, self._current_message)\n   960→            logger.info(f\"[activate_skill] Auto-routed rule: {rule}\")\n   961→\n   962→        self._active_scenario = rule  # 内部仍用 _active_scenario，后续统一替换\n   963→\n   964→        # 同步 skill 到数据库\n   965→        if self._context and self._context.conversation_id:\n   966→            try:\n   967→                from stores.conversation_repo import update_conversation_skill\n   968→                from uuid import UUID\n   969→                conv_id = UUID(self._context.conversation_id)\n   970→                await update_conversation_skill(conv_id, skill)\n   971→            except Exception as e:\n   972→                logger.warning(f\"[activate_skill] Failed to sync skill to DB: {e}\")\n   973→\n   974→        # 动态加载该 skill 需要的数据\n   975→        if self._context and self._context.user_id != \"guest\":\n   976→            try:\n   977→                from stores.profile_cache import get_cached_profile_with_skill\n   978→                from uuid import UUID\n   979→\n   980→                user_id = UUID(self._context.user_id)\n   981→                result = await get_cached_profile_with_skill(user_id, skill)\n   982→\n   983→                self._context.profile = result.get(\"profile\", {})\n   984→                self._context.skill_data = result.get(\"skill_data\", {})\n   985→\n   986→                logger.info(f\"[activate_skill] Loaded profile for skill={skill}\")\n   987→            except Exception as e:\n   988→                logger.warning(f\"[activate_skill] Failed to load profile: {e}\")\n   989→\n   990→        # 重新构建 System Prompt\n   991→        if self._messages:\n   992→            new_system_prompt = await self._build_system_prompt(\n   993→                self._current_message,\n   994→                self._context\n   995→            )\n   996→            self._messages[0] = LLMMessage(role=\"system\", content=new_system_prompt)\n   997→            self._perf_log[\"phase\"] = \"phase2\"\n   998→            self._perf_log[\"system_prompt_reloaded\"] = True\n   999→            logger.info(f\"[activate_skill] System prompt reloaded, len={len(new_system_prompt)}\")\n  1000→\n  1001→        return {\n  1002→            \"status\": \"activated\",\n  1003→            \"skill\": skill,\n  1004→            \"rule\": rule,\n  1005→            \"message\": f\"已激活 {skill} 技能\" + (f\"，规则: {rule}\" if rule else \"\")\n  1006→        }\n  1007→\n  1008→    async def _handle_show_protocol_invitation(\n  1009→        self,\n  1010→        args: Dict[str, Any],\n  1011→        context: AgentContext\n  1012→    ) -> Dict[str, Any]:\n  1013→        \"\"\"\n  1014→        v9: 展示协议邀请卡片\n  1015→\n  1016→        直接返回卡片数据，前端渲染 ProtocolInvitationCard\n  1017→        \"\"\"\n  1018→        protocol_id = args.get(\"protocol_id\")\n  1019→        title = args.get(\"title\", \"\")\n  1020→        description = args.get(\"description\", \"\")\n  1021→        estimated_time = args.get(\"estimated_time\", \"10分钟\")\n  1022→        total_steps = args.get(\"total_steps\", 6)\n  1023→\n  1024→        if not protocol_id:\n  1025→            return {\"status\": \"error\", \"message\": \"No protocol_id specified\"}\n  1026→\n  1027→        # 协议元数据\n  1028→        protocol_meta = {\n  1029→            \"dankoe\": {\"title\": \"Dan Koe 快速重置\", \"description\": \"10分钟完成人生重置，通过反愿景驱动和身份转换实现快速转变\", \"time\": \"10分钟\", \"steps\": 6},\n  1030→            \"covey\": {\"title\": \"Covey 七个习惯\", \"description\": \"角色平衡与时间管理，找到生活的大石头\", \"time\": \"15分钟\", \"steps\": 8},\n  1031→            \"yangming\": {\"title\": \"王阳明心学\", \"description\": \"致良知与知行合一，找到内心的声音\", \"time\": \"12分钟\", \"steps\": 6},\n  1032→            \"liaofan\": {\"title\": \"了凡四训\", \"description\": \"立命改过积善，改变命运的实践方法\", \"time\": \"15分钟\", \"steps\": 7},\n  1033→        }\n  1034→\n  1035→        meta = protocol_meta.get(protocol_id, {})\n  1036→\n  1037→        logger.info(f\"[show_protocol_invitation] protocol_id={protocol_id}\")\n  1038→\n  1039→        return {\n  1040→            \"status\": \"success\",\n  1041→            \"card_type\": \"protocol_invitation\",\n  1042→            \"protocol_id\": protocol_id,\n  1043→            \"title\": title or meta.get(\"title\", protocol_id),\n  1044→            \"description\": description or meta.get(\"description\", \"\"),\n  1045→            \"estimated_time\": estimated_time or meta.get(\"time\", \"10分钟\"),\n  1046→            \"total_steps\": total_steps or meta.get(\"steps\", 6),\n  1047→        }\n  1048→\n  1049→    async def _handle_show_skill_intro(\n  1050→        self,\n  1051→        args: Dict[str, Any],\n  1052→        context: AgentContext\n  1053→    ) -> Dict[str, Any]:\n  1054→        \"\"\"\n  1055→        v9: 展示 Skill 介绍卡片\n  1056→        \"\"\"\n  1057→        skill_id = args.get(\"skill\")\n  1058→        reason = args.get(\"reason\", \"功能介绍\")\n  1059→\n  1060→        if not skill_id:\n  1061→            return {\"status\": \"error\", \"message\": \"No skill specified\"}\n  1062→\n  1063→        skill = load_skill(skill_id)\n  1064→        if not skill:\n  1065→            return {\"status\": \"error\", \"message\": f\"Skill {skill_id} not found\"}\n  1066→\n  1067→        logger.info(f\"[show_skill_intro] skill={skill_id}, reason={reason}\")\n  1068→\n  1069→        return {\n  1070→            \"status\": \"success\",\n  1071→            \"card_type\": \"skill_intro\",\n  1072→            \"skill_id\": skill_id,\n  1073→            \"name\": skill.name,\n  1074→            \"description\": skill.description,\n  1075→            \"triggers\": skill.triggers[:5] if skill.triggers else [],\n  1076→            \"reason\": reason,\n  1077→        }\n  1078→\n  1079→    async def _handle_recommend_skills(\n  1080→        self,\n  1081→        args: Dict[str, Any],\n  1082→        context: AgentContext\n  1083→    ) -> Dict[str, Any]:\n  1084→        \"\"\"\n  1085→        v9: 推荐相关 Skills\n  1086→        \"\"\"\n  1087→        skills = args.get(\"skills\", [])\n  1088→        reason = args.get(\"reason\", \"\")\n  1089→\n  1090→        if not skills:\n  1091→            return {\"status\": \"error\", \"message\": \"No skills specified\"}\n  1092→\n  1093→        # 获取每个 skill 的信息\n  1094→        skill_infos = []\n  1095→        for skill_id in skills:\n  1096→            skill = load_skill(skill_id)\n  1097→            if skill:\n  1098→                desc = skill.description\n  1099→                if \"触发词\" in desc:\n  1100→                    desc = desc.split(\"触发词\")[0].strip().rstrip(\"。\")\n  1101→                skill_infos.append({\n  1102→                    \"id\": skill_id,\n  1103→                    \"name\": skill.name,\n  1104→                    \"description\": desc[:100] if len(desc) > 100 else desc,\n  1105→                })\n  1106→\n  1107→        logger.info(f\"[recommend_skills] skills={skills}, reason={reason}\")\n  1108→\n  1109→        return {\n  1110→            \"status\": \"success\",\n  1111→            \"card_type\": \"skill_recommendations\",\n  1112→            \"skills\": skill_infos,\n  1113→            \"reason\": reason,\n  1114→        }\n  1115→\n  1116→    async def _handle_use_skill(\n  1117→        self,\n  1118→        args: Dict[str, Any],\n  1119→        context: AgentContext\n  1120→    ) -> Dict[str, Any]:\n  1121→        \"\"\"\n  1122→        v9: 兼容旧的 use_skill 工具（逐步废弃）\n  1123→\n  1124→        内部转发到 _handle_activate_skill\n  1125→        \"\"\"\n  1126→        # 转换参数：scenario → rule\n  1127→        new_args = {\n  1128→            \"skill\": args.get(\"skill\"),\n  1129→            \"rule\": args.get(\"scenario\"),\n  1130→        }\n  1131→        return await self._handle_activate_skill(new_args, context)\n  1132→\n  1133→\n  1134→def create_agent(\n  1135→    llm: Optional[LLMClient] = None,\n  1136→    max_iterations: int = 10\n  1137→) -> CoreAgent:\n  1138→    \"\"\"创建 CoreAgent 实例\"\"\"\n  1139→    return CoreAgent(llm=llm, max_iterations=max_iterations)\n  1140→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8fec6fc4-fcbb-4859-9415-613411eef508","timestamp":"2026-01-20T17:17:14.837Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/agent/core.py","content":"\"\"\"\nCoreAgent v9 - Agentic 架构重构\n\nv9 架构特性：\n- Phase 1 提供所有路由工具，LLM 一次性决策\n- 移除 Python 硬编码决策逻辑（confidence/birth_info 判断）\n- 工具即行为：activate_skill, show_protocol_invitation, show_skill_intro, recommend_skills\n- scenario → rule 概念统一（进行中）\n\nv8 架构特性（保留）：\n- 分阶段上下文加载：Phase 1 (Skill 选择) / Phase 2 (Skill 执行)\n- use_skill 同轮重载：激活 skill 后同一轮内重新构建上下文\n- 历史消息从数据库获取（不依赖前端传入）\n- Case 倒排索引匹配\n- LLM 驱动的 SOP 执行\n\"\"\"\nimport json\nimport logging\nimport time\nfrom typing import Optional, List, Dict, Any, AsyncGenerator\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nfrom services.llm import LLMClient, get_llm_client\nfrom services.llm.client import LLMMessage\nfrom .case_index import get_case_index, extract_features, CaseIndex\nfrom .skill_loader import (\n    load_skill, get_skill_triggers,\n    build_system_prompt,\n    get_available_skills, get_skill_scenarios,\n    skill_requires_birth_info,\n    skill_requires_compute,\n    get_skill_compute_type,\n    get_skill_compute_tool,\n    get_skill_collect_tool,\n    load_rule, get_skill_rules,\n)\nfrom .tool_registry import ToolRegistry, ToolContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass AgentState(str, Enum):\n    \"\"\"Agent 执行状态\"\"\"\n    IDLE = \"idle\"\n    THINKING = \"thinking\"\n    TOOL_CALLING = \"tool_calling\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n\n\n@dataclass\nclass AgentEvent:\n    \"\"\"Agent 执行事件\"\"\"\n    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase\n    data: Any = None\n\n\n@dataclass\nclass AgentContext:\n    \"\"\"Agent 执行上下文\n\n    v8 更新：\n    - 删除 portrait 和 recent_insights（已废弃，数据从 profile.extracted 获取）\n    - history 从数据库获取，不再依赖前端传入\n    - profile 和 skill_data 分阶段加载\n    - 新增 protocol_prompt 支持协议模式\n    \"\"\"\n    user_id: str\n    user_tier: str = \"free\"\n    profile: Optional[Dict[str, Any]] = None      # Phase 2 才加载\n    skill_data: Optional[Dict[str, Any]] = None   # Phase 2 才加载，只含当前 skill\n    history: Optional[List[Dict[str, str]]] = None  # 从数据库获取\n    skill: Optional[str] = None\n    scenario: Optional[str] = None\n    conversation_id: Optional[str] = None\n    voice_mode: Optional[str] = \"warm\"\n    protocol_prompt: Optional[str] = None  # 协议模式专用 prompt\n\n\ndef build_phase1_tools() -> List[Dict[str, Any]]:\n    \"\"\"\n    构建 Phase 1 路由工具集 - v9: Agentic 重构\n\n    v9 架构：\n    - 所有路由工具在 Phase 1 提供，LLM 一次性决策\n    - 移除 Python 硬编码决策逻辑，让 LLM 自己判断\n    - 工具即行为：每个用户意图对应一个工具\n\n    工具列表：\n    1. activate_skill - 激活 skill 并切换上下文\n    2. show_protocol_invitation - 展示协议邀请卡片（lifecoach 专用）\n    3. show_skill_intro - 展示 skill 介绍卡片\n    4. recommend_skills - 推荐相关 skills\n    \"\"\"\n    available_skills = [s for s in get_available_skills() if s != \"core\"]\n\n    # 构建 Skill 描述（用于 activate_skill 工具）\n    skill_descriptions = []\n    for skill_id in available_skills:\n        skill = load_skill(skill_id)\n        if skill:\n            desc = skill.description\n            if \"触发词\" in desc:\n                desc = desc.split(\"触发词\")[0].strip().rstrip(\"。\")\n            if len(desc) > 80:\n                desc = desc[:80] + \"...\"\n            triggers = \"、\".join(skill.triggers[:3]) if skill.triggers else \"\"\n            skill_descriptions.append(f\"- {skill_id}: {desc}（{triggers}）\")\n\n    skill_list_text = \"\\n\".join(skill_descriptions)\n\n    # 工具 1: activate_skill - 激活专业技能\n    activate_skill_tool = {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"activate_skill\",\n            \"description\": f\"\"\"激活专业技能来回答用户问题。\n\n## 可用技能\n{skill_list_text}\n\n## 何时调用\n- 用户明确需要某个专业领域的帮助\n- 用户提到了技能相关的关键词\n\n## 示例\n- 用户说\"帮我算算命\" → activate_skill(skill=\"bazi\")\n- 用户说\"看看我的星盘\" → activate_skill(skill=\"zodiac\")\n- 用户说\"我想做职业规划\" → activate_skill(skill=\"career\")\"\"\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"skill\": {\n                        \"type\": \"string\",\n                        \"enum\": available_skills,\n                        \"description\": \"要激活的技能 ID\"\n                    },\n                    \"rule\": {\n                        \"type\": \"string\",\n                        \"description\": \"可选的规则 ID，用于指定具体场景\"\n                    }\n                },\n                \"required\": [\"skill\"]\n            }\n        }\n    }\n\n    # 工具 2: show_protocol_invitation - 展示协议邀请卡片\n    show_protocol_invitation_tool = {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"show_protocol_invitation\",\n            \"description\": \"\"\"展示协议邀请卡片，引导用户进入结构化协议流程。\n\n## 可用协议\n| protocol_id | 名称 | 适用场景 | 时长 |\n|-------------|------|---------|------|\n| dankoe | Dan Koe 快速重置 | 迷茫、想改变、人生重构 | 10分钟 |\n| covey | Covey 七个习惯 | 角色平衡、时间管理、周计划 | 15分钟 |\n| yangming | 王阳明心学 | 知行不一、内心冲突、致良知 | 12分钟 |\n| liaofan | 了凡四训 | 改变命运、积善改过、功过格 | 15分钟 |\n\n## 何时调用（必须！）\n- 用户说\"人生重构\"、\"快速重置\"、\"帮我用 Dan Koe 方法\" → dankoe\n- 用户说\"七个习惯\"、\"角色平衡\"、\"大石头\" → covey\n- 用户说\"知行合一\"、\"致良知\"、\"王阳明\" → yangming\n- 用户说\"改命\"、\"功过格\"、\"了凡四训\" → liaofan\n\n## 重要\n匹配到协议关键词时，必须调用此工具！不要用文字描述协议内容！\"\"\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"protocol_id\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"dankoe\", \"covey\", \"yangming\", \"liaofan\"],\n                        \"description\": \"协议 ID\"\n                    },\n                    \"title\": {\n                        \"type\": \"string\",\n                        \"description\": \"协议标题，如 'Dan Koe 快速重置'\"\n                    },\n                    \"description\": {\n                        \"type\": \"string\",\n                        \"description\": \"协议描述，一句话说明价值\"\n                    },\n                    \"estimated_time\": {\n                        \"type\": \"string\",\n                        \"description\": \"预计时长，如 '10分钟'\"\n                    },\n                    \"total_steps\": {\n                        \"type\": \"integer\",\n                        \"description\": \"总步骤数\"\n                    }\n                },\n                \"required\": [\"protocol_id\", \"title\", \"description\"]\n            }\n        }\n    }\n\n    # 工具 3: show_skill_intro - 展示 skill 介绍卡片\n    show_skill_intro_tool = {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"show_skill_intro\",\n            \"description\": \"\"\"展示 Skill 介绍卡片，帮助用户了解功能。\n\n## 何时调用\n- 用户首次使用某个 Skill\n- 用户问\"这个能做什么\"、\"有什么功能\"\n- 只确定 skill 但不确定具体需求\n\n## 示例\n- 用户说\"lifecoach 是什么\" → show_skill_intro(skill=\"lifecoach\")\n- 用户说\"我想了解八字\" → show_skill_intro(skill=\"bazi\")\"\"\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"skill\": {\n                        \"type\": \"string\",\n                        \"enum\": available_skills,\n                        \"description\": \"要介绍的技能 ID\"\n                    },\n                    \"reason\": {\n                        \"type\": \"string\",\n                        \"description\": \"展示原因，如 '首次使用'、'功能介绍'\"\n                    }\n                },\n                \"required\": [\"skill\"]\n            }\n        }\n    }\n\n    # 工具 4: recommend_skills - 推荐相关 skills\n    recommend_skills_tool = {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"recommend_skills\",\n            \"description\": \"\"\"推荐相关的 Skills，帮助用户选择。\n\n## 何时调用\n- 不确定用户想用哪个 skill\n- 用户的需���可能涉及多个 skill\n- 用户说\"帮帮我\"、\"有什么推荐\"\n\n## 示例\n- 用户说\"我最近不太顺\" → recommend_skills(skills=[\"bazi\", \"lifecoach\"], reason=\"...\")\"\"\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"skills\": {\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\", \"enum\": available_skills},\n                        \"description\": \"推荐的技能列表（2-3个）\"\n                    },\n                    \"reason\": {\n                        \"type\": \"string\",\n                        \"description\": \"推荐理由\"\n                    }\n                },\n                \"required\": [\"skills\", \"reason\"]\n            }\n        }\n    }\n\n    return [\n        activate_skill_tool,\n        show_protocol_invitation_tool,\n        show_skill_intro_tool,\n        recommend_skills_tool\n    ]\n\n\n# 缓存动态生成的工具定义\n_PHASE1_TOOLS_CACHE: Optional[List[Dict[str, Any]]] = None\n\n\ndef get_phase1_tools() -> List[Dict[str, Any]]:\n    \"\"\"获取 Phase 1 工具定义（带缓存）\"\"\"\n    global _PHASE1_TOOLS_CACHE\n    if _PHASE1_TOOLS_CACHE is None:\n        _PHASE1_TOOLS_CACHE = build_phase1_tools()\n    return _PHASE1_TOOLS_CACHE\n\n\nclass CoreAgent:\n    \"\"\"\n    CoreAgent v8 - 分阶段渐进式加载的智能体\n\n    Features:\n    - 分阶段上下文加载：Phase 1 轻量，Phase 2 完整\n    - use_skill 同轮重载：激活后立即重新构建上下文\n    - Case 倒排索引匹配（替代向量检索）\n    - LLM 驱动的 SOP 执行\n    - Tool-card mapping\n    \"\"\"\n\n    def __init__(\n        self,\n        llm: Optional[LLMClient] = None,\n        max_iterations: int = 10,\n        case_index: Optional[CaseIndex] = None\n    ):\n        self.llm = llm or get_llm_client()\n        self.max_iterations = max_iterations\n        self.case_index = case_index or get_case_index()\n        self.state = AgentState.IDLE\n        self._active_skill: Optional[str] = None\n        self._active_scenario: Optional[str] = None\n        self._topic: Optional[str] = None\n        self._current_message: str = \"\"\n        # v8: 用于同轮重载\n        self._context: Optional[AgentContext] = None\n        self._messages: Optional[List[LLMMessage]] = None\n        self._perf_log: Dict[str, Any] = {}  # v8: 初始化性能日志，避免 AttributeError\n\n    @property\n    def usage(self) -> Dict[str, int]:\n        \"\"\"获取 LLM 使用统计\"\"\"\n        return self.llm.usage\n\n    async def run(\n        self,\n        message: str,\n        context: AgentContext\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行 Agent 循环\"\"\"\n        self.state = AgentState.IDLE\n        self._current_message = message\n        self._context = context  # v8: 保存引用用于同轮重载\n        self._perf_log = {\"iterations\": 0, \"llm_calls\": [], \"phase\": \"phase1\" if not context.skill else \"phase2\"}\n\n        # 使用前端指定的 skill/scenario，或让 LLM 决定\n        if context.skill:\n            self._active_skill = context.skill\n            self._active_scenario = context.scenario or await self._route_scenario(context.skill, message)\n        else:\n            self._active_skill = None\n            self._active_scenario = None\n\n        # v7.2: 移除 SOPEngine，改为 LLM 驱动\n        # SOP 规则和状态将通过 System Prompt 传达给 LLM\n        # LLM 自主决定是否需要收集信息或计算\n        if self._active_skill:\n            # 计算当前状态，用于前端显示和 Prompt 构建\n            sop_status = self._compute_sop_status(context)\n\n            yield AgentEvent(type=\"sop_phase\", data={\n                \"skill\": self._active_skill,\n                \"scenario\": self._active_scenario,\n                \"status\": sop_status,\n                \"message\": \"LLM 驱动模式\"\n            })\n\n        # [PERF T6] 构建初始消息\n        t_prompt_start = time.time()\n        messages = await self._build_initial_messages(message, context)\n        self._messages = messages  # v8: 保存引用用于同轮重载\n        self._perf_log[\"prompt_build_ms\"] = int((time.time() - t_prompt_start) * 1000)\n        self._perf_log[\"system_prompt_len\"] = len(messages[0].content) if messages else 0\n        logger.info(f\"[PERF Agent] Prompt built: {self._perf_log['prompt_build_ms']}ms, len={self._perf_log['system_prompt_len']}, phase={self._perf_log['phase']}\")\n\n        for iteration in range(self.max_iterations):\n            self.state = AgentState.THINKING\n            yield AgentEvent(type=\"thinking\", data={\"iteration\": iteration})\n            self._perf_log[\"iterations\"] = iteration + 1\n\n            tools = self._get_current_tools(context)\n\n            try:\n                content_buffer = \"\"\n                tool_calls = []\n\n                # [PERF T7/T9] LLM 调用\n                t_llm_start = time.time()\n                first_token_time = None\n\n                async for chunk in self.llm.stream(\n                    messages=messages,\n                    tools=tools,\n                    tool_choice=None,\n                    user_tier=context.user_tier\n                ):\n                    # 记录首 token 时间\n                    if first_token_time is None:\n                        first_token_time = time.time()\n                        ttft = int((first_token_time - t_llm_start) * 1000)\n                        logger.info(f\"[PERF Agent] LLM #{iteration+1} TTFT: {ttft}ms\")\n\n                    if chunk[\"type\"] == \"content\":\n                        content_buffer += chunk[\"content\"]\n                        yield AgentEvent(type=\"content\", data={\"content\": chunk[\"content\"]})\n                    elif chunk[\"type\"] == \"tool_call\":\n                        tool_calls.append(chunk)\n\n                # [PERF] LLM 调用完成\n                llm_total = int((time.time() - t_llm_start) * 1000)\n                self._perf_log[\"llm_calls\"].append({\n                    \"iteration\": iteration + 1,\n                    \"ttft_ms\": int((first_token_time - t_llm_start) * 1000) if first_token_time else 0,\n                    \"total_ms\": llm_total,\n                    \"has_tools\": len(tool_calls) > 0\n                })\n                logger.info(f\"[PERF Agent] LLM #{iteration+1} total: {llm_total}ms, tools={len(tool_calls)}\")\n\n                if tool_calls:\n                    self.state = AgentState.TOOL_CALLING\n\n                    assistant_tool_calls = []\n                    for tc in tool_calls:\n                        assistant_tool_calls.append({\n                            \"id\": tc[\"tool_call_id\"],\n                            \"function\": {\n                                \"name\": tc[\"tool_name\"],\n                                \"arguments\": tc[\"tool_args\"]\n                            }\n                        })\n                    messages.append(LLMMessage(\n                        role=\"assistant\",\n                        content=content_buffer or \"\",\n                        tool_calls=assistant_tool_calls\n                    ))\n                    content_buffer = \"\"\n\n                    # [PERF T8] 工具执行\n                    t_tools_start = time.time()\n                    tool_results = []\n                    for tc in tool_calls:\n                        tool_name = tc[\"tool_name\"]\n                        tool_args = tc[\"tool_args\"]\n                        tool_call_id = tc[\"tool_call_id\"]\n\n                        yield AgentEvent(type=\"tool_call\", data={\n                            \"id\": tool_call_id,\n                            \"name\": tool_name,\n                            \"arguments\": tool_args\n                        })\n\n                        t_tool_start = time.time()\n                        result = await self._execute_tool(tool_name, tool_args, context)\n                        tool_exec_ms = int((time.time() - t_tool_start) * 1000)\n                        logger.info(f\"[PERF Agent] Tool {tool_name}: {tool_exec_ms}ms\")\n\n                        tool_results.append({\n                            \"tool_call_id\": tool_call_id,\n                            \"result\": result\n                        })\n\n                        yield AgentEvent(type=\"tool_result\", data={\n                            \"id\": tool_call_id,\n                            \"name\": tool_name,\n                            \"result\": result\n                        })\n\n                    tools_total = int((time.time() - t_tools_start) * 1000)\n                    logger.info(f\"[PERF Agent] All tools: {tools_total}ms\")\n\n                    for tr in tool_results:\n                        result_content = tr[\"result\"]\n                        if isinstance(result_content, dict):\n                            result_content = json.dumps(result_content, ensure_ascii=False)\n                        messages.append(LLMMessage(\n                            role=\"tool\",\n                            content=str(result_content),\n                            tool_call_id=tr[\"tool_call_id\"]\n                        ))\n                else:\n                    self.state = AgentState.COMPLETED\n                    logger.info(f\"[PERF Agent] Done: {self._perf_log}\")\n                    yield AgentEvent(type=\"done\", data={\"content\": content_buffer})\n                    return\n\n            except Exception as e:\n                self.state = AgentState.ERROR\n                logger.error(f\"Agent error: {e}\")\n                yield AgentEvent(type=\"error\", data={\"error\": str(e)})\n                return\n\n        self.state = AgentState.COMPLETED\n        yield AgentEvent(type=\"done\", data={\"max_iterations_reached\": True})\n\n    def _filter_valid_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"\n        过滤历史消息，确保 tool 消息配对完整。\n\n        Anthropic API 要求每个 tool_result 必须有对应的 tool_use。\n        如果历史消息不完整（如只有 tool 消息没有对应的 assistant tool_calls），\n        需要过滤掉这些孤立的消息。\n        \"\"\"\n        if not history:\n            return []\n\n        # 收集所有有效的 tool_call_ids（来自 assistant 的 tool_calls）\n        valid_tool_ids = set()\n        for msg in history:\n            if msg.get(\"role\") == \"assistant\" and msg.get(\"tool_calls\"):\n                for tc in msg[\"tool_calls\"]:\n                    tc_id = tc.get(\"id\")\n                    if tc_id:\n                        valid_tool_ids.add(tc_id)\n\n        # 过滤消息\n        filtered = []\n        for msg in history:\n            role = msg.get(\"role\", \"user\")\n\n            # tool 消息需要检查是否有对应的 tool_use\n            if role == \"tool\":\n                tool_call_id = msg.get(\"tool_call_id\")\n                if tool_call_id and tool_call_id in valid_tool_ids:\n                    filtered.append(msg)\n                else:\n                    # 孤立的 tool 消息，跳过\n                    logger.warning(f\"Skipping orphan tool message: {tool_call_id}\")\n            else:\n                # user/assistant 消息直接保留\n                filtered.append(msg)\n\n        return filtered\n\n    async def _route_scenario(self, skill_id: str, message: str) -> Optional[str]:\n        \"\"\"场景路由 - 基于 tags 匹配最佳 rule\n\n        v8.1: 实现 tags 匹配路由\n        1. 遍历 skill 的所有 rules\n        2. 检查 message 是否包含 rule 的 tags\n        3. 返回匹配的 rule，或默认 scenario\n        \"\"\"\n        skill = load_skill(skill_id)\n        if not skill:\n            return None\n\n        # 获取所有 rules\n        rules = get_skill_rules(skill_id)\n        if not rules:\n            return skill.default_scenario\n\n        message_lower = message.lower()\n\n        # 遍历 rules，检查 tags 匹配\n        for rule_id in rules:\n            rule = load_rule(skill_id, rule_id)\n            if rule and rule.tags:\n                for tag in rule.tags:\n                    if tag.lower() in message_lower:\n                        logger.info(f\"[Scenario] Matched rule '{rule_id}' via tag '{tag}'\")\n                        return rule_id\n\n        return skill.default_scenario\n\n    async def _build_initial_messages(\n        self,\n        message: str,\n        context: AgentContext\n    ) -> List[LLMMessage]:\n        \"\"\"构建初始消息列表\"\"\"\n        system_prompt = await self._build_system_prompt(message, context)\n\n        messages = [LLMMessage(role=\"system\", content=system_prompt)]\n\n        if context.history:\n            # 过滤并验证历史消息，确保 tool 消息配对完整\n            filtered_history = self._filter_valid_history(context.history[-10:])\n            for msg in filtered_history:\n                messages.append(LLMMessage(\n                    role=msg.get(\"role\", \"user\"),\n                    content=msg.get(\"content\", \"\"),\n                    tool_call_id=msg.get(\"tool_call_id\"),\n                    tool_calls=msg.get(\"tool_calls\")\n                ))\n\n        messages.append(LLMMessage(role=\"user\", content=message))\n        return messages\n\n    def _compute_sop_status(self, context: AgentContext) -> Dict[str, Any]:\n        \"\"\"\n        v7.2: 计算 SOP 状态（替代 SOPEngine）\n\n        返回当前状态信息，用于：\n        1. 前端显示\n        2. System Prompt 构建\n        \"\"\"\n        skill_id = self._active_skill\n\n        # 检查是否需要出生信息\n        needs_birth = skill_requires_birth_info(skill_id) if skill_id else False\n        birth_info = context.profile.get(\"birth_info\", {}) if context.profile else {}\n        has_birth = bool(\n            birth_info.get(\"birth_date\") or birth_info.get(\"date\")\n        )\n\n        # 检查是否需要计算\n        needs_compute = skill_requires_compute(skill_id) if skill_id else False\n        compute_type = get_skill_compute_type(skill_id) if skill_id else None\n        actual_compute_type = compute_type or skill_id\n\n        # 检查是否有命盘数据\n        has_chart = False\n        if context.skill_data and actual_compute_type:\n            skill_data = context.skill_data.get(actual_compute_type, {})\n            # 通用检查：chart 或 cards\n            has_chart = bool(skill_data.get(\"chart\") or skill_data.get(\"cards\"))\n\n        return {\n            \"skill_id\": skill_id,\n            \"needs_birth_info\": needs_birth,\n            \"has_birth_info\": has_birth,\n            \"needs_compute\": needs_compute,\n            \"has_chart_data\": has_chart,\n            \"compute_type\": actual_compute_type,\n            \"ready_for_analysis\": (not needs_birth or has_birth) and (not needs_compute or has_chart)\n        }\n\n    def _build_sop_rules(self, context: AgentContext) -> str:\n        \"\"\"\n        v7.2: 构建 SOP 规则（替代 SOPEngine）\n\n        将 SOP 规则通过 System Prompt 传达给 LLM，\n        让 LLM 自主决定执行流程。\n        \"\"\"\n        skill_id = self._active_skill\n        if not skill_id:\n            return \"\"\n\n        # 获取配置\n        needs_birth = skill_requires_birth_info(skill_id)\n        needs_compute = skill_requires_compute(skill_id)\n        compute_type = get_skill_compute_type(skill_id) or skill_id\n\n        # 计算当前状态\n        status = self._compute_sop_status(context)\n\n        rules = \"\\n## SOP 执行规则（必须遵守）\\n\\n\"\n\n        # P1: 信息收集\n        if needs_birth:\n            if not status[\"has_birth_info\"]:\n                # v7.3: 从 SKILL.md 配置读取 collect_tool，不再硬编码\n                collect_tool = get_skill_collect_tool(skill_id)\n                if not collect_tool:\n                    # 默认约定：request_info\n                    collect_tool = \"request_info\"\n\n                rules += f\"\"\"### P1: 信息收集 ⚠️ 需要执行\n用户尚未提供出生信息。你必须：\n1. 首先调用 `{collect_tool}` 工具展示收集表单\n2. 不要用文字询问，必须使用工具\n3. 收集到信息后再进行下一步\n\n\"\"\"\n            else:\n                rules += \"\"\"### P1: 信息收集 ✅ 已完成\n用户已提供出生信息。\n\n\"\"\"\n\n        # P2: 计算排盘\n        if needs_compute:\n            if not status[\"has_chart_data\"]:\n                # v7.3: 从 SKILL.md 配置读取 compute_tool，不再硬编码\n                compute_tool = get_skill_compute_tool(skill_id)\n                if not compute_tool:\n                    # 默认约定：calculate_{compute_type}\n                    compute_tool = f\"calculate_{compute_type}\"\n\n                rules += f\"\"\"### P2: 计算排盘 ⚠️ 需要执行\n用户尚未有命盘数据。你必须：\n1. 调用 `{compute_tool}` 工具生成命盘数据\n2. 计算完成后再进行分析\n\n\"\"\"\n            else:\n                rules += \"\"\"### P2: 计算排盘 ✅ 已完成\n用户已有命盘数据。\n\n\"\"\"\n\n        # P3-P7: LLM 自由发挥\n        rules += \"\"\"### P3-P7: 分析与输出\n完成信息收集和计算后，按以下流程执行：\n1. **扫描**: 快速识别命盘中的关键模式和特征\n2. **追问**: 根据需要向用户提出针对性问题\n3. **分析**: 深度分析，结合知识库检索结果\n4. **输出**: 调用展示工具（show_xxx）呈现分析结果\n5. **讨论**: 回答用户的追问\n\n\"\"\"\n\n        # 当前状态摘要\n        rules += \"### 当前状态\\n\"\n        rules += f\"- 出生信息: {'✅ 已有' if status['has_birth_info'] else '❌ 未收集'}\\n\"\n        rules += f\"- 命盘数据: {'✅ 已计算' if status['has_chart_data'] else '❌ 未计算'}\\n\"\n        rules += f\"- 可以分析: {'✅ 是' if status['ready_for_analysis'] else '❌ 否，请先完成上述步骤'}\\n\"\n\n        return rules\n\n    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:\n        \"\"\"\n        构建 System Prompt - v8: 分阶段加载\n\n        Phase 1 (无 skill): 轻量级 prompt，只包含 Core 人格和 use_skill 工具\n        Phase 2 (有 skill): 完整 prompt，包含专家身份、SOP、Cases、用户数据\n        Protocol Mode: 使用协议专用 prompt\n        \"\"\"\n        parts = []\n\n        # ═══════════════════════════════════════════════════════════════\n        # 协议模式：使用协议专用 prompt\n        # ═══════════════════════════════════════════════════════════════\n        if context.protocol_prompt:\n            # 协议模式下，使用 chat_v5.py 构建的 protocol_prompt\n            # 加上基础的 lifecoach 人格\n            skill = load_skill(\"lifecoach\")\n            if skill:\n                parts.append(f\"# {skill.name}\\n\\n{skill.expert_persona}\")\n            parts.append(\"\\n---\\n\")\n            parts.append(context.protocol_prompt)\n            return \"\\n\".join(parts)\n\n        if self._active_skill:\n            # ═══════════════════════════════════════════════════════════════\n            # Phase 2: Skill 执行阶段 - 完整上下文\n            # ═══════════════════════════════════════════════════════════════\n\n            # 传递完整 profile，让 skill_loader 自动处理所有字段\n            user_ctx = dict(context.profile) if context.profile else {}\n            base_prompt = build_system_prompt(\n                self._active_skill,\n                self._active_scenario,\n                user_ctx\n            )\n            parts.append(base_prompt)\n\n            # v7.2: 添加 SOP 规则（替代 SOPEngine）\n            sop_rules = self._build_sop_rules(context)\n            if sop_rules:\n                parts.append(sop_rules)\n\n            # v7: 案例匹配 - 使用倒排索引（只在 Phase 2 执行）\n            try:\n                if context.skill_data:\n                    features = extract_features(context.skill_data)\n                    if features:\n                        cases = await self.case_index.get_matched_cases(\n                            self._active_skill,\n                            features,\n                            top_k=2\n                        )\n                        if cases:\n                            cases_text = \"\\n## 相关案例\\n\\n\"\n                            for case in cases:\n                                cases_text += f\"### {case.name}\\n{case.content}\\n\\n\"\n                            parts.append(cases_text)\n            except Exception as e:\n                logger.warning(f\"Case matching failed: {e}\")\n\n            # 用户数据（使用 compute_type 读取，支持跨 skill 复用）\n            if context.skill_data:\n                compute_type = get_skill_compute_type(self._active_skill) or self._active_skill\n                skill_data = context.skill_data.get(compute_type, {})\n                if skill_data:\n                    parts.append(f\"\\n## 用户数据\\n{json.dumps(skill_data, ensure_ascii=False, indent=2)}\")\n\n        else:\n            # ═══════════════════════════════════════════════════════════════\n            # Phase 1: Skill 选择阶段 - v9 Agentic 重构\n            # ═══════════════════════════════════════════════════════════════\n\n            core_prompt = \"\"\"# Vibe - 生命对话者\n\n你是 Vibe，一个生命对话者。你的任务是理解用户意图，并调用合适的工具。\n\n## 你的能力\n- 深度倾听和情绪感知\n- 理解用户的真实需求\n- 调用工具激活专业技能或展示卡片\n\n## 工具调用规则（必须遵守！）\n\n**重要：识别到用户意图后，必须立即调用对应工具，不要用文字回复。**\n\n### 协议类（优先匹配 - lifecoach 专属）\n\n| 用户说 | 必须调用 |\n|-------|---------|\n| 人生重构、Dan Koe、快速重置、迷茫想改变 | `show_protocol_invitation(protocol_id=\"dankoe\", title=\"Dan Koe 快速重置\", description=\"10分钟完成人生重置\", estimated_time=\"10分钟\", total_steps=6)` |\n| Covey、七个习惯、角色平衡、大石头、周计划 | `show_protocol_invitation(protocol_id=\"covey\", title=\"Covey 七个习惯\", description=\"角色平衡与时间管理\", estimated_time=\"15分钟\", total_steps=8)` |\n| 王阳明、心学、知行合一、致良知 | `show_protocol_invitation(protocol_id=\"yangming\", title=\"王阳明心学\", description=\"致良知与知行合一\", estimated_time=\"12分钟\", total_steps=6)` |\n| 了凡四训、改命、功过格、积善 | `show_protocol_invitation(protocol_id=\"liaofan\", title=\"了凡四训\", description=\"立命改过积善\", estimated_time=\"15分钟\", total_steps=7)` |\n\n### Skill 类\n\n| 用户说 | 必须调用 |\n|-------|---------|\n| 八字、命理、生辰、算命、看命 | `activate_skill(skill=\"bazi\")` |\n| 星座、星盘、占星、上升、月亮 | `activate_skill(skill=\"zodiac\")` |\n| 塔罗、牌阵、占卜、抽牌 | `activate_skill(skill=\"tarot\")` |\n| 职业、工作、跳槽、面试、简历 | `activate_skill(skill=\"career\")` |\n| 人生规划、目标、习惯（非协议关键词） | `activate_skill(skill=\"lifecoach\")` |\n\n### 不确定时\n\n| 情况 | 必须调用 |\n|-----|---------|\n| 用户问\"这个能做什么\"、想了解功能 | `show_skill_intro(skill=\"xxx\")` |\n| 不确定用哪个 skill | `recommend_skills(skills=[\"xxx\", \"yyy\"], reason=\"...\")` |\n\n### 示例\n\n1. 用户: \"帮我用 Dan Koe 方法做一次人生重置\"\n   → 调用 `show_protocol_invitation(protocol_id=\"dankoe\", ...)`\n\n2. 用户: \"我想算算命\"\n   → 调用 `activate_skill(skill=\"bazi\")`\n\n3. 用户: \"lifecoach 有什么功能\"\n   → 调用 `show_skill_intro(skill=\"lifecoach\")`\n\n4. 用户: \"我最近很迷茫\"\n   → 调用 `show_protocol_invitation(protocol_id=\"dankoe\", ...)` （迷茫 = 协议关键词）\n\n5. 用户: \"帮帮我\"\n   → 可以直接对话探索，或调用 `recommend_skills`\n\n## 对话原则\n\n- 如果用户只是打招呼或闲聊，可以直接回复，不需要调用工具\n- 如果用户表达了具体困境但没有明确要求，可以先共情再探索\n- 一旦识别到专业需求或协议关键词，必须调用工具\n\"\"\"\n            parts.append(core_prompt)\n\n        return \"\\n\".join(parts)\n\n    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取当前可用工具 - v9.1: SOP 工具集限制\n\n        Phase 1 (无 skill): 返回所有路由工具\n        Phase 2 (有 skill): 根据 SOP 状态返回受限工具集\n          - P1 阶段（需要收集信息）: 只返回收集工具\n          - P2 阶段（需要计算）: 只返回计算工具\n          - P3+ 阶段（可以分析）: 返回完整工具集\n        \"\"\"\n        if not context.skill and not self._active_skill:\n            # Phase 1: 返回所有路由工具（LLM 一次性决策）\n            return get_phase1_tools()\n\n        skill_id = self._active_skill or context.skill\n\n        # 计算 SOP 状态\n        status = self._compute_sop_status(context)\n\n        # ═══════════════════════════════════════════════════════════════\n        # v9.1: SOP 工具集限制 - 用工具集强制 SOP 流程\n        # ═══════════════════════════════════════════════════════════════\n\n        # P1: 需要收集信息但尚未收集 → 只提供收集工具\n        if status[\"needs_birth_info\"] and not status[\"has_birth_info\"]:\n            collect_tool_name = get_skill_collect_tool(skill_id) or \"request_info\"\n            tool_def = ToolRegistry.get_tool_def(collect_tool_name)\n            if tool_def:\n                logger.info(f\"[SOP] P1 阶段: 只提供收集工具 {collect_tool_name}\")\n                return [tool_def.to_openai_format()]\n            # fallback: 如果找不到收集工具，返回完整工具集\n            logger.warning(f\"[SOP] 收集工具 {collect_tool_name} 未找到，返回完整���具集\")\n\n        # P2: 需要计算但尚未计算 → 只提供计算工具\n        if status[\"needs_compute\"] and not status[\"has_chart_data\"]:\n            compute_type = get_skill_compute_type(skill_id) or skill_id\n            compute_tool_name = get_skill_compute_tool(skill_id) or f\"calculate_{compute_type}\"\n            tool_def = ToolRegistry.get_tool_def(compute_tool_name)\n            if tool_def:\n                logger.info(f\"[SOP] P2 阶段: 只提供计算工具 {compute_tool_name}\")\n                return [tool_def.to_openai_format()]\n            # fallback: 如果找不到计算工具，返回完整工具集\n            logger.warning(f\"[SOP] 计算工具 {compute_tool_name} 未找到，返回完整工具集\")\n\n        # P3+: 可以分析 → 返回完整工具集\n        tools = ToolRegistry.get_tools_for_skill(skill_id)\n        return tools if tools else get_phase1_tools()\n\n    async def _execute_tool(\n        self,\n        tool_name: str,\n        tool_args: str,\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"执行工具调用 - v9: 支持新的路由工具\"\"\"\n        try:\n            args = json.loads(tool_args) if tool_args else {}\n        except json.JSONDecodeError:\n            args = {}\n\n        # ═══════════════════════════════════════════════════════════════\n        # v9: Phase 1 路由工具处理\n        # ═══════════════════════════════════════════════════════════════\n\n        # 工具 1: activate_skill - 激活 skill\n        if tool_name == \"activate_skill\":\n            return await self._handle_activate_skill(args, context)\n\n        # 工具 2: show_protocol_invitation - 展示协议邀请（直接返回卡片数据）\n        if tool_name == \"show_protocol_invitation\":\n            return await self._handle_show_protocol_invitation(args, context)\n\n        # 工具 3: show_skill_intro - 展示 skill 介绍（直接返回卡片数据）\n        if tool_name == \"show_skill_intro\":\n            return await self._handle_show_skill_intro(args, context)\n\n        # 工具 4: recommend_skills - 推荐 skills\n        if tool_name == \"recommend_skills\":\n            return await self._handle_recommend_skills(args, context)\n\n        # 兼容旧的 use_skill 工具（逐步废弃）\n        if tool_name == \"use_skill\":\n            return await self._handle_use_skill(args, context)\n\n        # 创建工具上下文\n        tool_context = ToolContext(\n            user_id=context.user_id,\n            user_tier=context.user_tier,\n            profile=context.profile or {},\n            skill_data=context.skill_data or {},\n            skill_id=self._active_skill,\n            scenario_id=self._active_scenario,\n            conversation_id=context.conversation_id\n        )\n\n        # 使用统一注册表执行工具\n        if ToolRegistry.has_handler(tool_name):\n            return await ToolRegistry.execute(tool_name, args, tool_context)\n\n        # 未找到处理器\n        logger.warning(f\"No handler found for tool: {tool_name}\")\n        return {\"status\": \"unknown_tool\", \"tool\": tool_name, \"message\": f\"工具 {tool_name} 暂未实现\"}\n\n    async def _handle_activate_skill(\n        self,\n        args: Dict[str, Any],\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"\n        v9: 激活 skill - 简化版，移除硬编码决策逻辑\n\n        只做一件事：切换上下文，让 LLM 继续决策\n        \"\"\"\n        skill = args.get(\"skill\")\n        rule = args.get(\"rule\")  # v9: scenario → rule\n\n        if not skill:\n            return {\"status\": \"error\", \"message\": \"No skill specified\"}\n\n        self._active_skill = skill\n\n        # 如果没有指定 rule，尝试自动匹配\n        if not rule and self._current_message:\n            rule = await self._route_scenario(skill, self._current_message)\n            logger.info(f\"[activate_skill] Auto-routed rule: {rule}\")\n\n        self._active_scenario = rule  # 内部仍用 _active_scenario，后续统一替换\n\n        # 同步 skill 到数据库\n        if self._context and self._context.conversation_id:\n            try:\n                from stores.conversation_repo import update_conversation_skill\n                from uuid import UUID\n                conv_id = UUID(self._context.conversation_id)\n                await update_conversation_skill(conv_id, skill)\n            except Exception as e:\n                logger.warning(f\"[activate_skill] Failed to sync skill to DB: {e}\")\n\n        # 动态加载该 skill 需要的数据\n        if self._context and self._context.user_id != \"guest\":\n            try:\n                from stores.profile_cache import get_cached_profile_with_skill\n                from uuid import UUID\n\n                user_id = UUID(self._context.user_id)\n                result = await get_cached_profile_with_skill(user_id, skill)\n\n                self._context.profile = result.get(\"profile\", {})\n                self._context.skill_data = result.get(\"skill_data\", {})\n\n                logger.info(f\"[activate_skill] Loaded profile for skill={skill}\")\n            except Exception as e:\n                logger.warning(f\"[activate_skill] Failed to load profile: {e}\")\n\n        # 重新构建 System Prompt\n        if self._messages:\n            new_system_prompt = await self._build_system_prompt(\n                self._current_message,\n                self._context\n            )\n            self._messages[0] = LLMMessage(role=\"system\", content=new_system_prompt)\n            self._perf_log[\"phase\"] = \"phase2\"\n            self._perf_log[\"system_prompt_reloaded\"] = True\n            logger.info(f\"[activate_skill] System prompt reloaded, len={len(new_system_prompt)}\")\n\n        return {\n            \"status\": \"activated\",\n            \"skill\": skill,\n            \"rule\": rule,\n            \"message\": f\"已激活 {skill} 技能\" + (f\"，规则: {rule}\" if rule else \"\")\n        }\n\n    async def _handle_show_protocol_invitation(\n        self,\n        args: Dict[str, Any],\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"\n        v9: 展示协议邀请卡片\n\n        直接返回卡片数据，前端渲染 ProtocolInvitationCard\n        \"\"\"\n        protocol_id = args.get(\"protocol_id\")\n        title = args.get(\"title\", \"\")\n        description = args.get(\"description\", \"\")\n        estimated_time = args.get(\"estimated_time\", \"10分钟\")\n        total_steps = args.get(\"total_steps\", 6)\n\n        if not protocol_id:\n            return {\"status\": \"error\", \"message\": \"No protocol_id specified\"}\n\n        # 协议元数据\n        protocol_meta = {\n            \"dankoe\": {\"title\": \"Dan Koe 快速重置\", \"description\": \"10分钟完成人生重置，通过反愿景驱动和身份转换实现快速转变\", \"time\": \"10分钟\", \"steps\": 6},\n            \"covey\": {\"title\": \"Covey 七个习惯\", \"description\": \"角色平衡与时间管理，找到生活的大石头\", \"time\": \"15分钟\", \"steps\": 8},\n            \"yangming\": {\"title\": \"王阳明心学\", \"description\": \"致良知与知行合一，找到内心的声音\", \"time\": \"12分钟\", \"steps\": 6},\n            \"liaofan\": {\"title\": \"了凡四训\", \"description\": \"立命改过积善，改变命运的实践方法\", \"time\": \"15分钟\", \"steps\": 7},\n        }\n\n        meta = protocol_meta.get(protocol_id, {})\n\n        logger.info(f\"[show_protocol_invitation] protocol_id={protocol_id}\")\n\n        return {\n            \"status\": \"success\",\n            \"card_type\": \"protocol_invitation\",\n            \"protocol_id\": protocol_id,\n            \"title\": title or meta.get(\"title\", protocol_id),\n            \"description\": description or meta.get(\"description\", \"\"),\n            \"estimated_time\": estimated_time or meta.get(\"time\", \"10分钟\"),\n            \"total_steps\": total_steps or meta.get(\"steps\", 6),\n        }\n\n    async def _handle_show_skill_intro(\n        self,\n        args: Dict[str, Any],\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"\n        v9: 展示 Skill 介绍卡片\n        \"\"\"\n        skill_id = args.get(\"skill\")\n        reason = args.get(\"reason\", \"功能介绍\")\n\n        if not skill_id:\n            return {\"status\": \"error\", \"message\": \"No skill specified\"}\n\n        skill = load_skill(skill_id)\n        if not skill:\n            return {\"status\": \"error\", \"message\": f\"Skill {skill_id} not found\"}\n\n        logger.info(f\"[show_skill_intro] skill={skill_id}, reason={reason}\")\n\n        return {\n            \"status\": \"success\",\n            \"card_type\": \"skill_intro\",\n            \"skill_id\": skill_id,\n            \"name\": skill.name,\n            \"description\": skill.description,\n            \"triggers\": skill.triggers[:5] if skill.triggers else [],\n            \"reason\": reason,\n        }\n\n    async def _handle_recommend_skills(\n        self,\n        args: Dict[str, Any],\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"\n        v9: 推荐相关 Skills\n        \"\"\"\n        skills = args.get(\"skills\", [])\n        reason = args.get(\"reason\", \"\")\n\n        if not skills:\n            return {\"status\": \"error\", \"message\": \"No skills specified\"}\n\n        # 获取每个 skill 的信息\n        skill_infos = []\n        for skill_id in skills:\n            skill = load_skill(skill_id)\n            if skill:\n                desc = skill.description\n                if \"触发词\" in desc:\n                    desc = desc.split(\"触发词\")[0].strip().rstrip(\"。\")\n                skill_infos.append({\n                    \"id\": skill_id,\n                    \"name\": skill.name,\n                    \"description\": desc[:100] if len(desc) > 100 else desc,\n                })\n\n        logger.info(f\"[recommend_skills] skills={skills}, reason={reason}\")\n\n        return {\n            \"status\": \"success\",\n            \"card_type\": \"skill_recommendations\",\n            \"skills\": skill_infos,\n            \"reason\": reason,\n        }\n\n    async def _handle_use_skill(\n        self,\n        args: Dict[str, Any],\n        context: AgentContext\n    ) -> Dict[str, Any]:\n        \"\"\"\n        v9: 兼容旧的 use_skill 工具（逐步废弃）\n\n        内部转发到 _handle_activate_skill\n        \"\"\"\n        # 转换参数：scenario → rule\n        new_args = {\n            \"skill\": args.get(\"skill\"),\n            \"rule\": args.get(\"scenario\"),\n        }\n        return await self._handle_activate_skill(new_args, context)\n\n\ndef create_agent(\n    llm: Optional[LLMClient] = None,\n    max_iterations: int = 10\n) -> CoreAgent:\n    \"\"\"创建 CoreAgent 实例\"\"\"\n    return CoreAgent(llm=llm, max_iterations=max_iterations)\n","numLines":1140,"startLine":1,"totalLines":1140}},"sourceToolAssistantUUID":"2e3f01f9-43ae-4a8d-810c-e0ff462cabf0"}
{"parentUuid":"8fec6fc4-fcbb-4859-9415-613411eef508","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_01L2todwLXGyo2FtCTRh2sq7","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The WebFetch redirected. Let me fetch from the correct URL.","signature":"EuUBCkgICxACGAIqQAXHtVIfoA5QF+Cb95SHqmr5PpcPkvUT0Vbur6qG47eBC0lTxgDRTbHaqacxsnWbq0EgGCTB9lgUxqHFWUMpvbgSDFeWjanJUrEQE8224hoMvUYFM5ClnKf4vGfNIjAt+BFOG6QAqwWelEfCinpdN7yKq5mGIQRE+niOqoRJH5YwUIgTgVMgUbCuLUHV5eUqSwehUpCgRmSj6D16L5bjB3fKh1+F1g9pV92z1Y5LQBSbR8Qjv3jtA/c2Jyvv4d4lCycvvFfYk44WchTqCOLAImyv32vJX8IITLIV6RgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":233,"cache_creation_input_tokens":18201,"cache_read_input_tokens":28226,"cache_creation":{"ephemeral_5m_input_tokens":18201,"ephemeral_1h_input_tokens":0},"output_tokens":5}},"requestId":"req_vrtx_011CXK1Xn3S4VC229trW9it6","type":"assistant","uuid":"caf583c1-f1c5-4cbc-906b-4d8fb424aa75","timestamp":"2026-01-20T17:17:25.586Z"}
{"parentUuid":"caf583c1-f1c5-4cbc-906b-4d8fb424aa75","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_01L2todwLXGyo2FtCTRh2sq7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_vrtx_01Pf3DSM4fYCi6YE38VNPbMj","name":"WebFetch","input":{"url":"https://platform.claude.com/docs/en/api/agent-sdk/python","prompt":"Extract the complete documentation for Python Agent SDK including: 1) Agent class initialization and configuration, 2) Agentic loop implementation and run method patterns, 3) Tool use and tool execution patterns, 4) Message history management, 5) State management, 6) Error handling patterns, 7) Best practices and recommendations"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":233,"cache_creation_input_tokens":18201,"cache_read_input_tokens":28226,"cache_creation":{"ephemeral_5m_input_tokens":18201,"ephemeral_1h_input_tokens":0},"output_tokens":5}},"requestId":"req_vrtx_011CXK1Xn3S4VC229trW9it6","type":"assistant","uuid":"957a466c-9465-4a1b-a90c-ac0c42f487ad","timestamp":"2026-01-20T17:17:26.681Z"}
{"parentUuid":"957a466c-9465-4a1b-a90c-ac0c42f487ad","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01Pf3DSM4fYCi6YE38VNPbMj","type":"tool_result","content":"# Agent SDK reference - Python\n\nComplete API reference for the Python Agent SDK, including all functions, types, and classes.\n\n---\n\n## Installation\n\n```bash\npip install claude-agent-sdk\n```\n\n## Choosing Between `query()` and `ClaudeSDKClient`\n\nThe Python SDK provides two ways to interact with Claude Code:\n\n### Quick Comparison\n\n| Feature             | `query()`                     | `ClaudeSDKClient`                  |\n| :------------------ | :---------------------------- | :--------------------------------- |\n| **Session**         | Creates new session each time | Reuses same session                |\n| **Conversation**    | Single exchange               | Multiple exchanges in same context |\n| **Connection**      | Managed automatically         | Manual control                     |\n| **Streaming Input** | ✅ Supported                  | ✅ Supported                       |\n| **Interrupts**      | ❌ Not supported              | ✅ Supported                       |\n| **Hooks**           | ❌ Not supported              | ✅ Supported                       |\n| **Custom Tools**    | ❌ Not supported              | ✅ Supported                       |\n| **Continue Chat**   | ❌ New session each time      | ✅ Maintains conversation          |\n| **Use Case**        | One-off tasks                 | Continuous conversations           |\n\n### When to Use `query()` (New Session Each Time)\n\n**Best for:**\n\n- One-off questions where you don't need conversation history\n- Independent tasks that don't require context from previous exchanges\n- Simple automation scripts\n- When you want a fresh start each time\n\n### When to Use `ClaudeSDKClient` (Continuous Conversation)\n\n**Best for:**\n\n- **Continuing conversations** - When you need Claude to remember context\n- **Follow-up questions** - Building on previous responses\n- **Interactive applications** - Chat interfaces, REPLs\n- **Response-driven logic** - When next action depends on Claude's response\n- **Session control** - Managing conversation lifecycle explicitly\n\n## Functions\n\n### `query()`\n\nCreates a new session for each interaction with Claude Code. Returns an async iterator that yields messages as they arrive. Each call to `query()` starts fresh with no memory of previous interactions.\n\n```python\nasync def query(\n    *,\n    prompt: str | AsyncIterable[dict[str, Any]],\n    options: ClaudeAgentOptions | None = None\n) -> AsyncIterator[Message]\n```\n\n#### Parameters\n\n| Parameter | Type                         | Description                                                                |\n| :-------- | :--------------------------- | :------------------------------------------------------------------------- |\n| `prompt`  | `str \\| AsyncIterable[dict]` | The input prompt as a string or async iterable for streaming mode          |\n| `options` | `ClaudeAgentOptions \\| None` | Optional configuration object (defaults to `ClaudeAgentOptions()` if None) |\n\n#### Returns\n\nReturns an `AsyncIterator[Message]` that yields messages from the conversation.\n\n#### Example - With options\n\n```python\n\nimport asyncio\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync def main():\n    options = ClaudeAgentOptions(\n        system_prompt=\"You are an expert Python developer\",\n        permission_mode='acceptEdits',\n        cwd=\"/home/user/project\"\n    )\n\n    async for message in query(\n        prompt=\"Create a Python web server\",\n        options=options\n    ):\n        print(message)\n\n\nasyncio.run(main())\n```\n\n### `tool()`\n\nDecorator for defining MCP tools with type safety.\n\n```python\ndef tool(\n    name: str,\n    description: str,\n    input_schema: type | dict[str, Any]\n) -> Callable[[Callable[[Any], Awaitable[dict[str, Any]]]], SdkMcpTool[Any]]\n```\n\n#### Parameters\n\n| Parameter      | Type                     | Description                                             |\n| :------------- | :----------------------- | :------------------------------------------------------ |\n| `name`         | `str`                    | Unique identifier for the tool                          |\n| `description`  | `str`                    | Human-readable description of what the tool does        |\n| `input_schema` | `type \\| dict[str, Any]` | Schema defining the tool's input parameters (see below) |\n\n#### Input Schema Options\n\n1. **Simple type mapping** (recommended):\n\n   ```python\n   {\"text\": str, \"count\": int, \"enabled\": bool}\n   ```\n\n2. **JSON Schema format** (for complex validation):\n   ```python\n   {\n       \"type\": \"object\",\n       \"properties\": {\n           \"text\": {\"type\": \"string\"},\n           \"count\": {\"type\": \"integer\", \"minimum\": 0}\n       },\n       \"required\": [\"text\"]\n   }\n   ```\n\n#### Returns\n\nA decorator function that wraps the tool implementation and returns an `SdkMcpTool` instance.\n\n#### Example\n\n```python\nfrom claude_agent_sdk import tool\nfrom typing import Any\n\n@tool(\"greet\", \"Greet a user\", {\"name\": str})\nasync def greet(args: dict[str, Any]) -> dict[str, Any]:\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Hello, {args['name']}!\"\n        }]\n    }\n```\n\n### `create_sdk_mcp_server()`\n\nCreate an in-process MCP server that runs within your Python application.\n\n```python\ndef create_sdk_mcp_server(\n    name: str,\n    version: str = \"1.0.0\",\n    tools: list[SdkMcpTool[Any]] | None = None\n) -> McpSdkServerConfig\n```\n\n#### Parameters\n\n| Parameter | Type                            | Default   | Description                                           |\n| :-------- | :------------------------------ | :-------- | :---------------------------------------------------- |\n| `name`    | `str`                           | -         | Unique identifier for the server                      |\n| `version` | `str`                           | `\"1.0.0\"` | Server version string                                 |\n| `tools`   | `list[SdkMcpTool[Any]] \\| None` | `None`    | List of tool functions created with `@tool` decorator |\n\n#### Returns\n\nReturns an `McpSdkServerConfig` object that can be passed to `ClaudeAgentOptions.mcp_servers`.\n\n#### Example\n\n```python\nfrom claude_agent_sdk import tool, create_sdk_mcp_server\n\n@tool(\"add\", \"Add two numbers\", {\"a\": float, \"b\": float})\nasync def add(args):\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Sum: {args['a'] + args['b']}\"\n        }]\n    }\n\n@tool(\"multiply\", \"Multiply two numbers\", {\"a\": float, \"b\": float})\nasync def multiply(args):\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Product: {args['a'] * args['b']}\"\n        }]\n    }\n\ncalculator = create_sdk_mcp_server(\n    name=\"calculator\",\n    version=\"2.0.0\",\n    tools=[add, multiply]  # Pass decorated functions\n)\n\n# Use with Claude\noptions = ClaudeAgentOptions(\n    mcp_servers={\"calc\": calculator},\n    allowed_tools=[\"mcp__calc__add\", \"mcp__calc__multiply\"]\n)\n```\n\n## Classes\n\n### `ClaudeSDKClient`\n\n**Maintains a conversation session across multiple exchanges.** This is the Python equivalent of how the TypeScript SDK's `query()` function works internally - it creates a client object that can continue conversations.\n\n#### Key Features\n\n- **Session Continuity**: Maintains conversation context across multiple `query()` calls\n- **Same Conversation**: Claude remembers previous messages in the session\n- **Interrupt Support**: Can stop Claude mid-execution\n- **Explicit Lifecycle**: You control when the session starts and ends\n- **Response-driven Flow**: Can react to responses and send follow-ups\n- **Custom Tools & Hooks**: Supports custom tools (created with `@tool` decorator) and hooks\n\n```python\nclass ClaudeSDKClient:\n    def __init__(self, options: ClaudeAgentOptions | None = None)\n    async def connect(self, prompt: str | AsyncIterable[dict] | None = None) -> None\n    async def query(self, prompt: str | AsyncIterable[dict], session_id: str = \"default\") -> None\n    async def receive_messages(self) -> AsyncIterator[Message]\n    async def receive_response(self) -> AsyncIterator[Message]\n    async def interrupt(self) -> None\n    async def rewind_files(self, user_message_uuid: str) -> None\n    async def disconnect(self) -> None\n```\n\n#### Methods\n\n| Method                      | Description                                                         |\n| :-------------------------- | :------------------------------------------------------------------ |\n| `__init__(options)`         | Initialize the client with optional configuration                   |\n| `connect(prompt)`           | Connect to Claude with an optional initial prompt or message stream |\n| `query(prompt, session_id)` | Send a new request in streaming mode                                |\n| `receive_messages()`        | Receive all messages from Claude as an async iterator               |\n| `receive_response()`        | Receive messages until and including a ResultMessage                |\n| `interrupt()`               | Send interrupt signal (only works in streaming mode)                |\n| `rewind_files(user_message_uuid)` | Restore files to their state at the specified user message. Requires `enable_file_checkpointing=True`. See [File checkpointing](/docs/en/agent-sdk/file-checkpointing) |\n| `disconnect()`              | Disconnect from Claude                                              |\n\n#### Context Manager Support\n\nThe client can be used as an async context manager for automatic connection management:\n\n```python\nasync with ClaudeSDKClient() as client:\n    await client.query(\"Hello Claude\")\n    async for message in client.receive_response():\n        print(message)\n```\n\n> **Important:** When iterating over messages, avoid using `break` to exit early as this can cause asyncio cleanup issues. Instead, let the iteration complete naturally or use flags to track when you've found what you need.\n\n#### Example - Continuing a conversation\n\n```python\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient, AssistantMessage, TextBlock, ResultMessage\n\nasync def main():\n    async with ClaudeSDKClient() as client:\n        # First question\n        await client.query(\"What's the capital of France?\")\n\n        # Process response\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\n        # Follow-up question - Claude remembers the previous context\n        await client.query(\"What's the population of that city?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\n        # Another follow-up - still in the same conversation\n        await client.query(\"What are some famous landmarks there?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\nasyncio.run(main())\n```\n\n#### Example - Streaming input with ClaudeSDKClient\n\n```python\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient\n\nasync def message_stream():\n    \"\"\"Generate messages dynamically.\"\"\"\n    yield {\"type\": \"text\", \"text\": \"Analyze the following data:\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"Temperature: 25°C\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"Humidity: 60%\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"What patterns do you see?\"}\n\nasync def main():\n    async with ClaudeSDKClient() as client:\n        # Stream input to Claude\n        await client.query(message_stream())\n\n        # Process response\n        async for message in client.receive_response():\n            print(message)\n\n        # Follow-up in same session\n        await client.query(\"Should we be concerned about these readings?\")\n\n        async for message in client.receive_response():\n            print(message)\n\nasyncio.run(main())\n```\n\n#### Example - Using interrupts\n\n```python\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions\n\nasync def interruptible_task():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        # Start a long-running task\n        await client.query(\"Count from 1 to 100 slowly\")\n\n        # Let it run for a bit\n        await asyncio.sleep(2)\n\n        # Interrupt the task\n        await client.interrupt()\n        print(\"Task interrupted!\")\n\n        # Send a new command\n        await client.query(\"Just say hello instead\")\n\n        async for message in client.receive_response():\n            # Process the new response\n            pass\n\nasyncio.run(interruptible_task())\n```\n\n#### Example - Advanced permission control\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions\n)\nfrom claude_agent_sdk.types import PermissionResultAllow, PermissionResultDeny\n\nasync def custom_permission_handler(\n    tool_name: str,\n    input_data: dict,\n    context: dict\n) -> PermissionResultAllow | PermissionResultDeny:\n    \"\"\"Custom logic for tool permissions.\"\"\"\n\n    # Block writes to system directories\n    if tool_name == \"Write\" and input_data.get(\"file_path\", \"\").startswith(\"/system/\"):\n        return PermissionResultDeny(\n            message=\"System directory write not allowed\",\n            interrupt=True\n        )\n\n    # Redirect sensitive file operations\n    if tool_name in [\"Write\", \"Edit\"] and \"config\" in input_data.get(\"file_path\", \"\"):\n        safe_path = f\"./sandbox/{input_data['file_path']}\"\n        return PermissionResultAllow(\n            updated_input={**input_data, \"file_path\": safe_path}\n        )\n\n    # Allow everything else\n    return PermissionResultAllow(updated_input=input_data)\n\nasync def main():\n    options = ClaudeAgentOptions(\n        can_use_tool=custom_permission_handler,\n        allowed_tools=[\"Read\", \"Write\", \"Edit\"]\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"Update the system config file\")\n\n        async for message in client.receive_response():\n            # Will use sandbox path instead\n            print(message)\n\nasyncio.run(main())\n```\n\n## Types\n\n### `SdkMcpTool`\n\nDefinition for an SDK MCP tool created with the `@tool` decorator.\n\n```python\n@dataclass\nclass SdkMcpTool(Generic[T]):\n    name: str\n    description: str\n    input_schema: type[T] | dict[str, Any]\n    handler: Callable[[T], Awaitable[dict[str, Any]]]\n```\n\n| Property       | Type                                       | Description                                |\n| :------------- | :----------------------------------------- | :----------------------------------------- |\n| `name`         | `str`                                      | Unique identifier for the tool             |\n| `description`  | `str`                                      | Human-readable description                 |\n| `input_schema` | `type[T] \\| dict[str, Any]`                | Schema for input validation                |\n| `handler`      | `Callable[[T], Awaitable[dict[str, Any]]]` | Async function that handles tool execution |\n\n### `ClaudeAgentOptions`\n\nConfiguration dataclass for Claude Code queries.\n\n```python\n@dataclass\nclass ClaudeAgentOptions:\n    allowed_tools: list[str] = field(default_factory=list)\n    system_prompt: str | SystemPromptPreset | None = None\n    mcp_servers: dict[str, McpServerConfig] | str | Path = field(default_factory=dict)\n    permission_mode: PermissionMode | None = None\n    continue_conversation: bool = False\n    resume: str | None = None\n    max_turns: int | None = None\n    disallowed_tools: list[str] = field(default_factory=list)\n    model: str | None = None\n    output_format: OutputFormat | None = None\n    permission_prompt_tool_name: str | None = None\n    cwd: str | Path | None = None\n    settings: str | None = None\n    add_dirs: list[str | Path] = field(default_factory=list)\n    env: dict[str, str] = field(default_factory=dict)\n    extra_args: dict[str, str | None] = field(default_factory=dict)\n    max_buffer_size: int | None = None\n    debug_stderr: Any = sys.stderr  # Deprecated\n    stderr: Callable[[str], None] | None = None\n    can_use_tool: CanUseTool | None = None\n    hooks: dict[HookEvent, list[HookMatcher]] | None = None\n    user: str | None = None\n    include_partial_messages: bool = False\n    fork_session: bool = False\n    agents: dict[str, AgentDefinition] | None = None\n    setting_sources: list[SettingSource] | None = None\n```\n\n| Property                      | Type                                         | Default              | Description                                                                                                                                                                             |\n| :---------------------------- | :------------------------------------------- | :------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `allowed_tools`               | `list[str]`                                  | `[]`                 | List of allowed tool names                                                                                                                                                              |\n| `system_prompt`               | `str \\| SystemPromptPreset \\| None`          | `None`               | System prompt configuration. Pass a string for custom prompt, or use `{\"type\": \"preset\", \"preset\": \"claude_code\"}` for Claude Code's system prompt. Add `\"append\"` to extend the preset |\n| `mcp_servers`                 | `dict[str, McpServerConfig] \\| str \\| Path`  | `{}`                 | MCP server configurations or path to config file                                                                                                                                        |\n| `permission_mode`             | `PermissionMode \\| None`                     | `None`               | Permission mode for tool usage                                                                                                                                                          |\n| `continue_conversation`       | `bool`                                       | `False`              | Continue the most recent conversation                                                                                                                                                   |\n| `resume`                      | `str \\| None`                                | `None`               | Session ID to resume                                                                                                                                                                    |\n| `max_turns`                   | `int \\| None`                                | `None`               | Maximum conversation turns                                                                                                                                                              |\n| `disallowed_tools`            | `list[str]`                                  | `[]`                 | List of disallowed tool names                                                                                                                                                           |\n| `enable_file_checkpointing`   | `bool`                                       | `False`              | Enable file change tracking for rewinding. See [File checkpointing](/docs/en/agent-sdk/file-checkpointing)                                                                              |\n| `model`                       | `str \\| None`                                | `None`               | Claude model to use                                                                                                                                                                     |\n| `output_format`               | [`OutputFormat`](#outputformat) ` \\| None`   | `None`               | Define output format for agent results. See [Structured outputs](/docs/en/agent-sdk/structured-outputs) for details                                                                    |\n| `permission_prompt_tool_name` | `str \\| None`                                | `None`               | MCP tool name for permission prompts                                                                                                                                                    |\n| `cwd`                         | `str \\| Path \\| None`                        | `None`               | Current working directory                                                                                                                                                               |\n| `settings`                    | `str \\| None`                                | `None`               | Path to settings file                                                                                                                                                                   |\n| `add_dirs`                    | `list[str \\| Path]`                          | `[]`                 | Additional directories Claude can access                                                                                                                                                |\n| `env`                         | `dict[str, str]`                             | `{}`                 | Environment variables                                                                                                                                                                   |\n| `extra_args`                  | `dict[str, str \\| None]`                     | `{}`                 | Additional CLI arguments to pass directly to the CLI                                                                                                                                    |\n| `max_buffer_size`             | `int \\| None`                                | `None`               | Maximum bytes when buffering CLI stdout                                                                                                                                                 |\n| `debug_stderr`                | `Any`                                        | `sys.stderr`         | _Deprecated_ - File-like object for debug output. Use `stderr` callback instead                                                                                                         |\n| `stderr`                      | `Callable[[str], None] \\| None`              | `None`               | Callback function for stderr output from CLI                                                                                                                                            |\n| `can_use_tool`                | `CanUseTool \\| None`                         | `None`               | Tool permission callback function                                                                                                                                                       |\n| `hooks`                       | `dict[HookEvent, list[HookMatcher]] \\| None` | `None`               | Hook configurations for intercepting events                                                                                                                                             |\n| `user`                        | `str \\| None`                                | `None`               | User identifier                                                                                                                                                                         |\n| `include_partial_messages`    | `bool`                                       | `False`              | Include partial message streaming events                                                                                                                                                |\n| `fork_session`                | `bool`                                       | `False`              | When resuming with `resume`, fork to a new session ID instead of continuing the original session                                                                                        |\n| `agents`                      | `dict[str, AgentDefinition] \\| None`         | `None`               | Programmatically defined subagents                                                                                                                                                      |\n| `plugins`                     | `list[SdkPluginConfig]`                      | `[]`                 | Load custom plugins from local paths. See [Plugins](/docs/en/agent-sdk/plugins) for details                                                                                             |\n| `sandbox`                     | [`SandboxSettings`](#sandboxsettings) ` \\| None` | `None`              | Configure sandbox behavior programmatically. See [Sandbox settings](#sandboxsettings) for details                                        |\n| `setting_sources`             | `list[SettingSource] \\| None`                | `None` (no settings) | Control which filesystem settings to load. When omitted, no settings are loaded. **Note:** Must include `\"project\"` to load CLAUDE.md files                                             |\n\n### `OutputFormat`\n\nConfiguration for structured output validation.\n\n```python\nclass OutputFormat(TypedDict):\n    type: Literal[\"json_schema\"]\n    schema: dict[str, Any]\n```\n\n| Field    | Required | Description                                    |\n| :------- | :------- | :--------------------------------------------- |\n| `type`   | Yes      | Must be `\"json_schema\"` for JSON Schema validation |\n| `schema` | Yes      | JSON Schema definition for output validation   |\n\n### `SystemPromptPreset`\n\nConfiguration for using Claude Code's preset system prompt with optional additions.\n\n```python\nclass SystemPromptPreset(TypedDict):\n    type: Literal[\"preset\"]\n    preset: Literal[\"claude_code\"]\n    append: NotRequired[str]\n```\n\n| Field    | Required | Description                                                   |\n| :------- | :------- | :------------------------------------------------------------ |\n| `type`   | Yes      | Must be `\"preset\"` to use a preset system prompt              |\n| `preset` | Yes      | Must be `\"claude_code\"` to use Claude Code's system prompt    |\n| `append` | No       | Additional instructions to append to the preset system prompt |\n\n### `SettingSource`\n\nControls which filesystem-based configuration sources the SDK loads settings from.\n\n```python\nSettingSource = Literal[\"user\", \"project\", \"local\"]\n```\n\n| Value       | Description                                  | Location                      |\n| :---------- | :------------------------------------------- | :---------------------------- |\n| `\"user\"`    | Global user settings                         | `~/.claude/settings.json`     |\n| `\"project\"` | Shared project settings (version controlled) | `.claude/settings.json`       |\n| `\"local\"`   | Local project settings (gitignored)          | `.claude/settings.local.json` |\n\n#### Default behavior\n\nWhen `setting_sources` is **omitted** or **`None`**, the SDK does **not** load any filesystem settings. This provides isolation for SDK applications.\n\n#### Why use setting_sources?\n\n**Load all filesystem settings (legacy behavior):**\n\n```python\n# Load all settings like SDK v0.0.x did\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync for message in query(\n    prompt=\"Analyze this code\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"user\", \"project\", \"local\"]  # Load all settings\n    )\n):\n    print(message)\n```\n\n**Load only specific setting sources:**\n\n```python\n# Load only project settings, ignore user and local\nasync for message in query(\n    prompt=\"Run CI checks\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"project\"]  # Only .claude/settings.json\n    )\n):\n    print(message)\n```\n\n**Testing and CI environments:**\n\n```python\n# Ensure consistent behavior in CI by excluding local settings\nasync for message in query(\n    prompt=\"Run tests\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"project\"],  # Only team-shared settings\n        permission_mode=\"bypassPermissions\"\n    )\n):\n    print(message)\n```\n\n**SDK-only applications:**\n\n```python\n# Define everything programmatically (default behavior)\n# No filesystem dependencies - setting_sources defaults to None\nasync for message in query(\n    prompt=\"Review this PR\",\n    options=ClaudeAgentOptions(\n        # setting_sources=None is the default, no need to specify\n        agents={ /* ... */ },\n        mcp_servers={ /* ... */ },\n        allowed_tools=[\"Read\", \"Grep\", \"Glob\"]\n    )\n):\n    print(message)\n```\n\n**Loading CLAUDE.md project instructions:**\n\n```python\n# Load project settings to include CLAUDE.md files\nasync for message in query(\n    prompt=\"Add a new feature following project conventions\",\n    options=ClaudeAgentOptions(\n        system_prompt={\n            \"type\": \"preset\",\n            \"preset\": \"claude_code\"  # Use Claude Code's system prompt\n        },\n        setting_sources=[\"project\"],  # Required to load CLAUDE.md from project\n        allowed_tools=[\"Read\", \"Write\", \"Edit\"]\n    )\n):\n    print(message)\n```\n\n#### Settings precedence\n\nWhen multiple sources are loaded, settings are merged with this precedence (highest to lowest):\n\n1. Local settings (`.claude/settings.local.json`)\n2. Project settings (`.claude/settings.json`)\n3. User settings (`~/.claude/settings.json`)\n\nProgrammatic options (like `agents`, `allowed_tools`) always override filesystem settings.\n\n### `AgentDefinition`\n\nConfiguration for a subagent defined programmatically.\n\n```python\n@dataclass\nclass AgentDefinition:\n    description: str\n    prompt: str\n    tools: list[str] | None = None\n    model: Literal[\"sonnet\", \"opus\", \"haiku\", \"inherit\"] | None = None\n```\n\n| Field         | Required | Description                                                    |\n| :------------ | :------- | :------------------------------------------------------------- |\n| `description` | Yes      | Natural language description of when to use this agent         |\n| `tools`       | No       | Array of allowed tool names. If omitted, inherits all tools    |\n| `prompt`      | Yes      | The agent's system prompt                                      |\n| `model`       | No       | Model override for this agent. If omitted, uses the main model |\n\n### `PermissionMode`\n\nPermission modes for controlling tool execution.\n\n```python\nPermissionMode = Literal[\n    \"default\",           # Standard permission behavior\n    \"acceptEdits\",       # Auto-accept file edits\n    \"plan\",              # Planning mode - no execution\n    \"bypassPermissions\"  # Bypass all permission checks (use with caution)\n]\n```\n\n### `McpSdkServerConfig`\n\nConfiguration for SDK MCP servers created with `create_sdk_mcp_server()`.\n\n```python\nclass McpSdkServerConfig(TypedDict):\n    type: Literal[\"sdk\"]\n    name: str\n    instance: Any  # MCP Server instance\n```\n\n### `McpServerConfig`\n\nUnion type for MCP server configurations.\n\n```python\nMcpServerConfig = McpStdioServerConfig | McpSSEServerConfig | McpHttpServerConfig | McpSdkServerConfig\n```\n\n#### `McpStdioServerConfig`\n\n```python\nclass McpStdioServerConfig(TypedDict):\n    type: NotRequired[Literal[\"stdio\"]]  # Optional for backwards compatibility\n    command: str\n    args: NotRequired[list[str]]\n    env: NotRequired[dict[str, str]]\n```\n\n#### `McpSSEServerConfig`\n\n```python\nclass McpSSEServerConfig(TypedDict):\n    type: Literal[\"sse\"]\n    url: str\n    headers: NotRequired[dict[str, str]]\n```\n\n#### `McpHttpServerConfig`\n\n```python\nclass McpHttpServerConfig(TypedDict):\n    type: Literal[\"http\"]\n    url: str\n    headers: NotRequired[dict[str, str]]\n```\n\n### `SdkPluginConfig`\n\nConfiguration for loading plugins in the SDK.\n\n```python\nclass SdkPluginConfig(TypedDict):\n    type: Literal[\"local\"]\n    path: str\n```\n\n| Field | Type | Description |\n|:------|:-----|:------------|\n| `type` | `Literal[\"local\"]` | Must be `\"local\"` (only local plugins currently supported) |\n| `path` | `str` | Absolute or relative path to the plugin directory |\n\n**Example:**\n```python\nplugins=[\n    {\"type\": \"local\", \"path\": \"./my-plugin\"},\n    {\"type\": \"local\", \"path\": \"/absolute/path/to/plugin\"}\n]\n```\n\nFor complete information on creating and using plugins, see [Plugins](/docs/en/agent-sdk/plugins).\n\n## Message Types\n\n### `Message`\n\nUnion type of all possible messages.\n\n```python\nMessage = UserMessage | AssistantMessage | SystemMessage | ResultMessage\n```\n\n### `UserMessage`\n\nUser input message.\n\n```python\n@dataclass\nclass UserMessage:\n    content: str | list[ContentBlock]\n```\n\n### `AssistantMessage`\n\nAssistant response message with content blocks.\n\n```python\n@dataclass\nclass AssistantMessage:\n    content: list[ContentBlock]\n    model: str\n```\n\n### `SystemMessage`\n\nSystem message with metadata.\n\n```python\n@dataclass\nclass SystemMessage:\n    subtype: str\n    data: dict[str, Any]\n```\n\n### `ResultMessage`\n\nFinal result message with cost and usage information.\n\n```python\n@dataclass\nclass ResultMessage:\n    subtype: str\n    duration_ms: int\n    duration_api_ms: int\n    is_error: bool\n    num_turns: int\n    session_id: str\n    total_cost_usd: float | None = None\n    usage: dict[str, Any] | None = None\n    result: str | None = None\n```\n\n## Content Block Types\n\n### `ContentBlock`\n\nUnion type of all content blocks.\n\n```python\nContentBlock = TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock\n```\n\n### `TextBlock`\n\nText content block.\n\n```python\n@dataclass\nclass TextBlock:\n    text: str\n```\n\n### `ThinkingBlock`\n\nThinking content block (for models with thinking capability).\n\n```python\n@dataclass\nclass ThinkingBlock:\n    thinking: str\n    signature: str\n```\n\n### `ToolUseBlock`\n\nTool use request block.\n\n```python\n@dataclass\nclass ToolUseBlock:\n    id: str\n    name: str\n    input: dict[str, Any]\n```\n\n### `ToolResultBlock`\n\nTool execution result block.\n\n```python\n@dataclass\nclass ToolResultBlock:\n    tool_use_id: str\n    content: str | list[dict[str, Any]] | None = None\n    is_error: bool | None = None\n```\n\n## Error Types\n\n### `ClaudeSDKError`\n\nBase exception class for all SDK errors.\n\n```python\nclass ClaudeSDKError(Exception):\n    \"\"\"Base error for Claude SDK.\"\"\"\n```\n\n### `CLINotFoundError`\n\nRaised when Claude Code CLI is not installed or not found.\n\n```python\nclass CLINotFoundError(CLIConnectionError):\n    def __init__(self, message: str = \"Claude Code not found\", cli_path: str | None = None):\n        \"\"\"\n        Args:\n            message: Error message (default: \"Claude Code not found\")\n            cli_path: Optional path to the CLI that was not found\n        \"\"\"\n```\n\n### `CLIConnectionError`\n\nRaised when connection to Claude Code fails.\n\n```python\nclass CLIConnectionError(ClaudeSDKError):\n    \"\"\"Failed to connect to Claude Code.\"\"\"\n```\n\n### `ProcessError`\n\nRaised when the Claude Code process fails.\n\n```python\nclass ProcessError(ClaudeSDKError):\n    def __init__(self, message: str, exit_code: int | None = None, stderr: str | None = None):\n        self.exit_code = exit_code\n        self.stderr = stderr\n```\n\n### `CLIJSONDecodeError`\n\nRaised when JSON parsing fails.\n\n```python\nclass CLIJSONDecodeError(ClaudeSDKError):\n    def __init__(self, line: str, original_error: Exception):\n        \"\"\"\n        Args:\n            line: The line that failed to parse\n            original_error: The original JSON decode exception\n        \"\"\"\n        self.line = line\n        self.original_error = original_error\n```\n\n## Hook Types\n\nFor a comprehensive guide on using hooks with examples and common patterns, see the [Hooks guide](/en/docs/agent-sdk/hooks).\n\n### `HookEvent`\n\nSupported hook event types. Note that due to setup limitations, the Python SDK does not support SessionStart, SessionEnd, and Notification hooks.\n\n```python\nHookEvent = Literal[\n    \"PreToolUse\",      # Called before tool execution\n    \"PostToolUse\",     # Called after tool execution\n    \"UserPromptSubmit\", # Called when user submits a prompt\n    \"Stop\",            # Called when stopping execution\n    \"SubagentStop\",    # Called when a subagent stops\n    \"PreCompact\"       # Called before message compaction\n]\n```\n\n### `HookCallback`\n\nType definition for hook callback functions.\n\n```python\nHookCallback = Callable[\n    [dict[str, Any], str | None, HookContext],\n    Awaitable[dict[str, Any]]\n]\n```\n\nParameters:\n\n- `input_data`: Hook-specific input data (see [Hooks guide](/docs/en/agent-sdk/hooks#input-data))\n- `tool_use_id`: Optional tool use identifier (for tool-related hooks)\n- `context`: Hook context with additional information\n\nReturns a dictionary that may contain:\n\n- `decision`: `\"block\"` to block the action\n- `systemMessage`: System message to add to the transcript\n- `hookSpecificOutput`: Hook-specific output data\n\n### `HookContext`\n\nContext information passed to hook callbacks.\n\n```python\n@dataclass\nclass HookContext:\n    signal: Any | None = None  # Future: abort signal support\n```\n\n### `HookMatcher`\n\nConfiguration for matching hooks to specific events or tools.\n\n```python\n@dataclass\nclass HookMatcher:\n    matcher: str | None = None        # Tool name or pattern to match (e.g., \"Bash\", \"Write|Edit\")\n    hooks: list[HookCallback] = field(default_factory=list)  # List of callbacks to execute\n    timeout: float | None = None        # Timeout in seconds for all hooks in this matcher (default: 60)\n```\n\n### Hook Usage Example\n\nThis example registers two hooks: one that blocks dangerous bash commands like `rm -rf /`, and another that logs all tool usage for auditing. The security hook only runs on Bash commands (via the `matcher`), while the logging hook runs on all tools.\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions, HookMatcher, HookContext\nfrom typing import Any\n\nasync def validate_bash_command(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Validate and potentially block dangerous bash commands.\"\"\"\n    if input_data['tool_name'] == 'Bash':\n        command = input_data['tool_input'].get('command', '')\n        if 'rm -rf /' in command:\n            return {\n                'hookSpecificOutput': {\n                    'hookEventName': 'PreToolUse',\n                    'permissionDecision': 'deny',\n                    'permissionDecisionReason': 'Dangerous command blocked'\n                }\n            }\n    return {}\n\nasync def log_tool_use(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log all tool usage for auditing.\"\"\"\n    print(f\"Tool used: {input_data.get('tool_name')}\")\n    return {}\n\noptions = ClaudeAgentOptions(\n    hooks={\n        'PreToolUse': [\n            HookMatcher(matcher='Bash', hooks=[validate_bash_command], timeout=120),  # 2 min for validation\n            HookMatcher(hooks=[log_tool_use])  # Applies to all tools (default 60s timeout)\n        ],\n        'PostToolUse': [\n            HookMatcher(hooks=[log_tool_use])\n        ]\n    }\n)\n\nasync for message in query(\n    prompt=\"Analyze this codebase\",\n    options=options\n):\n    print(message)\n```\n\n## Tool Input/Output Types\n\nDocumentation of input/output schemas for all built-in Claude Code tools. While the Python SDK doesn't export these as types, they represent the structure of tool inputs and outputs in messages.\n\n### Task\n\n**Tool name:** `Task`\n\n**Input:**\n\n```python\n{\n    \"description\": str,      # A short (3-5 word) description of the task\n    \"prompt\": str,           # The task for the agent to perform\n    \"subagent_type\": str     # The type of specialized agent to use\n}\n```\n\n**Output:**\n\n```python\n{\n    \"result\": str,                    # Final result from the subagent\n    \"usage\": dict | None,             # Token usage statistics\n    \"total_cost_usd\": float | None,  # Total cost in USD\n    \"duration_ms\": int | None         # Execution duration in milliseconds\n}\n```\n\n### AskUserQuestion\n\n**Tool name:** `AskUserQuestion`\n\nAsks the user clarifying questions during execution. See [Handle approvals and user input](/docs/en/agent-sdk/user-input#handle-clarifying-questions) for usage details.\n\n**Input:**\n\n```python\n{\n    \"questions\": [                    # Questions to ask the user (1-4 questions)\n        {\n            \"question\": str,          # The complete question to ask the user\n            \"header\": str,            # Very short label displayed as a chip/tag (max 12 chars)\n            \"options\": [              # The available choices (2-4 options)\n                {\n                    \"label\": str,         # Display text for this option (1-5 words)\n                    \"description\": str    # Explanation of what this option means\n                }\n            ],\n            \"multiSelect\": bool       # Set to true to allow multiple selections\n        }\n    ],\n    \"answers\": dict | None            # User answers populated by the permission system\n}\n```\n\n**Output:**\n\n```python\n{\n    \"questions\": [                    # The questions that were asked\n        {\n            \"question\": str,\n            \"header\": str,\n            \"options\": [{\"label\": str, \"description\": str}],\n            \"multiSelect\": bool\n        }\n    ],\n    \"answers\": dict[str, str]         # Maps question text to answer string\n                                      # Multi-select answers are comma-separated\n}\n```\n\n### Bash\n\n**Tool name:** `Bash`\n\n**Input:**\n\n```python\n{\n    \"command\": str,                  # The command to execute\n    \"timeout\": int | None,           # Optional timeout in milliseconds (max 600000)\n    \"description\": str | None,       # Clear, concise description (5-10 words)\n    \"run_in_background\": bool | None # Set to true to run in background\n}\n```\n\n**Output:**\n\n```python\n{\n    \"output\": str,              # Combined stdout and stderr output\n    \"exitCode\": int,            # Exit code of the command\n    \"killed\": bool | None,      # Whether command was killed due to timeout\n    \"shellId\": str | None       # Shell ID for background processes\n}\n```\n\n### Edit\n\n**Tool name:** `Edit`\n\n**Input:**\n\n```python\n{\n    \"file_path\": str,           # The absolute path to the file to modify\n    \"old_string\": str,          # The text to replace\n    \"new_string\": str,          # The text to replace it with\n    \"replace_all\": bool | None  # Replace all occurrences (default False)\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,      # Confirmation message\n    \"replacements\": int, # Number of replacements made\n    \"file_path\": str     # File path that was edited\n}\n```\n\n### Read\n\n**Tool name:** `Read`\n\n**Input:**\n\n```python\n{\n    \"file_path\": str,       # The absolute path to the file to read\n    \"offset\": int | None,   # The line number to start reading from\n    \"limit\": int | None     # The number of lines to read\n}\n```\n\n**Output (Text files):**\n\n```python\n{\n    \"content\": str,         # File contents with line numbers\n    \"total_lines\": int,     # Total number of lines in file\n    \"lines_returned\": int   # Lines actually returned\n}\n```\n\n**Output (Images):**\n\n```python\n{\n    \"image\": str,       # Base64 encoded image data\n    \"mime_type\": str,   # Image MIME type\n    \"file_size\": int    # File size in bytes\n}\n```\n\n### Write\n\n**Tool name:** `Write`\n\n**Input:**\n\n```python\n{\n    \"file_path\": str,  # The absolute path to the file to write\n    \"content\": str     # The content to write to the file\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,        # Success message\n    \"bytes_written\": int,  # Number of bytes written\n    \"file_path\": str       # File path that was written\n}\n```\n\n### Glob\n\n**Tool name:** `Glob`\n\n**Input:**\n\n```python\n{\n    \"pattern\": str,       # The glob pattern to match files against\n    \"path\": str | None    # The directory to search in (defaults to cwd)\n}\n```\n\n**Output:**\n\n```python\n{\n    \"matches\": list[str],  # Array of matching file paths\n    \"count\": int,          # Number of matches found\n    \"search_path\": str     # Search directory used\n}\n```\n\n### Grep\n\n**Tool name:** `Grep`\n\n**Input:**\n\n```python\n{\n    \"pattern\": str,                    # The regular expression pattern\n    \"path\": str | None,                # File or directory to search in\n    \"glob\": str | None,                # Glob pattern to filter files\n    \"type\": str | None,                # File type to search\n    \"output_mode\": str | None,         # \"content\", \"files_with_matches\", or \"count\"\n    \"-i\": bool | None,                 # Case insensitive search\n    \"-n\": bool | None,                 # Show line numbers\n    \"-B\": int | None,                  # Lines to show before each match\n    \"-A\": int | None,                  # Lines to show after each match\n    \"-C\": int | None,                  # Lines to show before and after\n    \"head_limit\": int | None,          # Limit output to first N lines/entries\n    \"multiline\": bool | None           # Enable multiline mode\n}\n```\n\n**Output (content mode):**\n\n```python\n{\n    \"matches\": [\n        {\n            \"file\": str,\n            \"line_number\": int | None,\n            \"line\": str,\n            \"before_context\": list[str] | None,\n            \"after_context\": list[str] | None\n        }\n    ],\n    \"total_matches\": int\n}\n```\n\n**Output (files_with_matches mode):**\n\n```python\n{\n    \"files\": list[str],  # Files containing matches\n    \"count\": int         # Number of files with matches\n}\n```\n\n### NotebookEdit\n\n**Tool name:** `NotebookEdit`\n\n**Input:**\n\n```python\n{\n    \"notebook_path\": str,                     # Absolute path to the Jupyter notebook\n    \"cell_id\": str | None,                    # The ID of the cell to edit\n    \"new_source\": str,                        # The new source for the cell\n    \"cell_type\": \"code\" | \"markdown\" | None,  # The type of the cell\n    \"edit_mode\": \"replace\" | \"insert\" | \"delete\" | None  # Edit operation type\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,                              # Success message\n    \"edit_type\": \"replaced\" | \"inserted\" | \"deleted\",  # Type of edit performed\n    \"cell_id\": str | None,                       # Cell ID that was affected\n    \"total_cells\": int                           # Total cells in notebook after edit\n}\n```\n\n### WebFetch\n\n**Tool name:** `WebFetch`\n\n**Input:**\n\n```python\n{\n    \"url\": str,     # The URL to fetch content from\n    \"prompt\": str   # The prompt to run on the fetched content\n}\n```\n\n**Output:**\n\n```python\n{\n    \"response\": str,           # AI model's response to the prompt\n    \"url\": str,                # URL that was fetched\n    \"final_url\": str | None,   # Final URL after redirects\n    \"status_code\": int | None  # HTTP status code\n}\n```\n\n### WebSearch\n\n**Tool name:** `WebSearch`\n\n**Input:**\n\n```python\n{\n    \"query\": str,                        # The search query to use\n    \"allowed_domains\": list[str] | None, # Only include results from these domains\n    \"blocked_domains\": list[str] | None  # Never include results from these domains\n}\n```\n\n**Output:**\n\n```python\n{\n    \"results\": [\n        {\n            \"title\": str,\n            \"url\": str,\n            \"snippet\": str,\n            \"metadata\": dict | None\n        }\n    ],\n    \"total_results\": int,\n    \"query\": str\n}\n```\n\n### TodoWrite\n\n**Tool name:** `TodoWrite`\n\n**Input:**\n\n```python\n{\n    \"todos\": [\n        {\n            \"content\": str,                              # The task description\n            \"status\": \"pending\" | \"in_progress\" | \"completed\",  # Task status\n            \"activeForm\": str                            # Active form of the description\n        }\n    ]\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,  # Success message\n    \"stats\": {\n        \"total\": int,\n        \"pending\": int,\n        \"in_progress\": int,\n        \"completed\": int\n    }\n}\n```\n\n### BashOutput\n\n**Tool name:** `BashOutput`\n\n**Input:**\n\n```python\n{\n    \"bash_id\": str,       # The ID of the background shell\n    \"filter\": str | None  # Optional regex to filter output lines\n}\n```\n\n**Output:**\n\n```python\n{\n    \"output\": str,                                      # New output since last check\n    \"status\": \"running\" | \"completed\" | \"failed\",       # Current shell status\n    \"exitCode\": int | None                              # Exit code when completed\n}\n```\n\n### KillBash\n\n**Tool name:** `KillBash`\n\n**Input:**\n\n```python\n{\n    \"shell_id\": str  # The ID of the background shell to kill\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,  # Success message\n    \"shell_id\": str  # ID of the killed shell\n}\n```\n\n### ExitPlanMode\n\n**Tool name:** `ExitPlanMode`\n\n**Input:**\n\n```python\n{\n    \"plan\": str  # The plan to run by the user for approval\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,          # Confirmation message\n    \"approved\": bool | None  # Whether user approved the plan\n}\n```\n\n### ListMcpResources\n\n**Tool name:** `ListMcpResources`\n\n**Input:**\n\n```python\n{\n    \"server\": str | None  # Optional server name to filter resources by\n}\n```\n\n**Output:**\n\n```python\n{\n    \"resources\": [\n        {\n            \"uri\": str,\n            \"name\": str,\n            \"description\": str | None,\n            \"mimeType\": str | None,\n            \"server\": str\n        }\n    ],\n    \"total\": int\n}\n```\n\n### ReadMcpResource\n\n**Tool name:** `ReadMcpResource`\n\n**Input:**\n\n```python\n{\n    \"server\": str,  # The MCP server name\n    \"uri\": str      # The resource URI to read\n}\n```\n\n**Output:**\n\n```python\n{\n    \"contents\": [\n        {\n            \"uri\": str,\n            \"mimeType\": str | None,\n            \"text\": str | None,\n            \"blob\": str | None\n        }\n    ],\n    \"server\": str\n}\n```\n\n## Advanced Features with ClaudeSDKClient\n\n### Building a Continuous Conversation Interface\n\n```python\nfrom claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions, AssistantMessage, TextBlock\nimport asyncio\n\nclass ConversationSession:\n    \"\"\"Maintains a single conversation session with Claude.\"\"\"\n\n    def __init__(self, options: ClaudeAgentOptions = None):\n        self.client = ClaudeSDKClient(options)\n        self.turn_count = 0\n\n    async def start(self):\n        await self.client.connect()\n        print(\"Starting conversation session. Claude will remember context.\")\n        print(\"Commands: 'exit' to quit, 'interrupt' to stop current task, 'new' for new session\")\n\n        while True:\n            user_input = input(f\"\\n[Turn {self.turn_count + 1}] You: \")\n\n            if user_input.lower() == 'exit':\n                break\n            elif user_input.lower() == 'interrupt':\n                await self.client.interrupt()\n                print(\"Task interrupted!\")\n                continue\n            elif user_input.lower() == 'new':\n                # Disconnect and reconnect for a fresh session\n                await self.client.disconnect()\n                await self.client.connect()\n                self.turn_count = 0\n                print(\"Started new conversation session (previous context cleared)\")\n                continue\n\n            # Send message - Claude remembers all previous messages in this session\n            await self.client.query(user_input)\n            self.turn_count += 1\n\n            # Process response\n            print(f\"[Turn {self.turn_count}] Claude: \", end=\"\")\n            async for message in self.client.receive_response():\n                if isinstance(message, AssistantMessage):\n                    for block in message.content:\n                        if isinstance(block, TextBlock):\n                            print(block.text, end=\"\")\n            print()  # New line after response\n\n        await self.client.disconnect()\n        print(f\"Conversation ended after {self.turn_count} turns.\")\n\nasync def main():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n    session = ConversationSession(options)\n    await session.start()\n\n# Example conversation:\n# Turn 1 - You: \"Create a file called hello.py\"\n# Turn 1 - Claude: \"I'll create a hello.py file for you...\"\n# Turn 2 - You: \"What's in that file?\"\n# Turn 2 - Claude: \"The hello.py file I just created contains...\" (remembers!)\n# Turn 3 - You: \"Add a main function to it\"\n# Turn 3 - Claude: \"I'll add a main function to hello.py...\" (knows which file!)\n\nasyncio.run(main())\n```\n\n### Using Hooks for Behavior Modification\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    HookMatcher,\n    HookContext\n)\nimport asyncio\nfrom typing import Any\n\nasync def pre_tool_logger(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log all tool usage before execution.\"\"\"\n    tool_name = input_data.get('tool_name', 'unknown')\n    print(f\"[PRE-TOOL] About to use: {tool_name}\")\n\n    # You can modify or block the tool execution here\n    if tool_name == \"Bash\" and \"rm -rf\" in str(input_data.get('tool_input', {})):\n        return {\n            'hookSpecificOutput': {\n                'hookEventName': 'PreToolUse',\n                'permissionDecision': 'deny',\n                'permissionDecisionReason': 'Dangerous command blocked'\n            }\n        }\n    return {}\n\nasync def post_tool_logger(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log results after tool execution.\"\"\"\n    tool_name = input_data.get('tool_name', 'unknown')\n    print(f\"[POST-TOOL] Completed: {tool_name}\")\n    return {}\n\nasync def user_prompt_modifier(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Add context to user prompts.\"\"\"\n    original_prompt = input_data.get('prompt', '')\n\n    # Add timestamp to all prompts\n    from datetime import datetime\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    return {\n        'hookSpecificOutput': {\n            'hookEventName': 'UserPromptSubmit',\n            'updatedPrompt': f\"[{timestamp}] {original_prompt}\"\n        }\n    }\n\nasync def main():\n    options = ClaudeAgentOptions(\n        hooks={\n            'PreToolUse': [\n                HookMatcher(hooks=[pre_tool_logger]),\n                HookMatcher(matcher='Bash', hooks=[pre_tool_logger])\n            ],\n            'PostToolUse': [\n                HookMatcher(hooks=[post_tool_logger])\n            ],\n            'UserPromptSubmit': [\n                HookMatcher(hooks=[user_prompt_modifier])\n            ]\n        },\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"]\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"List files in current directory\")\n\n        async for message in client.receive_response():\n            # Hooks will automatically log tool usage\n            pass\n\nasyncio.run(main())\n```\n\n### Real-time Progress Monitoring\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    AssistantMessage,\n    ToolUseBlock,\n    ToolResultBlock,\n    TextBlock\n)\nimport asyncio\n\nasync def monitor_progress():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Write\", \"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\n            \"Create 5 Python files with different sorting algorithms\"\n        )\n\n        # Monitor progress in real-time\n        files_created = []\n        async for message in client.receive_messages():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, ToolUseBlock):\n                        if block.name == \"Write\":\n                            file_path = block.input.get(\"file_path\", \"\")\n                            print(f\"🔨 Creating: {file_path}\")\n                    elif isinstance(block, ToolResultBlock):\n                        print(f\"✅ Completed tool execution\")\n                    elif isinstance(block, TextBlock):\n                        print(f\"💭 Claude says: {block.text[:100]}...\")\n\n            # Check if we've received the final result\n            if hasattr(message, 'subtype') and message.subtype in ['success', 'error']:\n                print(f\"\\n🎯 Task completed!\")\n                break\n\nasyncio.run(monitor_progress())\n```\n\n## Example Usage\n\n### Basic file operations (using query)\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions, AssistantMessage, ToolUseBlock\nimport asyncio\n\nasync def create_project():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"],\n        permission_mode='acceptEdits',\n        cwd=\"/home/user/project\"\n    )\n\n    async for message in query(\n        prompt=\"Create a Python project structure with setup.py\",\n        options=options\n    ):\n        if isinstance(message, AssistantMessage):\n            for block in message.content:\n                if isinstance(block, ToolUseBlock):\n                    print(f\"Using tool: {block.name}\")\n\nasyncio.run(create_project())\n```\n\n### Error handling\n\n```python\nfrom claude_agent_sdk import (\n    query,\n    CLINotFoundError,\n    ProcessError,\n    CLIJSONDecodeError\n)\n\ntry:\n    async for message in query(prompt=\"Hello\"):\n        print(message)\nexcept CLINotFoundError:\n    print(\"Please install Claude Code: npm install -g @anthropic-ai/claude-code\")\nexcept ProcessError as e:\n    print(f\"Process failed with exit code: {e.exit_code}\")\nexcept CLIJSONDecodeError as e:\n    print(f\"Failed to parse response: {e}\")\n```\n\n### Streaming mode with client\n\n```python\nfrom claude_agent_sdk import ClaudeSDKClient\nimport asyncio\n\nasync def interactive_session():\n    async with ClaudeSDKClient() as client:\n        # Send initial message\n        await client.query(\"What's the weather like?\")\n\n        # Process responses\n        async for msg in client.receive_response():\n            print(msg)\n\n        # Send follow-up\n        await client.query(\"Tell me more about that\")\n\n        # Process follow-up response\n        async for msg in client.receive_response():\n            print(msg)\n\nasyncio.run(interactive_session())\n```\n\n### Using custom tools with ClaudeSDKClient\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    tool,\n    create_sdk_mcp_server,\n    AssistantMessage,\n    TextBlock\n)\nimport asyncio\nfrom typing import Any\n\n# Define custom tools with @tool decorator\n@tool(\"calculate\", \"Perform mathematical calculations\", {\"expression\": str})\nasync def calculate(args: dict[str, Any]) -> dict[str, Any]:\n    try:\n        result = eval(args[\"expression\"], {\"__builtins__\": {}})\n        return {\n            \"content\": [{\n                \"type\": \"text\",\n                \"text\": f\"Result: {result}\"\n            }]\n        }\n    except Exception as e:\n        return {\n            \"content\": [{\n                \"type\": \"text\",\n                \"text\": f\"Error: {str(e)}\"\n            }],\n            \"is_error\": True\n        }\n\n@tool(\"get_time\", \"Get current time\", {})\nasync def get_time(args: dict[str, Any]) -> dict[str, Any]:\n    from datetime import datetime\n    current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Current time: {current_time}\"\n        }]\n    }\n\nasync def main():\n    # Create SDK MCP server with custom tools\n    my_server = create_sdk_mcp_server(\n        name=\"utilities\",\n        version=\"1.0.0\",\n        tools=[calculate, get_time]\n    )\n\n    # Configure options with the server\n    options = ClaudeAgentOptions(\n        mcp_servers={\"utils\": my_server},\n        allowed_tools=[\n            \"mcp__utils__calculate\",\n            \"mcp__utils__get_time\"\n        ]\n    )\n\n    # Use ClaudeSDKClient for interactive tool usage\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"What's 123 * 456?\")\n\n        # Process calculation response\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Calculation: {block.text}\")\n\n        # Follow up with time query\n        await client.query(\"What time is it now?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Time: {block.text}\")\n\nasyncio.run(main())\n```\n\n## Sandbox Configuration\n\n### `SandboxSettings`\n\nConfiguration for sandbox behavior. Use this to enable command sandboxing and configure network restrictions programmatically.\n\n```python\nclass SandboxSettings(TypedDict, total=False):\n    enabled: bool\n    autoAllowBashIfSandboxed: bool\n    excludedCommands: list[str]\n    allowUnsandboxedCommands: bool\n    network: SandboxNetworkConfig\n    ignoreViolations: SandboxIgnoreViolations\n    enableWeakerNestedSandbox: bool\n```\n\n| Property | Type | Default | Description |\n| :------- | :--- | :------ | :---------- |\n| `enabled` | `bool` | `False` | Enable sandbox mode for command execution |\n| `autoAllowBashIfSandboxed` | `bool` | `False` | Auto-approve bash commands when sandbox is enabled |\n| `excludedCommands` | `list[str]` | `[]` | Commands that always bypass sandbox restrictions (e.g., `[\"docker\"]`). These run unsandboxed automatically without model involvement |\n| `allowUnsandboxedCommands` | `bool` | `False` | Allow the model to request running commands outside the sandbox. When `True`, the model can set `dangerouslyDisableSandbox` in tool input, which falls back to the [permissions system](#permissions-fallback-for-unsandboxed-commands) |\n| `network` | [`SandboxNetworkConfig`](#sandboxnetworkconfig) | `None` | Network-specific sandbox configuration |\n| `ignoreViolations` | [`SandboxIgnoreViolations`](#sandboxignoreviolations) | `None` | Configure which sandbox violations to ignore |\n| `enableWeakerNestedSandbox` | `bool` | `False` | Enable a weaker nested sandbox for compatibility |\n\n<Note>\n**Filesystem and network access restrictions** are NOT configured via sandbox settings. Instead, they are derived from [permission rules](https://code.claude.com/docs/en/settings#permission-settings):\n\n- **Filesystem read restrictions**: Read deny rules\n- **Filesystem write restrictions**: Edit allow/deny rules\n- **Network restrictions**: WebFetch allow/deny rules\n\nUse sandbox settings for command execution sandboxing, and permission rules for filesystem and network access control.\n</Note>\n\n#### Example usage\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions, SandboxSettings\n\nsandbox_settings: SandboxSettings = {\n    \"enabled\": True,\n    \"autoAllowBashIfSandboxed\": True,\n    \"network\": {\n        \"allowLocalBinding\": True\n    }\n}\n\nasync for message in query(\n    prompt=\"Build and test my project\",\n    options=ClaudeAgentOptions(sandbox=sandbox_settings)\n):\n    print(message)\n```\n\n<Warning>\n**Unix socket security**: The `allowUnixSockets` option can grant access to powerful system services. For example, allowing `/var/run/docker.sock` effectively grants full host system access through the Docker API, bypassing sandbox isolation. Only allow Unix sockets that are strictly necessary and understand the security implications of each.\n</Warning>\n\n### `SandboxNetworkConfig`\n\nNetwork-specific configuration for sandbox mode.\n\n```python\nclass SandboxNetworkConfig(TypedDict, total=False):\n    allowLocalBinding: bool\n    allowUnixSockets: list[str]\n    allowAllUnixSockets: bool\n    httpProxyPort: int\n    socksProxyPort: int\n```\n\n| Property | Type | Default | Description |\n| :------- | :--- | :------ | :---------- |\n| `allowLocalBinding` | `bool` | `False` | Allow processes to bind to local ports (e.g., for dev servers) |\n| `allowUnixSockets` | `list[str]` | `[]` | Unix socket paths that processes can access (e.g., Docker socket) |\n| `allowAllUnixSockets` | `bool` | `False` | Allow access to all Unix sockets |\n| `httpProxyPort` | `int` | `None` | HTTP proxy port for network requests |\n| `socksProxyPort` | `int` | `None` | SOCKS proxy port for network requests |\n\n### `SandboxIgnoreViolations`\n\nConfiguration for ignoring specific sandbox violations.\n\n```python\nclass SandboxIgnoreViolations(TypedDict, total=False):\n    file: list[str]\n    network: list[str]\n```\n\n| Property | Type | Default | Description |\n| :------- | :--- | :------ | :---------- |\n| `file` | `list[str]` | `[]` | File path patterns to ignore violations for |\n| `network` | `list[str]` | `[]` | Network patterns to ignore violations for |\n\n### Permissions Fallback for Unsandboxed Commands\n\nWhen `allowUnsandboxedCommands` is enabled, the model can request to run commands outside the sandbox by setting `dangerouslyDisableSandbox: True` in the tool input. These requests fall back to the existing permissions system, meaning your `can_use_tool` handler will be invoked, allowing you to implement custom authorization logic.\n\n<Note>\n**`excludedCommands` vs `allowUnsandboxedCommands`:**\n- `excludedCommands`: A static list of commands that always bypass the sandbox automatically (e.g., `[\"docker\"]`). The model has no control over this.\n- `allowUnsandboxedCommands`: Lets the model decide at runtime whether to request unsandboxed execution by setting `dangerouslyDisableSandbox: True` in the tool input.\n</Note>\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync def can_use_tool(tool: str, input: dict) -> bool:\n    # Check if the model is requesting to bypass the sandbox\n    if tool == \"Bash\" and input.get(\"dangerouslyDisableSandbox\"):\n        # The model wants to run this command outside the sandbox\n        print(f\"Unsandboxed command requested: {input.get('command')}\")\n\n        # Return True to allow, False to deny\n        return is_command_authorized(input.get(\"command\"))\n    return True\n\nasync def main():\n    async for message in query(\n        prompt=\"Deploy my application\",\n        options=ClaudeAgentOptions(\n            sandbox={\n                \"enabled\": True,\n                \"allowUnsandboxedCommands\": True  # Model can request unsandboxed execution\n            },\n            permission_mode=\"default\",\n            can_use_tool=can_use_tool\n        )\n    ):\n        print(message)\n```\n\nThis pattern enables you to:\n\n- **Audit model requests**: Log when the model requests unsandboxed execution\n- **Implement allowlists**: Only permit specific commands to run unsandboxed\n- **Add approval workflows**: Require explicit authorization for privileged operations\n\n<Warning>\nCommands running with `dangerouslyDisableSandbox: True` have full system access. Ensure your `can_use_tool` handler validates these requests carefully.\n\nIf `permission_mode` is set to `bypassPermissions` and `allow_unsandboxed_commands` is enabled, the model can autonomously execute commands outside the sandbox without any approval prompts. This combination effectively allows the model to escape sandbox isolation silently.\n</Warning>\n\n## See also\n\n- [Python SDK guide](/docs/en/agent-sdk/python) - Tutorial and examples\n- [SDK overview](/docs/en/agent-sdk/overview) - General SDK concepts\n- [TypeScript SDK reference](/docs/en/agent-sdk/typescript) - TypeScript SDK documentation\n- [CLI reference](https://code.claude.com/docs/en/cli-reference) - Command-line interface\n- [Common workflows](https://code.claude.com/docs/en/common-workflows) - Step-by-step guides"}]},"uuid":"b8fd2460-f5e6-4ef3-9c58-fc79359e995e","timestamp":"2026-01-20T17:17:33.397Z","toolUseResult":{"bytes":68001,"code":200,"codeText":"OK","result":"# Agent SDK reference - Python\n\nComplete API reference for the Python Agent SDK, including all functions, types, and classes.\n\n---\n\n## Installation\n\n```bash\npip install claude-agent-sdk\n```\n\n## Choosing Between `query()` and `ClaudeSDKClient`\n\nThe Python SDK provides two ways to interact with Claude Code:\n\n### Quick Comparison\n\n| Feature             | `query()`                     | `ClaudeSDKClient`                  |\n| :------------------ | :---------------------------- | :--------------------------------- |\n| **Session**         | Creates new session each time | Reuses same session                |\n| **Conversation**    | Single exchange               | Multiple exchanges in same context |\n| **Connection**      | Managed automatically         | Manual control                     |\n| **Streaming Input** | ✅ Supported                  | ✅ Supported                       |\n| **Interrupts**      | ❌ Not supported              | ✅ Supported                       |\n| **Hooks**           | ❌ Not supported              | ✅ Supported                       |\n| **Custom Tools**    | ❌ Not supported              | ✅ Supported                       |\n| **Continue Chat**   | ❌ New session each time      | ✅ Maintains conversation          |\n| **Use Case**        | One-off tasks                 | Continuous conversations           |\n\n### When to Use `query()` (New Session Each Time)\n\n**Best for:**\n\n- One-off questions where you don't need conversation history\n- Independent tasks that don't require context from previous exchanges\n- Simple automation scripts\n- When you want a fresh start each time\n\n### When to Use `ClaudeSDKClient` (Continuous Conversation)\n\n**Best for:**\n\n- **Continuing conversations** - When you need Claude to remember context\n- **Follow-up questions** - Building on previous responses\n- **Interactive applications** - Chat interfaces, REPLs\n- **Response-driven logic** - When next action depends on Claude's response\n- **Session control** - Managing conversation lifecycle explicitly\n\n## Functions\n\n### `query()`\n\nCreates a new session for each interaction with Claude Code. Returns an async iterator that yields messages as they arrive. Each call to `query()` starts fresh with no memory of previous interactions.\n\n```python\nasync def query(\n    *,\n    prompt: str | AsyncIterable[dict[str, Any]],\n    options: ClaudeAgentOptions | None = None\n) -> AsyncIterator[Message]\n```\n\n#### Parameters\n\n| Parameter | Type                         | Description                                                                |\n| :-------- | :--------------------------- | :------------------------------------------------------------------------- |\n| `prompt`  | `str \\| AsyncIterable[dict]` | The input prompt as a string or async iterable for streaming mode          |\n| `options` | `ClaudeAgentOptions \\| None` | Optional configuration object (defaults to `ClaudeAgentOptions()` if None) |\n\n#### Returns\n\nReturns an `AsyncIterator[Message]` that yields messages from the conversation.\n\n#### Example - With options\n\n```python\n\nimport asyncio\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync def main():\n    options = ClaudeAgentOptions(\n        system_prompt=\"You are an expert Python developer\",\n        permission_mode='acceptEdits',\n        cwd=\"/home/user/project\"\n    )\n\n    async for message in query(\n        prompt=\"Create a Python web server\",\n        options=options\n    ):\n        print(message)\n\n\nasyncio.run(main())\n```\n\n### `tool()`\n\nDecorator for defining MCP tools with type safety.\n\n```python\ndef tool(\n    name: str,\n    description: str,\n    input_schema: type | dict[str, Any]\n) -> Callable[[Callable[[Any], Awaitable[dict[str, Any]]]], SdkMcpTool[Any]]\n```\n\n#### Parameters\n\n| Parameter      | Type                     | Description                                             |\n| :------------- | :----------------------- | :------------------------------------------------------ |\n| `name`         | `str`                    | Unique identifier for the tool                          |\n| `description`  | `str`                    | Human-readable description of what the tool does        |\n| `input_schema` | `type \\| dict[str, Any]` | Schema defining the tool's input parameters (see below) |\n\n#### Input Schema Options\n\n1. **Simple type mapping** (recommended):\n\n   ```python\n   {\"text\": str, \"count\": int, \"enabled\": bool}\n   ```\n\n2. **JSON Schema format** (for complex validation):\n   ```python\n   {\n       \"type\": \"object\",\n       \"properties\": {\n           \"text\": {\"type\": \"string\"},\n           \"count\": {\"type\": \"integer\", \"minimum\": 0}\n       },\n       \"required\": [\"text\"]\n   }\n   ```\n\n#### Returns\n\nA decorator function that wraps the tool implementation and returns an `SdkMcpTool` instance.\n\n#### Example\n\n```python\nfrom claude_agent_sdk import tool\nfrom typing import Any\n\n@tool(\"greet\", \"Greet a user\", {\"name\": str})\nasync def greet(args: dict[str, Any]) -> dict[str, Any]:\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Hello, {args['name']}!\"\n        }]\n    }\n```\n\n### `create_sdk_mcp_server()`\n\nCreate an in-process MCP server that runs within your Python application.\n\n```python\ndef create_sdk_mcp_server(\n    name: str,\n    version: str = \"1.0.0\",\n    tools: list[SdkMcpTool[Any]] | None = None\n) -> McpSdkServerConfig\n```\n\n#### Parameters\n\n| Parameter | Type                            | Default   | Description                                           |\n| :-------- | :------------------------------ | :-------- | :---------------------------------------------------- |\n| `name`    | `str`                           | -         | Unique identifier for the server                      |\n| `version` | `str`                           | `\"1.0.0\"` | Server version string                                 |\n| `tools`   | `list[SdkMcpTool[Any]] \\| None` | `None`    | List of tool functions created with `@tool` decorator |\n\n#### Returns\n\nReturns an `McpSdkServerConfig` object that can be passed to `ClaudeAgentOptions.mcp_servers`.\n\n#### Example\n\n```python\nfrom claude_agent_sdk import tool, create_sdk_mcp_server\n\n@tool(\"add\", \"Add two numbers\", {\"a\": float, \"b\": float})\nasync def add(args):\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Sum: {args['a'] + args['b']}\"\n        }]\n    }\n\n@tool(\"multiply\", \"Multiply two numbers\", {\"a\": float, \"b\": float})\nasync def multiply(args):\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Product: {args['a'] * args['b']}\"\n        }]\n    }\n\ncalculator = create_sdk_mcp_server(\n    name=\"calculator\",\n    version=\"2.0.0\",\n    tools=[add, multiply]  # Pass decorated functions\n)\n\n# Use with Claude\noptions = ClaudeAgentOptions(\n    mcp_servers={\"calc\": calculator},\n    allowed_tools=[\"mcp__calc__add\", \"mcp__calc__multiply\"]\n)\n```\n\n## Classes\n\n### `ClaudeSDKClient`\n\n**Maintains a conversation session across multiple exchanges.** This is the Python equivalent of how the TypeScript SDK's `query()` function works internally - it creates a client object that can continue conversations.\n\n#### Key Features\n\n- **Session Continuity**: Maintains conversation context across multiple `query()` calls\n- **Same Conversation**: Claude remembers previous messages in the session\n- **Interrupt Support**: Can stop Claude mid-execution\n- **Explicit Lifecycle**: You control when the session starts and ends\n- **Response-driven Flow**: Can react to responses and send follow-ups\n- **Custom Tools & Hooks**: Supports custom tools (created with `@tool` decorator) and hooks\n\n```python\nclass ClaudeSDKClient:\n    def __init__(self, options: ClaudeAgentOptions | None = None)\n    async def connect(self, prompt: str | AsyncIterable[dict] | None = None) -> None\n    async def query(self, prompt: str | AsyncIterable[dict], session_id: str = \"default\") -> None\n    async def receive_messages(self) -> AsyncIterator[Message]\n    async def receive_response(self) -> AsyncIterator[Message]\n    async def interrupt(self) -> None\n    async def rewind_files(self, user_message_uuid: str) -> None\n    async def disconnect(self) -> None\n```\n\n#### Methods\n\n| Method                      | Description                                                         |\n| :-------------------------- | :------------------------------------------------------------------ |\n| `__init__(options)`         | Initialize the client with optional configuration                   |\n| `connect(prompt)`           | Connect to Claude with an optional initial prompt or message stream |\n| `query(prompt, session_id)` | Send a new request in streaming mode                                |\n| `receive_messages()`        | Receive all messages from Claude as an async iterator               |\n| `receive_response()`        | Receive messages until and including a ResultMessage                |\n| `interrupt()`               | Send interrupt signal (only works in streaming mode)                |\n| `rewind_files(user_message_uuid)` | Restore files to their state at the specified user message. Requires `enable_file_checkpointing=True`. See [File checkpointing](/docs/en/agent-sdk/file-checkpointing) |\n| `disconnect()`              | Disconnect from Claude                                              |\n\n#### Context Manager Support\n\nThe client can be used as an async context manager for automatic connection management:\n\n```python\nasync with ClaudeSDKClient() as client:\n    await client.query(\"Hello Claude\")\n    async for message in client.receive_response():\n        print(message)\n```\n\n> **Important:** When iterating over messages, avoid using `break` to exit early as this can cause asyncio cleanup issues. Instead, let the iteration complete naturally or use flags to track when you've found what you need.\n\n#### Example - Continuing a conversation\n\n```python\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient, AssistantMessage, TextBlock, ResultMessage\n\nasync def main():\n    async with ClaudeSDKClient() as client:\n        # First question\n        await client.query(\"What's the capital of France?\")\n\n        # Process response\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\n        # Follow-up question - Claude remembers the previous context\n        await client.query(\"What's the population of that city?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\n        # Another follow-up - still in the same conversation\n        await client.query(\"What are some famous landmarks there?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\nasyncio.run(main())\n```\n\n#### Example - Streaming input with ClaudeSDKClient\n\n```python\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient\n\nasync def message_stream():\n    \"\"\"Generate messages dynamically.\"\"\"\n    yield {\"type\": \"text\", \"text\": \"Analyze the following data:\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"Temperature: 25°C\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"Humidity: 60%\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"What patterns do you see?\"}\n\nasync def main():\n    async with ClaudeSDKClient() as client:\n        # Stream input to Claude\n        await client.query(message_stream())\n\n        # Process response\n        async for message in client.receive_response():\n            print(message)\n\n        # Follow-up in same session\n        await client.query(\"Should we be concerned about these readings?\")\n\n        async for message in client.receive_response():\n            print(message)\n\nasyncio.run(main())\n```\n\n#### Example - Using interrupts\n\n```python\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions\n\nasync def interruptible_task():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        # Start a long-running task\n        await client.query(\"Count from 1 to 100 slowly\")\n\n        # Let it run for a bit\n        await asyncio.sleep(2)\n\n        # Interrupt the task\n        await client.interrupt()\n        print(\"Task interrupted!\")\n\n        # Send a new command\n        await client.query(\"Just say hello instead\")\n\n        async for message in client.receive_response():\n            # Process the new response\n            pass\n\nasyncio.run(interruptible_task())\n```\n\n#### Example - Advanced permission control\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions\n)\nfrom claude_agent_sdk.types import PermissionResultAllow, PermissionResultDeny\n\nasync def custom_permission_handler(\n    tool_name: str,\n    input_data: dict,\n    context: dict\n) -> PermissionResultAllow | PermissionResultDeny:\n    \"\"\"Custom logic for tool permissions.\"\"\"\n\n    # Block writes to system directories\n    if tool_name == \"Write\" and input_data.get(\"file_path\", \"\").startswith(\"/system/\"):\n        return PermissionResultDeny(\n            message=\"System directory write not allowed\",\n            interrupt=True\n        )\n\n    # Redirect sensitive file operations\n    if tool_name in [\"Write\", \"Edit\"] and \"config\" in input_data.get(\"file_path\", \"\"):\n        safe_path = f\"./sandbox/{input_data['file_path']}\"\n        return PermissionResultAllow(\n            updated_input={**input_data, \"file_path\": safe_path}\n        )\n\n    # Allow everything else\n    return PermissionResultAllow(updated_input=input_data)\n\nasync def main():\n    options = ClaudeAgentOptions(\n        can_use_tool=custom_permission_handler,\n        allowed_tools=[\"Read\", \"Write\", \"Edit\"]\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"Update the system config file\")\n\n        async for message in client.receive_response():\n            # Will use sandbox path instead\n            print(message)\n\nasyncio.run(main())\n```\n\n## Types\n\n### `SdkMcpTool`\n\nDefinition for an SDK MCP tool created with the `@tool` decorator.\n\n```python\n@dataclass\nclass SdkMcpTool(Generic[T]):\n    name: str\n    description: str\n    input_schema: type[T] | dict[str, Any]\n    handler: Callable[[T], Awaitable[dict[str, Any]]]\n```\n\n| Property       | Type                                       | Description                                |\n| :------------- | :----------------------------------------- | :----------------------------------------- |\n| `name`         | `str`                                      | Unique identifier for the tool             |\n| `description`  | `str`                                      | Human-readable description                 |\n| `input_schema` | `type[T] \\| dict[str, Any]`                | Schema for input validation                |\n| `handler`      | `Callable[[T], Awaitable[dict[str, Any]]]` | Async function that handles tool execution |\n\n### `ClaudeAgentOptions`\n\nConfiguration dataclass for Claude Code queries.\n\n```python\n@dataclass\nclass ClaudeAgentOptions:\n    allowed_tools: list[str] = field(default_factory=list)\n    system_prompt: str | SystemPromptPreset | None = None\n    mcp_servers: dict[str, McpServerConfig] | str | Path = field(default_factory=dict)\n    permission_mode: PermissionMode | None = None\n    continue_conversation: bool = False\n    resume: str | None = None\n    max_turns: int | None = None\n    disallowed_tools: list[str] = field(default_factory=list)\n    model: str | None = None\n    output_format: OutputFormat | None = None\n    permission_prompt_tool_name: str | None = None\n    cwd: str | Path | None = None\n    settings: str | None = None\n    add_dirs: list[str | Path] = field(default_factory=list)\n    env: dict[str, str] = field(default_factory=dict)\n    extra_args: dict[str, str | None] = field(default_factory=dict)\n    max_buffer_size: int | None = None\n    debug_stderr: Any = sys.stderr  # Deprecated\n    stderr: Callable[[str], None] | None = None\n    can_use_tool: CanUseTool | None = None\n    hooks: dict[HookEvent, list[HookMatcher]] | None = None\n    user: str | None = None\n    include_partial_messages: bool = False\n    fork_session: bool = False\n    agents: dict[str, AgentDefinition] | None = None\n    setting_sources: list[SettingSource] | None = None\n```\n\n| Property                      | Type                                         | Default              | Description                                                                                                                                                                             |\n| :---------------------------- | :------------------------------------------- | :------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `allowed_tools`               | `list[str]`                                  | `[]`                 | List of allowed tool names                                                                                                                                                              |\n| `system_prompt`               | `str \\| SystemPromptPreset \\| None`          | `None`               | System prompt configuration. Pass a string for custom prompt, or use `{\"type\": \"preset\", \"preset\": \"claude_code\"}` for Claude Code's system prompt. Add `\"append\"` to extend the preset |\n| `mcp_servers`                 | `dict[str, McpServerConfig] \\| str \\| Path`  | `{}`                 | MCP server configurations or path to config file                                                                                                                                        |\n| `permission_mode`             | `PermissionMode \\| None`                     | `None`               | Permission mode for tool usage                                                                                                                                                          |\n| `continue_conversation`       | `bool`                                       | `False`              | Continue the most recent conversation                                                                                                                                                   |\n| `resume`                      | `str \\| None`                                | `None`               | Session ID to resume                                                                                                                                                                    |\n| `max_turns`                   | `int \\| None`                                | `None`               | Maximum conversation turns                                                                                                                                                              |\n| `disallowed_tools`            | `list[str]`                                  | `[]`                 | List of disallowed tool names                                                                                                                                                           |\n| `enable_file_checkpointing`   | `bool`                                       | `False`              | Enable file change tracking for rewinding. See [File checkpointing](/docs/en/agent-sdk/file-checkpointing)                                                                              |\n| `model`                       | `str \\| None`                                | `None`               | Claude model to use                                                                                                                                                                     |\n| `output_format`               | [`OutputFormat`](#outputformat) ` \\| None`   | `None`               | Define output format for agent results. See [Structured outputs](/docs/en/agent-sdk/structured-outputs) for details                                                                    |\n| `permission_prompt_tool_name` | `str \\| None`                                | `None`               | MCP tool name for permission prompts                                                                                                                                                    |\n| `cwd`                         | `str \\| Path \\| None`                        | `None`               | Current working directory                                                                                                                                                               |\n| `settings`                    | `str \\| None`                                | `None`               | Path to settings file                                                                                                                                                                   |\n| `add_dirs`                    | `list[str \\| Path]`                          | `[]`                 | Additional directories Claude can access                                                                                                                                                |\n| `env`                         | `dict[str, str]`                             | `{}`                 | Environment variables                                                                                                                                                                   |\n| `extra_args`                  | `dict[str, str \\| None]`                     | `{}`                 | Additional CLI arguments to pass directly to the CLI                                                                                                                                    |\n| `max_buffer_size`             | `int \\| None`                                | `None`               | Maximum bytes when buffering CLI stdout                                                                                                                                                 |\n| `debug_stderr`                | `Any`                                        | `sys.stderr`         | _Deprecated_ - File-like object for debug output. Use `stderr` callback instead                                                                                                         |\n| `stderr`                      | `Callable[[str], None] \\| None`              | `None`               | Callback function for stderr output from CLI                                                                                                                                            |\n| `can_use_tool`                | `CanUseTool \\| None`                         | `None`               | Tool permission callback function                                                                                                                                                       |\n| `hooks`                       | `dict[HookEvent, list[HookMatcher]] \\| None` | `None`               | Hook configurations for intercepting events                                                                                                                                             |\n| `user`                        | `str \\| None`                                | `None`               | User identifier                                                                                                                                                                         |\n| `include_partial_messages`    | `bool`                                       | `False`              | Include partial message streaming events                                                                                                                                                |\n| `fork_session`                | `bool`                                       | `False`              | When resuming with `resume`, fork to a new session ID instead of continuing the original session                                                                                        |\n| `agents`                      | `dict[str, AgentDefinition] \\| None`         | `None`               | Programmatically defined subagents                                                                                                                                                      |\n| `plugins`                     | `list[SdkPluginConfig]`                      | `[]`                 | Load custom plugins from local paths. See [Plugins](/docs/en/agent-sdk/plugins) for details                                                                                             |\n| `sandbox`                     | [`SandboxSettings`](#sandboxsettings) ` \\| None` | `None`              | Configure sandbox behavior programmatically. See [Sandbox settings](#sandboxsettings) for details                                        |\n| `setting_sources`             | `list[SettingSource] \\| None`                | `None` (no settings) | Control which filesystem settings to load. When omitted, no settings are loaded. **Note:** Must include `\"project\"` to load CLAUDE.md files                                             |\n\n### `OutputFormat`\n\nConfiguration for structured output validation.\n\n```python\nclass OutputFormat(TypedDict):\n    type: Literal[\"json_schema\"]\n    schema: dict[str, Any]\n```\n\n| Field    | Required | Description                                    |\n| :------- | :------- | :--------------------------------------------- |\n| `type`   | Yes      | Must be `\"json_schema\"` for JSON Schema validation |\n| `schema` | Yes      | JSON Schema definition for output validation   |\n\n### `SystemPromptPreset`\n\nConfiguration for using Claude Code's preset system prompt with optional additions.\n\n```python\nclass SystemPromptPreset(TypedDict):\n    type: Literal[\"preset\"]\n    preset: Literal[\"claude_code\"]\n    append: NotRequired[str]\n```\n\n| Field    | Required | Description                                                   |\n| :------- | :------- | :------------------------------------------------------------ |\n| `type`   | Yes      | Must be `\"preset\"` to use a preset system prompt              |\n| `preset` | Yes      | Must be `\"claude_code\"` to use Claude Code's system prompt    |\n| `append` | No       | Additional instructions to append to the preset system prompt |\n\n### `SettingSource`\n\nControls which filesystem-based configuration sources the SDK loads settings from.\n\n```python\nSettingSource = Literal[\"user\", \"project\", \"local\"]\n```\n\n| Value       | Description                                  | Location                      |\n| :---------- | :------------------------------------------- | :---------------------------- |\n| `\"user\"`    | Global user settings                         | `~/.claude/settings.json`     |\n| `\"project\"` | Shared project settings (version controlled) | `.claude/settings.json`       |\n| `\"local\"`   | Local project settings (gitignored)          | `.claude/settings.local.json` |\n\n#### Default behavior\n\nWhen `setting_sources` is **omitted** or **`None`**, the SDK does **not** load any filesystem settings. This provides isolation for SDK applications.\n\n#### Why use setting_sources?\n\n**Load all filesystem settings (legacy behavior):**\n\n```python\n# Load all settings like SDK v0.0.x did\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync for message in query(\n    prompt=\"Analyze this code\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"user\", \"project\", \"local\"]  # Load all settings\n    )\n):\n    print(message)\n```\n\n**Load only specific setting sources:**\n\n```python\n# Load only project settings, ignore user and local\nasync for message in query(\n    prompt=\"Run CI checks\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"project\"]  # Only .claude/settings.json\n    )\n):\n    print(message)\n```\n\n**Testing and CI environments:**\n\n```python\n# Ensure consistent behavior in CI by excluding local settings\nasync for message in query(\n    prompt=\"Run tests\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"project\"],  # Only team-shared settings\n        permission_mode=\"bypassPermissions\"\n    )\n):\n    print(message)\n```\n\n**SDK-only applications:**\n\n```python\n# Define everything programmatically (default behavior)\n# No filesystem dependencies - setting_sources defaults to None\nasync for message in query(\n    prompt=\"Review this PR\",\n    options=ClaudeAgentOptions(\n        # setting_sources=None is the default, no need to specify\n        agents={ /* ... */ },\n        mcp_servers={ /* ... */ },\n        allowed_tools=[\"Read\", \"Grep\", \"Glob\"]\n    )\n):\n    print(message)\n```\n\n**Loading CLAUDE.md project instructions:**\n\n```python\n# Load project settings to include CLAUDE.md files\nasync for message in query(\n    prompt=\"Add a new feature following project conventions\",\n    options=ClaudeAgentOptions(\n        system_prompt={\n            \"type\": \"preset\",\n            \"preset\": \"claude_code\"  # Use Claude Code's system prompt\n        },\n        setting_sources=[\"project\"],  # Required to load CLAUDE.md from project\n        allowed_tools=[\"Read\", \"Write\", \"Edit\"]\n    )\n):\n    print(message)\n```\n\n#### Settings precedence\n\nWhen multiple sources are loaded, settings are merged with this precedence (highest to lowest):\n\n1. Local settings (`.claude/settings.local.json`)\n2. Project settings (`.claude/settings.json`)\n3. User settings (`~/.claude/settings.json`)\n\nProgrammatic options (like `agents`, `allowed_tools`) always override filesystem settings.\n\n### `AgentDefinition`\n\nConfiguration for a subagent defined programmatically.\n\n```python\n@dataclass\nclass AgentDefinition:\n    description: str\n    prompt: str\n    tools: list[str] | None = None\n    model: Literal[\"sonnet\", \"opus\", \"haiku\", \"inherit\"] | None = None\n```\n\n| Field         | Required | Description                                                    |\n| :------------ | :------- | :------------------------------------------------------------- |\n| `description` | Yes      | Natural language description of when to use this agent         |\n| `tools`       | No       | Array of allowed tool names. If omitted, inherits all tools    |\n| `prompt`      | Yes      | The agent's system prompt                                      |\n| `model`       | No       | Model override for this agent. If omitted, uses the main model |\n\n### `PermissionMode`\n\nPermission modes for controlling tool execution.\n\n```python\nPermissionMode = Literal[\n    \"default\",           # Standard permission behavior\n    \"acceptEdits\",       # Auto-accept file edits\n    \"plan\",              # Planning mode - no execution\n    \"bypassPermissions\"  # Bypass all permission checks (use with caution)\n]\n```\n\n### `McpSdkServerConfig`\n\nConfiguration for SDK MCP servers created with `create_sdk_mcp_server()`.\n\n```python\nclass McpSdkServerConfig(TypedDict):\n    type: Literal[\"sdk\"]\n    name: str\n    instance: Any  # MCP Server instance\n```\n\n### `McpServerConfig`\n\nUnion type for MCP server configurations.\n\n```python\nMcpServerConfig = McpStdioServerConfig | McpSSEServerConfig | McpHttpServerConfig | McpSdkServerConfig\n```\n\n#### `McpStdioServerConfig`\n\n```python\nclass McpStdioServerConfig(TypedDict):\n    type: NotRequired[Literal[\"stdio\"]]  # Optional for backwards compatibility\n    command: str\n    args: NotRequired[list[str]]\n    env: NotRequired[dict[str, str]]\n```\n\n#### `McpSSEServerConfig`\n\n```python\nclass McpSSEServerConfig(TypedDict):\n    type: Literal[\"sse\"]\n    url: str\n    headers: NotRequired[dict[str, str]]\n```\n\n#### `McpHttpServerConfig`\n\n```python\nclass McpHttpServerConfig(TypedDict):\n    type: Literal[\"http\"]\n    url: str\n    headers: NotRequired[dict[str, str]]\n```\n\n### `SdkPluginConfig`\n\nConfiguration for loading plugins in the SDK.\n\n```python\nclass SdkPluginConfig(TypedDict):\n    type: Literal[\"local\"]\n    path: str\n```\n\n| Field | Type | Description |\n|:------|:-----|:------------|\n| `type` | `Literal[\"local\"]` | Must be `\"local\"` (only local plugins currently supported) |\n| `path` | `str` | Absolute or relative path to the plugin directory |\n\n**Example:**\n```python\nplugins=[\n    {\"type\": \"local\", \"path\": \"./my-plugin\"},\n    {\"type\": \"local\", \"path\": \"/absolute/path/to/plugin\"}\n]\n```\n\nFor complete information on creating and using plugins, see [Plugins](/docs/en/agent-sdk/plugins).\n\n## Message Types\n\n### `Message`\n\nUnion type of all possible messages.\n\n```python\nMessage = UserMessage | AssistantMessage | SystemMessage | ResultMessage\n```\n\n### `UserMessage`\n\nUser input message.\n\n```python\n@dataclass\nclass UserMessage:\n    content: str | list[ContentBlock]\n```\n\n### `AssistantMessage`\n\nAssistant response message with content blocks.\n\n```python\n@dataclass\nclass AssistantMessage:\n    content: list[ContentBlock]\n    model: str\n```\n\n### `SystemMessage`\n\nSystem message with metadata.\n\n```python\n@dataclass\nclass SystemMessage:\n    subtype: str\n    data: dict[str, Any]\n```\n\n### `ResultMessage`\n\nFinal result message with cost and usage information.\n\n```python\n@dataclass\nclass ResultMessage:\n    subtype: str\n    duration_ms: int\n    duration_api_ms: int\n    is_error: bool\n    num_turns: int\n    session_id: str\n    total_cost_usd: float | None = None\n    usage: dict[str, Any] | None = None\n    result: str | None = None\n```\n\n## Content Block Types\n\n### `ContentBlock`\n\nUnion type of all content blocks.\n\n```python\nContentBlock = TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock\n```\n\n### `TextBlock`\n\nText content block.\n\n```python\n@dataclass\nclass TextBlock:\n    text: str\n```\n\n### `ThinkingBlock`\n\nThinking content block (for models with thinking capability).\n\n```python\n@dataclass\nclass ThinkingBlock:\n    thinking: str\n    signature: str\n```\n\n### `ToolUseBlock`\n\nTool use request block.\n\n```python\n@dataclass\nclass ToolUseBlock:\n    id: str\n    name: str\n    input: dict[str, Any]\n```\n\n### `ToolResultBlock`\n\nTool execution result block.\n\n```python\n@dataclass\nclass ToolResultBlock:\n    tool_use_id: str\n    content: str | list[dict[str, Any]] | None = None\n    is_error: bool | None = None\n```\n\n## Error Types\n\n### `ClaudeSDKError`\n\nBase exception class for all SDK errors.\n\n```python\nclass ClaudeSDKError(Exception):\n    \"\"\"Base error for Claude SDK.\"\"\"\n```\n\n### `CLINotFoundError`\n\nRaised when Claude Code CLI is not installed or not found.\n\n```python\nclass CLINotFoundError(CLIConnectionError):\n    def __init__(self, message: str = \"Claude Code not found\", cli_path: str | None = None):\n        \"\"\"\n        Args:\n            message: Error message (default: \"Claude Code not found\")\n            cli_path: Optional path to the CLI that was not found\n        \"\"\"\n```\n\n### `CLIConnectionError`\n\nRaised when connection to Claude Code fails.\n\n```python\nclass CLIConnectionError(ClaudeSDKError):\n    \"\"\"Failed to connect to Claude Code.\"\"\"\n```\n\n### `ProcessError`\n\nRaised when the Claude Code process fails.\n\n```python\nclass ProcessError(ClaudeSDKError):\n    def __init__(self, message: str, exit_code: int | None = None, stderr: str | None = None):\n        self.exit_code = exit_code\n        self.stderr = stderr\n```\n\n### `CLIJSONDecodeError`\n\nRaised when JSON parsing fails.\n\n```python\nclass CLIJSONDecodeError(ClaudeSDKError):\n    def __init__(self, line: str, original_error: Exception):\n        \"\"\"\n        Args:\n            line: The line that failed to parse\n            original_error: The original JSON decode exception\n        \"\"\"\n        self.line = line\n        self.original_error = original_error\n```\n\n## Hook Types\n\nFor a comprehensive guide on using hooks with examples and common patterns, see the [Hooks guide](/en/docs/agent-sdk/hooks).\n\n### `HookEvent`\n\nSupported hook event types. Note that due to setup limitations, the Python SDK does not support SessionStart, SessionEnd, and Notification hooks.\n\n```python\nHookEvent = Literal[\n    \"PreToolUse\",      # Called before tool execution\n    \"PostToolUse\",     # Called after tool execution\n    \"UserPromptSubmit\", # Called when user submits a prompt\n    \"Stop\",            # Called when stopping execution\n    \"SubagentStop\",    # Called when a subagent stops\n    \"PreCompact\"       # Called before message compaction\n]\n```\n\n### `HookCallback`\n\nType definition for hook callback functions.\n\n```python\nHookCallback = Callable[\n    [dict[str, Any], str | None, HookContext],\n    Awaitable[dict[str, Any]]\n]\n```\n\nParameters:\n\n- `input_data`: Hook-specific input data (see [Hooks guide](/docs/en/agent-sdk/hooks#input-data))\n- `tool_use_id`: Optional tool use identifier (for tool-related hooks)\n- `context`: Hook context with additional information\n\nReturns a dictionary that may contain:\n\n- `decision`: `\"block\"` to block the action\n- `systemMessage`: System message to add to the transcript\n- `hookSpecificOutput`: Hook-specific output data\n\n### `HookContext`\n\nContext information passed to hook callbacks.\n\n```python\n@dataclass\nclass HookContext:\n    signal: Any | None = None  # Future: abort signal support\n```\n\n### `HookMatcher`\n\nConfiguration for matching hooks to specific events or tools.\n\n```python\n@dataclass\nclass HookMatcher:\n    matcher: str | None = None        # Tool name or pattern to match (e.g., \"Bash\", \"Write|Edit\")\n    hooks: list[HookCallback] = field(default_factory=list)  # List of callbacks to execute\n    timeout: float | None = None        # Timeout in seconds for all hooks in this matcher (default: 60)\n```\n\n### Hook Usage Example\n\nThis example registers two hooks: one that blocks dangerous bash commands like `rm -rf /`, and another that logs all tool usage for auditing. The security hook only runs on Bash commands (via the `matcher`), while the logging hook runs on all tools.\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions, HookMatcher, HookContext\nfrom typing import Any\n\nasync def validate_bash_command(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Validate and potentially block dangerous bash commands.\"\"\"\n    if input_data['tool_name'] == 'Bash':\n        command = input_data['tool_input'].get('command', '')\n        if 'rm -rf /' in command:\n            return {\n                'hookSpecificOutput': {\n                    'hookEventName': 'PreToolUse',\n                    'permissionDecision': 'deny',\n                    'permissionDecisionReason': 'Dangerous command blocked'\n                }\n            }\n    return {}\n\nasync def log_tool_use(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log all tool usage for auditing.\"\"\"\n    print(f\"Tool used: {input_data.get('tool_name')}\")\n    return {}\n\noptions = ClaudeAgentOptions(\n    hooks={\n        'PreToolUse': [\n            HookMatcher(matcher='Bash', hooks=[validate_bash_command], timeout=120),  # 2 min for validation\n            HookMatcher(hooks=[log_tool_use])  # Applies to all tools (default 60s timeout)\n        ],\n        'PostToolUse': [\n            HookMatcher(hooks=[log_tool_use])\n        ]\n    }\n)\n\nasync for message in query(\n    prompt=\"Analyze this codebase\",\n    options=options\n):\n    print(message)\n```\n\n## Tool Input/Output Types\n\nDocumentation of input/output schemas for all built-in Claude Code tools. While the Python SDK doesn't export these as types, they represent the structure of tool inputs and outputs in messages.\n\n### Task\n\n**Tool name:** `Task`\n\n**Input:**\n\n```python\n{\n    \"description\": str,      # A short (3-5 word) description of the task\n    \"prompt\": str,           # The task for the agent to perform\n    \"subagent_type\": str     # The type of specialized agent to use\n}\n```\n\n**Output:**\n\n```python\n{\n    \"result\": str,                    # Final result from the subagent\n    \"usage\": dict | None,             # Token usage statistics\n    \"total_cost_usd\": float | None,  # Total cost in USD\n    \"duration_ms\": int | None         # Execution duration in milliseconds\n}\n```\n\n### AskUserQuestion\n\n**Tool name:** `AskUserQuestion`\n\nAsks the user clarifying questions during execution. See [Handle approvals and user input](/docs/en/agent-sdk/user-input#handle-clarifying-questions) for usage details.\n\n**Input:**\n\n```python\n{\n    \"questions\": [                    # Questions to ask the user (1-4 questions)\n        {\n            \"question\": str,          # The complete question to ask the user\n            \"header\": str,            # Very short label displayed as a chip/tag (max 12 chars)\n            \"options\": [              # The available choices (2-4 options)\n                {\n                    \"label\": str,         # Display text for this option (1-5 words)\n                    \"description\": str    # Explanation of what this option means\n                }\n            ],\n            \"multiSelect\": bool       # Set to true to allow multiple selections\n        }\n    ],\n    \"answers\": dict | None            # User answers populated by the permission system\n}\n```\n\n**Output:**\n\n```python\n{\n    \"questions\": [                    # The questions that were asked\n        {\n            \"question\": str,\n            \"header\": str,\n            \"options\": [{\"label\": str, \"description\": str}],\n            \"multiSelect\": bool\n        }\n    ],\n    \"answers\": dict[str, str]         # Maps question text to answer string\n                                      # Multi-select answers are comma-separated\n}\n```\n\n### Bash\n\n**Tool name:** `Bash`\n\n**Input:**\n\n```python\n{\n    \"command\": str,                  # The command to execute\n    \"timeout\": int | None,           # Optional timeout in milliseconds (max 600000)\n    \"description\": str | None,       # Clear, concise description (5-10 words)\n    \"run_in_background\": bool | None # Set to true to run in background\n}\n```\n\n**Output:**\n\n```python\n{\n    \"output\": str,              # Combined stdout and stderr output\n    \"exitCode\": int,            # Exit code of the command\n    \"killed\": bool | None,      # Whether command was killed due to timeout\n    \"shellId\": str | None       # Shell ID for background processes\n}\n```\n\n### Edit\n\n**Tool name:** `Edit`\n\n**Input:**\n\n```python\n{\n    \"file_path\": str,           # The absolute path to the file to modify\n    \"old_string\": str,          # The text to replace\n    \"new_string\": str,          # The text to replace it with\n    \"replace_all\": bool | None  # Replace all occurrences (default False)\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,      # Confirmation message\n    \"replacements\": int, # Number of replacements made\n    \"file_path\": str     # File path that was edited\n}\n```\n\n### Read\n\n**Tool name:** `Read`\n\n**Input:**\n\n```python\n{\n    \"file_path\": str,       # The absolute path to the file to read\n    \"offset\": int | None,   # The line number to start reading from\n    \"limit\": int | None     # The number of lines to read\n}\n```\n\n**Output (Text files):**\n\n```python\n{\n    \"content\": str,         # File contents with line numbers\n    \"total_lines\": int,     # Total number of lines in file\n    \"lines_returned\": int   # Lines actually returned\n}\n```\n\n**Output (Images):**\n\n```python\n{\n    \"image\": str,       # Base64 encoded image data\n    \"mime_type\": str,   # Image MIME type\n    \"file_size\": int    # File size in bytes\n}\n```\n\n### Write\n\n**Tool name:** `Write`\n\n**Input:**\n\n```python\n{\n    \"file_path\": str,  # The absolute path to the file to write\n    \"content\": str     # The content to write to the file\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,        # Success message\n    \"bytes_written\": int,  # Number of bytes written\n    \"file_path\": str       # File path that was written\n}\n```\n\n### Glob\n\n**Tool name:** `Glob`\n\n**Input:**\n\n```python\n{\n    \"pattern\": str,       # The glob pattern to match files against\n    \"path\": str | None    # The directory to search in (defaults to cwd)\n}\n```\n\n**Output:**\n\n```python\n{\n    \"matches\": list[str],  # Array of matching file paths\n    \"count\": int,          # Number of matches found\n    \"search_path\": str     # Search directory used\n}\n```\n\n### Grep\n\n**Tool name:** `Grep`\n\n**Input:**\n\n```python\n{\n    \"pattern\": str,                    # The regular expression pattern\n    \"path\": str | None,                # File or directory to search in\n    \"glob\": str | None,                # Glob pattern to filter files\n    \"type\": str | None,                # File type to search\n    \"output_mode\": str | None,         # \"content\", \"files_with_matches\", or \"count\"\n    \"-i\": bool | None,                 # Case insensitive search\n    \"-n\": bool | None,                 # Show line numbers\n    \"-B\": int | None,                  # Lines to show before each match\n    \"-A\": int | None,                  # Lines to show after each match\n    \"-C\": int | None,                  # Lines to show before and after\n    \"head_limit\": int | None,          # Limit output to first N lines/entries\n    \"multiline\": bool | None           # Enable multiline mode\n}\n```\n\n**Output (content mode):**\n\n```python\n{\n    \"matches\": [\n        {\n            \"file\": str,\n            \"line_number\": int | None,\n            \"line\": str,\n            \"before_context\": list[str] | None,\n            \"after_context\": list[str] | None\n        }\n    ],\n    \"total_matches\": int\n}\n```\n\n**Output (files_with_matches mode):**\n\n```python\n{\n    \"files\": list[str],  # Files containing matches\n    \"count\": int         # Number of files with matches\n}\n```\n\n### NotebookEdit\n\n**Tool name:** `NotebookEdit`\n\n**Input:**\n\n```python\n{\n    \"notebook_path\": str,                     # Absolute path to the Jupyter notebook\n    \"cell_id\": str | None,                    # The ID of the cell to edit\n    \"new_source\": str,                        # The new source for the cell\n    \"cell_type\": \"code\" | \"markdown\" | None,  # The type of the cell\n    \"edit_mode\": \"replace\" | \"insert\" | \"delete\" | None  # Edit operation type\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,                              # Success message\n    \"edit_type\": \"replaced\" | \"inserted\" | \"deleted\",  # Type of edit performed\n    \"cell_id\": str | None,                       # Cell ID that was affected\n    \"total_cells\": int                           # Total cells in notebook after edit\n}\n```\n\n### WebFetch\n\n**Tool name:** `WebFetch`\n\n**Input:**\n\n```python\n{\n    \"url\": str,     # The URL to fetch content from\n    \"prompt\": str   # The prompt to run on the fetched content\n}\n```\n\n**Output:**\n\n```python\n{\n    \"response\": str,           # AI model's response to the prompt\n    \"url\": str,                # URL that was fetched\n    \"final_url\": str | None,   # Final URL after redirects\n    \"status_code\": int | None  # HTTP status code\n}\n```\n\n### WebSearch\n\n**Tool name:** `WebSearch`\n\n**Input:**\n\n```python\n{\n    \"query\": str,                        # The search query to use\n    \"allowed_domains\": list[str] | None, # Only include results from these domains\n    \"blocked_domains\": list[str] | None  # Never include results from these domains\n}\n```\n\n**Output:**\n\n```python\n{\n    \"results\": [\n        {\n            \"title\": str,\n            \"url\": str,\n            \"snippet\": str,\n            \"metadata\": dict | None\n        }\n    ],\n    \"total_results\": int,\n    \"query\": str\n}\n```\n\n### TodoWrite\n\n**Tool name:** `TodoWrite`\n\n**Input:**\n\n```python\n{\n    \"todos\": [\n        {\n            \"content\": str,                              # The task description\n            \"status\": \"pending\" | \"in_progress\" | \"completed\",  # Task status\n            \"activeForm\": str                            # Active form of the description\n        }\n    ]\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,  # Success message\n    \"stats\": {\n        \"total\": int,\n        \"pending\": int,\n        \"in_progress\": int,\n        \"completed\": int\n    }\n}\n```\n\n### BashOutput\n\n**Tool name:** `BashOutput`\n\n**Input:**\n\n```python\n{\n    \"bash_id\": str,       # The ID of the background shell\n    \"filter\": str | None  # Optional regex to filter output lines\n}\n```\n\n**Output:**\n\n```python\n{\n    \"output\": str,                                      # New output since last check\n    \"status\": \"running\" | \"completed\" | \"failed\",       # Current shell status\n    \"exitCode\": int | None                              # Exit code when completed\n}\n```\n\n### KillBash\n\n**Tool name:** `KillBash`\n\n**Input:**\n\n```python\n{\n    \"shell_id\": str  # The ID of the background shell to kill\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,  # Success message\n    \"shell_id\": str  # ID of the killed shell\n}\n```\n\n### ExitPlanMode\n\n**Tool name:** `ExitPlanMode`\n\n**Input:**\n\n```python\n{\n    \"plan\": str  # The plan to run by the user for approval\n}\n```\n\n**Output:**\n\n```python\n{\n    \"message\": str,          # Confirmation message\n    \"approved\": bool | None  # Whether user approved the plan\n}\n```\n\n### ListMcpResources\n\n**Tool name:** `ListMcpResources`\n\n**Input:**\n\n```python\n{\n    \"server\": str | None  # Optional server name to filter resources by\n}\n```\n\n**Output:**\n\n```python\n{\n    \"resources\": [\n        {\n            \"uri\": str,\n            \"name\": str,\n            \"description\": str | None,\n            \"mimeType\": str | None,\n            \"server\": str\n        }\n    ],\n    \"total\": int\n}\n```\n\n### ReadMcpResource\n\n**Tool name:** `ReadMcpResource`\n\n**Input:**\n\n```python\n{\n    \"server\": str,  # The MCP server name\n    \"uri\": str      # The resource URI to read\n}\n```\n\n**Output:**\n\n```python\n{\n    \"contents\": [\n        {\n            \"uri\": str,\n            \"mimeType\": str | None,\n            \"text\": str | None,\n            \"blob\": str | None\n        }\n    ],\n    \"server\": str\n}\n```\n\n## Advanced Features with ClaudeSDKClient\n\n### Building a Continuous Conversation Interface\n\n```python\nfrom claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions, AssistantMessage, TextBlock\nimport asyncio\n\nclass ConversationSession:\n    \"\"\"Maintains a single conversation session with Claude.\"\"\"\n\n    def __init__(self, options: ClaudeAgentOptions = None):\n        self.client = ClaudeSDKClient(options)\n        self.turn_count = 0\n\n    async def start(self):\n        await self.client.connect()\n        print(\"Starting conversation session. Claude will remember context.\")\n        print(\"Commands: 'exit' to quit, 'interrupt' to stop current task, 'new' for new session\")\n\n        while True:\n            user_input = input(f\"\\n[Turn {self.turn_count + 1}] You: \")\n\n            if user_input.lower() == 'exit':\n                break\n            elif user_input.lower() == 'interrupt':\n                await self.client.interrupt()\n                print(\"Task interrupted!\")\n                continue\n            elif user_input.lower() == 'new':\n                # Disconnect and reconnect for a fresh session\n                await self.client.disconnect()\n                await self.client.connect()\n                self.turn_count = 0\n                print(\"Started new conversation session (previous context cleared)\")\n                continue\n\n            # Send message - Claude remembers all previous messages in this session\n            await self.client.query(user_input)\n            self.turn_count += 1\n\n            # Process response\n            print(f\"[Turn {self.turn_count}] Claude: \", end=\"\")\n            async for message in self.client.receive_response():\n                if isinstance(message, AssistantMessage):\n                    for block in message.content:\n                        if isinstance(block, TextBlock):\n                            print(block.text, end=\"\")\n            print()  # New line after response\n\n        await self.client.disconnect()\n        print(f\"Conversation ended after {self.turn_count} turns.\")\n\nasync def main():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n    session = ConversationSession(options)\n    await session.start()\n\n# Example conversation:\n# Turn 1 - You: \"Create a file called hello.py\"\n# Turn 1 - Claude: \"I'll create a hello.py file for you...\"\n# Turn 2 - You: \"What's in that file?\"\n# Turn 2 - Claude: \"The hello.py file I just created contains...\" (remembers!)\n# Turn 3 - You: \"Add a main function to it\"\n# Turn 3 - Claude: \"I'll add a main function to hello.py...\" (knows which file!)\n\nasyncio.run(main())\n```\n\n### Using Hooks for Behavior Modification\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    HookMatcher,\n    HookContext\n)\nimport asyncio\nfrom typing import Any\n\nasync def pre_tool_logger(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log all tool usage before execution.\"\"\"\n    tool_name = input_data.get('tool_name', 'unknown')\n    print(f\"[PRE-TOOL] About to use: {tool_name}\")\n\n    # You can modify or block the tool execution here\n    if tool_name == \"Bash\" and \"rm -rf\" in str(input_data.get('tool_input', {})):\n        return {\n            'hookSpecificOutput': {\n                'hookEventName': 'PreToolUse',\n                'permissionDecision': 'deny',\n                'permissionDecisionReason': 'Dangerous command blocked'\n            }\n        }\n    return {}\n\nasync def post_tool_logger(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log results after tool execution.\"\"\"\n    tool_name = input_data.get('tool_name', 'unknown')\n    print(f\"[POST-TOOL] Completed: {tool_name}\")\n    return {}\n\nasync def user_prompt_modifier(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Add context to user prompts.\"\"\"\n    original_prompt = input_data.get('prompt', '')\n\n    # Add timestamp to all prompts\n    from datetime import datetime\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    return {\n        'hookSpecificOutput': {\n            'hookEventName': 'UserPromptSubmit',\n            'updatedPrompt': f\"[{timestamp}] {original_prompt}\"\n        }\n    }\n\nasync def main():\n    options = ClaudeAgentOptions(\n        hooks={\n            'PreToolUse': [\n                HookMatcher(hooks=[pre_tool_logger]),\n                HookMatcher(matcher='Bash', hooks=[pre_tool_logger])\n            ],\n            'PostToolUse': [\n                HookMatcher(hooks=[post_tool_logger])\n            ],\n            'UserPromptSubmit': [\n                HookMatcher(hooks=[user_prompt_modifier])\n            ]\n        },\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"]\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"List files in current directory\")\n\n        async for message in client.receive_response():\n            # Hooks will automatically log tool usage\n            pass\n\nasyncio.run(main())\n```\n\n### Real-time Progress Monitoring\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    AssistantMessage,\n    ToolUseBlock,\n    ToolResultBlock,\n    TextBlock\n)\nimport asyncio\n\nasync def monitor_progress():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Write\", \"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\n            \"Create 5 Python files with different sorting algorithms\"\n        )\n\n        # Monitor progress in real-time\n        files_created = []\n        async for message in client.receive_messages():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, ToolUseBlock):\n                        if block.name == \"Write\":\n                            file_path = block.input.get(\"file_path\", \"\")\n                            print(f\"🔨 Creating: {file_path}\")\n                    elif isinstance(block, ToolResultBlock):\n                        print(f\"✅ Completed tool execution\")\n                    elif isinstance(block, TextBlock):\n                        print(f\"💭 Claude says: {block.text[:100]}...\")\n\n            # Check if we've received the final result\n            if hasattr(message, 'subtype') and message.subtype in ['success', 'error']:\n                print(f\"\\n🎯 Task completed!\")\n                break\n\nasyncio.run(monitor_progress())\n```\n\n## Example Usage\n\n### Basic file operations (using query)\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions, AssistantMessage, ToolUseBlock\nimport asyncio\n\nasync def create_project():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"],\n        permission_mode='acceptEdits',\n        cwd=\"/home/user/project\"\n    )\n\n    async for message in query(\n        prompt=\"Create a Python project structure with setup.py\",\n        options=options\n    ):\n        if isinstance(message, AssistantMessage):\n            for block in message.content:\n                if isinstance(block, ToolUseBlock):\n                    print(f\"Using tool: {block.name}\")\n\nasyncio.run(create_project())\n```\n\n### Error handling\n\n```python\nfrom claude_agent_sdk import (\n    query,\n    CLINotFoundError,\n    ProcessError,\n    CLIJSONDecodeError\n)\n\ntry:\n    async for message in query(prompt=\"Hello\"):\n        print(message)\nexcept CLINotFoundError:\n    print(\"Please install Claude Code: npm install -g @anthropic-ai/claude-code\")\nexcept ProcessError as e:\n    print(f\"Process failed with exit code: {e.exit_code}\")\nexcept CLIJSONDecodeError as e:\n    print(f\"Failed to parse response: {e}\")\n```\n\n### Streaming mode with client\n\n```python\nfrom claude_agent_sdk import ClaudeSDKClient\nimport asyncio\n\nasync def interactive_session():\n    async with ClaudeSDKClient() as client:\n        # Send initial message\n        await client.query(\"What's the weather like?\")\n\n        # Process responses\n        async for msg in client.receive_response():\n            print(msg)\n\n        # Send follow-up\n        await client.query(\"Tell me more about that\")\n\n        # Process follow-up response\n        async for msg in client.receive_response():\n            print(msg)\n\nasyncio.run(interactive_session())\n```\n\n### Using custom tools with ClaudeSDKClient\n\n```python\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    tool,\n    create_sdk_mcp_server,\n    AssistantMessage,\n    TextBlock\n)\nimport asyncio\nfrom typing import Any\n\n# Define custom tools with @tool decorator\n@tool(\"calculate\", \"Perform mathematical calculations\", {\"expression\": str})\nasync def calculate(args: dict[str, Any]) -> dict[str, Any]:\n    try:\n        result = eval(args[\"expression\"], {\"__builtins__\": {}})\n        return {\n            \"content\": [{\n                \"type\": \"text\",\n                \"text\": f\"Result: {result}\"\n            }]\n        }\n    except Exception as e:\n        return {\n            \"content\": [{\n                \"type\": \"text\",\n                \"text\": f\"Error: {str(e)}\"\n            }],\n            \"is_error\": True\n        }\n\n@tool(\"get_time\", \"Get current time\", {})\nasync def get_time(args: dict[str, Any]) -> dict[str, Any]:\n    from datetime import datetime\n    current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Current time: {current_time}\"\n        }]\n    }\n\nasync def main():\n    # Create SDK MCP server with custom tools\n    my_server = create_sdk_mcp_server(\n        name=\"utilities\",\n        version=\"1.0.0\",\n        tools=[calculate, get_time]\n    )\n\n    # Configure options with the server\n    options = ClaudeAgentOptions(\n        mcp_servers={\"utils\": my_server},\n        allowed_tools=[\n            \"mcp__utils__calculate\",\n            \"mcp__utils__get_time\"\n        ]\n    )\n\n    # Use ClaudeSDKClient for interactive tool usage\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"What's 123 * 456?\")\n\n        # Process calculation response\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Calculation: {block.text}\")\n\n        # Follow up with time query\n        await client.query(\"What time is it now?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Time: {block.text}\")\n\nasyncio.run(main())\n```\n\n## Sandbox Configuration\n\n### `SandboxSettings`\n\nConfiguration for sandbox behavior. Use this to enable command sandboxing and configure network restrictions programmatically.\n\n```python\nclass SandboxSettings(TypedDict, total=False):\n    enabled: bool\n    autoAllowBashIfSandboxed: bool\n    excludedCommands: list[str]\n    allowUnsandboxedCommands: bool\n    network: SandboxNetworkConfig\n    ignoreViolations: SandboxIgnoreViolations\n    enableWeakerNestedSandbox: bool\n```\n\n| Property | Type | Default | Description |\n| :------- | :--- | :------ | :---------- |\n| `enabled` | `bool` | `False` | Enable sandbox mode for command execution |\n| `autoAllowBashIfSandboxed` | `bool` | `False` | Auto-approve bash commands when sandbox is enabled |\n| `excludedCommands` | `list[str]` | `[]` | Commands that always bypass sandbox restrictions (e.g., `[\"docker\"]`). These run unsandboxed automatically without model involvement |\n| `allowUnsandboxedCommands` | `bool` | `False` | Allow the model to request running commands outside the sandbox. When `True`, the model can set `dangerouslyDisableSandbox` in tool input, which falls back to the [permissions system](#permissions-fallback-for-unsandboxed-commands) |\n| `network` | [`SandboxNetworkConfig`](#sandboxnetworkconfig) | `None` | Network-specific sandbox configuration |\n| `ignoreViolations` | [`SandboxIgnoreViolations`](#sandboxignoreviolations) | `None` | Configure which sandbox violations to ignore |\n| `enableWeakerNestedSandbox` | `bool` | `False` | Enable a weaker nested sandbox for compatibility |\n\n<Note>\n**Filesystem and network access restrictions** are NOT configured via sandbox settings. Instead, they are derived from [permission rules](https://code.claude.com/docs/en/settings#permission-settings):\n\n- **Filesystem read restrictions**: Read deny rules\n- **Filesystem write restrictions**: Edit allow/deny rules\n- **Network restrictions**: WebFetch allow/deny rules\n\nUse sandbox settings for command execution sandboxing, and permission rules for filesystem and network access control.\n</Note>\n\n#### Example usage\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions, SandboxSettings\n\nsandbox_settings: SandboxSettings = {\n    \"enabled\": True,\n    \"autoAllowBashIfSandboxed\": True,\n    \"network\": {\n        \"allowLocalBinding\": True\n    }\n}\n\nasync for message in query(\n    prompt=\"Build and test my project\",\n    options=ClaudeAgentOptions(sandbox=sandbox_settings)\n):\n    print(message)\n```\n\n<Warning>\n**Unix socket security**: The `allowUnixSockets` option can grant access to powerful system services. For example, allowing `/var/run/docker.sock` effectively grants full host system access through the Docker API, bypassing sandbox isolation. Only allow Unix sockets that are strictly necessary and understand the security implications of each.\n</Warning>\n\n### `SandboxNetworkConfig`\n\nNetwork-specific configuration for sandbox mode.\n\n```python\nclass SandboxNetworkConfig(TypedDict, total=False):\n    allowLocalBinding: bool\n    allowUnixSockets: list[str]\n    allowAllUnixSockets: bool\n    httpProxyPort: int\n    socksProxyPort: int\n```\n\n| Property | Type | Default | Description |\n| :------- | :--- | :------ | :---------- |\n| `allowLocalBinding` | `bool` | `False` | Allow processes to bind to local ports (e.g., for dev servers) |\n| `allowUnixSockets` | `list[str]` | `[]` | Unix socket paths that processes can access (e.g., Docker socket) |\n| `allowAllUnixSockets` | `bool` | `False` | Allow access to all Unix sockets |\n| `httpProxyPort` | `int` | `None` | HTTP proxy port for network requests |\n| `socksProxyPort` | `int` | `None` | SOCKS proxy port for network requests |\n\n### `SandboxIgnoreViolations`\n\nConfiguration for ignoring specific sandbox violations.\n\n```python\nclass SandboxIgnoreViolations(TypedDict, total=False):\n    file: list[str]\n    network: list[str]\n```\n\n| Property | Type | Default | Description |\n| :------- | :--- | :------ | :---------- |\n| `file` | `list[str]` | `[]` | File path patterns to ignore violations for |\n| `network` | `list[str]` | `[]` | Network patterns to ignore violations for |\n\n### Permissions Fallback for Unsandboxed Commands\n\nWhen `allowUnsandboxedCommands` is enabled, the model can request to run commands outside the sandbox by setting `dangerouslyDisableSandbox: True` in the tool input. These requests fall back to the existing permissions system, meaning your `can_use_tool` handler will be invoked, allowing you to implement custom authorization logic.\n\n<Note>\n**`excludedCommands` vs `allowUnsandboxedCommands`:**\n- `excludedCommands`: A static list of commands that always bypass the sandbox automatically (e.g., `[\"docker\"]`). The model has no control over this.\n- `allowUnsandboxedCommands`: Lets the model decide at runtime whether to request unsandboxed execution by setting `dangerouslyDisableSandbox: True` in the tool input.\n</Note>\n\n```python\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync def can_use_tool(tool: str, input: dict) -> bool:\n    # Check if the model is requesting to bypass the sandbox\n    if tool == \"Bash\" and input.get(\"dangerouslyDisableSandbox\"):\n        # The model wants to run this command outside the sandbox\n        print(f\"Unsandboxed command requested: {input.get('command')}\")\n\n        # Return True to allow, False to deny\n        return is_command_authorized(input.get(\"command\"))\n    return True\n\nasync def main():\n    async for message in query(\n        prompt=\"Deploy my application\",\n        options=ClaudeAgentOptions(\n            sandbox={\n                \"enabled\": True,\n                \"allowUnsandboxedCommands\": True  # Model can request unsandboxed execution\n            },\n            permission_mode=\"default\",\n            can_use_tool=can_use_tool\n        )\n    ):\n        print(message)\n```\n\nThis pattern enables you to:\n\n- **Audit model requests**: Log when the model requests unsandboxed execution\n- **Implement allowlists**: Only permit specific commands to run unsandboxed\n- **Add approval workflows**: Require explicit authorization for privileged operations\n\n<Warning>\nCommands running with `dangerouslyDisableSandbox: True` have full system access. Ensure your `can_use_tool` handler validates these requests carefully.\n\nIf `permission_mode` is set to `bypassPermissions` and `allow_unsandboxed_commands` is enabled, the model can autonomously execute commands outside the sandbox without any approval prompts. This combination effectively allows the model to escape sandbox isolation silently.\n</Warning>\n\n## See also\n\n- [Python SDK guide](/docs/en/agent-sdk/python) - Tutorial and examples\n- [SDK overview](/docs/en/agent-sdk/overview) - General SDK concepts\n- [TypeScript SDK reference](/docs/en/agent-sdk/typescript) - TypeScript SDK documentation\n- [CLI reference](https://code.claude.com/docs/en/cli-reference) - Command-line interface\n- [Common workflows](https://code.claude.com/docs/en/common-workflows) - Step-by-step guides","durationMs":6251,"url":"https://platform.claude.com/docs/en/api/agent-sdk/python"},"sourceToolAssistantUUID":"957a466c-9465-4a1b-a90c-ac0c42f487ad"}
{"parentUuid":"b8fd2460-f5e6-4ef3-9c58-fc79359e995e","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_014aXhWjNAJCZE2L7oDL4R5q","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have both the implementation and the official documentation. Let me analyze the core.py file against the SDK documentation to provide a comprehensive comparison.\n\nThe key things I need to check:\n\n1. Is this using the official Python Agent SDK at all? Looking at the imports, I see:\n   - No imports from `claude_agent_sdk`\n   - Instead imports from `services.llm` and other internal modules\n   - This is NOT using the official Agent SDK\n\n2. So this is a custom implementation. Let me compare its patterns against what the SDK recommends:\n\n**Architecture Differences:**\n- The SDK provides `query()` and `ClaudeSDKClient` for agent creation\n- This code has a custom `CoreAgent` class\n- The SDK manages message history automatically\n- This code manually manages messages\n\n**Agentic Loop:**\n- SDK: Built-in through `receive_messages()` and `receive_response()`\n- CoreAgent: Custom loop in `run()` method with manual iteration control\n\n**Tool Execution:**\n- SDK: Tools defined with `@tool` decorator and `create_sdk_mcp_server()`\n- CoreAgent: Custom tool registry and manual tool execution\n\n**Message History:**\n- SDK: Automatic message history management in sessions\n- CoreAgent: Manual message list management with filtering\n\n**State Management:**\n- SDK: Session-based state in ClaudeSDKClient\n- CoreAgent: Custom AgentState enum and manual state tracking\n\nLet me write a comprehensive analysis report.","signature":"EpgMCkgICxACGAIqQBbDMmNrHYWKYkJrP0GGYgL/WYkkgy15q3smvv2BRiN91niM3E94Ic208x6xmK5Mt44c8IasOXkSmcL4pI0hXOcSDA1l0mTsRJ6dCT+MpBoMJadKp/E4rslmy4XlIjD61aAdtubByrmyuxYSuxX4iwBNjqBkCOv8H1jHuOspcJwKXlEnRODs+Qch8636Bv8q/QqwGeRG7sfZR4JgRbECDxqBSl7GSQZEz3aZrBsKmQc6tT2vxNGLpL/mK6gpuhnoMq3kbTeXsnFh6KK0RRhNDF/tq/vLYio9fQTE1KIgwARHdp1aw4O7Ox5wUe2PSf+drfB6qnFeIPhltuzHx1PM01pWgPupDaQvScFiwDB5hIJQEp3Ba+NTdonUspRhksqioICh6SOfc/X0TSCOWECa7r0JqBNUWnkTWSCkKaWviDUR8V0QdC2C7Hguzjf9pvm5dEkQh4J+ydBxqGHF+fAIl8CzTxrHpvieYByhiYfXKTE1+81FO8mQpvxSX02t2m6JU7O6KyDP9cHHRaCggj64fKho7t7onEJPrAy7z8arBZPlZPZV2OclBm0ner13lyRdLpO+/sEBigFjHoCfHq1cQZdQBgMmumXDLlJNVus3j5SNWkcFeTLDmpM5DZuCEG/ofTp8TMLI7Xu68VLeLt+2a1v+wZguMO8qUolDX7V69mX7nSpzh6BLKczc2XhI/goh/CqGT92RDXvwnmqvINtR527tVJ7KzVcvj0ShpNFcXGTOXI3topwQBjhHs9SgA4qe0mkFR96wzQuJSnLPcBNwv/btXjHWpm/L8HWoT6xmy7XWemD9k1y4XqH9ww/S6lKphdUE7hbFQVdR++4qqIXdimSUawuYH1QKxy1i3EpXs/2+vPwHRpYDjGMo6By3ZNnyktXK9TBpN9rCStHUAUGLBDeS+K6qZk8tkw2ObMYTGyQ6+HEcDMeRoU+gMqFhz9hHqIPf2imUjLb/qhCQQWq7bCg1/WZAVfADOnIVj59Jvwo3CMU/3dvRcYaxuZQgV3uarQtp8wK08MxJbaBENtr8FNlnAvtFvROp7drQp3Fw4V/gAdxjt9HsGrTH0jpLEtj/7CFT/yBsIoiAO7Fu5l3Q+i7BWlDReURcYMyNTbHJ6fxKrG83nLfjnOl54ogHWxQagHX94u0t8tnAtYYln3DL4aqw/57uLOygNmwek1zDhfuBaKPa9mXtUpwjOu6jaHYtWf2dT6QOttfLeRSg6Hi3ffhCPUbRtstHsBFvECNAdNBsUEoUxnx9qXqJZi4wsHcJMshkhD5c0tAVhoR9IfhDRo/KwlCteLO1idTiFwk5udQVIdHyWJtkld+ZzQglzDFye3DS7uN+AI4hwVB4G+nY/CDTJpiJz0gTEFbsQDj4fI4TBG9VMp0A/1O5sD0gBT/JEAhj2i6y69Uo74N+j9V36Fe+5hlKeFFDd0ui+kjOJlLQkulYmKWf2TddqAZ6xGhiA2RLTXUBln8je6QXIRKMvbmpd2HZwg6VDUtzvistNHba2osmJnaSUMAF/LoKFusf+EXb5pGrEKfRq1pn/Gu9/XvtIAVfKPp4mdWewENR8/GWPFqSixoM7Div2fE6z4CssnfJVTctUEK+pJIeo89p2LaFhXOyn/HBMxVClOsPy9buAtSqzVekrIoyH5v5pKgtE4SZXeAfhObu/BmCROjW6NTPgC/8tPQJcq7c5C0P4eZo9m2Bspd0/1RKcmpjzkUhnrhoVuNjztUMqGNPa5cx/ldxgteIHkxOta3CmjQGkyb9ALhE+Wz6Cps//FvtJbbIu1BaYDrrLIRpqp1D16wz1jHmmzjY0t3TiEuFcLH+QKHvy9rCOpnGBgNNfNpcxYdSaq3HGYh88tXHpMA3Nd1m9N/XBHfwFmrRjS7ZiuYTlHchVhNan0m3zNyGZ7KMWHwfkV0MzJ74vAG4FFssd94zCmatQQYA1OUVoSYOkL2269Tbn6xeY4t97MYRyLfqwLaHuiuLEgOVZKQes5S/PWzGScbbZTzrFWZp5uVECsZoCAaYTqaGHVoFKam8J/wZUU4f3yJV/tdS4P9VYYhC8PShGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":17870,"cache_read_input_tokens":46427,"cache_creation":{"ephemeral_5m_input_tokens":17870,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"requestId":"req_vrtx_011CXK1Ydevv9GjMcuvGzEdL","type":"assistant","uuid":"caf780f7-7eae-45bd-8fbd-53fe00860dd9","timestamp":"2026-01-20T17:17:44.946Z"}
{"parentUuid":"caf780f7-7eae-45bd-8fbd-53fe00860dd9","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_014aXhWjNAJCZE2L7oDL4R5q","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll analyze the implementation and provide a comprehensive comparison report."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":17870,"cache_read_input_tokens":46427,"cache_creation":{"ephemeral_5m_input_tokens":17870,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"requestId":"req_vrtx_011CXK1Ydevv9GjMcuvGzEdL","type":"assistant","uuid":"85e791c0-9b35-4c7e-a60c-5a8bd056af7e","timestamp":"2026-01-20T17:17:45.326Z"}
{"parentUuid":"85e791c0-9b35-4c7e-a60c-5a8bd056af7e","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_014aXhWjNAJCZE2L7oDL4R5q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_vrtx_01D3pkicv6L97NcYUUPyUPe5","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/requirements.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":17870,"cache_read_input_tokens":46427,"cache_creation":{"ephemeral_5m_input_tokens":17870,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"requestId":"req_vrtx_011CXK1Ydevv9GjMcuvGzEdL","type":"assistant","uuid":"5e8ae35e-9d27-4cb1-b41b-57427163a35d","timestamp":"2026-01-20T17:17:46.438Z"}
{"parentUuid":"5e8ae35e-9d27-4cb1-b41b-57427163a35d","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_014aXhWjNAJCZE2L7oDL4R5q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_vrtx_01S6nMjDWXXHYqcq4fKHiMau","name":"Glob","input":{"pattern":"**/pyproject.toml"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":17870,"cache_read_input_tokens":46427,"cache_creation":{"ephemeral_5m_input_tokens":17870,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"requestId":"req_vrtx_011CXK1Ydevv9GjMcuvGzEdL","type":"assistant","uuid":"189f1831-5c28-4ea5-b746-8d55447f64ac","timestamp":"2026-01-20T17:17:46.750Z"}
{"parentUuid":"5e8ae35e-9d27-4cb1-b41b-57427163a35d","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist.</tool_use_error>","is_error":true,"tool_use_id":"toolu_vrtx_01D3pkicv6L97NcYUUPyUPe5"}]},"uuid":"1a6a4037-6acc-4413-b33d-62be74a0f915","timestamp":"2026-01-20T17:17:46.857Z","toolUseResult":"Error: File does not exist.","sourceToolAssistantUUID":"5e8ae35e-9d27-4cb1-b41b-57427163a35d"}
{"parentUuid":"189f1831-5c28-4ea5-b746-8d55447f64ac","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01S6nMjDWXXHYqcq4fKHiMau","type":"tool_result","content":"No files found"}]},"uuid":"b03848a9-87fe-454d-a84d-9db74591c34e","timestamp":"2026-01-20T17:17:48.381Z","toolUseResult":{"filenames":[],"durationMs":1102,"numFiles":0,"truncated":false},"sourceToolAssistantUUID":"189f1831-5c28-4ea5-b746-8d55447f64ac"}
{"parentUuid":"b03848a9-87fe-454d-a84d-9db74591c34e","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_01Y8JrtMKr3zkeb8WGfAEQ8N","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"No requirements.txt or pyproject.toml found. Let me check what dependencies they have and write my analysis report.","signature":"Ep4CCkgICxACGAIqQHUs7azvcFgXUXIk4/BhIxNRwKFmGQ6avt3HeTqrEwE4eMA4mbLpFu0uMZMo53bOCn2Hp7P9/D/COx8cRZ79ODMSDGVKGGRla+iduYdb0BoMZ8AJoRQ7CIQ+G0WLIjAR2wAZu74y03IumP57PIaMTgwhM7IXl8YCiALzrYldP6kK2LSs2dTAT9k/orPwSSEqgwHJXAB6bCrTNk2qNaEtUqy6ibwB3k1tGu9g3u0x9mlucoxAYYtYQbUqvBR48WBo/3PuTAdJN32z8CX03ZBD97T0Xmk4C8PmpJRmK0VqMY7HGHoG2lEVAzN6D+Zmfeso7UvKbpF9WRpkZ8I0X6Oce5hUC43LWO9aWQkf7PvbfD+CApWLXRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":541,"cache_read_input_tokens":64297,"cache_creation":{"ephemeral_5m_input_tokens":541,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"requestId":"req_vrtx_011CXK1Zm1UXm4n2wMvkG9ua","type":"assistant","uuid":"90109922-6d13-41b5-9b4a-2071d0dc8bf1","timestamp":"2026-01-20T17:17:52.653Z"}
{"parentUuid":"90109922-6d13-41b5-9b4a-2071d0dc8bf1","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_01Y8JrtMKr3zkeb8WGfAEQ8N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_vrtx_01Fj5S3z8HpFBkzgkv8cyRzV","name":"Bash","input":{"command":"find /home/aiscend/work/vibelife -name \"requirements*.txt\" -o -name \"pyproject.toml\" 2>/dev/null | head -10","description":"Find Python dependency files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":541,"cache_read_input_tokens":64297,"cache_creation":{"ephemeral_5m_input_tokens":541,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"requestId":"req_vrtx_011CXK1Zm1UXm4n2wMvkG9ua","type":"assistant","uuid":"2f8227ec-2fa5-496d-8853-fd6292f13519","timestamp":"2026-01-20T17:17:53.630Z"}
{"parentUuid":"2f8227ec-2fa5-496d-8853-fd6292f13519","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01Fj5S3z8HpFBkzgkv8cyRzV","type":"tool_result","content":"/home/aiscend/work/vibelife/apps/api/requirements.txt","is_error":false}]},"uuid":"95e5c2ef-300c-4f8d-a829-544fd84a905d","timestamp":"2026-01-20T17:17:54.857Z","toolUseResult":{"stdout":"/home/aiscend/work/vibelife/apps/api/requirements.txt","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"2f8227ec-2fa5-496d-8853-fd6292f13519"}
{"parentUuid":"95e5c2ef-300c-4f8d-a829-544fd84a905d","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014beLuHAAoVc2iySyM3J1ew","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Found it! Let me check the requirements.","signature":"EtABCkYICxgCKkCDPA+GqEwJYZrtZb87Ey3mfcfQGaZZBeEwyPsV/YkZqSzudhDCwUhFS4Gv9AW+EIDLoTtG43BV+J4sHACnVIzJEgwoBadNrwPhkg0qlAgaDKK1Mua92o5tC5smxCIwNjqy7ZZM2gOj8zVpxMmPAmaHBJ5SYejlUwXnCtdmlNPyOp/QzIMuZIy4LiuOXs54KjiTC7wyeu64uJIvD4kCdYUUHepUHrWhxoTJ3ecqZcNKPZKJCI93BCu6iGHAsFZc5EczDyhlSS0baBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":18595,"cache_read_input_tokens":46427,"cache_creation":{"ephemeral_5m_input_tokens":18595,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXK1aDVBWwTkvMPGg3Xzb","type":"assistant","uuid":"4088e070-aead-45be-abcf-a332a35a1398","timestamp":"2026-01-20T17:17:59.689Z"}
{"parentUuid":"4088e070-aead-45be-abcf-a332a35a1398","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014beLuHAAoVc2iySyM3J1ew","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JXvcBpwunXHJ7hncosdone","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/requirements.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":18595,"cache_read_input_tokens":46427,"cache_creation":{"ephemeral_5m_input_tokens":18595,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXK1aDVBWwTkvMPGg3Xzb","type":"assistant","uuid":"fdf94662-e73a-4fd5-be55-35f68fc5def0","timestamp":"2026-01-20T17:18:00.028Z"}
{"parentUuid":"fdf94662-e73a-4fd5-be55-35f68fc5def0","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JXvcBpwunXHJ7hncosdone","type":"tool_result","content":"     1→# ═══════════════════════════════════════════════════════════════\n     2→# VIBELIFE API Dependencies\n     3→# ═══════════════════════════════════════════════════════════════\n     4→\n     5→# ─────────────────────────────────────────────────────────────────\n     6→# Web Framework\n     7→# ─────────────────────────────────────────────────────────────────\n     8→fastapi>=0.109.0\n     9→uvicorn[standard]>=0.27.0\n    10→python-multipart>=0.0.6\n    11→sse-starlette>=1.8.0\n    12→\n    13→# ─────────────────────────────────────────────────────────────────\n    14→# Data Validation\n    15→# ─────────────────────────────────────────────────────────────────\n    16→pydantic>=2.5.0\n    17→pydantic-settings>=2.1.0\n    18→\n    19→# ─────────────────────────────────────────────────────────────────\n    20→# Database\n    21→# ─────────────────────────────────────────────────────────────────\n    22→psycopg2-binary>=2.9.9\n    23→asyncpg>=0.29.0\n    24→\n    25→# ─────────────────────────────────────────────────────────────────\n    26→# Authentication\n    27→# ─────────────────────────────────────────────────────────────────\n    28→pyjwt>=2.8.0\n    29→passlib[bcrypt]>=1.7.4\n    30→python-jose[cryptography]>=3.3.0\n    31→\n    32→# ─────────────────────────────────────────────────────────────────\n    33→# HTTP Client\n    34→# ─────────────────────────────────────────────────────────────────\n    35→httpx>=0.26.0\n    36→aiohttp>=3.9.0\n    37→\n    38→# ─────────────────────────────────────────────────────────────────\n    39→# LLM Services\n    40→# ─────────────────────────────────────────────────────────────────\n    41→anthropic>=0.18.0\n    42→zhipuai>=2.0.0\n    43→\n    44→# Embeddings (BAAI/bge-m3 via SentenceTransformers)\n    45→sentence-transformers>=2.7.0\n    46→transformers>=4.45.0\n    47→torch>=2.2.0\n    48→# Vector storage uses PostgreSQL pgvector (no additional dependency)\n    49→\n    50→# ─────────────────────────────────────────────────────────────────\n    51→# Payment\n    52→# ─────────────────────────────────────────────────────────────────\n    53→stripe>=7.0.0\n    54→\n    55→# ─────────────────────────────────────────────────────────────────\n    56→# Image Generation\n    57→# ─────────────────────────────────────────────────────────────────\n    58→pillow>=10.0.0\n    59→\n    60→# ─────────────────────────────────────────────────────────────────\n    61→# Skill Tools\n    62→# ─────────────────────────────────────────────────────────────────\n    63→# 八字计算\n    64→lunar-python>=1.3.0\n    65→\n    66→# 星盘计算\n    67→pyswisseph>=2.10.0\n    68→\n    69→# ─────────────────────────────────────────────────────────────────\n    70→# Utilities\n    71→# ─────────────────────────────────────────────────────────────────\n    72→python-dotenv>=1.0.0\n    73→pyyaml>=6.0.0\n    74→numpy>=1.26.0\n    75→\n    76→# ─────────────────────────────────────────────────────────────────\n    77→# Knowledge System V2\n    78→# ─────────────────────────────────────────────────────────────────\n    79→jieba>=0.42.1              # Chinese text segmentation\n    80→pymupdf4llm>=0.0.17        # PDF to Markdown\n    81→ebooklib>=0.18             # EPUB ebook parsing\n    82→python-docx>=1.1.0         # DOCX Word documents\n    83→html2text>=2024.2.26       # HTML to Markdown\n    84→beautifulsoup4>=4.12.0     # HTML parsing\n    85→lxml>=5.0.0                # XML/HTML parser backend\n    86→loguru>=0.7.0              # embedding logging\n    87→\n    88→# ─────────────────────────────────────────────────────────────────\n    89→# Testing\n    90→# ─────────────────────────────────────────────────────────────────\n    91→pytest>=7.4.0\n    92→pytest-asyncio>=0.23.0\n    93→pytest-cov>=4.1.0\n    94→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5b0a8583-5ecc-4d69-b878-c1364f840aaf","timestamp":"2026-01-20T17:18:00.682Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/requirements.txt","content":"# ═══════════════════════════════════════════════════════════════\n# VIBELIFE API Dependencies\n# ═══════════════════════════════════════════════════════════════\n\n# ─────────────────────────────────────────────────────────────────\n# Web Framework\n# ─────────────────────────────────────────────────────────────────\nfastapi>=0.109.0\nuvicorn[standard]>=0.27.0\npython-multipart>=0.0.6\nsse-starlette>=1.8.0\n\n# ─────────────────────────────────────────────────────────────────\n# Data Validation\n# ─────────────────────────────────────────────────────────────────\npydantic>=2.5.0\npydantic-settings>=2.1.0\n\n# ─────────────────────────────────────────────────────────────────\n# Database\n# ─────────────────────────────────────────────────────────────────\npsycopg2-binary>=2.9.9\nasyncpg>=0.29.0\n\n# ─────────────────────────────────────────────────────────────────\n# Authentication\n# ─────────────────────────────────────────────────────────────────\npyjwt>=2.8.0\npasslib[bcrypt]>=1.7.4\npython-jose[cryptography]>=3.3.0\n\n# ─────────────────────────────────────────────────────────────────\n# HTTP Client\n# ─────────────────────────────────────────────────────────────────\nhttpx>=0.26.0\naiohttp>=3.9.0\n\n# ─────────────────────────────────────────────────────────────────\n# LLM Services\n# ─────────────────────────────────────────────────────────────────\nanthropic>=0.18.0\nzhipuai>=2.0.0\n\n# Embeddings (BAAI/bge-m3 via SentenceTransformers)\nsentence-transformers>=2.7.0\ntransformers>=4.45.0\ntorch>=2.2.0\n# Vector storage uses PostgreSQL pgvector (no additional dependency)\n\n# ─────────────────────────────────────────────────────────────────\n# Payment\n# ─────────────────────────────────────────────────────────────────\nstripe>=7.0.0\n\n# ─────────────────────────────────────────────────────────────────\n# Image Generation\n# ─────────────────────────────────────────────────────────────────\npillow>=10.0.0\n\n# ─────────────────────────────────────────────────────────────────\n# Skill Tools\n# ─────────────────────────────────────────────────────────────────\n# 八字计算\nlunar-python>=1.3.0\n\n# 星盘计算\npyswisseph>=2.10.0\n\n# ─────────────────────────────────────────────────────────────────\n# Utilities\n# ─────────────────────────────────────────────────────────────────\npython-dotenv>=1.0.0\npyyaml>=6.0.0\nnumpy>=1.26.0\n\n# ─────────────────────────────────────────────────────────────────\n# Knowledge System V2\n# ─────────────────────────────────────────────────────────────────\njieba>=0.42.1              # Chinese text segmentation\npymupdf4llm>=0.0.17        # PDF to Markdown\nebooklib>=0.18             # EPUB ebook parsing\npython-docx>=1.1.0         # DOCX Word documents\nhtml2text>=2024.2.26       # HTML to Markdown\nbeautifulsoup4>=4.12.0     # HTML parsing\nlxml>=5.0.0                # XML/HTML parser backend\nloguru>=0.7.0              # embedding logging\n\n# ─────────────────────────────────────────────────────────────────\n# Testing\n# ─────────────────────────────────────────────────────────────────\npytest>=7.4.0\npytest-asyncio>=0.23.0\npytest-cov>=4.1.0\n","numLines":94,"startLine":1,"totalLines":94}},"sourceToolAssistantUUID":"fdf94662-e73a-4fd5-be55-35f68fc5def0"}
{"parentUuid":"5b0a8583-5ecc-4d69-b878-c1364f840aaf","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_01EttUTt7YgQTUcMyoweSY8N","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I can see that the requirements.txt does NOT include `claude-agent-sdk`. Instead, it uses `anthropic>=0.18.0` directly. This confirms that this is a custom Agent implementation, not using the official Python Agent SDK.\n\nNow I can write a comprehensive verification report comparing this custom implementation against the official SDK patterns.","signature":"EoIECkgICxACGAIqQB8Il6FoWBQovwImBhiCpYkrqkbwMEOhDyEKBu/RgSuiGLojq0w6lgCas3Ro8dRE86zpGR8A1608xXV+I5ZAJhISDIuoLjFaHr7EA63C1xoMLLha6nAyZTzYIZ+pIjA1Nte4wezAcBl6aAI3bdiDeANL4pbyqvErd7hwXSUcm1TH9ZNj/Der1SqhafOubqgq5wIWD1uX1p//yFeHjrY1NfuTosRpvAQu/RqQHTFwaD/wvtptaNuKf2kGktR8hPhTFTICHSq7Aqmuo0YayptIR/xzbtua9CBZKHsEXFJp1JgFRxV1ztEUUsOjyyNxAQUgFThtfqNl3WQbpXjYgXVW4V1N+oPGfbNvIG5R2A6FPSMblzY0vve32IVvwHfv3X8zd9KtVa88EJKpWvfm4QkmQ1MnT/PY5wc17s9tzzeJfOP9TEgsXEIjyo3i9S9j5kyJIqHLQZiT1bdnmIwCmOjKwY1hE8kjWOKXn/rZCdquJuap3yhtmWwLsctS/PgGwYAAuL2G1INbk22Auo3vPNUIIp9hVhrRO55sw3FEJ+2fyN/2LiSm9rLcsQHZCGPWS3o7AA+G2ro+HL+i/wX8N3ro9ZEZZAc5PQPxeTPEBZ+JB6HSyj6rDNaBhVgzKlDImn4q7TrTby+O+W0aEuOP5BWjFg/3cilLfugC5xgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":1724,"cache_read_input_tokens":64838,"cache_creation":{"ephemeral_5m_input_tokens":1724,"ephemeral_1h_input_tokens":0},"output_tokens":2}},"requestId":"req_vrtx_011CXK1afZqGnWudAcXBYnno","type":"assistant","uuid":"7a2ee7c6-497c-4d7a-84e4-7e52aec33b51","timestamp":"2026-01-20T17:18:06.946Z"}
{"parentUuid":"7a2ee7c6-497c-4d7a-84e4-7e52aec33b51","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"d04217f4-f6d0-49f3-82e3-2909b883875f","version":"2.1.12","gitBranch":"master","agentId":"aae26ca","slug":"mossy-cuddling-cookie","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_vrtx_01EttUTt7YgQTUcMyoweSY8N","type":"message","role":"assistant","content":[{"type":"text","text":"# Python Agent SDK Verification Report\n\n## Overall Status: **CUSTOM IMPLEMENTATION - NOT USING OFFICIAL SDK**\n\n## Summary\n\nThe `/home/aiscend/work/vibelife/apps/api/services/agent/core.py` file implements a **custom Agent framework** rather than using the official Claude Agent SDK for Python. While it demonstrates sophisticated agent patterns, it is **not an Agent SDK application** and therefore cannot be verified against SDK compliance.\n\n## Critical Findings\n\n### 1. SDK Not Installed\n\n**Issue**: The application does not use the official Claude Agent SDK.\n\n**Evidence**:\n- `requirements.txt` includes `anthropic>=0.18.0` (direct Anthropic API client)\n- **Missing**: `claude-agent-sdk` package\n- No imports from `claude_agent_sdk` in the codebase\n\n**Impact**: This is a completely custom implementation with different architecture, patterns, and capabilities than the SDK.\n\n### 2. Different Architecture Pattern\n\n**SDK Pattern**:\n```python\nfrom claude_agent_sdk import query, ClaudeSDKClient\n\n# SDK manages sessions, message history, and tool execution\nasync with ClaudeSDKClient() as client:\n    await client.query(\"Do something\")\n    async for message in client.receive_response():\n        print(message)\n```\n\n**Current Implementation**:\n```python\n# Custom Agent class with manual state management\nagent = CoreAgent(llm=llm_client, max_iterations=10)\nasync for event in agent.run(message, context):\n    # Custom event handling\n```\n\n**Key Differences**:\n\n| Aspect | Official SDK | Current Implementation |\n|--------|--------------|------------------------|\n| **Package** | `claude-agent-sdk` | Custom classes |\n| **Agent Creation** | `ClaudeSDKClient()` or `query()` | `CoreAgent(llm, max_iterations)` |\n| **Session Management** | Automatic | Manual via `AgentContext` |\n| **Message History** | Built-in | Custom filtering logic |\n| **Tool Execution** | `@tool` decorator + MCP servers | Custom `ToolRegistry` |\n| **Streaming** | `receive_messages()` iterator | Custom `AsyncGenerator[AgentEvent]` |\n| **State Management** | Session-based | Custom `AgentState` enum |\n\n### 3. Custom vs SDK Message History Management\n\n**SDK Approach** (Automatic):\n```python\nasync with ClaudeSDKClient() as client:\n    # First message\n    await client.query(\"What's the capital of France?\")\n    async for msg in client.receive_response():\n        print(msg)\n    \n    # Follow-up - SDK automatically maintains history\n    await client.query(\"What's the population?\")  # SDK remembers context\n```\n\n**Current Implementation** (Manual):\n```python\ndef _filter_valid_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Manual validation of tool_call pairing\"\"\"\n    valid_tool_ids = set()\n    # Collect all valid tool_call_ids\n    for msg in history:\n        if msg.get(\"role\") == \"assistant\" and msg.get(\"tool_calls\"):\n            for tc in msg[\"tool_calls\"]:\n                if tc_id := tc.get(\"id\"):\n                    valid_tool_ids.add(tc_id)\n    \n    # Filter orphan tool messages\n    filtered = []\n    for msg in history:\n        if msg.get(\"role\") == \"tool\":\n            if msg.get(\"tool_call_id\") in valid_tool_ids:\n                filtered.append(msg)\n        else:\n            filtered.append(msg)\n    return filtered\n```\n\n**Analysis**: The SDK handles message pairing automatically. This custom implementation manually validates tool_use/tool_result pairs, which is error-prone and unnecessary with the SDK.\n\n### 4. Tool Use Pattern Comparison\n\n**SDK Pattern**:\n```python\nfrom claude_agent_sdk import tool, create_sdk_mcp_server\n\n@tool(\"calculate\", \"Perform calculations\", {\"expression\": str})\nasync def calculate(args):\n    result = eval(args[\"expression\"])\n    return {\"content\": [{\"type\": \"text\", \"text\": f\"Result: {result}\"}]}\n\nserver = create_sdk_mcp_server(\n    name=\"calculator\",\n    tools=[calculate]\n)\n\noptions = ClaudeAgentOptions(\n    mcp_servers={\"calc\": server},\n    allowed_tools=[\"mcp__calc__calculate\"]\n)\n```\n\n**Current Implementation**:\n```python\n# Custom tool registry with manual execution\nclass CoreAgent:\n    async def _execute_tool(self, tool_name: str, tool_args: str, context: AgentContext):\n        args = json.loads(tool_args)\n        \n        # Manual routing\n        if tool_name == \"activate_skill\":\n            return await self._handle_activate_skill(args, context)\n        elif tool_name == \"show_protocol_invitation\":\n            return await self._handle_show_protocol_invitation(args, context)\n        \n        # Use custom ToolRegistry\n        if ToolRegistry.has_handler(tool_name):\n            return await ToolRegistry.execute(tool_name, args, tool_context)\n```\n\n**Analysis**: SDK provides declarative tool definitions with type safety. Custom implementation requires manual routing and validation.\n\n### 5. Agentic Loop Implementation\n\n**SDK Agentic Loop** (Built-in):\n- Managed by `ClaudeSDKClient.receive_messages()`\n- Automatic turn management\n- Built-in iteration control\n- Session continuity across queries\n\n**Current Agentic Loop** (Custom):\n```python\nasync def run(self, message: str, context: AgentContext) -> AsyncGenerator[AgentEvent, None]:\n    # Manual iteration loop\n    for iteration in range(self.max_iterations):\n        self.state = AgentState.THINKING\n        yield AgentEvent(type=\"thinking\", data={\"iteration\": iteration})\n        \n        # Manual LLM call\n        async for chunk in self.llm.stream(messages=messages, tools=tools):\n            if chunk[\"type\"] == \"content\":\n                content_buffer += chunk[\"content\"]\n                yield AgentEvent(type=\"content\", data=chunk)\n            elif chunk[\"type\"] == \"tool_call\":\n                tool_calls.append(chunk)\n        \n        # Manual tool execution\n        if tool_calls:\n            for tc in tool_calls:\n                result = await self._execute_tool(tc[\"tool_name\"], tc[\"tool_args\"], context)\n                messages.append(LLMMessage(role=\"tool\", content=str(result)))\n        else:\n            return  # Done\n```\n\n**Strengths of Custom Implementation**:\n- Fine-grained control over execution phases\n- Custom event types (`thinking`, `tool_call`, `sop_phase`)\n- Performance logging integrated\n- Phase-based context loading (v8 architecture)\n\n**SDK Advantages**:\n- Less code to maintain\n- Automatic error handling\n- Built-in interrupts and session management\n- Standard message types\n\n### 6. Error Handling Comparison\n\n**SDK Error Handling**:\n```python\nfrom claude_agent_sdk import CLINotFoundError, ProcessError\n\ntry:\n    async for message in query(prompt=\"Hello\"):\n        print(message)\nexcept CLINotFoundError:\n    print(\"Install Claude Code CLI\")\nexcept ProcessError as e:\n    print(f\"Failed: {e.exit_code}\")\n```\n\n**Current Implementation**:\n```python\n# Generic exception handling\ntry:\n    async for chunk in self.llm.stream(...):\n        # Process chunk\nexcept Exception as e:\n    self.state = AgentState.ERROR\n    logger.error(f\"Agent error: {e}\")\n    yield AgentEvent(type=\"error\", data={\"error\": str(e)})\n```\n\n**Analysis**: SDK provides typed exceptions for specific failure modes. Custom implementation uses generic exception handling.\n\n## Architectural Strengths of Current Implementation\n\nDespite not using the SDK, the custom implementation has notable strengths:\n\n### 1. Phase-Based Context Loading\n```python\n# Phase 1: Lightweight routing (no user data)\nif not context.skill:\n    return get_phase1_tools()  # Only routing tools\n\n# Phase 2: Full context with user data\nif self._active_skill:\n    # Load skill-specific data\n    result = await get_cached_profile_with_skill(user_id, skill)\n    self._context.profile = result[\"profile\"]\n    self._context.skill_data = result[\"skill_data\"]\n```\n\n**Benefit**: Reduces initial latency by deferring heavy data loading until skill is selected.\n\n### 2. SOP-Driven Tool Restriction\n```python\n# P1: Only provide collection tool if birth info needed\nif status[\"needs_birth_info\"] and not status[\"has_birth_info\"]:\n    collect_tool_name = get_skill_collect_tool(skill_id)\n    tool_def = ToolRegistry.get_tool_def(collect_tool_name)\n    return [tool_def.to_openai_format()]  # Force LLM to use this tool\n\n# P2: Only provide compute tool if calculation needed\nif status[\"needs_compute\"] and not status[\"has_chart_data\"]:\n    compute_tool_name = get_skill_compute_tool(skill_id)\n    return [tool_def.to_openai_format()]\n```\n\n**Benefit**: Enforces workflow steps by restricting available tools, ensuring LLM follows required procedures.\n\n### 3. Performance Monitoring\n```python\nself._perf_log = {\n    \"iterations\": 0,\n    \"llm_calls\": [],\n    \"phase\": \"phase1\",\n    \"prompt_build_ms\": ...,\n    \"system_prompt_len\": ...\n}\n```\n\n**Benefit**: Built-in performance tracking for optimization and debugging.\n\n### 4. Case-Based Retrieval\n```python\n# Inverted index matching (alternative to vector search)\nfeatures = extract_features(context.skill_data)\ncases = await self.case_index.get_matched_cases(skill_id, features, top_k=2)\n```\n\n**Benefit**: Domain-specific retrieval using inverted index instead of generic vector similarity.\n\n## Recommendations\n\n### Option 1: Keep Custom Implementation (Current Path)\n\n**When to choose**:\n- Need fine-grained control over execution phases\n- Require custom event types and state management\n- Performance optimization is critical\n- Domain-specific workflow enforcement needed\n\n**Actions**:\n1. Document the custom architecture clearly\n2. Add comprehensive error handling for LLM failures\n3. Implement retry logic for transient failures\n4. Add unit tests for message filtering logic\n5. Consider type safety improvements (use Pydantic models)\n\n### Option 2: Migrate to Official SDK\n\n**When to choose**:\n- Want standard Agent patterns and community support\n- Need built-in features (interrupts, session management, file checkpointing)\n- Prefer declarative tool definitions\n- Want to reduce maintenance burden\n\n**Migration complexity**: **HIGH**\n\n**Major changes required**:\n1. Install `claude-agent-sdk`\n2. Replace `CoreAgent` with `ClaudeSDKClient`\n3. Rewrite tool handlers using `@tool` decorator\n4. Migrate `ToolRegistry` to MCP server pattern\n5. Adapt streaming events to SDK message types\n6. Remove manual message history management\n7. Refactor phase-based loading to SDK hooks\n\n**Estimated effort**: 2-3 weeks of development + testing\n\n### Option 3: Hybrid Approach\n\nUse SDK for new features while maintaining custom core:\n\n```python\n# Use SDK for subagents or specific tools\nfrom claude_agent_sdk import ClaudeSDKClient, tool\n\n@tool(\"lifecycle_analysis\", \"Complex analysis\", {\"data\": dict})\nasync def lifecycle_analysis(args):\n    # Delegate complex analysis to SDK-based subagent\n    async with ClaudeSDKClient() as client:\n        await client.query(f\"Analyze: {args['data']}\")\n        result = await client.receive_response()\n    return result\n\n# Keep CoreAgent for main routing\nagent = CoreAgent(llm=llm_client)\n```\n\n## Specific Issues to Address\n\n### 1. Message History Filtering Logic\n\n**Current code** (lines 483-520):\n```python\ndef _filter_valid_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    # Manual validation to ensure tool_use/tool_result pairing\n```\n\n**Issue**: This logic is complex and error-prone. The SDK handles this automatically.\n\n**Recommendation**: If keeping custom implementation:\n- Add unit tests for edge cases (nested tool calls, multiple tool_results)\n- Add validation for `assistant` messages without tool_calls\n- Log filtered messages for debugging\n\n### 2. Error Handling in Tool Execution\n\n**Current code** (line 892):\n```python\ntry:\n    args = json.loads(tool_args) if tool_args else {}\nexcept json.JSONDecodeError:\n    args = {}  # Silently fails!\n```\n\n**Issue**: JSON decode errors are silently ignored, leading to empty args.\n\n**Fix**:\n```python\ntry:\n    args = json.loads(tool_args) if tool_args else {}\nexcept json.JSONDecodeError as e:\n    logger.error(f\"Failed to parse tool args: {tool_args}, error: {e}\")\n    return {\n        \"status\": \"error\",\n        \"message\": f\"Invalid tool arguments: {str(e)}\",\n        \"tool_name\": tool_name\n    }\n```\n\n### 3. State Management\n\n**Current code**:\n```python\nclass AgentState(str, Enum):\n    IDLE = \"idle\"\n    THINKING = \"thinking\"\n    TOOL_CALLING = \"tool_calling\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n```\n\n**Issue**: State transitions are not validated. Could transition from ERROR to THINKING without reset.\n\n**Recommendation**: Add state transition validation or use a state machine library.\n\n### 4. Max Iterations Handling\n\n**Current code** (line 481):\n```python\nself.state = AgentState.COMPLETED\nyield AgentEvent(type=\"done\", data={\"max_iterations_reached\": True})\n```\n\n**Issue**: Reaching max iterations is treated as successful completion, but might indicate runaway loop.\n\n**Fix**:\n```python\nlogger.warning(f\"Max iterations ({self.max_iterations}) reached without completion\")\nyield AgentEvent(\n    type=\"error\",\n    data={\n        \"error\": \"Max iterations reached\",\n        \"iterations\": self.max_iterations,\n        \"suggestion\": \"Consider increasing max_iterations or simplifying the task\"\n    }\n)\n```\n\n## Conclusion\n\nThe `/home/aiscend/work/vibelife/apps/api/services/agent/core.py` implements a **sophisticated custom Agent framework** with advanced features like phase-based loading and SOP-driven tool restriction. However, it is **not a Claude Agent SDK application** and cannot be verified for SDK compliance.\n\n**Key Decision**: Choose between:\n1. **Continue custom path**: Invest in testing, documentation, and error handling for the custom implementation\n2. **Migrate to SDK**: Gain standard patterns and community support at cost of refactoring\n3. **Hybrid approach**: Use SDK for specific features while keeping custom core\n\nThe current implementation demonstrates deep understanding of Agent patterns and has valuable domain-specific optimizations. If continuing with the custom approach, prioritize:\n- Comprehensive error handling\n- Unit tests for message filtering and state transitions\n- Documentation of architectural decisions\n- Type safety improvements\n\nIf migrating to SDK is desired, I can provide a detailed migration plan and code examples."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":1724,"cache_read_input_tokens":64838,"cache_creation":{"ephemeral_5m_input_tokens":1724,"ephemeral_1h_input_tokens":0},"output_tokens":2}},"requestId":"req_vrtx_011CXK1afZqGnWudAcXBYnno","type":"assistant","uuid":"bfc4a7bf-2472-406a-90ea-42b4883c3c5b","timestamp":"2026-01-20T17:19:19.565Z"}
