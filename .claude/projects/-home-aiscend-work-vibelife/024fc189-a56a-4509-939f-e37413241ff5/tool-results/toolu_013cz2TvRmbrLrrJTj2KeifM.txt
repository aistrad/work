     1→'use client';
     2→
     3→/**
     4→ * CategorySection - 分类区块
     5→ *
     6→ * App Store 风格的横向滚动卡片列表
     7→ * v2: 增强滚动体验
     8→ * - 左右导航箭头（hover 显示）
     9→ * - 滚动进度指示器
    10→ * - Peek 效果暗示可滚动
    11→ * - 显示更多数量提示
    12→ */
    13→
    14→import React, { useRef, useState, useCallback, useEffect } from 'react';
    15→import { ChevronLeft, ChevronRight } from 'lucide-react';
    16→import { SkillShowcaseCard } from './SkillShowcaseCard';
    17→import type { SkillMetadata, SkillUserStatus } from '@/types/skill';
    18→
    19→interface CategorySectionProps {
    20→  title: string;
    21→  subtitle?: string;
    22→  skills: SkillMetadata[];
    23→  userStatuses?: Record<string, SkillUserStatus>;
    24→  onSkillClick: (skillId: string) => void;
    25→  onSubscribe: (skillId: string) => void;
    26→  onViewAll?: () => void;
    27→}
    28→
    29→export function CategorySection({
    30→  title,
    31→  subtitle,
    32→  skills,
    33→  userStatuses = {},
    34→  onSkillClick,
    35→  onSubscribe,
    36→  onViewAll,
    37→}: CategorySectionProps) {
    38→  const scrollRef = useRef<HTMLDivElement>(null);
    39→  const [isDragging, setIsDragging] = useState(false);
    40→  const [hasDragged, setHasDragged] = useState(false);
    41→  const [startX, setStartX] = useState(0);
    42→  const [scrollLeft, setScrollLeft] = useState(0);
    43→  const [isHovered, setIsHovered] = useState(false);
    44→  const [canScrollLeft, setCanScrollLeft] = useState(false);
    45→  const [canScrollRight, setCanScrollRight] = useState(false);
    46→  const [currentIndex, setCurrentIndex] = useState(0);
    47→
    48→  const displaySkills = skills.slice(0, 8); // 最多显示8个
    49→  const cardWidth = 268; // 卡片宽度 + gap
    50→
    51→  // 检查滚动状态
    52→  const checkScrollState = useCallback(() => {
    53→    if (!scrollRef.current) return;
    54→    const { scrollLeft, scrollWidth, clientWidth } = scrollRef.current;
    55→    setCanScrollLeft(scrollLeft > 10);
    56→    setCanScrollRight(scrollLeft < scrollWidth - clientWidth - 10);
    57→
    58→    // 计算当前索引
    59→    const index = Math.round(scrollLeft / cardWidth);
    60→    setCurrentIndex(Math.min(index, displaySkills.length - 1));
    61→  }, [displaySkills.length]);
    62→
    63→  useEffect(() => {
    64→    checkScrollState();
    65→    const el = scrollRef.current;
    66→    if (el) {
    67→      el.addEventListener('scroll', checkScrollState);
    68→      return () => el.removeEventListener('scroll', checkScrollState);
    69→    }
    70→  }, [checkScrollState]);
    71→
    72→  // 滚动到指定方向
    73→  const scroll = useCallback((direction: 'left' | 'right') => {
    74→    if (!scrollRef.current) return;
    75→    const scrollAmount = cardWidth * 2; // 每次滚动2个卡片
    76→    scrollRef.current.scrollBy({
    77→      left: direction === 'left' ? -scrollAmount : scrollAmount,
    78→      behavior: 'smooth'
    79→    });
    80→  }, []);
    81→
    82→  // 鼠标按下开始拖拽
    83→  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    84→    if (!scrollRef.current) return;
    85→    setIsDragging(true);
    86→    setHasDragged(false);
    87→    setStartX(e.pageX - scrollRef.current.offsetLeft);
    88→    setScrollLeft(scrollRef.current.scrollLeft);
    89→  }, []);
    90→
    91→  // 鼠标移动拖拽
    92→  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    93→    if (!isDragging || !scrollRef.current) return;
    94→    e.preventDefault();
    95→    const x = e.pageX - scrollRef.current.offsetLeft;
    96→    const walk = (x - startX) * 2;
    97→
    98→    if (Math.abs(walk) > 5) {
    99→      setHasDragged(true);
   100→    }
   101→
   102→    scrollRef.current.scrollLeft = scrollLeft - walk;
   103→  }, [isDragging, startX, scrollLeft]);
   104→
   105→  // 鼠标抬起停止拖拽
   106→  const handleMouseUp = useCallback(() => {
   107→    setIsDragging(false);
   108→  }, []);
   109→
   110→  // 鼠标离开容器停止拖拽
   111→  const handleMouseLeave = useCallback(() => {
   112→    setIsDragging(false);
   113→  }, []);
   114→
   115→  if (skills.length === 0) return null;
   116→
   117→  // 计算可见卡片数和总数
   118→  const visibleCount = Math.min(3, displaySkills.length); // 移动端大约能看到2-3个
   119→  const hiddenCount = displaySkills.length - visibleCount;
   120→
   121→  return (
   122→    <section
   123→      className="space-y-4 relative group/section"
   124→      onMouseEnter={() => setIsHovered(true)}
   125→      onMouseLeave={() => setIsHovered(false)}
   126→    >
   127→      {/* Header */}
   128→      <div className="flex items-end justify-between">
   129→        <div className="flex-1">
   130→          <div className="flex items-center gap-3">
   131→            <h2 className="text-2xl font-bold text-text-primary">{title}</h2>
   132→            {/* 显示更多数量提示 */}
   133→            {hiddenCount > 0 && (
   134→              <span className="text-xs text-text-tertiary bg-bg-secondary px-2 py-0.5 rounded-full">
   135→                +{hiddenCount} 更多
   136→              </span>
   137→            )}
   138→          </div>
   139→          {subtitle && (
   140→            <p className="text-sm text-text-secondary mt-1">{subtitle}</p>
   141→          )}
   142→        </div>
   143→        {onViewAll && skills.length > 3 && (
   144→          <button
   145→            onClick={onViewAll}
   146→            className="flex items-center gap-1 text-sm font-medium text-accent-primary hover:gap-2 transition-all"
   147→          >
   148→            <span>查看全部</span>
   149→            <ChevronRight className="w-4 h-4" />
   150→          </button>
   151→        )}
   152→      </div>
   153→
   154→      {/* 横向滚动容器 */}
   155→      <div className="relative">
   156→        {/* 左侧导航箭头 - PC hover显示 */}
   157→        {canScrollLeft && (
   158→          <button
   159→            onClick={() => scroll('left')}
   160→            className="absolute left-0 top-1/2 -translate-y-1/2 z-10 w-10 h-10
   161→                       bg-bg-card/95 backdrop-blur-sm border border-subtle rounded-full
   162→                       shadow-lg flex items-center justify-center
   163→                       opacity-0 group-hover/section:opacity-100 transition-opacity duration-200
   164→                       hover:bg-bg-secondary hover:scale-110 -ml-5
   165→                       hidden lg:flex"
   166→            aria-label="向左滚动"
   167→          >
   168→            <ChevronLeft className="w-5 h-5 text-text-primary" />
   169→          </button>
   170→        )}
   171→
   172→        {/* 右侧导航箭头 - PC hover显示 */}
   173→        {canScrollRight && (
   174→          <button
   175→            onClick={() => scroll('right')}
   176→            className="absolute right-0 top-1/2 -translate-y-1/2 z-10 w-10 h-10
   177→                       bg-bg-card/95 backdrop-blur-sm border border-subtle rounded-full
   178→                       shadow-lg flex items-center justify-center
   179→                       opacity-0 group-hover/section:opacity-100 transition-opacity duration-200
   180→                       hover:bg-bg-secondary hover:scale-110 -mr-5
   181→                       hidden lg:flex"
   182→            aria-label="向右滚动"
   183→          >
   184→            <ChevronRight className="w-5 h-5 text-text-primary" />
   185→          </button>
   186→        )}
   187→
   188→        {/* 右侧渐变遮罩 - 暗示可滚动 */}
   189→        {canScrollRight && (
   190→          <div className="absolute right-0 top-0 bottom-4 w-16 bg-gradient-to-l from-bg-primary to-transparent pointer-events-none z-[1]" />
   191→        )}
   192→
   193→        {/* 横向滚动卡片 */}
   194→        <div
   195→          ref={scrollRef}
   196→          onMouseDown={handleMouseDown}
   197→          onMouseMove={handleMouseMove}
   198→          onMouseUp={handleMouseUp}
   199→          onMouseLeave={handleMouseLeave}
   200→          className="overflow-x-auto pb-4 scrollbar-hide -mx-4 px-4 cursor-grab active:cursor-grabbing select-none scroll-smooth"
   201→        >
   202→          <div className="flex gap-3 min-w-min">
   203→            {displaySkills.map((skill) => (
   204→              <div key={skill.id} className="w-64 flex-shrink-0">
   205→                <SkillShowcaseCard
   206→                  skill={skill}
   207→                  userStatus={userStatuses[skill.id]}
   208→                  onClick={() => {
   209→                    if (!hasDragged) {
   210→                      onSkillClick(skill.id);
   211→                    }
   212→                  }}
   213→                  onSubscribe={() => {
   214→                    onSubscribe(skill.id);
   215→                  }}
   216→                />
   217→              </div>
   218→            ))}
   219→          </div>
   220→        </div>
   221→
   222→        {/* 滚动进度指示器 - 仅在有多个可滚动时显示 */}
   223→        {displaySkills.length > 2 && (
   224→          <div className="flex justify-center gap-1.5 mt-2">
   225→            {displaySkills.map((_, index) => (
   226→              <button
   227→                key={index}
   228→                onClick={() => {
   229→                  scrollRef.current?.scrollTo({
   230→                    left: index * cardWidth,
   231→                    behavior: 'smooth'
   232→                  });
   233→                }}
   234→                className={`h-1.5 rounded-full transition-all duration-200 ${
   235→                  index === currentIndex
   236→                    ? 'w-6 bg-accent-primary'
   237→                    : 'w-1.5 bg-bg-tertiary hover:bg-text-tertiary'
   238→                }`}
   239→                aria-label={`跳转到第 ${index + 1} 个`}
   240→              />
   241→            ))}
   242→          </div>
   243→        )}
   244→      </div>
   245→
   246→      {/* 移动端滑动提示 - 首次显示 */}
   247→      {displaySkills.length > 2 && (
   248→        <p className="text-xs text-text-tertiary text-center lg:hidden">
   249→          <span className="inline-flex items-center gap-1">
   250→            <span>←</span>
   251→            左右滑动查看更多
   252→            <span>→</span>
   253→          </span>
   254→        </p>
   255→      )}
   256→    </section>
   257→  );
   258→}
   259→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
