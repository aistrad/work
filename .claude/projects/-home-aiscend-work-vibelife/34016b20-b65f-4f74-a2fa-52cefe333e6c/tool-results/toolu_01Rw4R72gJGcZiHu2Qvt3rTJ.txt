     1→"use client";
     2→
     3→import { useState, useRef, useEffect, useMemo } from "react";
     4→import { ChatMessage } from "./ChatMessage";
     5→import { ChatInput } from "./ChatInput";
     6→import { InsightCard, InsightType } from "@/components/insight/InsightCard";
     7→import { VibeGlyph, BreathAura, type SkillType } from "@/components/core";
     8→import { DailyGreeting } from "@/components/greeting/DailyGreeting";
     9→import { getTokens, sendGuestMessage, streamChat } from "@/lib/api";
    10→
    11→interface Message {
    12→  id: string;
    13→  role: "user" | "assistant";
    14→  content: string;
    15→  timestamp?: string;
    16→  insight?: {
    17→    id: string;
    18→    insight_type: InsightType;
    19→    title: string;
    20→    content: string;
    21→  };
    22→}
    23→
    24→export type VoiceMode = "warm" | "sarcastic";
    25→
    26→export interface ChatContainerProps {
    27→  skillId: string;
    28→  skill?: SkillType;
    29→  conversationId?: string;
    30→  voiceMode?: VoiceMode;
    31→  onConversationStart?: (id: string) => void;
    32→}
    33→
    34→// ═══════════════════════════════════════════════════════════════════════════
    35→// ChatEmptyState - LUMINOUS PAPER Design System
    36→// 空状态：居中 VibeGlyph + 技能感知文案 + 呼吸光晕
    37→// ═══════════════════════════════════════════════════════════════════════════
    38→
    39→const SKILL_EMPTY_STATE: Record<SkillType, { title: string; subtitle: string }> = {
    40→  bazi: {
    41→    title: "探索你的命理",
    42→    subtitle: "分享你的生辰，开启八字解读之旅",
    43→  },
    44→  zodiac: {
    45→    title: "倾听星辰的声音",
    46→    subtitle: "让星盘为你揭示宇宙的密语",
    47→  },
    48→  mbti: {
    49→    title: "发现真实的自己",
    50→    subtitle: "通过对话，探索你的人格特质",
    51→  },
    52→  attach: {
    53→    title: "理解你的依恋模式",
    54→    subtitle: "探索亲密关系中的自我",
    55→  },
    56→  career: {
    57→    title: "规划你的职业蓝图",
    58→    subtitle: "让我们一起探索你的职业发展方向",
    59→  },
    60→};
    61→
    62→// Quick prompts for each skill
    63→const SKILL_QUICK_PROMPTS: Record<SkillType, string[]> = {
    64→  bazi: [
    65→    "我是1990年5月15日早上8点出生的",
    66→    "帮我分析今年的运势",
    67→    "我的事业运如何？",
    68→    "什么时候适合做重大决定？",
    69→  ],
    70→  zodiac: [
    71→    "我是双子座，帮我看看本周运势",
    72→    "我的太阳星座和上升星座有什么区别？",
    73→    "双子座和什么星座最配？",
    74→    "水逆对我有什么影响？",
    75→  ],
    76→  mbti: [
    77→    "帮我测测我的MBTI类型",
    78→    "INFP适合什么职业？",
    79→    "我是INTJ，如何改善人际关系？",
    80→    "E人和I人有什么本质区别？",
    81→  ],
    82→  attach: [
    83→    "帮我分析我的依恋类型",
    84→    "回避型依恋如何建立亲密关系？",
    85→    "为什么我总是害怕被抛弃？",
    86→    "如何治愈童年的情感创伤？",
    87→  ],
    88→  career: [
    89→    "我该如何规划职业发展？",
    90→    "我适合创业还是打工？",
    91→    "如何在面试中展现自己？",
    92→    "转行需要考虑什么？",
    93→  ],
    94→};
    95→
    96→// 生成当日问候数据
    97→function useDailyGreeting() {
    98→  return useMemo(() => {
    99→    const now = new Date();
   100→    const hour = now.getHours();
   101→
   102→    // 基于时间的问候语
   103→    const greetings = {
   104→      morning: "早安，愿你今日能量满满",
   105→      afternoon: "午后时光，适合沉淀思考",
   106→      evening: "晚间静谧，回顾今日收获",
   107→    };
   108→
   109→    let greeting = greetings.morning;
   110→    if (hour >= 12 && hour < 18) greeting = greetings.afternoon;
   111→    else if (hour >= 18) greeting = greetings.evening;
   112→
   113→    // 节气（简化版，实际应根据日期计算）
   114→    const solarTerms = ["小寒", "大寒", "立春", "雨水", "惊蛰", "春分"];
   115→    const termIdx = Math.floor((now.getMonth() * 2 + Math.floor(now.getDate() / 15)) % 6);
   116→
   117→    return {
   118→      greeting,
   119→      solarTerm: solarTerms[termIdx],
   120→      termDescription: "万物生长",
   121→      todayTip: "今日宜专注当下，一步一脚印",
   122→    };
   123→  }, []);
   124→}
   125→
   126→function ChatEmptyState({ skill, onQuickPrompt }: { skill: SkillType; onQuickPrompt?: (prompt: string) => void }) {
   127→  const config = SKILL_EMPTY_STATE[skill] || SKILL_EMPTY_STATE.bazi;
   128→  const quickPrompts = SKILL_QUICK_PROMPTS[skill] || SKILL_QUICK_PROMPTS.bazi;
   129→  const dailyData = useDailyGreeting();
   130→
   131→  return (
   132→    <div className="flex flex-col items-center justify-center max-w-xl mx-auto px-4 py-6 w-full">
   133→      {/* Daily Greeting 每日问候 */}
   134→      <DailyGreeting
   135→        greeting={dailyData.greeting}
   136→        solarTerm={dailyData.solarTerm}
   137→        termDescription={dailyData.termDescription}
   138→        todayTip={dailyData.todayTip}
   139→        className="mb-6 w-full"
   140→      />
   141→
   142→      {/* Animated glyph with enhanced aura */}
   143→      <div className="relative flex items-center justify-center mb-4">
   144→        {/* Outer pulsing ring */}
   145→        <div className="absolute w-16 h-16 rounded-full border border-skill-primary/20 animate-pulse-slow" />
   146→        <div className="absolute w-24 h-24 rounded-full border border-skill-primary/10 animate-pulse-slower" />
   147→
   148→        {/* Breath aura */}
   149→        <BreathAura
   150→          skill={skill}
   151→          size="sm"
   152→          position="center"
   153→          intensity="medium"
   154→          className="opacity-40"
   155→        />
   156→
   157→        {/* Central glyph */}
   158→        <VibeGlyph
   159→          size="sm"
   160→          skill={skill}
   161→          showAura={true}
   162→          animate={true}
   163→          className="relative z-10"
   164→        />
   165→      </div>
   166→
   167→      {/* Title */}
   168→      <h3 className="text-base md:text-lg font-serif font-semibold text-foreground mb-1 text-center">
   169→        {config.title}
   170→      </h3>
   171→
   172→      {/* Subtitle */}
   173→      <p className="text-sm text-muted-foreground max-w-sm text-center mb-4">
   174→        {config.subtitle}
   175→      </p>
   176→
   177→      {/* Quick prompt suggestions */}
   178→      <div className="w-full space-y-2">
   179→        <p className="text-xs text-muted-foreground/60 text-center mb-2">
   180→          试试这样问
   181→        </p>
   182→        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
   183→          {quickPrompts.slice(0, 4).map((prompt, index) => (
   184→            <button
   185→              key={index}
   186→              onClick={() => onQuickPrompt?.(prompt)}
   187→              className="group relative px-3 py-2 text-left text-sm text-muted-foreground
   188→                       bg-card hover:bg-card/80 border border-border/50 hover:border-border
   189→                       rounded-lg transition-all duration-200
   190→                       hover:shadow-sm"
   191→            >
   192→              <span className="line-clamp-2">{prompt}</span>
   193→            </button>
   194→          ))}
   195→        </div>
   196→      </div>
   197→    </div>
   198→  );
   199→}
   200→
   201→export function ChatContainer({
   202→  skillId,
   203→  skill = "bazi",
   204→  conversationId,
   205→  voiceMode = "warm",
   206→  onConversationStart,
   207→}: ChatContainerProps) {
   208→  const [messages, setMessages] = useState<Message[]>([]);
   209→  const [isLoading, setIsLoading] = useState(false);
   210→  const [currentConvoId, setCurrentConvoId] = useState(conversationId);
   211→  const messagesEndRef = useRef<HTMLDivElement>(null);
   212→
   213→  // Map skillId to SkillType if not provided
   214→  const activeSkill: SkillType = skill || (skillId as SkillType) || "bazi";
   215→
   216→  const scrollToBottom = () => {
   217→    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
   218→  };
   219→
   220→  useEffect(() => {
   221→    scrollToBottom();
   222→  }, [messages]);
   223→
   224→  const handleSend = async (content: string) => {
   225→    // Add user message
   226→    const userMessage: Message = {
   227→      id: Date.now().toString(),
   228→      role: "user",
   229→      content,
   230→      timestamp: new Date().toLocaleTimeString(),
   231→    };
   232→    setMessages((prev) => [...prev, userMessage]);
   233→    setIsLoading(true);
   234→
   235→    try {
   236→      const { accessToken } = getTokens();
   237→
   238→      if (accessToken) {
   239→        // Create placeholder for streaming response
   240→        const assistantMsgId = (Date.now() + 1).toString();
   241→        setMessages((prev) => [...prev, {
   242→          id: assistantMsgId,
   243→          role: "assistant",
   244→          content: "",
   245→          timestamp: new Date().toLocaleTimeString(),
   246→        }]);
   247→
   248→        // Use streaming API
   249→        await streamChat(
   250→          {
   251→            message: content,
   252→            skill: skillId,
   253→            conversation_id: currentConvoId,
   254→            voice_mode: voiceMode,
   255→          },
   256→          // onChunk
   257→          (chunk) => {
   258→            setMessages((prev) =>
   259→              prev.map((msg) =>
   260→                msg.id === assistantMsgId
   261→                  ? { ...msg, content: msg.content + chunk }
   262→                  : msg
   263→              )
   264→            );
   265→          },
   266→          // onDone
   267→          (result) => {
   268→            if (!currentConvoId && result.conversation_id) {
   269→              setCurrentConvoId(result.conversation_id);
   270→              onConversationStart?.(result.conversation_id);
   271→            }
   272→            setIsLoading(false);
   273→          },
   274→          // onError
   275→          (error) => {
   276→            console.error("Stream error:", error);
   277→            setMessages((prev) =>
   278→              prev.map((msg) =>
   279→                msg.id === assistantMsgId
   280→                  ? { ...msg, content: "抱歉，出了点问题。请稍后再试。" }
   281→                  : msg
   282→              )
   283→            );
   284→            setIsLoading(false);
   285→          }
   286→        );
   287→        return; // Early return since streaming handles setIsLoading
   288→      } else {
   289→        // Guest mode: use the public endpoint for progressive disclosure
   290→        const response = await sendGuestMessage(content, skillId);
   291→        const assistantMessage: Message = {
   292→          id: (Date.now() + 1).toString(),
   293→          role: "assistant",
   294→          content: response.content,
   295→          timestamp: new Date().toLocaleTimeString(),
   296→        };
   297→        setMessages((prev) => [...prev, assistantMessage]);
   298→
   299→        if (response.suggestion) {
   300→          setMessages((prev) => [
   301→            ...prev,
   302→            {
   303→              id: (Date.now() + 2).toString(),
   304→              role: "assistant",
   305→              content: response.suggestion,
   306→              timestamp: new Date().toLocaleTimeString(),
   307→            },
   308→          ]);
   309→        }
   310→      }
   311→    } catch (error) {
   312→      console.error("Chat error:", error);
   313→      setMessages((prev) => [...prev, {
   314→        id: (Date.now() + 1).toString(),
   315→        role: "assistant",
   316→        content: "抱歉，出了点问题。请稍后再试。",
   317→      }]);
   318→    } finally {
   319→      setIsLoading(false);
   320→    }
   321→  };
   322→
   323→  const hasMessages = messages.length > 0;
   324→
   325→  return (
   326→    <div className="flex flex-col h-full" data-skill={activeSkill}>
   327→      {/* Messages area - always flex-1 to push input to bottom */}
   328→      <div className="flex-1 overflow-y-auto relative min-h-0">
   329→        {!hasMessages ? (
   330→          /* Empty state - centered within scrollable area */
   331→          <div className="flex flex-col items-center justify-end h-full pb-4 px-4">
   332→            <ChatEmptyState skill={activeSkill} onQuickPrompt={handleSend} />
   333→          </div>
   334→        ) : (
   335→          /* Messages list */
   336→          <div className="px-4 pt-4 pb-2">
   337→            {messages.map((message) => (
   338→              <div key={message.id}>
   339→                <ChatMessage
   340→                  role={message.role}
   341→                  content={message.content}
   342→                  timestamp={message.timestamp}
   343→                />
   344→                {/* Show insight card if present */}
   345→                {message.insight && (
   346→                  <div className="ml-12 mt-2 mb-4">
   347→                    <InsightCard
   348→                      type={message.insight.insight_type}
   349→                      title={message.insight.title}
   350→                      content={message.insight.content}
   351→                      onSave={() => console.log("Save insight:", message.insight?.id)}
   352→                      onShare={() => console.log("Share insight:", message.insight?.id)}
   353→                    />
   354→                  </div>
   355→                )}
   356→              </div>
   357→            ))}
   358→            {isLoading && (
   359→              <ChatMessage
   360→                role="assistant"
   361→                content=""
   362→                isStreaming
   363→              />
   364→            )}
   365→            <div ref={messagesEndRef} />
   366→          </div>
   367→        )}
   368→      </div>
   369→
   370→      {/* Input - fixed at bottom */}
   371→      <div className="flex-shrink-0">
   372→        <ChatInput onSend={handleSend} disabled={isLoading} />
   373→      </div>
   374→    </div>
   375→  );
   376→}
   377→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
