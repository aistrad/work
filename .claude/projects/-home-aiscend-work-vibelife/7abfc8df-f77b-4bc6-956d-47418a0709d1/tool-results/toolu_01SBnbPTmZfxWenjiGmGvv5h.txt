     1→# VibeLife LLM 驱动架构 - 完整设计文档
     2→
     3→> **版本**: 2.1
     4→> **日期**: 2026-01-21
     5→> **状态**: 实施中
     6→> **架构原则**: 完全 LLM 驱动，指导而非限制，符合 Agent SDK 规范
     7→
     8→---
     9→
    10→## 执行摘要
    11→
    12→**核心理念**：将所有流程控制交给 LLM，通过 Rule 文件和 Prompt 工程驱动行为，避免硬编码状态机。
    13→
    14→**架构转变**：
    15→```
    16→旧架构：独立页面 + 前端状态管理 + 后端步骤追踪
    17→新架构：Rule 文件 + LLM 自驱动 + 主 Chat 统一体验
    18→```
    19→
    20→**关键成果**：
    21→- ✅ Rule 文件架构已建立
    22→- ✅ 通用工具系统已完成
    23→- ✅ Dashboard 已整合到 Chat 空状态
    24→- ⚠️ 需移除旧架构残留
    25→- ⚠️ 需优化工具调用机制
    26→
    27→---
    28→
    29→## 1. 核心架构
    30→
    31→### 1.1 整体架构图
    32→
    33→```
    34→┌─────────────────────────────────────────────────────────────────┐
    35→│                         VibeLife 架构                            │
    36→└─────────────────────────────────────────────────────────────────┘
    37→
    38→用户输入
    39→    │
    40→    ▼
    41→┌─────────────────────────────────────────────────────────────────┐
    42→│ Phase 1: 意图路由（轻量上下文）                                  │
    43→│                                                                  │
    44→│  System Prompt: routing.yaml/phase1_prompt                      │
    45→│  工具集: [activate_skill, recommend_skills, show_skill_intro]   │
    46→│  目的: LLM 理解意图 → 路由到正确 Skill                           │
    47→└─────────────────────────────────────────────────────────────────┘
    48→    │
    49→    ▼ activate_skill(skill_id, rule=?)
    50→    │
    51→┌─────────────────────────────────────────────────────────────────┐
    52→│ Phase 2: 专家执行（完整上下文）                                  │
    53→│                                                                  │
    54→│  System Prompt: SKILL.md + Rule.md + SOP + Cases + Profile      │
    55→│  工具集: [collect, compute, display] + 通用工具                  │
    56→│  数据上下文: profile.skills.{skill_id}                           │
    57→│  目的: LLM 执行专业任务 → 输出卡片/分析                          │
    58→└─────────────────────────────────────────────────────────────────┘
    59→    │
    60→    ▼ save_skill_data(data)
    61→    │
    62→┌─────────────────────────────────────────────────────────────────┐
    63→│ VibeProfile (PostgreSQL JSONB)                                  │
    64→│                                                                  │
    65→│  profile.skills.{skill_id}                                      │
    66→│    ├─ {业务数据} (north_star, goals, etc)                        │
    67→│    ├─ _state (运行时状态)                                        │
    68→│    └─ _meta (版本、时间戳)                                       │
    69→└─────────────────────────────────────────────────────────────────┘
    70→```
    71→
    72→### 1.2 分层职责
    73→
    74→| 层级 | 职责 | LLM 驱动 | 示例 |
    75→|------|------|----------|------|
    76→| **Phase 1 - 路由层** | 理解意图，选择 Skill | ✅ 完全 | "算命" → activate_skill("bazi") |
    77→| **Phase 2 - 执行层** | 执行专业任务 | ✅ 完全 | LLM 根据 SKILL.md 引导对话 |
    78→| **Rule 层** | 定义流程结构 | ✅ Prompt | rules/dankoe.md 定义 6 个问题 |
    79→| **工具层** | 数据操作和卡片展示 | ❌ 声明式 | save_skill_data, show_card |
    80→| **存储层** | 持久化用户数据 | ❌ 基础设施 | profile.skills.{skill_id} |
    81→
    82→---
    83→
    84→## 2. Protocol 系统架构（方案 D：纯 Prompt 驱动）
    85→
    86→### 2.1 设计原理
    87→
    88→**核心思想**：Protocol 是一个由 LLM 驱动的结构化对话流程，通过 Rule 文件定义流程，LLM 从对话历史判断进度。
    89→
    90→```
    91→Protocol 实现 = Rule 文件 + LLM 记忆 + save_skill_data 工具
    92→
    93→不需要（已废弃）：
    94→├─ ❌ protocol.step（步骤计数器）
    95→├─ ❌ protocol.data（中间状态）
    96→├─ ❌ advance_protocol_step（步骤推进工具）
    97→├─ ❌ 独立 /protocol/[id] 页面
    98→├─ ❌ 前端步骤管理
    99→└─ ❌ SSE protocol_progress 事件
   100→
   101→需要（新架构）：
   102→├─ ✅ Rule 文件（定义流程结构）
   103→├─ ✅ LLM 对话历史（判断进度）
   104→├─ ✅ save_skill_data（完成后保存）
   105→└─ ✅ 主 Chat 中完成（统一体验）
   106→```
   107→
   108→### 2.2 Protocol 执行流程
   109→
   110→```
   111→用户："我想做人生重置"
   112→    │
   113→    ▼ Phase 1 LLM 识别意图
   114→    │
   115→activate_skill(skill="lifecoach", rule="dankoe")
   116→    │
   117→    ▼ Phase 2 上下文切换
   118→    │
   119→System Prompt 包含：
   120→├─ lifecoach/SKILL.md（专家人格）
   121→├─ lifecoach/rules/dankoe.md（6 个问题流程）
   122→└─ profile.skills.lifecoach（历史数据）
   123→    │
   124→    ▼ LLM 驱动对话（在主 Chat 中）
   125→    │
   126→LLM: "准备好开始 Dan Koe 快速重置了吗？这需要 10 分钟。"
   127→用户: "准备好了"
   128→LLM: "第一个问题：你持续忍受的不满是什么？"
   129→用户: "工作没意义，总是被打断"
   130→LLM: "第二个问题：如果不改变，3 年后会是什么样？"
   131→... (LLM 根据 Rule 自己推进 6 个问题)
   132→    │
   133→    ▼ 完成后
   134→    │
   135→LLM 调用: save_skill_data({
   136→  data: {
   137→    north_star: { vision: "...", anti_vision: "..." },
   138→    identity: { old: "...", new: "..." },
   139→    weekly: { actions: [...] }
   140→  }
   141→})
   142→    │
   143→    ▼ 数据持久化
   144→    │
   145→profile.skills.lifecoach.{north_star, identity, weekly}
   146→```
   147→
   148→**关键特性**：
   149→1. **无状态追踪**：LLM 从历史判断"已完成哪些问题"
   150→2. **无步骤计数器**：Rule 文件定义流程，LLM 自己推进
   151→3. **中断恢复**：用户切换话题后回来，LLM 识别未完成的问题
   152→4. **统一体验**：全程在主 Chat，无需跳转独立页面
   153→
   154→### 2.3 Rule 文件结构
   155→
   156→**核心模式**：
   157→```markdown
   158→# skills/lifecoach/rules/dankoe.md
   159→
   160→---
   161→id: dankoe
   162→name: Dan Koe 快速重置
   163→triggers: [人生重置, 快速重置, Dan Koe]
   164→estimated_time: 10分钟
   165→---
   166→
   167→## 流程
   168→
   169→按顺序完成 6 个问题：
   170→
   171→### Phase 1: 觉醒
   172→1. **持续的不满**：你忍受的痛苦是什么？
   173→2. **反愿景场景**：如果不改变，3 年后会怎样？
   174→3. **愿景场景**：理想的 3 年后是什么样？
   175→
   176→### Phase 2: 设计
   177→4. **放弃的身份**：你是什么样的人？
   178→5. **新身份宣言**：你想成为什么样的人？
   179→
   180→### Phase 3: 启动
   181→6. **本周行动**：具体的行动清单？
   182→
   183→## 完成后
   184→
   185→调用 save_skill_data 保存：
   186→- north_star: {vision, anti_vision}
   187→- identity: {old, new}
   188→- weekly: {actions}
   189→
   190→## 中断处理
   191→
   192→从对话历史判断进度：
   193→- 如果已回答问题 1-3，继续问题 4
   194→- 如果用户说"继续"，从未完成的问题开始
   195→```
   196→
   197→**Rule 文件的作用**：
   198→- ✅ 定义流程结构（不是控制流程执行）
   199→- ✅ 提供 LLM 指引（不是状态机）
   200→- ✅ 声明数据模型（不是数据存储）
   201→
   202→---
   203→
   204→## 3. 工具调用机制
   205→
   206→### 3.1 Phase 1 工具调用问题
   207→
   208→**问题现象**：
   209→```
   210→用户："我想聊聊"
   211→预期：recommend_skills 工具调用 + 卡片显示
   212→实际：纯文字回复，无卡片
   213→```
   214→
   215→**根本原因**：
   216→1. **Prompt 指令不够强**：LLM 将"必须调用工具"理解为"建议"
   217→2. **缺少对比学习**：没有展示"错误"vs"正确"示例
   218→3. **缺少动机解释**：没说明为什么必须调用（卡片 UI 依赖）
   219→4. **缺少强制机制**：未使用 Claude API tool_choice 参数
   220→
   221→### 3.2 解决方案架构
   222→
   223→**方案 A：Prompt 优化（LLM 驱动）**
   224→
   225→```yaml
   226→核心原则：
   227→├─ 强化指令："你必须使用工具，禁止纯文字回复"
   228→├─ 解释原因："用户使用卡片界面，纯文字无法触发卡片"
   229→├─ 对比学习：展示 ❌ 错误示例 vs ✅ 正确示例
   230→└─ 行为映射表：明确列出 [用户说 → 工具调用] 映射
   231→
   232→预期效果：
   233→├─ 工具调用率：60% → 90%+
   234→└─ 保持 LLM 驱动架构
   235→```
   236→
   237→**方案 B：tool_choice 参数（API 层强制）**
   238→
   239→```python
   240→核心机制：
   241→├─ Phase 1: tool_choice={"type": "any"}  # 必须调用任一工具
   242→└─ Phase 2: tool_choice={"type": "auto"} # 允许自由选择
   243→
   244→架构特点：
   245→├─ ✅ Claude SDK 原生支持
   246→├─ ✅ 100% 工具调用率
   247→├─ ✅ LLM 仍选择具体工具（仍是 LLM 驱动）
   248→└─ ✅ 无需 Python 硬编码兜底逻辑
   249→
   250→工作流程：
   251→Phase 1 → 强制工具调用 → LLM 选择最合适的工具
   252→Phase 2 → 自由选择 → LLM 可纯文字或工具调用
   253→```
   254→
   255→**方案对比**：
   256→
   257→| 方案 | 调用率 | 架构纯粹度 | 实施成本 | 推荐度 |
   258→|------|--------|-----------|---------|--------|
   259→| A (Prompt) | 90%+ | ⭐⭐⭐⭐⭐ | 低 | ⭐⭐⭐⭐ |
   260→| B (tool_choice) | 100% | ⭐⭐⭐⭐ | 中 | ⭐⭐⭐⭐⭐ |
   261→| A + B | 100% | ⭐⭐⭐⭐⭐ | 中 | ⭐⭐⭐⭐⭐ |
   262→
   263→**推荐**：先实施方案 A，如果调用率 < 90% 则补充方案 B。
   264→
   265→### 3.3 工具调用遥测
   266→
   267→**监控架构**：
   268→```
   269→CoreAgent._execute_tool()
   270→    │
   271→    ▼ 记录日志
   272→    │
   273→logger.info({
   274→  tool: "recommend_skills",
   275→  phase: "phase1",
   276→  skill: null,
   277→  timestamp: "..."
   278→})
   279→    │
   280→    ▼ 可选：发送遥测
   281→    │
   282→Grafana / Prometheus
   283→    │
   284→    ▼ 监控指标
   285→    │
   286→├─ 工具调用率（Phase 1 vs Phase 2）
   287→├─ 各工具调用频率分布
   288→└─ 工具调用失败率
   289→```
   290→
   291→---
   292→
   293→## 4. 通用工具系统
   294→
   295→### 4.1 设计原理
   296→
   297→**问题**：每个 Skill 都需要读写数据，导致重复实现 `read_lifecoach_state`、`read_bazi_state` 等。
   298→
   299→**解决方案**：通用工具 + 自动 skill_id 注入
   300→
   301→```
   302→通用工具系统架构：
   303→├─ read_state(sections?) → 读取 profile.skills.{当前skill_id}
   304→├─ write_state(section, data) → 写入 profile.skills.{当前skill_id}.{section}
   305→├─ append_to_list(path, entry) → 追加到列表（如 journal）
   306→└─ save_skill_data(data) → 深度合并保存（向后兼容）
   307→
   308→关键机制：
   309→├─ context.skill_id 自动注入 → LLM 无需传递 skill_id
   310→├─ 深度合并策略 → 不会覆盖未指定的字段
   311→└─ 自动时间戳 → _meta.updated_at 自动更新
   312→```
   313→
   314→### 4.2 数据流
   315→
   316→```
   317→LLM 调用: write_state(section="north_star", data={vision: "..."})
   318→    │
   319→    ▼ 工具处理器
   320→    │
   321→ToolContext: {user_id, skill_id="lifecoach"}
   322→    │
   323→    ▼ Repository 层
   324→    │
   325→update_skill_state(user_id, "lifecoach", "north_star", {vision: "..."})
   326→    │
   327→    ▼ PostgreSQL JSONB 操作
   328→    │
   329→jsonb_set(
   330→  profile,
   331→  '{skills, lifecoach, north_star}',
   332→  '{skills, lifecoach, north_star}' || {vision: "..."}
   333→)
   334→    │
   335→    ▼ 结果
   336→    │
   337→profile.skills.lifecoach.north_star = {
   338→  vision: "...",  # 新数据
   339→  anti_vision: "..."  # 保留旧数据（深度合并）
   340→}
   341→```
   342→
   343→---
   344→
   345→## 5. Dashboard 整合架构
   346→
   347→### 5.1 设计决策
   348→
   349→**核心理念**：Dashboard 不是独立页面，而是 Chat 空状态的增强展示。
   350→
   351→```
   352→旧架构（已废弃）：
   353→├─ 独立路由：/dashboard
   354→├─ 独立页面组件
   355→└─ 独立导航入口
   356→
   357→新架构（已实施）：
   358→├─ 整合到 Chat 空状态
   359→├─ /dashboard → 重定向到 /chat
   360→└─ 导航直接指向 /chat
   361→```
   362→
   363→### 5.2 组件层级
   364→
   365→```
   366→ChatPage
   367→  └─ ChatContent
   368→      ├─ useDashboard() → {dashboard, checkIn, toggleLever, ...}
   369→      └─ ChatContainer
   370→          └─ messages.length === 0 ?
   371→              ├─ ChatEmptyStateWithDashboard
   372→              │   ├─ DailyGreeting
   373→              │   ├─ VibeGlyph
   374→              │   ├─ AmbientStatusBar (简化版)
   375→              │   ├─ LifecoachQuickView (可展开卡片)
   376→              │   └─ MySkillsCarousel
   377→              └─ : null
   378→          └─ messages.map(msg => ChatMessage)
   379→```
   380→
   381→**设计优势**：
   382→- ✅ 用户无需切换 Tab
   383→- ✅ 对话开始后自动隐藏，不干扰
   384→- ✅ 组件复用 Dashboard 数据层
   385→- ✅ 统一体验，减少认知负担
   386→
   387→---
   388→
   389→## 6. 模块职责划分
   390→
   391→### 6.1 CoreAgent 模块
   392→
   393→**职责**：
   394→- ✅ Phase 1/2 上下文切换
   395→- ✅ System Prompt 构建
   396→- ✅ LLM 调用和工具执行
   397→- ✅ AgentEvent 流生成
   398→
   399→**不负责**：
   400→- ❌ Protocol 状态追踪（废弃）
   401→- ❌ 业务逻辑判断（交给 LLM）
   402→- ❌ 前端路由控制
   403→
   404→### 6.2 RoutingConfig 模块
   405→
   406→**职责**：
   407→- ✅ 加载 routing.yaml 配置
   408→- ✅ 提供 Phase 1 Prompt
   409→- ✅ 提供 Skill/Protocol 元数据
   410→- ✅ 动态生成工具描述
   411→
   412→**设计模式**：Single Source of Truth
   413→- 所有路由配置在 YAML 中定义
   414→- 代码从 YAML 加载，不硬编码
   415→
   416→### 6.3 Skill 模块
   417→
   418→**职责**：
   419→- ✅ 定义专家人格（SKILL.md）
   420→- ✅ 定义流程规则（rules/*.md）
   421→- ✅ 注册工具（tools/tools.yaml）
   422→- ✅ 实现工具处理器（tools/handlers.py）
   423→
   424→**Rule 文件职责**：
   425→- ✅ 定义流程结构
   426→- ✅ 提供 LLM 指引
   427→- ✅ 声明数据模型
   428→
   429→**不负责**：
   430→- ❌ 控制流程执行（交给 LLM）
   431→- ❌ 状态追踪（LLM 从历史判断）
   432→
   433→### 6.4 UnifiedProfile 模块
   434→
   435→**职责**：
   436→- ✅ 管理用户数据（account, birth_info, preferences）
   437→- ✅ 管理 Skill 数据（profile.skills.{skill_id}）
   438→- ✅ JSONB 深度合并操作
   439→- ✅ 缓存管理
   440→
   441→**数据结构**：
   442→```
   443→profile
   444→├─ account (账户信息)
   445→├─ birth_info (出生信息)
   446→├─ preferences (用户偏好)
   447→├─ state (当前状态)
   448→├─ skills.{skill_id} (Skill 数据)
   449→│   ├─ {业务数据}
   450→│   ├─ _state (运行时状态)
   451→│   └─ _meta (版本、时间戳)
   452→└─ extracted (AI 抽取的信息)
   453→```
   454→
   455→---
   456→
   457→## 7. 关键算法
   458→
   459→### 7.1 Phase 切换算法
   460→
   461→```
   462→输入：user_message, conversation_history
   463→输出：AgentEvent stream
   464→
   465→算法：
   466→1. 检测当前 Phase
   467→   IF conversation 中无 skill → Phase 1
   468→   ELSE → Phase 2
   469→
   470→2. Phase 1 流程
   471→   a. 构建轻量 System Prompt（routing.yaml）
   472→   b. 提供 4 个路由工具
   473→   c. LLM 选择工具
   474→   d. IF tool == activate_skill:
   475→      - 设置 self._active_skill
   476→      - 重新构建 System Prompt（同轮切换）
   477→      - 重新调用 LLM（Phase 2）
   478→
   479→3. Phase 2 流程
   480→   a. 构建完整 System Prompt（SKILL.md + Rule + SOP + Cases）
   481→   b. 加载 Skill 工具集
   482→   c. IF 需要收集信息 → 限制工具为 collect_tool
   483→      ELIF 需要计算 → 限制工具为 compute_tool
   484→      ELSE → 完整工具集
   485→   d. LLM 执行任务
   486→```
   487→
   488→**关键特性**：
   489→- ✅ 同轮切换：activate_skill 后立即重新构建上下文
   490→- ✅ 渐进式加载：Phase 1 轻量，Phase 2 完整
   491→- ✅ SOP 驱动：工具可用性由 SOP 状态决定
   492→
   493→### 7.2 Rule 驱动对话算法
   494→
   495→```
   496→输入：Rule 文件, 对话历史
   497→输出：下一步引导
   498→
   499→算法：
   500→1. LLM 读取 Rule 文件（在 System Prompt 中）
   501→2. LLM 分析对话历史
   502→   - 识别已完成的问题（通过用户回答）
   503→   - 识别未完成的问题
   504→3. LLM 决策
   505→   IF 所有问题已完成:
   506→     调用 save_skill_data
   507→   ELIF 用户切换话题:
   508→     正常回答，等待用户回来
   509→   ELSE:
   510→     提出下一个未完成的问题
   511→```
   512→
   513→**与传统状态机的区别**：
   514→
   515→| 特性 | 传统状态机 | Rule 驱动（LLM） |
   516→|------|-----------|-----------------|
   517→| 进度追踪 | step=3 (硬编码) | 从历史推断 |
   518→| 中断恢复 | 保存 step，恢复时读取 | LLM 自动识别未完成问题 |
   519→| 灵活性 | 严格按步骤 | 可跳跃、追问、澄清 |
   520→| 维护成本 | 每次改流程需改代码 | 只需改 Rule 文件 |
   521→
   522→### 7.3 工具可用性决策算法（SOP）- v2.1 更新
   523→
   524→> **重要变更 (v2.1)**：从"限制工具集"改为"指导 LLM 决策"，符合 CLAUDE.md 核心原则。
   525→
   526→**旧做法（已废弃）**：
   527→```python
   528→# ❌ 错误：限制 LLM 能看到的工具
   529→if phase == "P1_COLLECT":
   530→    allowed_tools = ["request_info"]  # LLM 看不到其他工具
   531→```
   532→
   533→**新做法（v2.1）**：
   534→```python
   535→# ✅ 正确：LLM 看到所有工具，通过 SOP 指导决策
   536→tools = ToolRegistry.get_tools_for_skill(skill_id)  # 完整工具集
   537→
   538→sop_rules = """
   539→## 当前状态：需要出生信息
   540→
   541→**推荐工具**：collect_bazi_info
   542→- 表单体验更好
   543→- 信息更完整
   544→
   545→**灵活处理**：
   546→如果用户在对话中直接提供了生日，可以解析并直接进入下一步。
   547→"""
   548→# LLM 有推荐但保留灵活性
   549→```
   550→
   551→**核心原则**：
   552→- ✅ 工具不受限：LLM 可以看到所有工具
   553→- ✅ SOP 提供指导：而非 if-else 限制
   554→- ✅ 保留灵活性：特殊情况可绕过
   555→
   556→### 7.4 Phase 2 边界意识（Context Continuity）- v2.1 新增
   557→
   558→**问题**：用户在 tarot skill 内说"今日指引"，LLM 调用 `recommend_skills` 让用户重新选择服务。
   559→
   560→**根本原因**：
   561→1. Phase 2 的 System Prompt 没有明确告知 LLM "你现在在哪个 skill 内"
   562→2. LLM 看到 `recommend_skills` 工具后可能误用
   563→3. 工具描述缺少 `when_to_call` 和 `when_not_to_call` 指导
   564→
   565→**解决方案**：通过 Prompt 和工具描述增强，而非工具集限制
   566→
   567→```
   568→┌─────────────────────────────────────────────────────────────────────┐
   569→│                   Phase 2 边界意识机制                               │
   570→├─────────────────────────────────────────────────────────────────────┤
   571→│                                                                      │
   572→│ 1. SOP 模板增强 (routing.yaml)                                      │
   573→│    ready_for_analysis 模板添加：                                     │
   574→│    - "你现在是 {skill_id} 专家"                                     │
   575→│    - "用户请求应该用本 skill 的工具处理"                            │
   576→│    - "不推荐调用 recommend_skills（除非用户明确要求换服务）"         │
   577→│                                                                      │
   578→│ 2. 工具描述增强 (tools.yaml)                                        │
   579→│    recommend_skills 添加 when_not_to_call：                         │
   580→│    - "用户已在某个 Skill 内执行任务时不要调用"                       │
   581→│    - "用户请求可用当前 Skill 工具处理时不要调用"                     │
   582→│                                                                      │
   583→│ 3. SKILL.md 增强                                                    │
   584→│    每个 Skill 的工具调用规则表补全常见意图映射                      │
   585→│    添加边界意识指引                                                  │
   586→│                                                                      │
   587→└─────────────────────────────────────────────────────────────────────┘
   588→```
   589→
   590→**关键原则**：
   591→
   592→| 原则 | 解释 | 实践 |
   593→|------|------|------|
   594→| **指导而非限制** | 告诉 LLM "推荐"和"不推荐"，而非禁止 | SOP 模板 |
   595→| **保留灵活性** | 用户明确要求换服务时可以切换 | 工具描述 |
   596→| **上下文意识** | LLM 知道"我现在在哪个 skill 内" | System Prompt |
   597→
   598→**判断原则（写入 SOP 模板）**：
   599→
   600→```markdown
   601→## 何时使用当前 Skill 工具
   602→- 用户请求与当前 Skill 直接相关
   603→- 用户说"今日指引"、"帮我看看"、"继续"等模糊请求
   604→
   605→## 何时切换 Skill（调用 activate_skill）
   606→- 用户明确说"我想看星座"（切换到 zodiac）
   607→- 用户明确说"帮我算八字"（切换到 bazi）
   608→- 用户说"换一个"、"退出"
   609→```
   610→
   611→**示例**：
   612→
   613→```
   614→场景：用户在 tarot skill 内
   615→
   616→用户："今日指引"
   617→❌ 错误：recommend_skills(skills=["tarot", "zodiac", "jungastro"])
   618→✅ 正确：draw_tarot_cards(spread_type="single", question="今日指引")
   619→
   620→用户："我想看星座"
   621→✅ 正确：activate_skill(skill="zodiac")  # 用户明确要求切换
   622→```
   623→
   624→---
   625→
   626→## 8. 架构对比
   627→
   628→### 8.1 旧 vs 新 Protocol 架构
   629→
   630→| 方面 | 旧架构 | 新架构（Rule 驱动） |
   631→|------|-------|-------------------|
   632→| **触发方式** | show_protocol_invitation → 跳转页面 | activate_skill + rule 参数 |
   633→| **状态管理** | 前端 ProtocolContainer 管理 step | LLM 从历史判断进度 |
   634→| **步骤推进** | advance_protocol_step 工具 | 无需工具，LLM 自驱动 |
   635→| **数据保存** | 每步调用工具保存 | 完成后一次性保存 |
   636→| **前端页面** | /protocol/dankoe 独立页面 | 主 Chat 中完成 |
   637→| **SSE 事件** | protocol_progress 事件 | 无需（普通对话流） |
   638→| **中断恢复** | 前端记录 currentStep | LLM 从历史判断 |
   639→| **代码量** | ~1500 行 | ~200 行 |
   640→| **维护成本** | 高（前后端复杂状态同步） | 低（只需维护 Rule 文件） |
   641→
   642→### 8.2 工具系统演进
   643→
   644→| 版本 | 模式 | 示例 | 问题 |
   645→|------|------|------|------|
   646→| V1 | Skill 专用工具 | read_lifecoach_state | 每个 Skill 需重复实现 |
   647→| V2 | 通用工具 + skill_id 参数 | read_state(skill_id="lifecoach") | LLM 需要知道 skill_id |
   648→| V3 | 通用工具 + 自动注入 | read_state() | ✅ LLM 无需传 skill_id |
   649→
   650→---
   651→
   652→## 9. 实施优先级
   653→
   654→### P0（最高优先级）- 卡片调用修复
   655→
   656→**目标**：工具调用率 60% → 90%+
   657→
   658→**模块**：
   659→- RoutingConfig (Phase 1 Prompt 优化)
   660→- CoreAgent (tool_choice 参数)
   661→- 监控遥测
   662→
   663→**时间**：2 天
   664→
   665→---
   666→
   667→### P1（重要）- 架构统一
   668→
   669→**目标**：完全移除旧 Protocol 系统
   670→
   671→**模块**：
   672→- 前端：删除 /protocol/* 页面和组件
   673→- 后端：删除 protocol 状态追踪逻辑
   674→- 工具：简化 show_protocol_invitation
   675→
   676→**时间**：3 天
   677→
   678→---
   679→
   680→### P1（重要）- Rule 驱动验证
   681→
   682→**目标**：确保新流程完整可用
   683→
   684→**测试**：
   685→- Dan Koe 完整流程
   686→- 中断恢复
   687→- 其他方法论（Covey, 王阳明, 了凡）
   688→
   689→**时间**：2 天
   690→
   691→---
   692→
   693→### P2（优化）- 监控和性能
   694→
   695→**目标**：系统稳定性和可观测性
   696→
   697→**模块**：
   698→- 工具调用遥测
   699→- Rule 文件缓存
   700→- Profile 查询优化
   701→- Grafana Dashboard
   702→
   703→**时间**：3 天
   704→
   705→---
   706→
   707→## 10. Profile 注入（简化版 v2.2）
   708→
   709→### 10.1 设计原则
   710→
   711→**核心理念**：两层 + 约定优于配置
   712→
   713→```
   714→┌─────────────────────────────────────────────────────────────┐
   715→│                  Profile 注入架构                            │
   716→├─────────────────────────────────────────────────────────────┤
   717→│                                                             │
   718→│  Layer 1: Base（所有 Skill 共享，~300 tokens）               │
   719→│  ───────────────────────────────────────────────────────    │
   720→│  • identity.birth_info（如有）                               │
   721→│  • identity.display_name                                    │
   722→│  • extracted.goals[:3]                                      │
   723→│  • extracted.facts[:5]                                      │
   724→│                                                             │
   725→│  Layer 2: Skill（按命名约定自动，~200 tokens）               │
   726→│  ───────────────────────────────────────────────────────    │
   727→│  • skill_data.{skill_id}                                    │
   728→│    - bazi → skill_data.bazi                                 │
   729→│    - zodiac → skill_data.zodiac                             │
   730→│    - lifecoach → skill_data.lifecoach                       │
   731→│                                                             │
   732→└─────────────────────────────────────────────────────────────┘
   733→```
   734→
   735→### 10.2 实现
   736→
   737→**单一函数**：`ContextManager.get_profile_context(user_id, skill_id)`
   738→
   739→```python
   740→async def get_profile_context(self, user_id: str, skill_id: str) -> Dict:
   741→    """简化版 Profile 注入 - 两层架构"""
   742→    profile = await UnifiedProfileRepository.get_profile(UUID(user_id))
   743→    if not profile:
   744→        return {}
   745→
   746→    return {
   747→        # Layer 1: Base（共享）
   748→        "user": {
   749→            "name": profile.get("identity", {}).get("display_name"),
   750→            "birth": profile.get("identity", {}).get("birth_info"),
   751→        },
   752→        "background": {
   753→            "goals": profile.get("extracted", {}).get("goals", [])[:3],
   754→            "facts": profile.get("extracted", {}).get("facts", [])[:5],
   755→        },
   756→        # Layer 2: Skill（按命名自动匹配）
   757→        "skill_data": profile.get("skill_data", {}).get(skill_id, {})
   758→    }
   759→```
   760→
   761→### 10.3 与旧设计对比
   762→
   763→| 删除的复杂性 | 原因 |
   764→|-------------|------|
   765→| 四层架构（Essential → Shared → Specific → Contextual） | 两层足够 |
   766→| 声明式配置（SKILL.md 声明需要的字段） | 约定优于配置 |
   767→| 默认映射表 | 命名约定自动匹配 |
   768→| Token 精细优化 | ~500 tokens 影响不大 |
   769→
   770→### 10.4 跨 Skill 数据配置
   771→
   772→**配置驱动**（在 SKILL.md frontmatter 中声明）：
   773→
   774→```yaml
   775→# skills/jungastro/SKILL.md
   776→---
   777→name: jungastro
   778→requires_skill_data: [bazi, zodiac]  # 声明需要的 skill_data
   779→---
   780→```
   781→
   782→**代码实现**：
   783→
   784→```python
   785→# skill_loader.py
   786→def get_skill_required_data(skill_id: str) -> List[str]:
   787→    """从 SKILL.md 配置读取需要的 skill_data"""
   788→    skill = load_skill(skill_id)
   789→    if skill and skill.requires_skill_data:
   790→        return skill.requires_skill_data
   791→    return [skill_id]  # 默认只需自身
   792→
   793→# prompt_builder.py - 使用配置
   794→skill_ids = get_skill_required_data(skill_id)  # 配置驱动，非硬编码
   795→```
   796→
   797→**新增 Skill 时**：只需在 SKILL.md 中添加 `requires_skill_data` 配置即可。
   798→
   799→---
   800→
   801→## 11. 架构原则
   802→
   803→### 11.1 LLM 驱动
   804→
   805→**定义**：所有流程控制交给 LLM，通过 Prompt 引导行为。
   806→
   807→**实践**：
   808→- ✅ Rule 文件定义流程结构，不控制执行
   809→- ✅ LLM 从对话历史判断进度
   810→- ✅ 工具提供能力，LLM 决定何时调用
   811→- ❌ 不使用 if-elif 硬编码状态机
   812→
   813→### 11.2 声明式配置
   814→
   815→**定义**：配置驱动，而非代码驱动。
   816→
   817→**实践**：
   818→- ✅ routing.yaml 定义路由规则
   819→- ✅ tools.yaml 定义工具能力
   820→- ✅ Rule.md 定义流程结构
   821→- ❌ 不在代码中硬编码配置
   822→
   823→### 11.3 单一职责
   824→
   825→**定义**：每个模块只负责一件事。
   826→
   827→**实践**：
   828→- ✅ CoreAgent：执行 Agent 流程
   829→- ✅ RoutingConfig：加载配置
   830→- ✅ Skill：定义专家能力
   831→- ✅ UnifiedProfile：管理用户数据
   832→- ❌ 模块间不交叉职责
   833→
   834→### 11.4 渐进式加载
   835→
   836→**定义**：按需加载，避免初始上下文过大。
   837→
   838→**实践**：
   839→- ✅ Phase 1：轻量上下文（routing prompt + 4 工具）
   840→- ✅ Phase 2：完整上下文（SKILL + Rule + SOP + Cases + Profile）
   841→- ✅ SOP 驱动：按状态限制工具集
   842→
   843→---
   844→
   845→## 12. 风险与缓解
   846→
   847→| 风险 | 概率 | 影响 | 缓解措施 |
   848→|------|------|------|---------|
   849→| LLM 不遵守 Prompt | 中 | 高 | tool_choice 参数 + Prompt 优化 |
   850→| LLM 无法理解 Rule 流程 | 低 | 高 | Rule 文件添加示例对话 |
   851→| 中断恢复不准确 | 中 | 中 | 增加历史长度（10 → 20 条） |
   852→| 用户习惯旧 protocol 页面 | 低 | 低 | 引导语提示在对话中完成 |
   853→
   854→---
   855→
   856→## 13. 总结
   857→
   858→### 核心成果
   859→
   860→**架构转变**：
   861→```
   862→旧：复杂状态机 + 独立页面 + 前后端状态同步
   863→新：Rule 文件 + LLM 自驱动 + 主 Chat 统一体验
   864→```
   865→
   866→**代码简化**：
   867→- 旧架构：~1500 行（前端 800 + 后端 700）
   868→- 新架构：~200 行（Rule 文件 + 通用工具）
   869→- 减少：87% 代码量
   870→
   871→**维护成本**：
   872→- 旧：改流程需修改前后端代码 + 状态同步逻辑
   873→- 新：只需修改 Rule 文件（Markdown）
   874→
   875→**用户体验**：
   876→- 旧：跳转独立页面，中断对话流
   877→- 新：主 Chat 中完成，无缝体验
   878→
   879→### 关键洞察
   880→
   881→1. **LLM 是最好的状态机**：不需要硬编码 step=1,2,3，LLM 从历史自然推断
   882→2. **Prompt 是配置**：Rule 文件 = 可读性极高的配置文件
   883→3. **工具是能力**：提供工具，让 LLM 决定何时调用
   884→4. **卡片是交互**：工具调用 = 卡片展示，统一模式
   885→
   886→### 未来方向
   887→
   888→1. **多方法论并行**：支持同时进行多个 Protocol（Dankoe + Weekly Review）
   889→2. **协议版本控制**：Rule 文件版本化，支持升级
   890→3. **Proactive Engine**：LLM 生成个性化 Dashboard 内容
   891→4. **A/B 测试框架**：对比 Rule 文件变体效果
   892→
   893→---
   894→
   895→**参考文档**：
   896→- `/docs/components/coreagent/SPEC.md` - 新架构设计（方案 D）
   897→- `/docs/components/coreagent/REFACTOR_PLAN.md` - 重构计划
   898→- `/docs/components/chat/README.md` - Chat 组件文档
   899→- `/apps/api/skills/lifecoach/rules/*.md` - Rule 文件示例
   900→- `CLAUDE.md` - Agent SDK 最佳实践
   901→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
