     1→"""
     2→Prompt Builder v10 - System Prompt 构建
     3→
     4→从 core.py 拆分出来的 Prompt 构建逻辑，支持：
     5→- Phase 1/Phase 2 分阶段 Prompt
     6→- 会话恢复 Prompt（断点续传）
     7→- SOP 规则注入
     8→- 案例匹配
     9→
    10→与 ContextManager 协作：
    11→- 读取会话上下文
    12→- 注入断点信息
    13→"""
    14→import json
    15→import logging
    16→from typing import Optional, Dict, Any, List
    17→
    18→from .skill_loader import (
    19→    load_skill, build_system_prompt,
    20→    skill_requires_birth_info, skill_requires_compute,
    21→    get_skill_compute_type, get_skill_compute_tool, get_skill_collect_tool,
    22→    get_skill_required_data
    23→)
    24→from .routing_config import get_phase1_prompt, get_sop_template
    25→from .context_manager import SessionContext
    26→
    27→logger = logging.getLogger(__name__)
    28→
    29→
    30→class PromptBuilder:
    31→    """
    32→    System Prompt 构建器
    33→
    34→    职责：
    35→    1. 根据 Phase 构建不同的 Prompt
    36→    2. 注入会话恢复上下文
    37→    3. 注入 SOP 规则
    38→    4. 动态加载案例
    39→    5. v10.1: 用户画像注入（让 Coach 了解用户）
    40→    """
    41→
    42→    # 需要详细用户画像的 Skill（注入 goals, patterns, findings）
    43→    PORTRAIT_FULL_SKILLS = {"lifecoach", "career"}
    44→
    45→    # 需要出生信息的 Skill
    46→    BIRTH_INFO_SKILLS = {"bazi", "zodiac", "jungastro"}
    47→
    48→    def __init__(self):
    49→        self.case_index = None  # Lazy init
    50→
    51→    async def build(
    52→        self,
    53→        skill_id: Optional[str],
    54→        rule_id: Optional[str],
    55→        message: str,
    56→        profile: Optional[Dict[str, Any]] = None,
    57→        skill_data: Optional[Dict[str, Any]] = None,
    58→        session_context: Optional[SessionContext] = None,
    59→        protocol_prompt: Optional[str] = None
    60→    ) -> str:
    61→        """
    62→        构建 System Prompt
    63→
    64→        Args:
    65→            skill_id: 当前技能 ID
    66→            rule_id: 当前规则 ID
    67→            message: 用户消息
    68→            profile: 用户 Profile
    69→            skill_data: Skill 数据
    70→            session_context: 会话上下文（断点续传）
    71→            protocol_prompt: 协议专用 Prompt（可选）
    72→
    73→        Returns:
    74→            完整的 System Prompt
    75→        """
    76→        parts = []
    77→
    78→        # ═══════════════════════════════════════════════════════════════
    79→        # 协议模式：使用协议专用 Prompt
    80→        # ═══════════════════════════════════════════════════════════════
    81→        if protocol_prompt:
    82→            skill = load_skill("lifecoach")
    83→            if skill:
    84→                parts.append(f"# {skill.name}\n\n{skill.expert_persona}")
    85→            parts.append("\n---\n")
    86→            parts.append(protocol_prompt)
    87→            return "\n".join(parts)
    88→
    89→        if skill_id:
    90→            # ═══════════════════════════════════════════════════════════════
    91→            # Phase 2: Skill 执行阶段 - 完整上下文
    92→            # ═══════════════════════════════════════════════════════════════
    93→
    94→            # 基础 Skill Prompt
    95→            user_ctx = dict(profile) if profile else {}
    96→            base_prompt = build_system_prompt(skill_id, rule_id, user_ctx)
    97→            parts.append(base_prompt)
    98→
    99→            # ═══════════════════════════════════════════════════════════════
   100→            # Profile 注入（简化版 v2.2）- 两层架构
   101→            # ═══════════════════════════════════════════════════════════════
   102→            profile_context = self._build_profile_context(profile, skill_data, skill_id)
   103→            if profile_context:
   104→                parts.append(profile_context)
   105→
   106→            # 会话恢复上下文（断点续传核心）
   107→            if session_context and session_context.has_checkpoint:
   108→                resume_context = session_context.to_prompt_context()
   109→                if resume_context:
   110→                    parts.append(resume_context)
   111→
   112→            # SOP 规则
   113→            sop_rules = self._build_sop_rules(skill_id, profile, skill_data)
   114→            if sop_rules:
   115→                parts.append(sop_rules)
   116→
   117→            # 案例匹配
   118→            cases_text = await self._match_cases(skill_id, skill_data)
   119→            if cases_text:
   120→                parts.append(cases_text)
   121→
   122→        else:
   123→            # ═══════════════════════════════════════════════════════════════
   124→            # Phase 1: Skill 选择阶段 - 轻量级
   125→            # ═══════════════════════════════════════════════════════════════
   126→
   127→            core_prompt = get_phase1_prompt()
   128→            if not core_prompt:
   129→                # Fallback
   130→                core_prompt = self._get_fallback_phase1_prompt()
   131→
   132→            parts.append(core_prompt)
   133→
   134→        return "\n".join(parts)
   135→
   136→    def _build_profile_context(
   137→        self,
   138→        profile: Optional[Dict[str, Any]],
   139→        skill_data: Optional[Dict[str, Any]],
   140→        skill_id: str
   141→    ) -> str:
   142→        """
   143→        构建 Profile 上下文（简化版 v2.2）
   144→
   145→        两层架构：
   146→        - Layer 1: Base（共享）- identity + extracted
   147→        - Layer 2: Skill（按命名约定）- skill_data.{skill_id}
   148→        """
   149→        parts = []
   150→
   151→        # ═══════════════════════════════════════════════════════════════
   152→        # Layer 1: Base（所有 Skill 共享，~300 tokens）
   153→        # ═══════════════════════════════════════════════════════════════
   154→        if profile:
   155→            identity = profile.get("identity", {})
   156→            extracted = profile.get("extracted", {})
   157→
   158→            base_info = []
   159→
   160→            # 用户名
   161→            name = identity.get("display_name")
   162→            if name:
   163→                base_info.append(f"- 用户名：{name}")
   164→
   165→            # 出生信息（如有）
   166→            birth = identity.get("birth_info", {})
   167→            if birth:
   168→                birth_date = birth.get("birth_date") or birth.get("date")
   169→                if birth_date:
   170→                    base_info.append(f"- 出生日期：{birth_date}")
   171→                birth_time = birth.get("birth_time") or birth.get("time")
   172→                if birth_time:
   173→                    base_info.append(f"- 出生时间：{birth_time}")
   174→                birth_place = birth.get("birth_place") or birth.get("location")
   175→                if birth_place:
   176→                    base_info.append(f"- 出生地点：{birth_place}")
   177→
   178→            # 用户目标（最近 3 条）
   179→            goals = extracted.get("goals", [])[:3]
   180→            if goals:
   181→                goals_text = ", ".join([g.get("content", str(g)) if isinstance(g, dict) else str(g) for g in goals])
   182→                base_info.append(f"- 关注目标：{goals_text}")
   183→
   184→            # 用户事实（最近 5 条）
   185→            facts = extracted.get("facts", [])[:5]
   186→            if facts:
   187→                facts_text = "; ".join([f.get("content", str(f)) if isinstance(f, dict) else str(f) for f in facts])
   188→                base_info.append(f"- 已知信息：{facts_text}")
   189→
   190→            if base_info:
   191→                parts.append("## 用户背景\n\n" + "\n".join(base_info))
   192→
   193→        # ═══════════════════════════════════════════════════════════════
   194→        # Layer 2: Skill（配置驱动，~200 tokens）
   195→        # ═══════════════════════════════════════════════════════════════
   196→        if skill_data:
   197→            # 获取该 Skill 需要的 skill_data（从 SKILL.md 配置读取）
   198→            skill_ids = get_skill_required_data(skill_id)
   199→
   200→            for sid in skill_ids:
   201→                data = skill_data.get(sid, {})
   202→                if data:
   203→                    # 过滤掉内部字段（以 _ 开头）
   204→                    filtered_data = {k: v for k, v in data.items() if not k.startswith("_")}
   205→                    if filtered_data:
   206→                        parts.append(f"\n## {sid} 数据\n\n```json\n{json.dumps(filtered_data, ensure_ascii=False, indent=2)}\n```")
   207→
   208→        return "\n".join(parts) if parts else ""
   209→
   210→    def _build_sop_rules(
   211→        self,
   212→        skill_id: str,
   213→        profile: Optional[Dict[str, Any]],
   214→        skill_data: Optional[Dict[str, Any]]
   215→    ) -> str:
   216→        """
   217→        构建 SOP 规则（自然语言版）
   218→
   219→        根据当前状态生成教练式指导。
   220→        """
   221→        needs_birth = skill_requires_birth_info(skill_id)
   222→        needs_compute = skill_requires_compute(skill_id)
   223→
   224→        # 计算当前状态
   225→        status = self._compute_status(skill_id, profile, skill_data)
   226→
   227→        # 如果已经可以分析，使用简洁的状态提示
   228→        if status["ready_for_analysis"]:
   229→            template = get_sop_template("ready_for_analysis")
   230→            if template:
   231→                chart_summary = self._extract_chart_summary(skill_id, skill_data)
   232→                return template.format(
   233→                    chart_summary=chart_summary,
   234→                    skill_id=skill_id
   235→                )
   236→            return self._get_ready_prompt()
   237→
   238→        rules_parts = []
   239→
   240→        # P1: 需要收集信息
   241→        if needs_birth and not status["has_birth_info"]:
   242→            collect_tool = get_skill_collect_tool(skill_id) or "request_info"
   243→            template = get_sop_template("need_birth_info")
   244→            if template:
   245→                rules_parts.append(template.format(collect_tool=collect_tool))
   246→            else:
   247→                rules_parts.append(self._get_need_birth_prompt(collect_tool))
   248→
   249→        # P2: 需要计算
   250→        elif needs_compute and not status["has_chart_data"]:
   251→            compute_type = get_skill_compute_type(skill_id) or skill_id
   252→            compute_tool = get_skill_compute_tool(skill_id) or f"calculate_{compute_type}"
   253→
   254→            template = get_sop_template("need_compute")
   255→            if template:
   256→                rules_parts.append(template.format(compute_tool=compute_tool, has_chart="否"))
   257→            else:
   258→                rules_parts.append(self._get_need_compute_prompt(compute_tool))
   259→
   260→        return "\n".join(rules_parts)
   261→
   262→    def _compute_status(
   263→        self,
   264→        skill_id: str,
   265→        profile: Optional[Dict[str, Any]],
   266→        skill_data: Optional[Dict[str, Any]]
   267→    ) -> Dict[str, Any]:
   268→        """计算当前 SOP 状态"""
   269→        needs_birth = skill_requires_birth_info(skill_id)
   270→        needs_compute = skill_requires_compute(skill_id)
   271→
   272→        # 检查出生信息
   273→        has_birth = False
   274→        if profile:
   275→            identity = profile.get("identity", {})
   276→            birth_info = identity.get("birth_info", {})
   277→            has_birth = bool(birth_info.get("birth_date") or birth_info.get("date"))
   278→
   279→        # 检查命盘数据
   280→        has_chart = False
   281→        if skill_data:
   282→            compute_type = get_skill_compute_type(skill_id) or skill_id
   283→            data = skill_data.get(compute_type, {})
   284→            has_chart = bool(data.get("chart") or data.get("cards"))
   285→
   286→        return {
   287→            "skill_id": skill_id,
   288→            "needs_birth_info": needs_birth,
   289→            "has_birth_info": has_birth,
   290→            "needs_compute": needs_compute,
   291→            "has_chart_data": has_chart,
   292→            "ready_for_analysis": (not needs_birth or has_birth) and (not needs_compute or has_chart)
   293→        }
   294→
   295→    def _extract_chart_summary(
   296→        self,
   297→        skill_id: str,
   298→        skill_data: Optional[Dict[str, Any]]
   299→    ) -> str:
   300→        """从命盘数据中提取关键摘要"""
   301→        if not skill_data:
   302→            return "无命盘数据"
   303→
   304→        compute_type = get_skill_compute_type(skill_id) or skill_id
   305→        data = skill_data.get(compute_type, {})
   306→
   307→        if not data:
   308→            return "无命盘数据"
   309→
   310→        summary_parts = []
   311→
   312→        # 八字
   313→        if compute_type == "bazi" and "chart" in data:
   314→            chart = data["chart"]
   315→            if "pillars" in chart and len(chart["pillars"]) > 2:
   316→                day_pillar = chart["pillars"][2]
   317→                summary_parts.append(f"日主{day_pillar.get('day_stem', '')}{day_pillar.get('day_branch', '')}")
   318→            if "month_order" in chart:
   319→                summary_parts.append(f"月令{chart['month_order']}")
   320→
   321→        # 星盘
   322→        elif compute_type == "zodiac" and "chart" in data:
   323→            chart = data["chart"]
   324→            planets = chart.get("planets", {})
   325→            if "sun" in planets:
   326→                summary_parts.append(f"太阳{planets['sun'].get('sign', '')}")
   327→            if "moon" in planets:
   328→                summary_parts.append(f"月亮{planets['moon'].get('sign', '')}")
   329→
   330→        # 塔罗
   331→        elif compute_type == "tarot" and "cards" in data:
   332→            cards = data["cards"]
   333→            if isinstance(cards, list) and len(cards) > 0:
   334→                summary_parts.append(f"{len(cards)}张牌")
   335→
   336→        if summary_parts:
   337→            return "、".join(summary_parts)
   338→        else:
   339→            return "已生成命盘"
   340→
   341→    async def _match_cases(
   342→        self,
   343→        skill_id: str,
   344→        skill_data: Optional[Dict[str, Any]]
   345→    ) -> str:
   346→        """匹配相关案例"""
   347→        if not skill_data:
   348→            return ""
   349→
   350→        try:
   351→            from .case_index import get_case_index, extract_features
   352→
   353→            if self.case_index is None:
   354→                self.case_index = get_case_index()
   355→
   356→            features = extract_features(skill_data)
   357→            if not features:
   358→                return ""
   359→
   360→            cases = await self.case_index.get_matched_cases(skill_id, features, top_k=2)
   361→            if not cases:
   362→                return ""
   363→
   364→            cases_text = "\n## 相关案例\n\n"
   365→            for case in cases:
   366→                cases_text += f"### {case.name}\n{case.content}\n\n"
   367→
   368→            return cases_text
   369→
   370→        except Exception as e:
   371→            logger.warning(f"[PromptBuilder] Case matching failed: {e}")
   372→            return ""
   373→
   374→    def _get_fallback_phase1_prompt(self) -> str:
   375→        """Fallback Phase 1 Prompt"""
   376→        return """# Vibe
   377→
   378→你是 Vibe，生命对话者。你的任务是理解用户意图，引导 Ta 到合适的服务。
   379→
   380→## 行为准则
   381→
   382→1. **识别意图 → 调用工具**：不要只用文字回复，要调用工具
   383→2. **简短回应 + 工具**：调用工具时配合一句暖心的话
   384→3. **不确定 → 推荐**：调用 recommend_skills 让用户选择
   385→
   386→## 语气
   387→
   388→温暖、简洁、不啰嗦。像一个懂你的老朋友。
   389→
   390→示例：
   391→- "嗨～ 今天想聊点什么？"
   392→- "好的，让我来帮你看看～"
   393→- "迷茫的时候来找我就对了。"
   394→"""
   395→
   396→    def _get_ready_prompt(self) -> str:
   397→        """已准备好分析的 Prompt"""
   398→        return """## 当前状态
   399→
   400→用户信息已完整，命盘已生成。你可以开始分析了。
   401→
   402→**分析流程**：
   403→1. 快速扫描命盘中的关键特征
   404→2. 根据用户问题聚焦分析
   405→3. 用 `show_xxx` 工具展示分析结果
   406→4. 回答用户的追问
   407→"""
   408→
   409→    def _get_need_birth_prompt(self, collect_tool: str) -> str:
   410→        """需要收集出生信息的 Prompt"""
   411→        return f"""## 当前状态
   412→
   413→用户还没有告诉你出生信息。在深入分析之前，你需要先了解 Ta 的出生时间。
   414→
   415→**下一步**：调用 `{collect_tool}` 工具，让用户填写出生信息表单。
   416→不要用文字问"请问你的生日是？"——表单体验更好。
   417→"""
   418→
   419→    def _get_need_compute_prompt(self, compute_tool: str) -> str:
   420→        """需要计算的 Prompt"""
   421→        return f"""## 当前状态
   422→
   423→用户已提供出生信息，但还没有生成命盘。
   424→
   425→**下一步**：调用 `{compute_tool}` 工具生成命盘数据。
   426→计算完成后你就可以开始分析了。
   427→"""
   428→
   429→    def build_session_resume_prompt(
   430→        self,
   431→        session_context: SessionContext,
   432→        rule_name: Optional[str] = None
   433→    ) -> str:
   434→        """
   435→        构建会话恢复 Prompt（用于 SOP 模板）
   436→
   437→        专门用于断点续传场景
   438→        """
   439→        if not session_context or not session_context.has_checkpoint:
   440→            return ""
   441→
   442→        cp = session_context.checkpoint
   443→        session = session_context.session
   444→
   445→        lines = ["## 会话恢复模式\n"]
   446→
   447→        if cp:
   448→            lines.append(f"用户上次完成了 {cp.step} 个步骤。\n")
   449→
   450→            if cp.collected_data:
   451→                lines.append("**已收集信息**：")
   452→                for key, value in cp.collected_data.items():
   453→                    lines.append(f"- {key}: {value}")
   454→                lines.append("")
   455→
   456→            next_step = cp.step + 1
   457→            lines.append(f"**下一步**：")
   458→            lines.append(f"继续第 {next_step} 个问题\n")
   459→
   460→        lines.append("**处理方式**：")
   461→        lines.append("1. 简短问候：「欢迎回来！上次我们聊到了...」")
   462→        lines.append("2. 快速回顾（1-2 句）")
   463→        lines.append("3. 直接问下一个问题")
   464→
   465→        return "\n".join(lines)
   466→
   467→
   468→# ═══════════════════════════════════════════════════════════════════════════
   469→# Singleton
   470→# ═══════════════════════════════════════════════════════════════════════════
   471→
   472→_prompt_builder: Optional[PromptBuilder] = None
   473→
   474→
   475→def get_prompt_builder() -> PromptBuilder:
   476→    """获取 PromptBuilder 单例"""
   477→    global _prompt_builder
   478→    if _prompt_builder is None:
   479→        _prompt_builder = PromptBuilder()
   480→    return _prompt_builder
   481→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
