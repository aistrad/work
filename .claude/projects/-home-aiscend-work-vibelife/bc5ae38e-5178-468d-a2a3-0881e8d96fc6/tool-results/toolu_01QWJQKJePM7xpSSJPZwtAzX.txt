     1→"""
     2→Relationship API Routes
     3→Based on: vibelife spec v3.0, section 2.2.4
     4→
     5→Endpoints:
     6→- POST /api/v1/relationship/analyze - Single-user analysis
     7→- POST /api/v1/relationship/vibe-link - Create Vibe Link
     8→- GET /api/v1/relationship/vibe-link/{code} - Get Vibe Link info
     9→- POST /api/v1/relationship/vibe-link/{code}/accept - Accept invitation
    10→- POST /api/v1/relationship/vibe-link/{code}/complete - Complete analysis
    11→- POST /api/v1/relationship/card - Generate shareable card
    12→"""
    13→
    14→import logging
    15→from typing import Optional
    16→from uuid import UUID
    17→from fastapi import APIRouter, HTTPException, Query
    18→from pydantic import BaseModel, Field
    19→
    20→from ..services.relationship import (
    21→    get_relationship_service,
    22→    VibeLinkService,
    23→    RelationshipCardGenerator,
    24→    DisclosureLevel,
    25→)
    26→from ..services.relationship.vibe_link import get_vibe_link_service
    27→
    28→logger = logging.getLogger(__name__)
    29→router = APIRouter(prefix="/relationship", tags=["relationship"])
    30→
    31→
    32→# ═══════════════════════════════════════════════════════════════════════════
    33→# Request/Response Models
    34→# ═══════════════════════════════════════════════════════════════════════════
    35→
    36→class AnalyzeRequest(BaseModel):
    37→    """Request for relationship analysis"""
    38→    user_id: str
    39→    user_profile: dict
    40→    partner_info: dict  # Can be full profile or minimal (zodiac/chinese_zodiac)
    41→    relationship_type: str = Field(default="general")
    42→
    43→
    44→class AnalyzeResponse(BaseModel):
    45→    """Response for relationship analysis"""
    46→    success: bool
    47→    analysis: Optional[dict] = None
    48→    error: Optional[str] = None
    49→
    50→
    51→class CreateVibeLinkRequest(BaseModel):
    52→    """Request to create a Vibe Link"""
    53→    creator_id: str
    54→    creator_nickname: str
    55→    creator_profile: dict
    56→    disclosure_level: str = Field(default="minimal")
    57→    relationship_type: str = Field(default="general")
    58→
    59→
    60→class VibeLinkResponse(BaseModel):
    61→    """Response for Vibe Link operations"""
    62→    success: bool
    63→    session: Optional[dict] = None
    64→    invite_url: Optional[str] = None
    65→    error: Optional[str] = None
    66→
    67→
    68→class AcceptVibeLinkRequest(BaseModel):
    69→    """Request to accept a Vibe Link"""
    70→    acceptor_id: str
    71→    acceptor_nickname: str
    72→    acceptor_profile: dict
    73→    disclosure_level: str = Field(default="minimal")
    74→
    75→
    76→class GenerateCardRequest(BaseModel):
    77→    """Request to generate relationship card"""
    78→    analysis_id: str
    79→    analysis: dict
    80→    tier: str = Field(default="basic")
    81→    creator_nickname: str = ""
    82→    partner_nickname: str = ""
    83→    include_type_info: bool = False
    84→    type_info: Optional[dict] = None
    85→
    86→
    87→class CardResponse(BaseModel):
    88→    """Response for card generation"""
    89→    success: bool
    90→    card: Optional[dict] = None
    91→    error: Optional[str] = None
    92→
    93→
    94→# ═══════════════════════════════════════════════════════════════════════════
    95→# Routes
    96→# ═══════════════════════════════════════════════════════════════════════════
    97→
    98→@router.post("/analyze", response_model=AnalyzeResponse)
    99→async def analyze_relationship(request: AnalyzeRequest):
   100→    """
   101→    Analyze relationship between user and partner.
   102→
   103→    Single-user mode: User enters partner's info directly.
   104→    Partner info can be:
   105→    - Full profile (if known)
   106→    - Minimal: {"zodiac": "leo"} or {"chinese_zodiac": "tiger"}
   107→    """
   108→    try:
   109→        service = get_relationship_service()
   110→
   111→        # Check if minimal info mode
   112→        partner_profile = request.partner_info
   113→        if "basic" not in partner_profile:
   114→            # Minimal info - wrap it
   115→            partner_profile = {"basic": request.partner_info, "life_context": {}}
   116→
   117→        analysis = await service.analyze(
   118→            user1_id=UUID(request.user_id),
   119→            user1_profile=request.user_profile,
   120→            user2_profile=partner_profile,
   121→            relationship_type=request.relationship_type,
   122→        )
   123→
   124→        return AnalyzeResponse(
   125→            success=True,
   126→            analysis=analysis.to_dict(),
   127→        )
   128→
   129→    except Exception as e:
   130→        logger.error(f"Relationship analysis failed: {e}")
   131→        return AnalyzeResponse(
   132→            success=False,
   133→            error=str(e),
   134→        )
   135→
   136→
   137→@router.post("/vibe-link", response_model=VibeLinkResponse)
   138→async def create_vibe_link(request: CreateVibeLinkRequest):
   139→    """
   140→    Create a new Vibe Link for privacy-preserving relationship analysis.
   141→
   142→    Returns an invite URL that can be shared with the partner.
   143→    """
   144→    try:
   145→        service = get_vibe_link_service()
   146→
   147→        session = service.create_link(
   148→            creator_id=UUID(request.creator_id),
   149→            creator_nickname=request.creator_nickname,
   150→            creator_profile=request.creator_profile,
   151→            disclosure_level=request.disclosure_level,
   152→            relationship_type=request.relationship_type,
   153→        )
   154→
   155→        return VibeLinkResponse(
   156→            success=True,
   157→            session=session.to_dict(),
   158→            invite_url=session.get_invite_url(),
   159→        )
   160→
   161→    except Exception as e:
   162→        logger.error(f"Create Vibe Link failed: {e}")
   163→        return VibeLinkResponse(
   164→            success=False,
   165→            error=str(e),
   166→        )
   167→
   168→
   169→@router.get("/vibe-link/{code}", response_model=VibeLinkResponse)
   170→async def get_vibe_link(code: str):
   171→    """
   172→    Get Vibe Link information by code.
   173→
   174→    Use this to check link status and show invitation info.
   175→    """
   176→    try:
   177→        service = get_vibe_link_service()
   178→        session = service.get_session(code)
   179→
   180→        if not session:
   181→            return VibeLinkResponse(
   182→                success=False,
   183→                error="Link not found or expired",
   184→            )
   185→
   186→        return VibeLinkResponse(
   187→            success=True,
   188→            session=session.to_dict(),
   189→        )
   190→
   191→    except Exception as e:
   192→        logger.error(f"Get Vibe Link failed: {e}")
   193→        return VibeLinkResponse(
   194→            success=False,
   195→            error=str(e),
   196→        )
   197→
   198→
   199→@router.post("/vibe-link/{code}/accept", response_model=VibeLinkResponse)
   200→async def accept_vibe_link(code: str, request: AcceptVibeLinkRequest):
   201→    """
   202→    Accept a Vibe Link invitation.
   203→
   204→    The acceptor chooses their disclosure level.
   205→    """
   206→    try:
   207→        service = get_vibe_link_service()
   208→
   209→        session = service.accept_link(
   210→            code=code,
   211→            acceptor_id=UUID(request.acceptor_id),
   212→            acceptor_nickname=request.acceptor_nickname,
   213→            acceptor_profile=request.acceptor_profile,
   214→            disclosure_level=request.disclosure_level,
   215→        )
   216→
   217→        if not session:
   218→            return VibeLinkResponse(
   219→                success=False,
   220→                error="Cannot accept link. It may be expired, already accepted, or invalid.",
   221→            )
   222→
   223→        return VibeLinkResponse(
   224→            success=True,
   225→            session=session.to_dict(),
   226→        )
   227→
   228→    except Exception as e:
   229→        logger.error(f"Accept Vibe Link failed: {e}")
   230→        return VibeLinkResponse(
   231→            success=False,
   232→            error=str(e),
   233→        )
   234→
   235→
   236→@router.post("/vibe-link/{code}/complete", response_model=VibeLinkResponse)
   237→async def complete_vibe_link(
   238→    code: str,
   239→    creator_profile: dict = None,
   240→    acceptor_profile: dict = None,
   241→):
   242→    """
   243→    Complete the Vibe Link analysis after both users have joined.
   244→
   245→    This generates personalized advice for each user.
   246→    """
   247→    try:
   248→        service = get_vibe_link_service()
   249→
   250→        session = await service.complete_analysis(
   251→            code=code,
   252→            creator_profile=creator_profile or {},
   253→            acceptor_profile=acceptor_profile or {},
   254→        )
   255→
   256→        if not session:
   257→            return VibeLinkResponse(
   258→                success=False,
   259→                error="Cannot complete analysis. Session may not be ready.",
   260→            )
   261→
   262→        return VibeLinkResponse(
   263→            success=True,
   264→            session={
   265→                **session.to_dict(),
   266→                "creator_analysis": session.creator_analysis,
   267→                "acceptor_analysis": session.acceptor_analysis,
   268→            },
   269→        )
   270→
   271→    except Exception as e:
   272→        logger.error(f"Complete Vibe Link failed: {e}")
   273→        return VibeLinkResponse(
   274→            success=False,
   275→            error=str(e),
   276→        )
   277→
   278→
   279→@router.delete("/vibe-link/{code}")
   280→async def cancel_vibe_link(code: str, user_id: str = Query(...)):
   281→    """Cancel a pending Vibe Link (creator only)"""
   282→    try:
   283→        service = get_vibe_link_service()
   284→        success = service.cancel_link(code, UUID(user_id))
   285→
   286→        return {
   287→            "success": success,
   288→            "message": "Link cancelled" if success else "Cannot cancel link",
   289→        }
   290→
   291→    except Exception as e:
   292→        logger.error(f"Cancel Vibe Link failed: {e}")
   293→        return {"success": False, "error": str(e)}
   294→
   295→
   296→@router.post("/card", response_model=CardResponse)
   297→async def generate_card(request: GenerateCardRequest):
   298→    """
   299→    Generate a shareable relationship card.
   300→
   301→    Basic cards are free and contain limited info.
   302→    Premium cards include scores, type info, and AI image.
   303→    """
   304→    try:
   305→        generator = RelationshipCardGenerator()
   306→
   307→        card = await generator.generate(
   308→            analysis=request.analysis,
   309→            tier=request.tier,
   310→            creator_nickname=request.creator_nickname,
   311→            partner_nickname=request.partner_nickname,
   312→            include_type_info=request.include_type_info,
   313→            type_info=request.type_info,
   314→        )
   315→
   316→        return CardResponse(
   317→            success=True,
   318→            card=card.to_dict(),
   319→        )
   320→
   321→    except Exception as e:
   322→        logger.error(f"Generate card failed: {e}")
   323→        return CardResponse(
   324→            success=False,
   325→            error=str(e),
   326→        )
   327→
   328→
   329→@router.get("/card/{share_code}")
   330→async def get_shared_card(share_code: str):
   331→    """Get a shared relationship card by its share code"""
   332→    # TODO: Load from database
   333→    return {
   334→        "success": False,
   335→        "error": "Card not found. Cards are generated on-demand.",
   336→    }
   337→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
