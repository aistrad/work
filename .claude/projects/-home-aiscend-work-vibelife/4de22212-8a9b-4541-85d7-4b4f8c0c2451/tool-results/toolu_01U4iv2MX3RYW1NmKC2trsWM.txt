     1→"use client";
     2→
     3→import { useEffect, useState, useRef } from "react";
     4→import { Bell } from "lucide-react";
     5→import { motion, AnimatePresence } from "framer-motion";
     6→import { cn } from "@/lib/utils";
     7→import { getTokens } from "@/lib/api";
     8→
     9→interface Notification {
    10→  id: string;
    11→  type: string;
    12→  title: string;
    13→  content: string;
    14→  is_read: boolean;
    15→  created_at: string;
    16→}
    17→
    18→export function NotificationBell({ className }: { className?: string }) {
    19→  const [notifications, setNotifications] = useState<Notification[]>([]);
    20→  const [unreadCount, setUnreadCount] = useState(0);
    21→  const [isOpen, setIsOpen] = useState(false);
    22→  const containerRef = useRef<HTMLDivElement>(null);
    23→
    24→  useEffect(() => {
    25→    async function fetchNotifications() {
    26→      try {
    27→        const { accessToken } = getTokens();
    28→        if (!accessToken) return;
    29→
    30→        const res = await fetch("/api/notifications?limit=10", {
    31→          headers: { Authorization: `Bearer ${accessToken}` },
    32→        });
    33→        if (res.ok) {
    34→          const data = await res.json();
    35→          setNotifications(data.items || []);
    36→          setUnreadCount(data.unread_count || data.items?.filter((n: Notification) => !n.is_read).length || 0);
    37→        }
    38→      } catch (err) {
    39→        console.error("Failed to fetch notifications:", err);
    40→      }
    41→    }
    42→    fetchNotifications();
    43→  }, []);
    44→
    45→  useEffect(() => {
    46→    function handleClickOutside(e: MouseEvent) {
    47→      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
    48→        setIsOpen(false);
    49→      }
    50→    }
    51→    document.addEventListener("mousedown", handleClickOutside);
    52→    return () => document.removeEventListener("mousedown", handleClickOutside);
    53→  }, []);
    54→
    55→  const markAsRead = async (id: string) => {
    56→    try {
    57→      const { accessToken } = getTokens();
    58→      await fetch(`/api/notifications/${id}/read`, {
    59→        method: "POST",
    60→        headers: { Authorization: `Bearer ${accessToken}` },
    61→      });
    62→      setNotifications((prev) =>
    63→        prev.map((n) => (n.id === id ? { ...n, is_read: true } : n))
    64→      );
    65→      setUnreadCount((c) => Math.max(0, c - 1));
    66→    } catch (err) {
    67→      console.error("Failed to mark notification as read:", err);
    68→    }
    69→  };
    70→
    71→  return (
    72→    <div ref={containerRef} className={cn("relative", className)}>
    73→      <button
    74→        onClick={() => setIsOpen(!isOpen)}
    75→        className="relative p-2 rounded-full hover:bg-muted/50 transition-colors"
    76→      >
    77→        <Bell className="w-5 h-5 text-muted-foreground" />
    78→        {unreadCount > 0 && (
    79→          <span className="absolute -top-0.5 -right-0.5 w-4 h-4 bg-red-500 text-white text-[10px] font-medium rounded-full flex items-center justify-center">
    80→            {unreadCount > 9 ? "9+" : unreadCount}
    81→          </span>
    82→        )}
    83→      </button>
    84→
    85→      <AnimatePresence>
    86→        {isOpen && (
    87→          <motion.div
    88→            initial={{ opacity: 0, y: 8, scale: 0.95 }}
    89→            animate={{ opacity: 1, y: 0, scale: 1 }}
    90→            exit={{ opacity: 0, y: 8, scale: 0.95 }}
    91→            transition={{ duration: 0.15 }}
    92→            className="absolute right-0 top-full mt-2 w-80 max-h-96 overflow-y-auto bg-card border border-border rounded-xl shadow-lg z-50"
    93→          >
    94→            <div className="p-3 border-b border-border">
    95→              <h3 className="font-semibold text-foreground">通知</h3>
    96→            </div>
    97→
    98→            {notifications.length === 0 ? (
    99→              <div className="p-6 text-center text-muted-foreground text-sm">
   100→                暂无通知
   101→              </div>
   102→            ) : (
   103→              <div className="divide-y divide-border">
   104→                {notifications.map((n) => (
   105→                  <button
   106→                    key={n.id}
   107→                    onClick={() => !n.is_read && markAsRead(n.id)}
   108→                    className={cn(
   109→                      "w-full p-3 text-left hover:bg-muted/30 transition-colors",
   110→                      !n.is_read && "bg-muted/10"
   111→                    )}
   112→                  >
   113→                    <div className="flex items-start gap-2">
   114→                      {!n.is_read && (
   115→                        <span className="w-2 h-2 mt-1.5 rounded-full bg-skill-primary flex-shrink-0" />
   116→                      )}
   117→                      <div className="flex-1 min-w-0">
   118→                        <p className="font-medium text-sm text-foreground truncate">
   119→                          {n.title}
   120→                        </p>
   121→                        <p className="text-xs text-muted-foreground line-clamp-2 mt-0.5">
   122→                          {typeof n.content === "string" ? n.content : ""}
   123→                        </p>
   124→                      </div>
   125→                    </div>
   126→                  </button>
   127→                ))}
   128→              </div>
   129→            )}
   130→          </motion.div>
   131→        )}
   132→      </AnimatePresence>
   133→    </div>
   134→  );
   135→}
   136→
   137→export default NotificationBell;
   138→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
