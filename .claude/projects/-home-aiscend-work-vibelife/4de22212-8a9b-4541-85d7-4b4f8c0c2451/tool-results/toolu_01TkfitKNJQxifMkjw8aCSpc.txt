     1→"""
     2→TriggerDetector - 触发条件检测器
     3→
     4→支持三种触发类型:
     5→1. time_based - 基于时间 (cron 表达式)
     6→2. event_based - 基于事件 (节气、月相、生日、大运交接等)
     7→3. threshold_based - 基于阈值 (运势分数等)
     8→
     9→设计原则:
    10→- 从 unified_profiles 读取数据
    11→- 支持 Skill 级自定义事件
    12→- 智能化: 事件触发 + 阈值触发
    13→"""
    14→
    15→import logging
    16→from datetime import datetime, date, timedelta
    17→from typing import Dict, Any, Optional, Tuple, List
    18→
    19→import pytz
    20→
    21→from skills.zodiac.services.events import ZodiacEvents
    22→
    23→logger = logging.getLogger(__name__)
    24→
    25→
    26→class TriggerDetector:
    27→    """触发条件检测器"""
    28→
    29→    def __init__(self):
    30→        self._event_detectors = {
    31→            "birthday": self._detect_birthday,
    32→            "dayun_change": self._detect_dayun_change,
    33→            "new_year": self._detect_new_year,
    34→            "solar_term": self._detect_solar_term,
    35→            "lunar_phase": self._detect_lunar_phase,
    36→            "mercury_retrograde": self._detect_mercury_retrograde,
    37→            "significant_transit": self._detect_significant_transit,
    38→        }
    39→
    40→    async def should_trigger(
    41→        self,
    42→        trigger_config: Dict[str, Any],
    43→        profile: Dict[str, Any],
    44→        skill_id: str,
    45→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
    46→        """
    47→        检测是否应该触发
    48→
    49→        Returns:
    50→            (should_trigger, event_info)
    51→            - should_trigger: 是否触发
    52→            - event_info: 事件信息 (event_name, event_date 等)
    53→        """
    54→        trigger_type = trigger_config.get("type")
    55→
    56→        if trigger_type == "time_based":
    57→            return self._check_time_based(trigger_config, profile), None
    58→        elif trigger_type == "event_based":
    59→            return await self._check_event_based(trigger_config, profile, skill_id)
    60→        elif trigger_type == "threshold_based":
    61→            return await self._check_threshold_based(trigger_config, profile, skill_id)
    62→
    63→        return False, None
    64→
    65→    def _check_time_based(self, config: Dict, profile: Dict) -> bool:
    66→        """
    67→        检查时间触发条件
    68→
    69→        支持简化的 cron 格式: "0 4 * * *" (分 时 日 月 周)
    70→        """
    71→        schedule = config.get("schedule", "")
    72→        timezone_aware = config.get("timezone_aware", True)
    73→
    74→        if not schedule:
    75→            return False
    76→
    77→        # 获取用户时区
    78→        if timezone_aware:
    79→            user_tz = profile.get("preferences", {}).get("timezone", "Asia/Shanghai")
    80→            try:
    81→                now = datetime.now(pytz.timezone(user_tz))
    82→            except Exception:
    83→                now = datetime.now(pytz.timezone("Asia/Shanghai"))
    84→        else:
    85→            now = datetime.now(pytz.UTC)
    86→
    87→        # 解析 cron 表达式
    88→        return self._match_cron(schedule, now)
    89→
    90→    def _match_cron(self, schedule: str, now: datetime) -> bool:
    91→        """匹配简化的 cron 表达式"""
    92→        try:
    93→            parts = schedule.split()
    94→            if len(parts) != 5:
    95→                return False
    96→
    97→            minute, hour, day, month, weekday = parts
    98→
    99→            # 检查各字段
   100→            if minute != "*" and int(minute) != now.minute:
   101→                return False
   102→            if hour != "*" and int(hour) != now.hour:
   103→                return False
   104→            if day != "*" and int(day) != now.day:
   105→                return False
   106→            if month != "*" and int(month) != now.month:
   107→                return False
   108→            if weekday != "*" and int(weekday) != now.weekday():
   109→                return False
   110→
   111→            return True
   112→        except Exception as e:
   113→            logger.error(f"Failed to parse cron schedule '{schedule}': {e}")
   114→            return False
   115→
   116→    async def _check_event_based(
   117→        self,
   118→        config: Dict,
   119→        profile: Dict,
   120→        skill_id: str,
   121→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   122→        """检查事件触发条件"""
   123→        event = config.get("event")
   124→        advance_days = config.get("advance_days", [0])
   125→
   126→        # 确保 advance_days 是列表
   127→        if isinstance(advance_days, int):
   128→            advance_days = [advance_days]
   129→
   130→        detector = self._event_detectors.get(event)
   131→        if not detector:
   132→            logger.warning(f"Unknown event type: {event}")
   133→            return False, None
   134→
   135→        return await detector(profile, advance_days, skill_id)
   136→
   137→    async def _check_threshold_based(
   138→        self,
   139→        config: Dict,
   140→        profile: Dict,
   141→        skill_id: str,
   142→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   143→        """检查阈值触发条件"""
   144→        metric = config.get("metric")
   145→        condition = config.get("condition")
   146→        threshold = config.get("threshold")
   147→        cooldown = config.get("cooldown", 0)
   148→
   149→        # 获取指标值
   150→        value = await self._get_metric_value(metric, profile, skill_id)
   151→        if value is None:
   152→            return False, None
   153→
   154→        # TODO: 检查冷却期 (需要记录上次触发时间)
   155→
   156→        # 检查条件
   157→        triggered = False
   158→        if condition == "<":
   159→            triggered = value < threshold
   160→        elif condition == ">":
   161→            triggered = value > threshold
   162→        elif condition == "<=":
   163→            triggered = value <= threshold
   164→        elif condition == ">=":
   165→            triggered = value >= threshold
   166→        elif condition == "==":
   167→            triggered = value == threshold
   168→
   169→        if triggered:
   170→            return True, {"metric": metric, "value": value, "threshold": threshold}
   171→
   172→        return False, None
   173→
   174→    async def _get_metric_value(
   175→        self,
   176→        metric: str,
   177→        profile: Dict,
   178→        skill_id: str,
   179→    ) -> Optional[float]:
   180→        """获取指标值"""
   181→        if metric == "daily_fortune_score":
   182→            # 计算今日运势分数
   183→            from skills.bazi.services import BaziComputer
   184→            computer = BaziComputer()
   185→            return await computer.get_daily_fortune_score(profile)
   186→
   187→        # 可扩展其他指标
   188→        return None
   189→
   190→    # ═════════════════���═════════════════════════════════════════════════════════
   191→    # 事件检测器
   192→    # ═══════════════════════════════════════════════════════════════════════════
   193→
   194→    async def _detect_birthday(
   195→        self,
   196→        profile: Dict,
   197→        advance_days: List[int],
   198→        skill_id: str,
   199→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   200→        """检测生日"""
   201→        birth_info = profile.get("birth_info", {})
   202→        birth_date_str = birth_info.get("date")
   203→
   204→        if not birth_date_str:
   205→            return False, None
   206→
   207→        try:
   208→            birth = datetime.strptime(birth_date_str, "%Y-%m-%d").date()
   209→        except ValueError:
   210→            return False, None
   211→
   212→        today = date.today()
   213→        birthday_this_year = date(today.year, birth.month, birth.day)
   214→
   215→        # 如果今年生日已过，检查明年
   216→        if birthday_this_year < today:
   217→            birthday_this_year = date(today.year + 1, birth.month, birth.day)
   218→
   219→        days_until = (birthday_this_year - today).days
   220→
   221→        if days_until in advance_days:
   222→            event_name = "birthday" if days_until == 0 else f"birthday_{days_until}days"
   223→            return True, {
   224→                "event_name": event_name,
   225→                "event_date": birthday_this_year,
   226→                "days_until": days_until,
   227→            }
   228→
   229→        return False, None
   230→
   231→    async def _detect_dayun_change(
   232→        self,
   233→        profile: Dict,
   234→        advance_days: List[int],
   235→        skill_id: str,
   236→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   237→        """检测大运交接"""
   238→        from skills.bazi.services import BaziComputer
   239→
   240→        computer = BaziComputer()
   241→        inflection_points = await computer.get_inflection_points(profile)
   242→
   243→        today = date.today()
   244→
   245→        for point in inflection_points:
   246→            if point.get("type") == "major_cycle_change":
   247→                point_year = point.get("year")
   248→                if point_year:
   249→                    # 大运交接通常在年初
   250→                    point_date = date(point_year, 1, 1)
   251→                    days_until = (point_date - today).days
   252→
   253→                    if days_until in advance_days:
   254→                        return True, {
   255→                            "event_name": point.get("title", "大运交接"),
   256→                            "event_date": point_date,
   257→                            "days_until": days_until,
   258→                            "point": point,
   259→                        }
   260→
   261→        return False, None
   262→
   263→    async def _detect_new_year(
   264→        self,
   265→        profile: Dict,
   266→        advance_days: List[int],
   267→        skill_id: str,
   268→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   269→        """检测新年"""
   270→        today = date.today()
   271→        next_new_year = date(today.year + 1, 1, 1)
   272→
   273→        # 如果今天是元旦
   274→        if today.month == 1 and today.day == 1:
   275→            if 0 in advance_days:
   276→                return True, {
   277→                    "event_name": "new_year",
   278→                    "event_date": today,
   279→                    "days_until": 0,
   280→                }
   281→
   282→        days_until = (next_new_year - today).days
   283→
   284→        if days_until in advance_days:
   285→            return True, {
   286→                "event_name": "new_year",
   287→                "event_date": next_new_year,
   288→                "days_until": days_until,
   289→            }
   290→
   291→        return False, None
   292→
   293→    async def _detect_solar_term(
   294→        self,
   295→        profile: Dict,
   296→        advance_days: List[int],
   297→        skill_id: str,
   298→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   299→        """检测节气"""
   300→        # 使用 ZodiacEvents 获取节气信息
   301→        today = date.today()
   302→
   303→        try:
   304→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)
   305→
   306→            for event in events:
   307→                if event.event_type == "solar_term":
   308→                    days_until = (event.start_date - today).days
   309→                    if days_until in advance_days:
   310→                        return True, {
   311→                            "event_name": event.name,
   312→                            "event_date": event.start_date,
   313→                            "days_until": days_until,
   314→                            "description": event.description,
   315→                        }
   316→        except Exception as e:
   317→            logger.error(f"Failed to detect solar term: {e}")
   318→
   319→        return False, None
   320→
   321→    async def _detect_lunar_phase(
   322→        self,
   323→        profile: Dict,
   324→        advance_days: List[int],
   325→        skill_id: str,
   326→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   327→        """检测月相 (新月/满月)"""
   328→        today = date.today()
   329→
   330→        try:
   331→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)
   332→
   333→            for event in events:
   334→                if event.event_type in ("new_moon", "full_moon"):
   335→                    days_until = (event.start_date - today).days
   336→                    if days_until in advance_days:
   337→                        return True, {
   338→                            "event_name": event.name,
   339→                            "event_date": event.start_date,
   340→                            "days_until": days_until,
   341→                            "phase": event.event_type,
   342→                        }
   343→        except Exception as e:
   344→            logger.error(f"Failed to detect lunar phase: {e}")
   345→
   346→        return False, None
   347→
   348→    async def _detect_mercury_retrograde(
   349→        self,
   350→        profile: Dict,
   351→        advance_days: List[int],
   352→        skill_id: str,
   353→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   354→        """检测水逆"""
   355→        today = date.today()
   356→
   357→        try:
   358→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)
   359→
   360→            for event in events:
   361→                if event.event_type == "mercury_retrograde":
   362→                    days_until = (event.start_date - today).days
   363→                    if days_until in advance_days:
   364→                        return True, {
   365→                            "event_name": event.name,
   366→                            "event_date": event.start_date,
   367→                            "days_until": days_until,
   368→                            "end_date": event.end_date,
   369→                        }
   370→        except Exception as e:
   371→            logger.error(f"Failed to detect mercury retrograde: {e}")
   372→
   373→        return False, None
   374→
   375→    async def _detect_significant_transit(
   376→        self,
   377→        profile: Dict,
   378→        advance_days: List[int],
   379→        skill_id: str,
   380→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
   381→        """检测重要行星过境"""
   382→        today = date.today()
   383→
   384→        try:
   385→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)
   386→
   387→            significant_types = ("saturn_return", "jupiter_transit", "eclipse")
   388→
   389→            for event in events:
   390→                if event.event_type in significant_types:
   391→                    days_until = (event.start_date - today).days
   392→                    if days_until in advance_days:
   393→                        return True, {
   394→                            "event_name": event.name,
   395→                            "event_date": event.start_date,
   396→                            "days_until": days_until,
   397→                            "transit_type": event.event_type,
   398→                        }
   399→        except Exception as e:
   400→            logger.error(f"Failed to detect significant transit: {e}")
   401→
   402→        return False, None
   403→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
