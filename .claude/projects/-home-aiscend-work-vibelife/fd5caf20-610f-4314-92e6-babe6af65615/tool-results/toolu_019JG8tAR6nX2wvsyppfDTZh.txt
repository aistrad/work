     1→"""
     2→CoreAgent v8 - 分阶段渐进式加载的智能体
     3→
     4→v8 架构特性：
     5→- 分阶段上下文加载：Phase 1 (Skill 选择) / Phase 2 (Skill 执行)
     6→- use_skill 同轮重载：激活 skill 后同一轮内重新构建上下文
     7→- 历史消息从数据库获取（不依赖前端传入）
     8→- Case 倒排索引匹配
     9→- LLM 驱动的 SOP 执行
    10→
    11→v7 架构特性（保留）：
    12→- Scenario 路由：根据用户消息匹配最佳场景
    13→- PostgreSQL 知识检索：RAG + 案例匹配
    14→- 7 阶段 SOP：P1-P2 强制，P3-P7 LLM 自由发挥
    15→- 工具-卡片映射：标准化工具元数据
    16→"""
    17→import json
    18→import logging
    19→import time
    20→from typing import Optional, List, Dict, Any, AsyncGenerator
    21→from dataclasses import dataclass
    22→from enum import Enum
    23→
    24→from services.llm import LLMClient, get_llm_client
    25→from services.llm.client import LLMMessage
    26→from .case_index import get_case_index, extract_features, CaseIndex
    27→from .skill_loader import (
    28→    load_skill, get_skill_triggers,
    29→    build_system_prompt,
    30→    get_available_skills, get_skill_scenarios,
    31→    skill_requires_birth_info,
    32→    skill_requires_compute,
    33→    get_skill_compute_type,
    34→    get_skill_compute_tool,
    35→    get_skill_collect_tool,
    36→    load_rule, get_skill_rules,
    37→)
    38→from .tool_registry import ToolRegistry, ToolContext
    39→
    40→logger = logging.getLogger(__name__)
    41→
    42→
    43→class AgentState(str, Enum):
    44→    """Agent 执行状态"""
    45→    IDLE = "idle"
    46→    THINKING = "thinking"
    47→    TOOL_CALLING = "tool_calling"
    48→    COMPLETED = "completed"
    49→    ERROR = "error"
    50→
    51→
    52→@dataclass
    53→class AgentEvent:
    54→    """Agent 执行事件"""
    55→    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase
    56→    data: Any = None
    57→
    58→
    59→@dataclass
    60→class AgentContext:
    61→    """Agent 执行上下文
    62→
    63→    v8 更新：
    64→    - 删除 portrait 和 recent_insights（已废弃，数据从 profile.extracted 获取）
    65→    - history 从数据库获取，不再依赖前端传入
    66→    - profile 和 skill_data 分阶段加载
    67→    - 新增 protocol_prompt 支持协议模式
    68→    """
    69→    user_id: str
    70→    user_tier: str = "free"
    71→    profile: Optional[Dict[str, Any]] = None      # Phase 2 才加载
    72→    skill_data: Optional[Dict[str, Any]] = None   # Phase 2 才加载，只含当前 skill
    73→    history: Optional[List[Dict[str, str]]] = None  # 从数据库获取
    74→    skill: Optional[str] = None
    75→    scenario: Optional[str] = None
    76→    conversation_id: Optional[str] = None
    77→    voice_mode: Optional[str] = "warm"
    78→    protocol_prompt: Optional[str] = None  # 协议模式专用 prompt
    79→
    80→
    81→def build_use_skill_tool() -> Dict[str, Any]:
    82→    """
    83→    动态构建 use_skill 工具定义
    84→
    85→    从 SKILL.md 自动读取：
    86→    - 可用的 Skills 列表
    87→    - 每个 Skill 的语义描述（用于 LLM 理解）
    88→    - 每个 Skill 的场景列表
    89→
    90→    v7.3: 改为语义描述驱动，让 LLM 基于理解而非关键词匹配来选择 skill
    91→    """
    92→    available_skills = [s for s in get_available_skills() if s != "core"]
    93→
    94→    # 构建 Skill 路由说明（语义描述 + 触发词辅助）
    95→    skill_routing = "## Skill 路由（基于语义理解选择最匹配的 skill）\n\n"
    96→    for skill_id in available_skills:
    97→        skill = load_skill(skill_id)
    98→        if skill:
    99→            # 提取 description 中触发词之前的部分作为语义描述
   100→            desc = skill.description
   101→            if "触发词" in desc:
   102→                desc = desc.split("触发词")[0].strip().rstrip("。")
   103→            # 限制长度
   104→            if len(desc) > 100:
   105→                desc = desc[:100] + "..."
   106→            skill_routing += f"### {skill_id}\n{desc}\n"
   107→            # 触发词作为辅助提示
   108→            if skill.triggers:
   109→                trigger_str = "、".join(skill.triggers[:5])
   110→                skill_routing += f"常见关键词：{trigger_str}\n"
   111→            skill_routing += "\n"
   112→
   113→    # 构建场景目录（只列出主要场景，避免 description 过长）
   114→    scenario_catalog = "\n## 场景目录（常用）\n"
   115→    for skill_id in available_skills:
   116→        scenarios = get_skill_scenarios(skill_id)
   117→        if scenarios:
   118→            # 只列出前5个场景
   119→            top_scenarios = scenarios[:5]
   120→            scenario_catalog += f"\n### {skill_id}\n"
   121→            for s in top_scenarios:
   122→                scenario_catalog += f"- {s}\n"
   123→            if len(scenarios) > 5:
   124→                scenario_catalog += f"- ... (共 {len(scenarios)} 个场景)\n"
   125→
   126→    description = f"""激活专业技能来回答用户问题。一次决定 skill、scenario 和 confidence。
   127→
   128→{skill_routing}
   129→{scenario_catalog}
   130→
   131→## Confidence 说明
   132→- high: 用户意图明确，直接执行
   133→- medium: 基本确定，可能需要追问细节
   134→- low: 不确定，需要向用户确认
   135→
   136→重要：如果用户消息中已经包含了出生信息，设置 birth_info_provided=true。"""
   137→
   138→    return {
   139→        "type": "function",
   140→        "function": {
   141→            "name": "use_skill",
   142→            "description": description,
   143→            "parameters": {
   144→                "type": "object",
   145→                "properties": {
   146→                    "skill": {
   147→                        "type": "string",
   148→                        "enum": available_skills,
   149→                        "description": "要使用的技能"
   150→                    },

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
