     1→"""
     2→Chat Routes V5 - Unified chat endpoint with CoreAgent
     3→Based on: Claude Agent SDK style architecture
     4→
     5→Features:
     6→- Single /chat/stream endpoint
     7→- CoreAgent with LLM-based skill selection
     8→- Quota check at entry + usage recording
     9→- OpenAI compatible SSE format (works with AI SDK 4.x useChat)
    10→- 分阶段渐进式加载（Phase 1: Skill 选择, Phase 2: Skill 执行）
    11→- 历史消息从数据库获取（不依赖前端传入）
    12→
    13→v3.0 更新 (2026-01-20):
    14→- 移除 Protocol 状态管理（改为 LLM 自己管理）
    15→- 添加 scenario 参数支持
    16→- 简化 SSE 事件流
    17→
    18→v2.0 更新 (2026-01-20):
    19→- 删除前端传入 history 机制，改为数据库查询
    20→- 分阶段加载：Phase 1 不加载 profile，Phase 2 按需加载
    21→- use_skill 同轮重载上下文
    22→"""
    23→import json
    24→import logging
    25→import time
    26→from typing import Optional
    27→from uuid import UUID, uuid4
    28→
    29→from fastapi import APIRouter, Depends, Request
    30→from fastapi.responses import StreamingResponse
    31→from pydantic import BaseModel, Field
    32→from sse_starlette.sse import EventSourceResponse
    33→
    34→from services.identity import get_optional_user, CurrentUser
    35→from services.agent import CoreAgent, AgentContext, QuotaTracker, create_agent, get_adapter, AgentEvent
    36→from stores.profile_cache import get_cached_profile_with_skill
    37→from stores import message_repo, conversation_repo
    38→
    39→router = APIRouter(prefix="/chat/v5", tags=["Chat V5"])
    40→logger = logging.getLogger(__name__)
    41→
    42→
    43→# ═══════════════════════════════════════════════════════════════════════════
    44→# Request/Response Models
    45→# ═══════════════════════════════════════════════════════════════════════════
    46→
    47→class MessageItem(BaseModel):
    48→    """Single message in AI SDK format"""
    49→    role: str
    50→    content: str
    51→
    52→
    53→class ChatRequestV5(BaseModel):
    54→    """V5 Chat request - supports both simple and AI SDK format"""
    55→    message: Optional[str] = Field(None, description="User message (simple format)")
    56→    messages: Optional[list[MessageItem]] = Field(None, description="Messages array (AI SDK format, used for user message extraction only)")
    57→    conversation_id: Optional[UUID] = Field(None, description="Conversation ID")
    58→    skill: Optional[str] = Field(None, description="Skill ID (bazi/zodiac/career/tarot)")
    59→    scenario: Optional[str] = Field(None, description="Scenario/Rule ID (dankoe/covey/weekly-review)")
    60→    voice_mode: Optional[str] = Field(None, description="Voice mode (warm/sarcastic)")
    61→
    62→    def get_user_message(self) -> str:
    63→        """Extract user message from either format"""
    64→        if self.message:
    65→            return self.message
    66→        if self.messages:
    67→            # Get the last user message from the array
    68→            for msg in reversed(self.messages):
    69→                if msg.role == "user":
    70→                    return msg.content
    71→        return ""
    72→
    73→    # 注意：get_history() 已删除，历史消息从数据库获取
    74→
    75→
    76→class GuestChatRequestV5(BaseModel):
    77→    """Guest chat request - supports both simple and AI SDK format"""
    78→    message: Optional[str] = Field(None, description="User message (simple format)")
    79→    messages: Optional[list[MessageItem]] = Field(None, description="Messages array (AI SDK format)")
    80→
    81→    def get_user_message(self) -> str:
    82→        """Extract user message from either format"""
    83→        if self.message:
    84→            return self.message
    85→        if self.messages:
    86→            for msg in reversed(self.messages):
    87→                if msg.role == "user":
    88→                    return msg.content
    89→        return ""
    90→
    91→
    92→# ═══════════════════════════════════════════════════════════════════════════
    93→# Helper Functions
    94→# ═══════════════════════════════════════════════════════════════════════════
    95→
    96→async def get_user_context(user_id: Optional[UUID], skill: Optional[str] = None) -> tuple:
    97→    """
    98→    Get user profile and skill data (分阶段加载)
    99→
   100→    Phase 1 (skill=None): 不加载 profile，返回空
   101→    Phase 2 (skill 有值): 按需加载当前 skill 需要的数据
   102→    """
   103→    if not user_id:
   104→        return {}, {}
   105→
   106→    if not skill:
   107→        # Phase 1: Skill 选择阶段，不需要 profile
   108→        return {}, {}
   109→
   110→    try:
   111→        # Phase 2: 只加载当前 skill 需要的数据
   112→        result = await get_cached_profile_with_skill(user_id, skill)
   113→        return result.get("profile", {}), result.get("skill_data", {})
   114→    except Exception as e:
   115→        logger.error(f"Failed to get user context: {e}")
   116→        return {}, {}
   117→
   118→
   119→async def get_conversation_history(conversation_id: Optional[UUID], skill: Optional[str] = None) -> list:
   120→    """
   121→    Get recent conversation history from database (分阶段加载)
   122→
   123→    Phase 1 (skill=None): 5 条历史，足够理解意图
   124→    Phase 2 (skill 有值): 10 条历史，深度分析需要更多上下文
   125→    """
   126→    if not conversation_id:
   127→        return []
   128→
   129→    # 根据阶段决定历史条数
   130→    limit = 5 if not skill else 10
   131→
   132→    try:
   133→        messages = await message_repo.get_messages_for_context(conversation_id, limit)
   134→        return messages
   135→    except Exception as e:
   136→        logger.error(f"Failed to get history: {e}")
   137→        return []
   138→
   139→
   140→async def ensure_conversation_exists(
   141→    conversation_id: UUID,
   142→    user_id: Optional[UUID],
   143→    skill: Optional[str] = None,
   144→    voice_mode: Optional[str] = None
   145→) -> None:
   146→    """Ensure conversation exists in database, create if not"""
   147→    try:
   148→        existing = await conversation_repo.get_conversation(conversation_id)
   149→        if not existing:
   150→            await conversation_repo.create_conversation(

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
