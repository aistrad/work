     1→"""
     2→Zodiac Skill API Services - 星座对外 API 服务
     3→
     4→使用 @skill_service 装饰器自动注册到 SkillServiceRegistry
     5→通过 /api/v1/skills/zodiac/{action} 访问
     6→
     7→端点:
     8→- chart: 星盘计算
     9→- transit: 行运分析
    10→- daily: 每日运势
    11→- events: 星象事件
    12→- synastry: 星座配对
    13→"""
    14→import asyncio
    15→import logging
    16→from typing import Dict, Any, Optional
    17→from datetime import date
    18→
    19→from services.agent.skill_service_registry import skill_service, ServiceContext
    20→from stores.unified_profile_repo import UnifiedProfileRepository
    21→from stores.profile_cache import invalidate_skill_cache
    22→
    23→from .calculator import ZodiacCalculator, calculate_zodiac, calculate_transit
    24→from .computer import ZodiacComputer
    25→
    26→logger = logging.getLogger(__name__)
    27→
    28→# Singleton instances
    29→_calculator: Optional[ZodiacCalculator] = None
    30→_computer: Optional[ZodiacComputer] = None
    31→
    32→
    33→def get_calculator() -> ZodiacCalculator:
    34→    global _calculator
    35→    if _calculator is None:
    36→        _calculator = ZodiacCalculator()
    37→    return _calculator
    38→
    39→
    40→def get_computer() -> ZodiacComputer:
    41→    global _computer
    42→    if _computer is None:
    43→        _computer = ZodiacComputer()
    44→    return _computer
    45→
    46→
    47→# ═══════════════════════════════════════════════════════════════════════════
    48→# Chart Service
    49→# ═══════════════════════════════════════════════════════════════════════════
    50→
    51→@skill_service("zodiac", "chart", description="计算星盘", auth_required=False)
    52→async def get_zodiac_chart(args: Dict[str, Any], context: ServiceContext) -> Dict[str, Any]:
    53→    """
    54→    计算星盘 (本命盘)
    55→
    56→    Args:
    57→        birth_date: 出生日期 (YYYY-MM-DD)
    58→        birth_time: 出生时间 (HH:MM)，默认 12:00
    59→        birth_place: 出生地点，默认 Shanghai
    60→        save: 是否保存到用户档案，默认 True
    61→
    62→    Returns:
    63→        chart: 完整星盘数据
    64→    """
    65→    birth_date = args.get("birth_date")
    66→    birth_time = args.get("birth_time", "12:00")
    67→    birth_place = args.get("birth_place", "Shanghai")
    68→    save = args.get("save", True)
    69→
    70→    # 尝试从 context 获取出生信息
    71→    if not birth_date and context.profile:
    72→        identity = context.profile.get("identity", {})
    73→        birth_info = identity.get("birth_info", {})
    74→        birth_date = birth_info.get("date")
    75→        birth_time = birth_info.get("time", birth_time)
    76→        birth_place = birth_info.get("place", birth_place)
    77→
    78→    if not birth_date:
    79→        return {"error": "birth_date is required", "status": "error"}
    80→
    81→    try:
    82→        # 检查缓存
    83→        if context.user_id and save:
    84→            existing = context.skill_data.get("zodiac", {})
    85→            if existing.get("chart"):
    86→                logger.info(f"Using cached zodiac chart for user {context.user_id}")
    87→                return {"status": "success", "chart": existing["chart"], "cached": True}
    88→
    89→        # 计算星盘
    90→        chart = calculate_zodiac(
    91→            birth_date=birth_date,
    92→            birth_time=birth_time,
    93→            birth_place=birth_place,
    94→        )
    95→
    96→        # 保存到用户档案
    97→        if context.user_id and save:
    98→            from uuid import UUID
    99→            user_uuid = UUID(context.user_id) if isinstance(context.user_id, str) else context.user_id
   100→            await UnifiedProfileRepository.update_skill_data(
   101→                user_uuid, "zodiac", {"chart": chart}
   102→            )
   103→            # 失效缓存
   104→            asyncio.create_task(invalidate_skill_cache(user_uuid, "zodiac"))
   105→
   106→        return {"status": "success", "chart": chart}
   107→
   108→    except Exception as e:
   109→        logger.error(f"Zodiac chart calculation failed: {e}")
   110→        return {"error": str(e), "status": "error"}
   111→
   112→
   113→# ═══════════════════════════════════════════════════════════════════════════
   114→# Transit Service
   115→# ═══════════════════════════════════════════════════════════════════════════
   116→
   117→@skill_service("zodiac", "transit", description="行运分析", auth_required=True)
   118→async def get_zodiac_transit(args: Dict[str, Any], context: ServiceContext) -> Dict[str, Any]:
   119→    """
   120→    计算行运分析
   121→
   122→    Args:
   123→        transit_date: 行运日期 (YYYY-MM-DD)，默认今天
   124→
   125→    Returns:
   126→        transits: 行运数据列表
   127→    """
   128→    transit_date = args.get("transit_date", str(date.today()))
   129→
   130→    # 获取星盘数据
   131→    zodiac_data = context.skill_data.get("zodiac", {})
   132→    if not zodiac_data.get("chart"):
   133→        return {"error": "No zodiac chart found, please calculate chart first", "status": "error"}
   134→
   135→    try:
   136→        chart = zodiac_data["chart"]
   137→        birth_date = chart.get("birth_date", "")
   138→        birth_time = chart.get("birth_time", "12:00")
   139→        birth_place = chart.get("birth_place", "Shanghai")
   140→
   141→        transits = calculate_transit(
   142→            birth_date=birth_date,
   143→            birth_time=birth_time,
   144→            birth_place=birth_place,
   145→            transit_date=transit_date,
   146→        )
   147→
   148→        return {
   149→            "status": "success",
   150→            "transit_date": transit_date,
   151→            "transits": transits,
   152→        }
   153→
   154→    except Exception as e:
   155→        logger.error(f"Zodiac transit calculation failed: {e}")
   156→        return {"error": str(e), "status": "error"}
   157→
   158→
   159→# ═══════════════════════════════════════════════════════════════════════════
   160→# Daily Horoscope Service
   161→# ═══════════════════════════════════════════════════════════════════════════
   162→
   163→@skill_service("zodiac", "daily", description="每日星座运势", auth_required=True)
   164→async def get_zodiac_daily(args: Dict[str, Any], context: ServiceContext) -> Dict[str, Any]:
   165→    """
   166→    获取每日星座运势
   167→
   168→    Args:
   169→        date: 日期 (YYYY-MM-DD)，默认今天
   170→
   171→    Returns:
   172→        daily: 每日运势数据
   173→    """
   174→    target_date = args.get("date", str(date.today()))
   175→
   176→    # 获取星盘数据
   177→    zodiac_data = context.skill_data.get("zodiac", {})
   178→    if not zodiac_data.get("chart"):
   179→        return {"error": "No zodiac chart found, please calculate chart first", "status": "error"}
   180→
   181→    try:
   182→        computer = get_computer()
   183→        profile = {
   184→            "skill_data": {"zodiac": zodiac_data}
   185→        }
   186→        daily = await computer.calculate_daily_horoscope(profile)
   187→
   188→        return {
   189→            "status": "success",
   190→            "date": target_date,
   191→            "daily": daily,
   192→        }
   193→
   194→    except Exception as e:
   195→        logger.error(f"Zodiac daily horoscope failed: {e}")
   196→        return {"error": str(e), "status": "error"}
   197→
   198→
   199→# ═══════════════════════════════════════════════════════════════════════════
   200→# Events Service
   201→# ═══════════════════════════════════════════════════════════════════════════
   202→
   203→@skill_service("zodiac", "events", description="星象事件", auth_required=False)
   204→async def get_zodiac_events(args: Dict[str, Any], context: ServiceContext) -> Dict[str, Any]:
   205→    """
   206→    获取即将到来的星象事件
   207→
   208→    Args:
   209→        days: 查询天数，默认 7
   210→
   211→    Returns:
   212→        events: 星象事件列表
   213→    """
   214→    days = args.get("days", 7)
   215→
   216→    try:
   217→        computer = get_computer()
   218→        events = await computer.get_upcoming_events(days=days)
   219→
   220→        return {
   221→            "status": "success",
   222→            "days": days,
   223→            "events": events,
   224→        }
   225→
   226→    except Exception as e:
   227→        logger.error(f"Zodiac events query failed: {e}")
   228→        return {"error": str(e), "status": "error"}
   229→
   230→
   231→# ═══════════════════════════════════════════════════════════════════════════
   232→# Synastry Service
   233→# ═══════════════════════════════════════════════════════════════════════════
   234→
   235→@skill_service("zodiac", "synastry", description="星座配对", auth_required=False)
   236→async def get_zodiac_synastry(args: Dict[str, Any], context: ServiceContext) -> Dict[str, Any]:
   237→    """
   238→    计算星座配对 (合盘)
   239→
   240→    Args:
   241→        person1: 第一人信息 {birth_date, birth_time, birth_place}
   242→        person2: 第二人信息 {birth_date, birth_time, birth_place}
   243→
   244→    Returns:
   245→        compatibility: 配对结果
   246→    """
   247→    person1 = args.get("person1", {})
   248→    person2 = args.get("person2", {})
   249→
   250→    if not person1.get("birth_date") or not person2.get("birth_date"):
   251→        return {"error": "Both person1 and person2 birth_date are required", "status": "error"}
   252→
   253→    try:
   254→        calculator = get_calculator()
   255→
   256→        # 计算两人星盘
   257→        chart1 = calculator.calculate(
   258→            birth_date=person1["birth_date"],
   259→            birth_time=person1.get("birth_time", "12:00"),
   260→            birth_place=person1.get("birth_place", "Shanghai"),
   261→        )
   262→
   263→        chart2 = calculator.calculate(
   264→            birth_date=person2["birth_date"],
   265→            birth_time=person2.get("birth_time", "12:00"),
   266→            birth_place=person2.get("birth_place", "Shanghai"),
   267→        )
   268→
   269→        # 计算配对
   270→        compatibility = _calculate_compatibility(chart1, chart2)
   271→
   272→        return {
   273→            "status": "success",
   274→            "compatibility": compatibility,
   275→        }
   276→
   277→    except Exception as e:
   278→        logger.error(f"Zodiac synastry calculation failed: {e}")
   279→        return {"error": str(e), "status": "error"}
   280→
   281→
   282→def _calculate_compatibility(chart1, chart2) -> dict:
   283→    """
   284→    计算两人星盘配对
   285→
   286→    Returns format expected by frontend show_synastry.tsx:
   287→    - person1/person2: { name, sunSign }
   288→    - overallScore: number
   289→    - categories: [{name, score, description}]
   290→    - strengths: string[]
   291→    - challenges: string[]
   292→    - advice: string
   293→    """
   294→    from .calculator import SIGN_ELEMENT, SIGN_CHINESE
   295→
   296→    # Element compatibility matrix
   297→    element_compat = {
   298→        ("fire", "fire"): 80,
   299→        ("fire", "air"): 85,
   300→        ("fire", "earth"): 50,
   301→        ("fire", "water"): 45,
   302→        ("earth", "earth"): 75,
   303→        ("earth", "water"): 80,
   304→        ("earth", "air"): 55,
   305→        ("air", "air"): 70,
   306→        ("air", "water"): 60,
   307→        ("water", "water"): 75,
   308→    }
   309→
   310→    # Get elements
   311→    elem1 = SIGN_ELEMENT.get(chart1.sun_sign, "fire").value
   312→    elem2 = SIGN_ELEMENT.get(chart2.sun_sign, "fire").value
   313→
   314→    # Look up compatibility (order doesn't matter)
   315→    key = (elem1, elem2) if (elem1, elem2) in element_compat else (elem2, elem1)
   316→    sun_score = element_compat.get(key, 65)
   317→
   318→    # Moon compatibility
   319→    moon_elem1 = SIGN_ELEMENT.get(chart1.moon_sign, "water").value
   320→    moon_elem2 = SIGN_ELEMENT.get(chart2.moon_sign, "water").value
   321→    moon_key = (moon_elem1, moon_elem2) if (moon_elem1, moon_elem2) in element_compat else (moon_elem2, moon_elem1)
   322→    moon_score = element_compat.get(moon_key, 65)
   323→
   324→    # Communication score
   325→    comm_score = 70 + (sun_score - 65) // 2
   326→
   327→    # Emotional connection
   328→    emotional_score = moon_score
   329→    if chart1.sun_sign == chart2.moon_sign or chart2.sun_sign == chart1.moon_sign:
   330→        emotional_score = min(100, emotional_score + 15)
   331→
   332→    # Calculate overall score
   333→    overall_score = round((sun_score * 0.3 + moon_score * 0.3 + comm_score * 0.2 + emotional_score * 0.2))
   334→
   335→    # Get Chinese sign names
   336→    sun1_cn = SIGN_CHINESE.get(chart1.sun_sign, chart1.sun_sign)
   337→    sun2_cn = SIGN_CHINESE.get(chart2.sun_sign, chart2.sun_sign)
   338→    moon1_cn = SIGN_CHINESE.get(chart1.moon_sign, chart1.moon_sign)
   339→    moon2_cn = SIGN_CHINESE.get(chart2.moon_sign, chart2.moon_sign)
   340→
   341→    # Element names in Chinese
   342→    elem_cn = {"fire": "火", "earth": "土", "air": "风", "water": "水"}
   343→
   344→    # Generate strengths
   345→    strengths = []
   346→    if sun_score >= 75:
   347→        strengths.append("太阳星座相合，性格自然吸引")
   348→    if moon_score >= 75:
   349→        strengths.append("月亮星座协调，情感共鸣强")
   350→    if emotional_score >= 80:
   351→        strengths.append("日月交互相位，深层默契")
   352→    if elem1 == elem2:
   353→        strengths.append(f"同为{elem_cn.get(elem1, elem1)}象星座，价值观一致")
   354→    if not strengths:
   355→        strengths.append("互补性强，可以相互学习成长")
   356→
   357→    # Generate challenges
   358→    challenges = []
   359→    if sun_score < 60:
   360→        challenges.append("性格差异需要更多理解和包容")
   361→    if moon_score < 60:
   362→        challenges.append("情感表达方式不同，需要耐心沟通")
   363→    if elem1 != elem2:
   364→        e1_cn = elem_cn.get(elem1, elem1)
   365→        e2_cn = elem_cn.get(elem2, elem2)
   366→        challenges.append(f"{e1_cn}象与{e2_cn}象的处事方式有差异")
   367→    if not challenges:
   368→        challenges.append("保持开放心态，避免过度依赖")
   369→
   370→    # Generate advice
   371→    if overall_score >= 80:
   372→        advice = "你们天生默契，珍惜��份缘分。保持真诚沟通，让关系持续升温。"
   373→    elif overall_score >= 65:
   374→        advice = "你们有很好的基础，多关注彼此的情感需求，用行动表达爱意。"
   375→    elif overall_score >= 50:
   376→        advice = "差异是成长的契机。学习对方的优点，用包容化解分歧。"
   377→    else:
   378→        advice = "关系需要更多努力经营。专注于共同目标，建立相互理解的桥梁。"
   379→
   380→    return {
   381→        "person1": {"name": "你", "sunSign": sun1_cn},
   382→        "person2": {"name": "TA", "sunSign": sun2_cn},
   383→        "overallScore": overall_score,
   384→        "categories": [
   385→            {"name": "性格契合", "score": sun_score, "description": f"{sun1_cn}与{sun2_cn}的能量互动"},
   386→            {"name": "情感连接", "score": emotional_score, "description": f"{moon1_cn}与{moon2_cn}的情感共鸣"},
   387→            {"name": "沟通默契", "score": comm_score, "description": "思维方式与表达习惯的匹配度"},
   388→            {"name": "长期稳定", "score": round((sun_score + moon_score) / 2), "description": "关系的持久性与成长潜力"}
   389→        ],
   390→        "strengths": strengths[:3],
   391→        "challenges": challenges[:3],
   392→        "advice": advice,
   393→    }
   394→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
