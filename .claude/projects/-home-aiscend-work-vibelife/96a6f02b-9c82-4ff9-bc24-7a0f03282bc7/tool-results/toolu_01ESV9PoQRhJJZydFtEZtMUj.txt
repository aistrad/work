     1→"""
     2→Skill Repository - Data access layer for skills
     3→"""
     4→from datetime import datetime
     5→from typing import Optional, List, Dict, Any
     6→from uuid import UUID
     7→
     8→from .db import get_connection
     9→
    10→
    11→class SkillRepository:
    12→    """Repository for skill operations"""
    13→
    14→    # ─────────────────────────────────────────────────────────────────
    15→    # Skill Profile
    16→    # ─────────────────────────────────────────────────────────────────
    17→
    18→    @staticmethod
    19→    async def get_or_create_profile(
    20→        user_id: UUID,
    21→        skill_id: str,
    22→        profile_data: Optional[Dict[str, Any]] = None
    23→    ) -> dict:
    24→        """Get or create skill profile for user"""
    25→        async with get_connection() as conn:
    26→            # Try to get existing
    27→            row = await conn.fetchrow(
    28→                """
    29→                SELECT * FROM skill_profiles
    30→                WHERE user_id = $1 AND skill_id = $2
    31→                """,
    32→                user_id, skill_id
    33→            )
    34→
    35→            if row:
    36→                return dict(row)
    37→
    38→            # Create new
    39→            row = await conn.fetchrow(
    40→                """
    41→                INSERT INTO skill_profiles (user_id, skill_id, profile_data)
    42→                VALUES ($1, $2, $3)
    43→                RETURNING *
    44→                """,
    45→                user_id, skill_id, profile_data or {}
    46→            )
    47→            return dict(row)
    48→
    49→    @staticmethod
    50→    async def update_profile(
    51→        user_id: UUID,
    52→        skill_id: str,
    53→        profile_data: Dict[str, Any]
    54→    ) -> Optional[dict]:
    55→        """Update skill profile data"""
    56→        async with get_connection() as conn:
    57→            row = await conn.fetchrow(
    58→                """
    59→                UPDATE skill_profiles
    60→                SET profile_data = profile_data || $3::jsonb,
    61→                    last_use_at = NOW()
    62→                WHERE user_id = $1 AND skill_id = $2
    63→                RETURNING *
    64→                """,
    65→                user_id, skill_id, profile_data
    66→            )
    67→            return dict(row) if row else None
    68→
    69→    @staticmethod
    70→    async def get_user_profiles(user_id: UUID) -> List[dict]:
    71→        """Get all skill profiles for user"""
    72→        async with get_connection() as conn:
    73→            rows = await conn.fetch(
    74→                "SELECT * FROM skill_profiles WHERE user_id = $1",
    75→                user_id
    76→            )
    77→            return [dict(row) for row in rows]
    78→
    79→    # ─────────────────────────────────────────────────────────────────
    80→    # Conversations
    81→    # ─────────────────────────────────────────────────────────────────
    82→
    83→    @staticmethod
    84→    async def create_conversation(
    85→        user_id: UUID,
    86→        skill_id: str,
    87→        entry_point: Optional[str] = None,
    88→        referrer: Optional[str] = None
    89→    ) -> dict:
    90→        """Create a new conversation"""
    91→        async with get_connection() as conn:
    92→            # Create conversation
    93→            row = await conn.fetchrow(
    94→                """
    95→                INSERT INTO skill_conversations (
    96→                    user_id, skill_id, entry_point, referrer
    97→                )
    98→                VALUES ($1, $2, $3, $4)
    99→                RETURNING *
   100→                """,
   101→                user_id, skill_id, entry_point, referrer
   102→            )
   103→
   104→            # Update profile session count
   105→            await conn.execute(
   106→                """
   107→                UPDATE skill_profiles
   108→                SET total_sessions = total_sessions + 1, last_use_at = NOW()
   109→                WHERE user_id = $1 AND skill_id = $2
   110→                """,
   111→                user_id, skill_id
   112→            )
   113→
   114→            return dict(row)
   115→
   116→    @staticmethod
   117→    async def get_conversation(conversation_id: UUID) -> Optional[dict]:
   118→        """Get conversation by ID"""
   119→        async with get_connection() as conn:
   120→            row = await conn.fetchrow(
   121→                "SELECT * FROM skill_conversations WHERE id = $1",
   122→                conversation_id
   123→            )
   124→            return dict(row) if row else None
   125→
   126→    @staticmethod
   127→    async def get_user_conversations(
   128→        user_id: UUID,
   129→        skill_id: Optional[str] = None,
   130→        limit: int = 20
   131→    ) -> List[dict]:
   132→        """Get user's conversations"""
   133→        async with get_connection() as conn:
   134→            if skill_id:
   135→                rows = await conn.fetch(
   136→                    """
   137→                    SELECT * FROM skill_conversations
   138→                    WHERE user_id = $1 AND skill_id = $2
   139→                    ORDER BY started_at DESC
   140→                    LIMIT $3
   141→                    """,
   142→                    user_id, skill_id, limit
   143→                )
   144→            else:
   145→                rows = await conn.fetch(
   146→                    """
   147→                    SELECT * FROM skill_conversations
   148→                    WHERE user_id = $1
   149→                    ORDER BY started_at DESC
   150→                    LIMIT $2
   151→                    """,
   152→                    user_id, limit
   153→                )
   154→            return [dict(row) for row in rows]
   155→
   156→    @staticmethod
   157→    async def end_conversation(conversation_id: UUID) -> Optional[dict]:
   158→        """End a conversation"""
   159→        async with get_connection() as conn:
   160→            row = await conn.fetchrow(
   161→                """
   162→                UPDATE skill_conversations
   163→                SET ended_at = NOW(), status = 'ended'
   164→                WHERE id = $1
   165→                RETURNING *
   166→                """,
   167→                conversation_id
   168→            )
   169→            return dict(row) if row else None
   170→
   171→    # ─────────────────────────────────────────────────────────────────
   172→    # Messages
   173→    # ─────────────────────────────────────────────────────────────────
   174→
   175→    @staticmethod
   176→    async def add_message(
   177→        conversation_id: UUID,
   178→        role: str,
   179→        content: str,
   180→        intent: Optional[str] = None,
   181→        tools_used: Optional[List[str]] = None,
   182→        knowledge_used: Optional[List[str]] = None
   183→    ) -> dict:
   184→        """Add message to conversation"""
   185→        async with get_connection() as conn:
   186→            # Insert message
   187→            row = await conn.fetchrow(
   188→                """
   189→                INSERT INTO skill_messages (
   190→                    conversation_id, role, content, intent,
   191→                    tools_used, knowledge_used
   192→                )
   193→                VALUES ($1, $2, $3, $4, $5, $6)
   194→                RETURNING *
   195→                """,
   196→                conversation_id, role, content, intent,
   197→                tools_used, knowledge_used
   198→            )
   199→
   200→            # Update conversation message count
   201→            await conn.execute(
   202→                """
   203→                UPDATE skill_conversations
   204→                SET message_count = message_count + 1
   205→                WHERE id = $1
   206→                """,
   207→                conversation_id
   208→            )
   209→
   210→            return dict(row)
   211→
   212→    @staticmethod
   213→    async def get_messages(
   214→        conversation_id: UUID,
   215→        limit: int = 50
   216→    ) -> List[dict]:
   217→        """Get messages in conversation"""
   218→        async with get_connection() as conn:
   219→            rows = await conn.fetch(
   220→                """
   221→                SELECT * FROM skill_messages
   222→                WHERE conversation_id = $1
   223→                ORDER BY created_at ASC
   224→                LIMIT $2
   225→                """,
   226→                conversation_id, limit
   227→            )
   228→            return [dict(row) for row in rows]
   229→
   230→    @staticmethod
   231→    async def get_recent_messages(
   232→        user_id: UUID,
   233→        skill_id: str,
   234→        limit: int = 10
   235→    ) -> List[dict]:
   236→        """Get recent messages for user in skill"""
   237→        async with get_connection() as conn:
   238→            rows = await conn.fetch(
   239→                """
   240→                SELECT m.* FROM skill_messages m
   241→                JOIN skill_conversations c ON m.conversation_id = c.id
   242→                WHERE c.user_id = $1 AND c.skill_id = $2
   243→                ORDER BY m.created_at DESC
   244→                LIMIT $3
   245→                """,
   246→                user_id, skill_id, limit
   247→            )
   248→            return [dict(row) for row in reversed(rows)]
   249→
   250→    # ─────────────────────────────────────────────────────────────────
   251→    # Insights
   252→    # ─────────────────────────────────────────────────────────────────
   253→
   254→    @staticmethod
   255→    async def create_insight(
   256→        user_id: UUID,
   257→        skill_id: str,
   258→        insight_type: str,
   259→        content: str,
   260→        title: Optional[str] = None,
   261→        evidence: Optional[Dict[str, Any]] = None,
   262→        confidence: Optional[float] = None,
   263→        conversation_id: Optional[UUID] = None
   264→    ) -> dict:
   265→        """Create an insight"""
   266→        async with get_connection() as conn:
   267→            row = await conn.fetchrow(
   268→                """
   269→                INSERT INTO skill_insights (
   270→                    user_id, skill_id, conversation_id, insight_type,
   271→                    title, content, evidence, confidence
   272→                )
   273→                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
   274→                RETURNING *
   275→                """,
   276→                user_id, skill_id, conversation_id, insight_type,
   277→                title, content, evidence, confidence
   278→            )
   279→            return dict(row)
   280→
   281→    @staticmethod
   282→    async def get_user_insights(
   283→        user_id: UUID,
   284→        skill_id: Optional[str] = None,
   285→        insight_type: Optional[str] = None,
   286→        limit: int = 20
   287→    ) -> List[dict]:
   288→        """Get user's insights"""
   289→        async with get_connection() as conn:
   290→            conditions = ["user_id = $1"]
   291→            params = [user_id]
   292→            idx = 2
   293→
   294→            if skill_id:
   295→                conditions.append(f"skill_id = ${idx}")
   296→                params.append(skill_id)
   297→                idx += 1
   298→
   299→            if insight_type:
   300→                conditions.append(f"insight_type = ${idx}")
   301→                params.append(insight_type)
   302→                idx += 1
   303→
   304→            params.append(limit)
   305→
   306→            query = f"""
   307→                SELECT * FROM skill_insights
   308→                WHERE {' AND '.join(conditions)}
   309→                ORDER BY created_at DESC
   310→                LIMIT ${idx}
   311→            """
   312→
   313→            rows = await conn.fetch(query, *params)
   314→            return [dict(row) for row in rows]
   315→
   316→    @staticmethod
   317→    async def update_insight_reaction(
   318→        insight_id: UUID,
   319→        user_reaction: str
   320→    ) -> Optional[dict]:
   321→        """Update user reaction to insight"""
   322→        async with get_connection() as conn:
   323→            row = await conn.fetchrow(
   324→                """
   325→                UPDATE skill_insights
   326→                SET user_reaction = $2
   327→                WHERE id = $1
   328→                RETURNING *
   329→                """,
   330→                insight_id, user_reaction
   331→            )
   332→            return dict(row) if row else None
   333→
   334→    @staticmethod
   335→    async def link_insight_to_message(
   336→        message_id: UUID,
   337→        insight_id: UUID
   338→    ) -> bool:
   339→        """Link insight to message"""
   340→        async with get_connection() as conn:
   341→            result = await conn.execute(
   342→                """
   343→                UPDATE skill_messages
   344→                SET insight_generated = true, insight_id = $2
   345→                WHERE id = $1
   346→                """,
   347→                message_id, insight_id
   348→            )
   349→            return "UPDATE 1" in result
   350→
   351→    # ─────────────────────────────────────────────────────────────────
   352→    # Insights with Embedding (Cold Memory)
   353→    # ─────────────────────────────────────────────────────────────────
   354→
   355→    @staticmethod
   356→    async def create_insight_with_embedding(
   357→        user_id: UUID,
   358→        skill_id: str,
   359→        insight_type: str,
   360→        content: str,
   361→        title: Optional[str] = None,
   362→        evidence: Optional[Dict[str, Any]] = None,
   363→        confidence: Optional[float] = None,
   364→        conversation_id: Optional[UUID] = None,
   365→        embedding: Optional[List[float]] = None
   366→    ) -> dict:
   367→        """Create an insight with optional embedding for vector search"""
   368→        async with get_connection() as conn:
   369→            if embedding:
   370→                # Convert list to vector string format for pgvector
   371→                embedding_str = "[" + ",".join(map(str, embedding)) + "]"
   372→                row = await conn.fetchrow(
   373→                    """
   374→                    INSERT INTO skill_insights (
   375→                        user_id, skill_id, conversation_id, insight_type,
   376→                        title, content, evidence, confidence, embedding
   377→                    )
   378→                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9::vector)
   379→                    RETURNING *
   380→                    """,
   381→                    user_id, skill_id, conversation_id, insight_type,
   382→                    title, content, evidence, confidence, embedding_str
   383→                )
   384→            else:
   385→                row = await conn.fetchrow(
   386→                    """
   387→                    INSERT INTO skill_insights (
   388→                        user_id, skill_id, conversation_id, insight_type,
   389→                        title, content, evidence, confidence
   390→                    )
   391→                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
   392→                    RETURNING *
   393→                    """,
   394→                    user_id, skill_id, conversation_id, insight_type,
   395→                    title, content, evidence, confidence
   396→                )
   397→            return dict(row)
   398→
   399→    @staticmethod
   400→    async def search_insights_by_embedding(
   401→        user_id: UUID,
   402→        query_embedding: List[float],
   403→        skill_id: Optional[str] = None,
   404→        threshold: float = 0.75,
   405→        limit: int = 3
   406→    ) -> List[dict]:
   407→        """
   408→        Search insights by embedding similarity (cosine distance).
   409→
   410→        Phase 1.5 Design:
   411→        - skill_id=None: Cross-skill search (all user's insights)
   412→        - skill_id=str: Single skill search
   413→
   414→        Returns insights with similarity > threshold.
   415→        """
   416→        async with get_connection() as conn:
   417→            # Convert embedding to vector string
   418→            embedding_str = "[" + ",".join(map(str, query_embedding)) + "]"
   419→
   420→            if skill_id:
   421→                rows = await conn.fetch(
   422→                    """
   423→                    SELECT id, skill_id, insight_type, title, content,
   424→                           (1 - (embedding <=> $1::vector)) as similarity
   425→                    FROM skill_insights
   426→                    WHERE user_id = $2 AND skill_id = $3 AND embedding IS NOT NULL
   427→                      AND (1 - (embedding <=> $1::vector)) > $4
   428→                    ORDER BY embedding <=> $1::vector
   429→                    LIMIT $5
   430→                    """,
   431→                    embedding_str, user_id, skill_id, threshold, limit
   432→                )
   433→            else:
   434→                # Cross-skill search (Phase 1.5)
   435→                rows = await conn.fetch(
   436→                    """
   437→                    SELECT id, skill_id, insight_type, title, content,
   438→                           (1 - (embedding <=> $1::vector)) as similarity
   439→                    FROM skill_insights
   440→                    WHERE user_id = $2 AND embedding IS NOT NULL
   441→                      AND (1 - (embedding <=> $1::vector)) > $3
   442→                    ORDER BY embedding <=> $1::vector
   443→                    LIMIT $4
   444→                    """,
   445→                    embedding_str, user_id, threshold, limit
   446→                )
   447→
   448→            return [dict(row) for row in rows]
   449→
   450→    @staticmethod
   451→    async def update_insight_embedding(
   452→        insight_id: UUID,
   453→        embedding: List[float]
   454→    ) -> bool:
   455→        """Update embedding for existing insight (backfill)"""
   456→        async with get_connection() as conn:
   457→            embedding_str = "[" + ",".join(map(str, embedding)) + "]"
   458→            result = await conn.execute(
   459→                """
   460→                UPDATE skill_insights
   461→                SET embedding = $2::vector
   462→                WHERE id = $1
   463→                """,
   464→                insight_id, embedding_str
   465→            )
   466→            return "UPDATE 1" in result
   467→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
