     1→"""
     2→Lifecoach Skill - Tool Handlers V4
     3→
     4→简化的卡片系统（移除 Protocol 工具）：
     5→- 公用卡片：ActionPlanCard, ProgressStreakCard
     6→- 方法论专属卡片（与 rule 名一一对应）：
     7→  - dankoe: DanKoeCard
     8→  - covey: CoveyCard
     9→  - yangming: YangmingCard
    10→  - liaofan: LiaofanCard
    11→"""
    12→
    13→from typing import Any, Dict
    14→from datetime import datetime, date, timezone
    15→
    16→from services.agent.tool_registry import tool_handler, ToolContext
    17→from stores.unified_profile_repo import UnifiedProfileRepository
    18→
    19→
    20→VALID_SECTIONS = ["system", "north_star", "goals", "roadmap", "current", "identity", "progress", "journal"]
    21→
    22→
    23→def deep_merge(base: Dict, update: Dict) -> Dict:
    24→    """深度合并两个字典"""
    25→    result = base.copy()
    26→    for key, value in update.items():
    27→        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
    28→            result[key] = deep_merge(result[key], value)
    29→        elif value is not None:
    30→            result[key] = value
    31→    return result
    32→
    33→
    34→# ═══════════════════════════════════════════════════════════════════════════
    35→# 数据工具
    36→# ═══════════════════════════════════════════════════════════════════════════
    37→
    38→@tool_handler("read_lifecoach_state")
    39→async def read_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    40→    """读取用户的人生地图状态"""
    41→    sections = args.get("sections", ["system", "north_star", "current", "progress"])
    42→
    43→    try:
    44→        data = await UnifiedProfileRepository.read_life_context_path(
    45→            context.user_id,
    46→            "lifecoach"
    47→        )
    48→
    49→        if not data or not data.content:
    50→            return {
    51→                "status": "empty",
    52→                "message": "尚未建立人生地图，让我们开始吧！",
    53→                "data": {}
    54→            }
    55→
    56→        result = {}
    57→        content = data.content
    58→        for section in sections:
    59→            if section in content:
    60→                result[section] = content[section]
    61→
    62→        return {
    63→            "status": "success",
    64→            "data": result,
    65→            "version": data.version,
    66→            "updated_at": data.updated_at.isoformat() if data.updated_at else None
    67→        }
    68→
    69→    except Exception as e:
    70→        return {
    71→            "status": "error",
    72→            "message": f"读取状态失败: {str(e)}",
    73→            "data": {}
    74→        }
    75→
    76→
    77→@tool_handler("write_lifecoach_state")
    78→async def write_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    79→    """写入用户的人生地图状态"""
    80→    section = args.get("section")
    81→    data = args.get("data")
    82→
    83→    if not section or not data:
    84→        return {"status": "error", "message": "缺少必要参数: section 和 data"}
    85→
    86→    if section not in VALID_SECTIONS:
    87→        return {"status": "error", "message": f"无效的 section: {section}"}
    88→
    89→    try:
    90→        existing = await UnifiedProfileRepository.read_life_context_path(
    91→            context.user_id,
    92→            "lifecoach"
    93→        )
    94→
    95→        content = existing.content if existing else {}
    96→
    97→        if section in content and isinstance(content[section], dict) and isinstance(data, dict):
    98→            content[section] = deep_merge(content[section], data)
    99→        else:
   100→            content[section] = data
   101→
   102→        content["_last_updated"] = datetime.now(timezone.utc).isoformat()
   103→        content["_last_section"] = section
   104→
   105→        result = await UnifiedProfileRepository.write_life_context_path(
   106→            context.user_id,
   107→            "lifecoach",
   108→            content
   109→        )
   110→
   111→        return {"status": "success", "message": f"已保存 {section}", "version": result.version}
   112→
   113→    except Exception as e:
   114→        return {"status": "error", "message": f"保存失败: {str(e)}"}
   115→
   116→
   117→@tool_handler("add_journal_entry")
   118→async def add_journal_entry(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   119→    """添加日志条目"""
   120→    entry_type = args.get("entry_type")
   121→
   122→    if not entry_type:
   123→        return {"status": "error", "message": "缺少必要参数: entry_type"}
   124→
   125→    try:
   126→        existing = await UnifiedProfileRepository.read_life_context_path(
   127→            context.user_id,
   128→            "lifecoach"
   129→        )
   130→
   131→        lifecoach_data = existing.content if existing else {}
   132→        journal = lifecoach_data.get("journal", [])
   133→        if isinstance(journal, dict):
   134→            journal = journal.get("entries", [])
   135→
   136→        today = date.today().isoformat()
   137→
   138→        entry = {
   139→            "date": args.get("date", today),
   140→            "type": entry_type,
   141→            "content": args.get("content"),
   142→            "wins": args.get("wins", []),
   143→            "struggles": args.get("struggles", []),
   144→            "merits": args.get("merits", []),
   145→            "demerits": args.get("demerits", []),
   146→            "_created_at": datetime.now(timezone.utc).isoformat(),
   147→        }
   148→
   149→        entry = {k: v for k, v in entry.items() if v is not None and v != []}
   150→
   151→        journal = [entry] + journal[:99]
   152→        lifecoach_data["journal"] = journal
   153→
   154→        await UnifiedProfileRepository.write_life_context_path(
   155→            context.user_id,
   156→            "lifecoach",
   157→            lifecoach_data
   158→        )
   159→
   160→        return {"status": "success", "message": "日志已记录", "date": entry["date"], "type": entry_type}
   161→
   162→    except Exception as e:
   163→        return {"status": "error", "message": f"记录失败: {str(e)}"}
   164→
   165→
   166→@tool_handler("update_progress")
   167→async def update_progress(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   168→    """更新进度/签到"""
   169→    action_type = args.get("action_type")
   170→
   171→    if not action_type:
   172→        return {"status": "error", "message": "缺少必要参数: action_type"}
   173→
   174→    try:
   175→        existing = await UnifiedProfileRepository.read_life_context_path(
   176→            context.user_id,
   177→            "lifecoach"
   178→        )
   179→
   180→        lifecoach_data = existing.content if existing else {}
   181→        progress = lifecoach_data.get("progress", {
   182→            "current_streak": 0,
   183→            "longest_streak": 0,
   184→            "total_checkins": 0,
   185→            "last_checkin_date": None,
   186→        })
   187→
   188→        today = date.today().isoformat()
   189→        now = datetime.now(timezone.utc).isoformat()
   190→
   191→        if action_type == "daily_checkin":
   192→            if progress.get("last_checkin_date") == today:
   193→                return {
   194→                    "status": "already_checked_in",
   195→                    "message": "今天已经签到过了！",
   196→                    "current_streak": progress["current_streak"]
   197→                }
   198→
   199→            last_date = progress.get("last_checkin_date")
   200→            days_since_last = (date.today() - date.fromisoformat(last_date)).days if last_date else None
   201→            old_streak = progress.get("current_streak", 0)
   202→            new_streak = old_streak + 1 if days_since_last == 1 else 1
   203→
   204→            progress["longest_streak"] = max(old_streak, new_streak, progress.get("longest_streak", 0))
   205→            progress["current_streak"] = new_streak
   206→            progress["total_checkins"] = progress.get("total_checkins", 0) + 1
   207→            progress["last_checkin_date"] = today
   208→
   209→        elif action_type == "task_complete":
   210→            completed = progress.get("tasks_completed", 0)
   211→            progress["tasks_completed"] = completed + 1
   212→
   213→        elif action_type == "milestone_reached":
   214→            milestones = progress.get("milestones", [])
   215→            milestones.append({"reached_at": now, "notes": args.get("notes")})
   216→            progress["milestones"] = milestones
   217→
   218→        lifecoach_data["progress"] = progress
   219→        await UnifiedProfileRepository.write_life_context_path(
   220→            context.user_id,
   221→            "lifecoach",
   222→            lifecoach_data
   223→        )
   224→
   225→        return {
   226→            "status": "success",
   227→            "message": "进度已更新",
   228→            "current_streak": progress.get("current_streak", 0),
   229→            "longest_streak": progress.get("longest_streak", 0),
   230→            "total_checkins": progress.get("total_checkins", 0)
   231→        }
   232→
   233→    except Exception as e:
   234→        return {"status": "error", "message": f"更新失败: {str(e)}"}
   235→
   236→
   237→# ═══════════════════════════════════════════════════════════════════════════
   238→# 公用卡片
   239→# ═══════════════════════════════════════════════════════════════════════════
   240→
   241→@tool_handler("show_protocol_invitation")
   242→async def show_protocol_invitation(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   243→    """展示协议邀请卡片，引导用户进入协议专属页面"""
   244→    protocol_id = args.get("protocol_id")
   245→    if not protocol_id:
   246→        return {"status": "error", "message": "缺少必要参数: protocol_id"}
   247→
   248→    return {
   249→        "card_type": "protocol_invitation",
   250→        "data": {
   251→            "protocol_id": protocol_id,
   252→            "title": args.get("title", ""),
   253→            "description": args.get("description", ""),
   254→            "estimated_time": args.get("estimated_time"),
   255→            "total_steps": args.get("total_steps"),
   256→            "generated_at": datetime.now(timezone.utc).isoformat()
   257→        }
   258→    }
   259→
   260→
   261→@tool_handler("show_skill_intro")
   262→async def show_skill_intro(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   263→    """展示 Skill 介绍卡片"""
   264→    return {
   265→        "card_type": "skill_intro",
   266→        "data": {
   267→            "skill_id": "lifecoach",
   268→            "variant": args.get("variant", "compact"),
   269→            "reason": args.get("reason"),
   270→            "generated_at": datetime.now(timezone.utc).isoformat()
   271→        }
   272→    }
   273→
   274→
   275→@tool_handler("show_action_plan")
   276→async def show_action_plan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   277→    """展示行动计划卡片（公用）"""
   278→    return {
   279→        "card_type": "action_plan",
   280→        "data": {
   281→            "long_term_goal": args.get("long_term_goal"),
   282→            "medium_term_goal": args.get("medium_term_goal"),
   283→            "daily_actions": args.get("daily_actions", []),
   284→            "first_step": args.get("first_step"),
   285→            "generated_at": datetime.now(timezone.utc).isoformat()
   286→        }
   287→    }
   288→
   289→
   290→@tool_handler("show_progress_streak")
   291→async def show_progress_streak(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   292→    """展示进度统计卡片（公用）"""
   293→    current_streak = args.get("current_streak", 0)
   294→
   295→    if current_streak >= 30:
   296→        motivation = "太棒了！一个月的坚持，你正在重塑自己！"
   297→    elif current_streak >= 14:
   298→        motivation = "两周了！习惯正在形成，继续保持！"
   299→    elif current_streak >= 7:
   300→        motivation = "一周连续签到！你已经超越了大多数人！"
   301→    elif current_streak >= 3:
   302→        motivation = "连续三天，好的开始！"
   303→    elif current_streak >= 1:
   304→        motivation = "今天是新的开始！"
   305→    else:
   306→        motivation = "准备好开始你的旅程了吗？"
   307→
   308→    return {
   309→        "card_type": "progress_streak",
   310→        "data": {
   311→            "current_streak": current_streak,
   312→            "longest_streak": args.get("longest_streak", current_streak),
   313→            "total_checkins": args.get("total_checkins", 0),
   314→            "completion_rate": args.get("completion_rate", 0),
   315→            "framework_stats": args.get("framework_stats", {}),
   316→            "motivation": motivation,
   317→            "generated_at": datetime.now(timezone.utc).isoformat()
   318→        }
   319→    }
   320→
   321→
   322→# ═══════════════════════════════════════════════════════════════════════════
   323→# 方法论专属卡片
   324→# ══════════════════════════════════════════════════════════════════════��════
   325→
   326→@tool_handler("show_dankoe")
   327→async def show_dankoe(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   328→    """
   329→    展示 Dan Koe 方法论卡片
   330→    整合：愿景、反愿景、身份、目标层级、游戏化框架
   331→    """
   332→    vision = args.get("vision", {})
   333→    anti_vision = args.get("anti_vision", {})
   334→    game_elements = args.get("game_elements", {})
   335→
   336→    return {
   337→        "card_type": "dankoe",
   338→        "data": {
   339→            "vision": {
   340→                "statement": vision.get("statement", ""),
   341→                "scene": vision.get("scene", ""),
   342→                "identity": vision.get("identity", "")
   343→            },
   344→            "anti_vision": {
   345→                "statement": anti_vision.get("statement", ""),
   346→                "scene": anti_vision.get("scene", "")
   347→            },
   348→            "game": {
   349→                "win_condition": vision.get("statement", ""),
   350→                "lose_condition": anti_vision.get("statement", ""),
   351→                "main_mission": game_elements.get("main_mission", ""),
   352→                "current_boss": game_elements.get("current_boss", ""),
   353→                "daily_quests": game_elements.get("daily_quests", []),
   354→                "rules": game_elements.get("rules", [])
   355→            },
   356→            "generated_at": datetime.now(timezone.utc).isoformat()
   357→        }
   358→    }
   359→
   360→
   361→@tool_handler("show_covey")
   362→async def show_covey(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   363→    """
   364→    展示 Covey 方法论卡片
   365→    整合：使命宣言、角色目标、大石头、平衡度
   366→    """
   367→    roles = args.get("roles", [])
   368→
   369→    # 计算平衡分数
   370→    if roles:
   371→        scores = [r.get("score", 0) for r in roles if r.get("score") is not None]
   372→        if scores:
   373→            avg = sum(scores) / len(scores)
   374→            variance = sum((s - avg) ** 2 for s in scores) / len(scores)
   375→            balance_score = min(100, max(0, avg * 10 - variance * 2))
   376→        else:
   377→            balance_score = 0
   378→    else:
   379→        balance_score = args.get("balance_score", 0)
   380→
   381→    return {
   382→        "card_type": "covey",
   383→        "data": {
   384→            "mission": args.get("mission", ""),
   385→            "principles": args.get("principles", []),
   386→            "roles": roles,
   387→            "balance_score": round(balance_score, 1),
   388→            "insight": args.get("insight", ""),
   389→            "generated_at": datetime.now(timezone.utc).isoformat()
   390→        }
   391→    }
   392→
   393→
   394→@tool_handler("show_yangming")
   395→async def show_yangming(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   396→    """
   397→    展示王阳明方法论卡片
   398→    整合：良知、私欲、知行差距、日课
   399→    """
   400→    daily_practice = args.get("daily_practice", {})
   401→
   402→    return {
   403→        "card_type": "yangming",
   404→        "data": {
   405→            "aspiration": args.get("aspiration", ""),
   406→            "conscience_voice": args.get("conscience_voice", ""),
   407→            "desire_obstacles": args.get("desire_obstacles", []),
   408→            "daily_practice": {
   409→                "morning_intention": daily_practice.get("morning_intention", ""),
   410→                "practice_focus": daily_practice.get("practice_focus", ""),
   411→                "evening_reflection": daily_practice.get("evening_reflection", "")
   412→            },
   413→            "recent_reflections": args.get("recent_reflections", []),
   414→            "generated_at": datetime.now(timezone.utc).isoformat()
   415→        }
   416→    }
   417→
   418→
   419→@tool_handler("show_liaofan")
   420→async def show_liaofan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   421→    """
   422→    展示了凡四训方法论卡片
   423→    整合：立命志向、功过统计、改命进度
   424→    """
   425→    fate_transform = args.get("fate_transform", {})
   426→    merit_stats = args.get("merit_stats", {})
   427→
   428→    return {
   429→        "card_type": "liaofan",
   430→        "data": {
   431→            "fate_transform": {
   432→                "original_fate": fate_transform.get("original_fate", ""),
   433→                "new_fate": fate_transform.get("new_fate", "")
   434→            },
   435→            "merit_stats": {
   436→                "total_merits": merit_stats.get("total_merits", 0),
   437→                "total_demerits": merit_stats.get("total_demerits", 0),
   438→                "net_karma": merit_stats.get("net_karma", 0),
   439→                "trend": merit_stats.get("trend", "stable")
   440→            },
   441→            "category_breakdown": args.get("category_breakdown", {}),
   442→            "recent_entries": args.get("recent_entries", []),
   443→            "milestones": args.get("milestones", []),
   444→            "generated_at": datetime.now(timezone.utc).isoformat()
   445→        }
   446→    }
   447→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
