     1→"""
     2→Lifecoach Skill - Tool Handlers V4
     3→
     4→简化的卡片系统（移除 Protocol 工具）：
     5→- 公用卡片：ActionPlanCard, ProgressStreakCard
     6→- 方法论专属卡片（与 rule 名一一对应）：
     7→  - dankoe: DanKoeCard
     8→  - covey: CoveyCard
     9→  - yangming: YangmingCard
    10→  - liaofan: LiaofanCard
    11→"""
    12→
    13→from typing import Any, Dict
    14→from datetime import datetime, date, timezone
    15→
    16→from services.agent.tool_registry import tool_handler, ToolContext
    17→from stores.unified_profile_repo import UnifiedProfileRepository
    18→
    19→
    20→VALID_SECTIONS = ["system", "north_star", "goals", "roadmap", "current", "identity", "progress", "journal"]
    21→
    22→
    23→def deep_merge(base: Dict, update: Dict) -> Dict:
    24→    """深度合并两个字典"""
    25→    result = base.copy()
    26→    for key, value in update.items():
    27→        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
    28→            result[key] = deep_merge(result[key], value)
    29→        elif value is not None:
    30→            result[key] = value
    31→    return result
    32→
    33→
    34→# ═══════════════════════════════════════════════════════════════════════════
    35→# 数据工具
    36→# ═══════════════════════════════════════════════════════════════════════════
    37→
    38→@tool_handler("read_lifecoach_state")
    39→async def read_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    40→    """读取用户的人生地图状态"""
    41→    sections = args.get("sections", ["system", "north_star", "current", "progress"])
    42→
    43→    try:
    44→        data = await UnifiedProfileRepository.read_life_context_path(
    45→            context.user_id,
    46→            "lifecoach"
    47→        )
    48→
    49→        if not data or not data.content:
    50→            return {
    51→                "status": "empty",
    52→                "message": "尚未建立人生地图，让我们开始吧！",
    53→                "data": {}
    54→            }
    55→
    56→        result = {}
    57→        content = data.content
    58→        for section in sections:
    59→            if section in content:
    60→                result[section] = content[section]
    61→
    62→        return {
    63→            "status": "success",
    64→            "data": result,
    65→            "version": data.version,
    66→            "updated_at": data.updated_at.isoformat() if data.updated_at else None
    67→        }
    68→
    69→    except Exception as e:
    70→        return {
    71→            "status": "error",
    72→            "message": f"读取状态失败: {str(e)}",
    73→            "data": {}
    74→        }
    75→
    76→
    77→@tool_handler("write_lifecoach_state")
    78→async def write_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    79→    """写入用户的人生地图状态"""
    80→    section = args.get("section")
    81→    data = args.get("data")
    82→
    83→    if not section or not data:
    84→        return {"status": "error", "message": "缺少必要参数: section 和 data"}
    85→
    86→    if section not in VALID_SECTIONS:
    87→        return {"status": "error", "message": f"无效的 section: {section}"}
    88→
    89→    try:
    90→        existing = await UnifiedProfileRepository.read_life_context_path(
    91→            context.user_id,
    92→            "lifecoach"
    93→        )
    94→
    95→        content = existing.content if existing else {}
    96→
    97→        if section in content and isinstance(content[section], dict) and isinstance(data, dict):
    98→            content[section] = deep_merge(content[section], data)
    99→        else:
   100→            content[section] = data
   101→
   102→        content["_last_updated"] = datetime.now(timezone.utc).isoformat()
   103→        content["_last_section"] = section
   104→
   105→        result = await UnifiedProfileRepository.write_life_context_path(
   106→            context.user_id,
   107→            "lifecoach",
   108→            content
   109→        )
   110→
   111→        return {"status": "success", "message": f"已保存 {section}", "version": result.version}
   112→
   113→    except Exception as e:
   114→        return {"status": "error", "message": f"保存失败: {str(e)}"}
   115→
   116→
   117→@tool_handler("add_journal_entry")
   118→async def add_journal_entry(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   119→    """添加日志条目"""
   120→    entry_type = args.get("entry_type")
   121→
   122→    if not entry_type:
   123→        return {"status": "error", "message": "缺少必要参数: entry_type"}
   124→
   125→    try:
   126→        existing = await UnifiedProfileRepository.read_life_context_path(
   127→            context.user_id,
   128→            "lifecoach"
   129→        )
   130→
   131→        lifecoach_data = existing.content if existing else {}
   132→        journal = lifecoach_data.get("journal", [])
   133→        if isinstance(journal, dict):
   134→            journal = journal.get("entries", [])
   135→
   136→        today = date.today().isoformat()
   137→
   138→        entry = {
   139→            "date": args.get("date", today),
   140→            "type": entry_type,
   141→            "content": args.get("content"),
   142→            "wins": args.get("wins", []),
   143→            "struggles": args.get("struggles", []),
   144→            "merits": args.get("merits", []),
   145→            "demerits": args.get("demerits", []),
   146→            "_created_at": datetime.now(timezone.utc).isoformat(),
   147→        }
   148→
   149→        entry = {k: v for k, v in entry.items() if v is not None and v != []}
   150→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
