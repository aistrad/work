{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":"Review and simplify the recently modified code in the lifecoach component. Focus on:\n\n1. `apps/api/skills/lifecoach/tools/handlers.py` - The handlers with deep_merge and section validation\n2. `apps/api/services/proactive/trigger_detector.py` - The new lifecoach condition checkers\n\nLook for:\n- Redundant code that can be consolidated\n- Overly complex logic that can be simplified\n- Inconsistent patterns\n- Unnecessary abstractions\n\nDo NOT change functionality, only simplify for clarity and maintainability."},"uuid":"d8b78480-e090-4d7a-bad3-018538cbaaad","timestamp":"2026-01-19T12:15:59.881Z"}
{"parentUuid":"d8b78480-e090-4d7a-bad3-018538cbaaad","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E3FrP9r6TAHYqX8pDUduwh","type":"message","role":"assistant","content":[{"type":"text","text":"I'll review the recently modified code in the lifecoach component. Let me start by reading the files you mentioned."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21660,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21660,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXGijy2pgGtv47nqmRcHk","type":"assistant","uuid":"59b3985e-faea-4645-bf13-ceec8d406b37","timestamp":"2026-01-19T12:16:04.422Z"}
{"parentUuid":"59b3985e-faea-4645-bf13-ceec8d406b37","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E3FrP9r6TAHYqX8pDUduwh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KcvvZwUUZQqMoxJGbsqeNr","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21660,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21660,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXGijy2pgGtv47nqmRcHk","type":"assistant","uuid":"7fffd7e1-c618-41a0-8910-2b0b01796c97","timestamp":"2026-01-19T12:16:04.861Z"}
{"parentUuid":"7fffd7e1-c618-41a0-8910-2b0b01796c97","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E3FrP9r6TAHYqX8pDUduwh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NTnWjPK9iVLiypsEf8V3Yf","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21660,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21660,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXGijy2pgGtv47nqmRcHk","type":"assistant","uuid":"2597ed1c-fbfa-4c9f-bc06-3a524ba54835","timestamp":"2026-01-19T12:16:05.388Z"}
{"parentUuid":"7fffd7e1-c618-41a0-8910-2b0b01796c97","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KcvvZwUUZQqMoxJGbsqeNr","type":"tool_result","content":"     1→\"\"\"\n     2→Lifecoach Skill - Tool Handlers V2\n     3→\n     4→使用 @tool_handler 装饰器注册工具执行器。\n     5→支持数据持久化和展示卡片生成。\n     6→\n     7→数据结构 (与 DATA-STRUCTURE.md 对齐):\n     8→- system: 系统配置（方法论、角色设定）\n     9→- north_star: 北极星愿景、反愿景、使命、原则\n    10→- goals: 核心目标（最多3个），包含年度目标\n    11→- roadmap: 路线图（年度、季度）\n    12→- current: 当前焦点（月度项目 current.month、周大石头 current.week、每日杠杆 current.daily）\n    13→- identity: 身份设计（当前身份、目标身份、锚定行为）\n    14→- progress: 进度追踪（签到、连续天数）\n    15→- journal: 复盘日志（数组）\n    16→\"\"\"\n    17→\n    18→import uuid\n    19→from typing import Any, Dict, List, Optional\n    20→from datetime import datetime, date\n    21→\n    22→from services.agent.tool_registry import tool_handler, ToolContext\n    23→from stores.unified_profile_repo import UnifiedProfileRepository\n    24→\n    25→\n    26→# 有效的 section 列表（与 DATA-STRUCTURE.md 对齐）\n    27→VALID_SECTIONS = [\"system\", \"north_star\", \"goals\", \"roadmap\", \"current\", \"identity\", \"progress\", \"journal\"]\n    28→\n    29→\n    30→def deep_merge(base: Dict, update: Dict) -> Dict:\n    31→    \"\"\"深度合并两个字典\"\"\"\n    32→    result = base.copy()\n    33→    for key, value in update.items():\n    34→        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n    35→            result[key] = deep_merge(result[key], value)\n    36→        elif value is not None:\n    37→            result[key] = value\n    38→    return result\n    39→\n    40→\n    41→# ═══════════════════════════════════════════════════════════════════════════\n    42→# 数据工具 (V2 - 与 DATA-STRUCTURE.md 对齐)\n    43→# ═══════════════════════════════════════════════════════════════════════════\n    44→\n    45→@tool_handler(\"read_lifecoach_state\")\n    46→async def read_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    47→    \"\"\"\n    48→    读取用户的人生地图状态\n    49→\n    50→    从 unified_profile 的 life_context.lifecoach 路径读取数据\n    51→    支持的 sections: system, north_star, goals, roadmap, current, identity, progress, journal\n    52→    \"\"\"\n    53→    sections = args.get(\"sections\", [\"north_star\", \"goals\", \"current\", \"progress\"])\n    54→\n    55→    try:\n    56→        # 从 unified_profile 读取 lifecoach 数据\n    57→        data = await UnifiedProfileRepository.read_life_context_path(\n    58→            context.user_id,\n    59→            \"lifecoach\"\n    60→        )\n    61→\n    62→        if not data or not data.content:\n    63→            return {\n    64→                \"status\": \"empty\",\n    65→                \"message\": \"尚未建立人生地图，让我们开始吧！\",\n    66→                \"data\": {}\n    67→            }\n    68→\n    69→        # 按请求的 sections 过滤返回\n    70→        result = {}\n    71→        content = data.content\n    72→        for section in sections:\n    73→            if section in content:\n    74→                result[section] = content[section]\n    75→\n    76→        return {\n    77→            \"status\": \"success\",\n    78→            \"data\": result,\n    79→            \"version\": data.version,\n    80→            \"updated_at\": data.updated_at.isoformat() if data.updated_at else None\n    81→        }\n    82→\n    83→    except Exception as e:\n    84→        return {\n    85→            \"status\": \"error\",\n    86→            \"message\": f\"读取状态失败: {str(e)}\",\n    87→            \"data\": {}\n    88→        }\n    89→\n    90→\n    91→@tool_handler(\"write_lifecoach_state\")\n    92→async def write_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    93→    \"\"\"\n    94→    写入用户的人生地图状态\n    95→\n    96→    支持的 section: system, north_star, goals, roadmap, current, identity, progress\n    97→    使用深度合并，避免覆盖已有数据\n    98→\n    99→    特别说明 - current 的嵌套结构:\n   100→    - current.month: 月度项目\n   101→    - current.week: 周大石头\n   102→    - current.daily: 每日杠杆\n   103→\n   104→    示例：\n   105→    write_lifecoach_state(section=\"current\", data={\"week\": {\"rocks\": [...]}})\n   106→    会合并到 current.week，不会覆盖 current.month 和 current.daily\n   107→    \"\"\"\n   108→    section = args.get(\"section\")\n   109→    data = args.get(\"data\")\n   110→\n   111→    if not section or not data:\n   112→        return {\n   113→            \"status\": \"error\",\n   114→            \"message\": \"缺少必要参数: section 和 data\"\n   115→        }\n   116→\n   117→    # 验证 section 有效性\n   118→    if section not in VALID_SECTIONS:\n   119→        return {\n   120→            \"status\": \"error\",\n   121→            \"message\": f\"无效的 section: {section}。有效值: {', '.join(VALID_SECTIONS)}\"\n   122→        }\n   123→\n   124→    try:\n   125→        # 先读取现有数据\n   126→        existing = await UnifiedProfileRepository.read_life_context_path(\n   127→            context.user_id,\n   128→            \"lifecoach\"\n   129→        )\n   130→\n   131→        # 深度合并数据\n   132→        content = existing.content if existing else {}\n   133→\n   134→        # 如果是 current 或其他嵌套结构，使用深度合并\n   135→        if section in content and isinstance(content[section], dict) and isinstance(data, dict):\n   136→            content[section] = deep_merge(content[section], data)\n   137→        else:\n   138→            content[section] = data\n   139→\n   140→        # 更新元信息\n   141→        content[\"_last_updated\"] = datetime.utcnow().isoformat()\n   142→        content[\"_last_section\"] = section\n   143→\n   144→        # 写入\n   145→        result = await UnifiedProfileRepository.write_life_context_path(\n   146→            context.user_id,\n   147→            \"lifecoach\",\n   148→            content\n   149→        )\n   150→\n   151→        return {\n   152→            \"status\": \"success\",\n   153→            \"message\": f\"已保存 {section}\",\n   154→            \"version\": result.version\n   155→        }\n   156→\n   157→    except Exception as e:\n   158→        return {\n   159→            \"status\": \"error\",\n   160→            \"message\": f\"保存失败: {str(e)}\"\n   161→        }\n   162→\n   163→\n   164→@tool_handler(\"add_journal_entry\")\n   165→async def add_journal_entry(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   166→    \"\"\"\n   167→    添加复盘日志条目\n   168→\n   169→    与 DATA-STRUCTURE.md 的 journal 结构对齐:\n   170→    journal 是一个数组，每个条目包含:\n   171→    - date: 日期\n   172→    - type: daily | weekly | monthly | quarterly | insight\n   173→    - mood: 心情 (1-10)\n   174→    - energy: 能量 (1-10)\n   175→    - rocks_completed: 完成的大石头数\n   176→    - rocks_total: 总大石头数\n   177→    - goal_balance: 目标平衡统计 (周复盘)\n   178→    - wins: 胜利列表\n   179→    - struggles: 挑战列表\n   180→    - insight: 洞察\n   181→    - gratitude: 感恩\n   182→    - tomorrow: 明天计划\n   183→    - next_week_focus: 下周聚焦\n   184→    \"\"\"\n   185→    entry_type = args.get(\"entry_type\")\n   186→    content = args.get(\"content\")\n   187→\n   188→    if not entry_type:\n   189→        return {\n   190→            \"status\": \"error\",\n   191→            \"message\": \"缺少必要参数: entry_type\"\n   192→        }\n   193→\n   194→    try:\n   195→        # 读取现有数据\n   196→        existing = await UnifiedProfileRepository.read_life_context_path(\n   197→            context.user_id,\n   198→            \"lifecoach\"\n   199→        )\n   200→\n   201→        lifecoach_data = existing.content if existing else {}\n   202→        # journal 是一个数组（与 DATA-STRUCTURE.md 对齐）\n   203→        journal = lifecoach_data.get(\"journal\", [])\n   204→        if isinstance(journal, dict):\n   205→            # 兼容旧格式：从 entries 数组迁移\n   206→            journal = journal.get(\"entries\", [])\n   207→\n   208→        today = date.today().isoformat()\n   209→\n   210→        # 创建新条目（与 DATA-STRUCTURE.md 字段对齐）\n   211→        entry = {\n   212→            \"date\": args.get(\"date\", today),\n   213→            \"type\": entry_type,\n   214→            \"content\": content,  # 额外字段：摘要内容\n   215→            \"mood\": args.get(\"mood\"),\n   216→            \"energy\": args.get(\"energy\"),\n   217→            \"rocks_completed\": args.get(\"rocks_completed\"),\n   218→            \"rocks_total\": args.get(\"rocks_total\"),\n   219→            \"goal_balance\": args.get(\"goal_balance\"),  # 周复盘用\n   220→            \"wins\": args.get(\"wins\", []),\n   221→            \"struggles\": args.get(\"blockers\", []),  # 兼容旧参数名\n   222→            \"insight\": args.get(\"insight\"),\n   223→            \"gratitude\": args.get(\"gratitude\"),\n   224→            \"tomorrow\": args.get(\"tomorrow\"),\n   225→            \"next_week_focus\": args.get(\"next_week_focus\"),\n   226→            \"adjustments\": args.get(\"adjustments\", []),\n   227→            \"learnings\": args.get(\"learnings\", []),\n   228→            \"_created_at\": datetime.utcnow().isoformat(),\n   229→        }\n   230→\n   231→        # 清理 None 值\n   232→        entry = {k: v for k, v in entry.items() if v is not None}\n   233→\n   234→        # 添加到日志列表（最新在前）\n   235→        journal = [entry] + journal[:99]  # 保留最近100条\n   236→\n   237→        # 保存\n   238→        lifecoach_data[\"journal\"] = journal\n   239→        await UnifiedProfileRepository.write_life_context_path(\n   240→            context.user_id,\n   241→            \"lifecoach\",\n   242→            lifecoach_data\n   243→        )\n   244→\n   245→        return {\n   246→            \"status\": \"success\",\n   247→            \"message\": \"日志已记录\",\n   248→            \"date\": entry[\"date\"],\n   249→            \"type\": entry_type\n   250→        }\n   251→\n   252→    except Exception as e:\n   253→        return {\n   254→            \"status\": \"error\",\n   255→            \"message\": f\"记录失败: {str(e)}\"\n   256→        }\n   257→\n   258→\n   259→@tool_handler(\"update_progress\")\n   260→async def update_progress(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   261→    \"\"\"\n   262→    更新进度/签到\n   263→    \"\"\"\n   264→    action_type = args.get(\"action_type\")\n   265→\n   266→    if not action_type:\n   267→        return {\n   268→            \"status\": \"error\",\n   269→            \"message\": \"缺少必要参数: action_type\"\n   270→        }\n   271→\n   272→    try:\n   273→        # 读取现有数据\n   274→        existing = await UnifiedProfileRepository.read_life_context_path(\n   275→            context.user_id,\n   276→            \"lifecoach\"\n   277→        )\n   278→\n   279→        lifecoach_data = existing.content if existing else {}\n   280→        progress = lifecoach_data.get(\"progress\", {\n   281→            \"current_streak\": 0,\n   282→            \"longest_streak\": 0,\n   283→            \"total_checkins\": 0,\n   284→            \"last_checkin_date\": None,\n   285→            \"checkin_history\": [],\n   286→            \"completed_levers\": [],\n   287→            \"completed_rocks\": [],\n   288→            \"milestones\": []\n   289→        })\n   290→\n   291→        today = date.today().isoformat()\n   292→        now = datetime.utcnow().isoformat()\n   293→\n   294→        if action_type == \"daily_checkin\":\n   295→            # 检查是否今天已签到\n   296→            if progress.get(\"last_checkin_date\") == today:\n   297→                return {\n   298→                    \"status\": \"already_checked_in\",\n   299→                    \"message\": \"今天已经签到过了！\",\n   300→                    \"current_streak\": progress[\"current_streak\"]\n   301→                }\n   302→\n   303→            # 更新连续签到\n   304→            last_date = progress.get(\"last_checkin_date\")\n   305→            if last_date:\n   306→                last = date.fromisoformat(last_date)\n   307→                today_date = date.today()\n   308→                diff = (today_date - last).days\n   309→                if diff == 1:\n   310→                    progress[\"current_streak\"] += 1\n   311→                elif diff > 1:\n   312→                    progress[\"current_streak\"] = 1\n   313→            else:\n   314→                progress[\"current_streak\"] = 1\n   315→\n   316→            # 更新最长连续\n   317→            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):\n   318→                progress[\"longest_streak\"] = progress[\"current_streak\"]\n   319→\n   320→            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n   321→            progress[\"last_checkin_date\"] = today\n   322→\n   323→            # 记录签到历史\n   324→            history = progress.get(\"checkin_history\", [])\n   325→            history.append({\n   326→                \"date\": today,\n   327→                \"time\": now,\n   328→                \"notes\": args.get(\"notes\")\n   329→            })\n   330→            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天\n   331→\n   332→        elif action_type == \"lever_complete\":\n   333→            lever_id = args.get(\"lever_id\")\n   334→            if lever_id:\n   335→                completed = progress.get(\"completed_levers\", [])\n   336→                completed.append({\n   337→                    \"id\": lever_id,\n   338→                    \"completed_at\": now,\n   339→                    \"notes\": args.get(\"notes\")\n   340→                })\n   341→                progress[\"completed_levers\"] = completed[-100:]\n   342→\n   343→        elif action_type == \"rock_complete\":\n   344→            rock_id = args.get(\"rock_id\")\n   345→            if rock_id:\n   346→                completed = progress.get(\"completed_rocks\", [])\n   347→                completed.append({\n   348→                    \"id\": rock_id,\n   349→                    \"completed_at\": now,\n   350→                    \"notes\": args.get(\"notes\")\n   351→                })\n   352→                progress[\"completed_rocks\"] = completed[-50:]\n   353→\n   354→        elif action_type == \"milestone_reached\":\n   355→            milestones = progress.get(\"milestones\", [])\n   356→            milestones.append({\n   357→                \"reached_at\": now,\n   358→                \"notes\": args.get(\"notes\")\n   359→            })\n   360→            progress[\"milestones\"] = milestones\n   361→\n   362→        # 保存\n   363→        lifecoach_data[\"progress\"] = progress\n   364→        await UnifiedProfileRepository.write_life_context_path(\n   365→            context.user_id,\n   366→            \"lifecoach\",\n   367→            lifecoach_data\n   368→        )\n   369→\n   370→        return {\n   371→            \"status\": \"success\",\n   372→            \"message\": \"进度已更新\",\n   373→            \"current_streak\": progress.get(\"current_streak\", 0),\n   374→            \"total_checkins\": progress.get(\"total_checkins\", 0)\n   375→        }\n   376→\n   377→    except Exception as e:\n   378→        return {\n   379→            \"status\": \"error\",\n   380→            \"message\": f\"更新失败: {str(e)}\"\n   381→        }\n   382→\n   383→\n   384→# ══════════════════��════════════════════════════════════════════════════════\n   385→# 展示工具 - V2 新增\n   386→# ═══════════════════════════════════════════════════════════════════════════\n   387→\n   388→@tool_handler(\"show_life_roadmap\")\n   389→async def show_life_roadmap(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   390→    \"\"\"\n   391→    展示人生路线图卡片\n   392→    \"\"\"\n   393→    north_star = args.get(\"north_star\", {})\n   394→\n   395→    return {\n   396→        \"card_type\": \"life_roadmap\",\n   397→        \"data\": {\n   398→            \"north_star\": north_star,\n   399→            \"yearly_theme\": args.get(\"yearly_theme\"),\n   400→            \"quarterly_milestones\": args.get(\"quarterly_milestones\", []),\n   401→            \"current_focus\": args.get(\"current_focus\"),\n   402→            \"generated_at\": datetime.utcnow().isoformat()\n   403→        }\n   404→    }\n   405→\n   406→\n   407→@tool_handler(\"show_role_balance\")\n   408→async def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   409→    \"\"\"\n   410→    展示目标平衡轮卡片\n   411→    \"\"\"\n   412→    roles = args.get(\"roles\", [])\n   413→\n   414→    # 计算平衡分数\n   415→    if roles:\n   416→        scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n   417→        if scores:\n   418→            avg = sum(scores) / len(scores)\n   419→            variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n   420→            # 平衡分数：平均分越高、方差越小，分数越高\n   421→            balance_score = min(100, max(0, avg * 10 - variance * 2))\n   422→        else:\n   423→            balance_score = 0\n   424→    else:\n   425→        balance_score = args.get(\"balance_score\", 0)\n   426→\n   427→    return {\n   428→        \"card_type\": \"role_balance\",\n   429→        \"data\": {\n   430→            \"roles\": roles,\n   431→            \"balance_score\": round(balance_score, 1),\n   432→            \"insight\": args.get(\"insight\"),\n   433→            \"generated_at\": datetime.utcnow().isoformat()\n   434→        }\n   435→    }\n   436→\n   437→\n   438→@tool_handler(\"show_weekly_rocks\")\n   439→async def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   440→    \"\"\"\n   441→    展示周大石头卡片\n   442→    \"\"\"\n   443→    rocks = args.get(\"rocks\", [])\n   444→\n   445→    # 计算完成进度\n   446→    total = len(rocks)\n   447→    completed = sum(1 for r in rocks if r.get(\"status\") == \"completed\")\n   448→    in_progress = sum(1 for r in rocks if r.get(\"status\") == \"in_progress\")\n   449→\n   450→    return {\n   451→        \"card_type\": \"weekly_rocks\",\n   452→        \"data\": {\n   453→            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n   454→            \"rocks\": rocks,\n   455→            \"theme\": args.get(\"theme\"),\n   456→            \"energy_budget\": args.get(\"energy_budget\"),\n   457→            \"stats\": {\n   458→                \"total\": total,\n   459→                \"completed\": completed,\n   460→                \"in_progress\": in_progress,\n   461→                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n   462→            },\n   463→            \"generated_at\": datetime.utcnow().isoformat()\n   464→        }\n   465→    }\n   466→\n   467→\n   468→@tool_handler(\"show_daily_levers\")\n   469→async def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   470→    \"\"\"\n   471→    展示每日杠杆行动卡片\n   472→    \"\"\"\n   473→    levers = args.get(\"levers\", [])\n   474→\n   475→    # 计算完成进度\n   476→    total = len(levers)\n   477→    completed = sum(1 for l in levers if l.get(\"status\") == \"completed\")\n   478→\n   479→    return {\n   480→        \"card_type\": \"daily_levers\",\n   481→        \"data\": {\n   482→            \"date\": args.get(\"date\", date.today().isoformat()),\n   483→            \"levers\": levers,\n   484→            \"energy_level\": args.get(\"energy_level\"),\n   485→            \"intention\": args.get(\"intention\"),\n   486→            \"stats\": {\n   487→                \"total\": total,\n   488→                \"completed\": completed,\n   489→                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n   490→            },\n   491→            \"generated_at\": datetime.utcnow().isoformat()\n   492→        }\n   493→    }\n   494→\n   495→\n   496→@tool_handler(\"show_progress_streak\")\n   497→async def show_progress_streak(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   498→    \"\"\"\n   499→    展示连续签到和进度统计卡片\n   500→    \"\"\"\n   501→    current_streak = args.get(\"current_streak\", 0)\n   502→    longest_streak = args.get(\"longest_streak\", current_streak)\n   503→\n   504→    # 计算激励消息\n   505→    if current_streak >= 30:\n   506→        motivation = \"太棒了！一个月的坚持，你正在重塑自己！\"\n   507→    elif current_streak >= 14:\n   508→        motivation = \"两周了！习惯正在形成，继续保持！\"\n   509→    elif current_streak >= 7:\n   510→        motivation = \"一周连续签到！你已经超越了大多数人！\"\n   511→    elif current_streak >= 3:\n   512→        motivation = \"连续三天，好的开始！\"\n   513→    elif current_streak >= 1:\n   514→        motivation = \"今天是新的开始！\"\n   515→    else:\n   516→        motivation = \"准备好开始你的旅程了吗？\"\n   517→\n   518→    return {\n   519→        \"card_type\": \"progress_streak\",\n   520→        \"data\": {\n   521→            \"current_streak\": current_streak,\n   522→            \"longest_streak\": longest_streak,\n   523→            \"total_checkins\": args.get(\"total_checkins\", 0),\n   524→            \"weekly_completion_rate\": args.get(\"weekly_completion_rate\", 0),\n   525→            \"monthly_stats\": args.get(\"monthly_stats\", {}),\n   526→            \"achievements\": args.get(\"achievements\", []),\n   527→            \"motivation\": motivation,\n   528→            \"generated_at\": datetime.utcnow().isoformat()\n   529→        }\n   530→    }\n   531→\n   532→\n   533→# ═══════════════════════════════════════════════════════════════════════════\n   534→# 展示工具 - V1 保留 (使用 @tool_handler 重写)\n   535→# ═══════════════════════════════════════════════════════════════════════════\n   536→\n   537→@tool_handler(\"show_pattern_insight\")\n   538→async def show_pattern_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   539→    \"\"\"\n   540→    展示行为模式洞察卡片\n   541→    \"\"\"\n   542→    pattern_type = args.get(\"pattern_type\", \"behavior\")\n   543→\n   544→    type_labels = {\n   545→        \"behavior\": \"行为模式\",\n   546→        \"stuck\": \"卡点分析\",\n   547→        \"conflict\": \"目标冲突\",\n   548→        \"protection\": \"自我保护\"\n   549→    }\n   550→\n   551→    return {\n   552→        \"card_type\": \"pattern_insight\",\n   553→        \"data\": {\n   554→            \"type\": pattern_type,\n   555→            \"type_label\": type_labels.get(pattern_type, \"模式分析\"),\n   556→            \"surface_pattern\": args.get(\"surface_pattern\", \"\"),\n   557→            \"hidden_goal\": args.get(\"hidden_goal\"),\n   558→            \"cost\": args.get(\"cost\"),\n   559→            \"insight\": args.get(\"insight\"),\n   560→            \"generated_at\": datetime.utcnow().isoformat()\n   561→        }\n   562→    }\n   563→\n   564→\n   565→@tool_handler(\"show_identity_design\")\n   566→async def show_identity_design(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   567→    \"\"\"\n   568→    展示身份设计卡片\n   569→    \"\"\"\n   570→    return {\n   571→        \"card_type\": \"identity_design\",\n   572→        \"data\": {\n   573→            \"old_identity\": args.get(\"old_identity\"),\n   574→            \"new_identity\": args.get(\"new_identity\", \"\"),\n   575→            \"bridge_belief\": args.get(\"bridge_belief\"),\n   576→            \"anchor_behaviors\": args.get(\"anchor_behaviors\", []),\n   577→            \"transformation_arrow\": \"→\" if args.get(\"old_identity\") else None,\n   578→            \"generated_at\": datetime.utcnow().isoformat()\n   579→        }\n   580→    }\n   581→\n   582→\n   583→@tool_handler(\"show_vision_map\")\n   584→async def show_vision_map(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   585→    \"\"\"\n   586→    展示愿景/反愿景地图\n   587→    \"\"\"\n   588→    map_type = args.get(\"map_type\", \"vision\")\n   589→\n   590→    return {\n   591→        \"card_type\": \"vision_map\",\n   592→        \"data\": {\n   593→            \"map_type\": map_type,\n   594→            \"vision\": {\n   595→                \"statement\": args.get(\"vision_statement\"),\n   596→                \"three_year_picture\": args.get(\"three_year_picture\"),\n   597→                \"identity_belief\": args.get(\"identity_belief\"),\n   598→                \"one_year_milestone\": args.get(\"one_year_milestone\")\n   599→            } if map_type in [\"vision\", \"both\"] else None,\n   600→            \"anti_vision\": {\n   601→                \"statement\": args.get(\"anti_vision_statement\"),\n   602→                \"five_year_picture\": args.get(\"five_year_picture\")\n   603→            } if map_type in [\"anti_vision\", \"both\"] else None,\n   604→            \"generated_at\": datetime.utcnow().isoformat()\n   605→        }\n   606→    }\n   607→\n   608→\n   609→@tool_handler(\"show_action_plan\")\n   610→async def show_action_plan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   611→    \"\"\"\n   612→    展示行动计划卡片\n   613→    \"\"\"\n   614→    return {\n   615→        \"card_type\": \"action_plan\",\n   616→        \"data\": {\n   617→            \"context\": args.get(\"context\"),\n   618→            \"hierarchy\": {\n   619→                \"one_year_goal\": args.get(\"one_year_goal\"),\n   620→                \"one_month_project\": args.get(\"one_month_project\"),\n   621→                \"daily_actions\": args.get(\"daily_actions\", [])\n   622→            },\n   623→            \"first_step\": args.get(\"first_step\"),\n   624→            \"generated_at\": datetime.utcnow().isoformat()\n   625→        }\n   626→    }\n   627→\n   628→\n   629→@tool_handler(\"show_life_game\")\n   630→async def show_life_game(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   631→    \"\"\"\n   632→    展示人生游戏设计卡片\n   633→    \"\"\"\n   634→    return {\n   635→        \"card_type\": \"life_game\",\n   636→        \"data\": {\n   637→            \"win_condition\": args.get(\"win_condition\", \"\"),\n   638→            \"lose_condition\": args.get(\"lose_condition\", \"\"),\n   639→            \"main_mission\": args.get(\"main_mission\", \"\"),\n   640→            \"current_boss\": {\n   641→                \"name\": args.get(\"current_boss\"),\n   642→                \"reward\": args.get(\"boss_reward\")\n   643→            } if args.get(\"current_boss\") else None,\n   644→            \"daily_quests\": args.get(\"daily_quests\", []),\n   645→            \"game_rules\": args.get(\"game_rules\", []),\n   646→            \"generated_at\": datetime.utcnow().isoformat()\n   647→        }\n   648→    }\n   649→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2af7f490-8088-404f-916c-d77b64b2ff19","timestamp":"2026-01-19T12:16:08.081Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py","content":"\"\"\"\nLifecoach Skill - Tool Handlers V2\n\n使用 @tool_handler 装饰器注册工具执行器。\n支持数据持久化和展示卡片生成。\n\n数据结构 (与 DATA-STRUCTURE.md 对齐):\n- system: 系统配置（方法论、角色设定）\n- north_star: 北极星愿景、反愿景、使命、原则\n- goals: 核心目标（最多3个），包含年度目标\n- roadmap: 路线图（年度、季度）\n- current: 当前焦点（月度项目 current.month、周大石头 current.week、每日杠杆 current.daily）\n- identity: 身份设计（当前身份、目标身份、锚定行为）\n- progress: 进度追踪（签到、连续天数）\n- journal: 复盘日志（数组）\n\"\"\"\n\nimport uuid\nfrom typing import Any, Dict, List, Optional\nfrom datetime import datetime, date\n\nfrom services.agent.tool_registry import tool_handler, ToolContext\nfrom stores.unified_profile_repo import UnifiedProfileRepository\n\n\n# 有效的 section 列表（与 DATA-STRUCTURE.md 对齐）\nVALID_SECTIONS = [\"system\", \"north_star\", \"goals\", \"roadmap\", \"current\", \"identity\", \"progress\", \"journal\"]\n\n\ndef deep_merge(base: Dict, update: Dict) -> Dict:\n    \"\"\"深度合并两个字典\"\"\"\n    result = base.copy()\n    for key, value in update.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        elif value is not None:\n            result[key] = value\n    return result\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 数据工具 (V2 - 与 DATA-STRUCTURE.md 对齐)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"read_lifecoach_state\")\nasync def read_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    读取用户的人生地图状态\n\n    从 unified_profile 的 life_context.lifecoach 路径读取数据\n    支持的 sections: system, north_star, goals, roadmap, current, identity, progress, journal\n    \"\"\"\n    sections = args.get(\"sections\", [\"north_star\", \"goals\", \"current\", \"progress\"])\n\n    try:\n        # 从 unified_profile 读取 lifecoach 数据\n        data = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        if not data or not data.content:\n            return {\n                \"status\": \"empty\",\n                \"message\": \"尚未建立人生地图，让我们开始吧！\",\n                \"data\": {}\n            }\n\n        # 按请求的 sections 过滤返回\n        result = {}\n        content = data.content\n        for section in sections:\n            if section in content:\n                result[section] = content[section]\n\n        return {\n            \"status\": \"success\",\n            \"data\": result,\n            \"version\": data.version,\n            \"updated_at\": data.updated_at.isoformat() if data.updated_at else None\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"读取状态失败: {str(e)}\",\n            \"data\": {}\n        }\n\n\n@tool_handler(\"write_lifecoach_state\")\nasync def write_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    写入用户的人生地图状态\n\n    支持的 section: system, north_star, goals, roadmap, current, identity, progress\n    使用深度合并，避免覆盖已有数据\n\n    特别说明 - current 的嵌套结构:\n    - current.month: 月度项目\n    - current.week: 周大石头\n    - current.daily: 每日杠杆\n\n    示例：\n    write_lifecoach_state(section=\"current\", data={\"week\": {\"rocks\": [...]}})\n    会合并到 current.week，不会覆盖 current.month 和 current.daily\n    \"\"\"\n    section = args.get(\"section\")\n    data = args.get(\"data\")\n\n    if not section or not data:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: section 和 data\"\n        }\n\n    # 验证 section 有效性\n    if section not in VALID_SECTIONS:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"无效的 section: {section}。有效值: {', '.join(VALID_SECTIONS)}\"\n        }\n\n    try:\n        # 先读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        # 深度合并数据\n        content = existing.content if existing else {}\n\n        # 如果是 current 或其他嵌套结构，使用深度合并\n        if section in content and isinstance(content[section], dict) and isinstance(data, dict):\n            content[section] = deep_merge(content[section], data)\n        else:\n            content[section] = data\n\n        # 更新元信息\n        content[\"_last_updated\"] = datetime.utcnow().isoformat()\n        content[\"_last_section\"] = section\n\n        # 写入\n        result = await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            content\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": f\"已保存 {section}\",\n            \"version\": result.version\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"保存失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"add_journal_entry\")\nasync def add_journal_entry(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    添加复盘日志条目\n\n    与 DATA-STRUCTURE.md 的 journal 结构对齐:\n    journal 是一个数组，每个条目包含:\n    - date: 日期\n    - type: daily | weekly | monthly | quarterly | insight\n    - mood: 心情 (1-10)\n    - energy: 能量 (1-10)\n    - rocks_completed: 完成的大石头数\n    - rocks_total: 总大石头数\n    - goal_balance: 目标平衡统计 (周复盘)\n    - wins: 胜利列表\n    - struggles: 挑战列表\n    - insight: 洞察\n    - gratitude: 感恩\n    - tomorrow: 明天计划\n    - next_week_focus: 下周聚焦\n    \"\"\"\n    entry_type = args.get(\"entry_type\")\n    content = args.get(\"content\")\n\n    if not entry_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: entry_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        # journal 是一个数组（与 DATA-STRUCTURE.md 对齐）\n        journal = lifecoach_data.get(\"journal\", [])\n        if isinstance(journal, dict):\n            # 兼容旧格式：从 entries 数组迁移\n            journal = journal.get(\"entries\", [])\n\n        today = date.today().isoformat()\n\n        # 创建新条目（与 DATA-STRUCTURE.md 字段对齐）\n        entry = {\n            \"date\": args.get(\"date\", today),\n            \"type\": entry_type,\n            \"content\": content,  # 额外字段：摘要内容\n            \"mood\": args.get(\"mood\"),\n            \"energy\": args.get(\"energy\"),\n            \"rocks_completed\": args.get(\"rocks_completed\"),\n            \"rocks_total\": args.get(\"rocks_total\"),\n            \"goal_balance\": args.get(\"goal_balance\"),  # 周复盘用\n            \"wins\": args.get(\"wins\", []),\n            \"struggles\": args.get(\"blockers\", []),  # 兼容旧参数名\n            \"insight\": args.get(\"insight\"),\n            \"gratitude\": args.get(\"gratitude\"),\n            \"tomorrow\": args.get(\"tomorrow\"),\n            \"next_week_focus\": args.get(\"next_week_focus\"),\n            \"adjustments\": args.get(\"adjustments\", []),\n            \"learnings\": args.get(\"learnings\", []),\n            \"_created_at\": datetime.utcnow().isoformat(),\n        }\n\n        # 清理 None 值\n        entry = {k: v for k, v in entry.items() if v is not None}\n\n        # 添加到日志列表（最新在前）\n        journal = [entry] + journal[:99]  # 保留最近100条\n\n        # 保存\n        lifecoach_data[\"journal\"] = journal\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"日志已记录\",\n            \"date\": entry[\"date\"],\n            \"type\": entry_type\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"记录失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"update_progress\")\nasync def update_progress(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    更新进度/签到\n    \"\"\"\n    action_type = args.get(\"action_type\")\n\n    if not action_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: action_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        progress = lifecoach_data.get(\"progress\", {\n            \"current_streak\": 0,\n            \"longest_streak\": 0,\n            \"total_checkins\": 0,\n            \"last_checkin_date\": None,\n            \"checkin_history\": [],\n            \"completed_levers\": [],\n            \"completed_rocks\": [],\n            \"milestones\": []\n        })\n\n        today = date.today().isoformat()\n        now = datetime.utcnow().isoformat()\n\n        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到\n            last_date = progress.get(\"last_checkin_date\")\n            if last_date:\n                last = date.fromisoformat(last_date)\n                today_date = date.today()\n                diff = (today_date - last).days\n                if diff == 1:\n                    progress[\"current_streak\"] += 1\n                elif diff > 1:\n                    progress[\"current_streak\"] = 1\n            else:\n                progress[\"current_streak\"] = 1\n\n            # 更新最长连续\n            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):\n                progress[\"longest_streak\"] = progress[\"current_streak\"]\n\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史\n            history = progress.get(\"checkin_history\", [])\n            history.append({\n                \"date\": today,\n                \"time\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天\n\n        elif action_type == \"lever_complete\":\n            lever_id = args.get(\"lever_id\")\n            if lever_id:\n                completed = progress.get(\"completed_levers\", [])\n                completed.append({\n                    \"id\": lever_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_levers\"] = completed[-100:]\n\n        elif action_type == \"rock_complete\":\n            rock_id = args.get(\"rock_id\")\n            if rock_id:\n                completed = progress.get(\"completed_rocks\", [])\n                completed.append({\n                    \"id\": rock_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_rocks\"] = completed[-50:]\n\n        elif action_type == \"milestone_reached\":\n            milestones = progress.get(\"milestones\", [])\n            milestones.append({\n                \"reached_at\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"milestones\"] = milestones\n\n        # 保存\n        lifecoach_data[\"progress\"] = progress\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"进度已更新\",\n            \"current_streak\": progress.get(\"current_streak\", 0),\n            \"total_checkins\": progress.get(\"total_checkins\", 0)\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"更新失败: {str(e)}\"\n        }\n\n\n# ══════════════════��════════════════════════════════════════════════════════\n# 展示工具 - V2 新增\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_life_roadmap\")\nasync def show_life_roadmap(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生路线图卡片\n    \"\"\"\n    north_star = args.get(\"north_star\", {})\n\n    return {\n        \"card_type\": \"life_roadmap\",\n        \"data\": {\n            \"north_star\": north_star,\n            \"yearly_theme\": args.get(\"yearly_theme\"),\n            \"quarterly_milestones\": args.get(\"quarterly_milestones\", []),\n            \"current_focus\": args.get(\"current_focus\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n\n    # 计算平衡分数\n    if roles:\n        scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n        if scores:\n            avg = sum(scores) / len(scores)\n            variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n            # 平衡分数：平均分越高、方差越小，分数越高\n            balance_score = min(100, max(0, avg * 10 - variance * 2))\n        else:\n            balance_score = 0\n    else:\n        balance_score = args.get(\"balance_score\", 0)\n\n    return {\n        \"card_type\": \"role_balance\",\n        \"data\": {\n            \"roles\": roles,\n            \"balance_score\": round(balance_score, 1),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    # 计算完成进度\n    total = len(rocks)\n    completed = sum(1 for r in rocks if r.get(\"status\") == \"completed\")\n    in_progress = sum(1 for r in rocks if r.get(\"status\") == \"in_progress\")\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"in_progress\": in_progress,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    # 计算完成进度\n    total = len(levers)\n    completed = sum(1 for l in levers if l.get(\"status\") == \"completed\")\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_progress_streak\")\nasync def show_progress_streak(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示连续签到和进度统计卡片\n    \"\"\"\n    current_streak = args.get(\"current_streak\", 0)\n    longest_streak = args.get(\"longest_streak\", current_streak)\n\n    # 计算激励消息\n    if current_streak >= 30:\n        motivation = \"太棒了！一个月的坚持，你正在重塑自己！\"\n    elif current_streak >= 14:\n        motivation = \"两周了！习惯正在形成，继续保持！\"\n    elif current_streak >= 7:\n        motivation = \"一周连续签到！你已经超越了大多数人！\"\n    elif current_streak >= 3:\n        motivation = \"连续三天，好的开始！\"\n    elif current_streak >= 1:\n        motivation = \"今天是新的开始！\"\n    else:\n        motivation = \"准备好开始你的旅程了吗？\"\n\n    return {\n        \"card_type\": \"progress_streak\",\n        \"data\": {\n            \"current_streak\": current_streak,\n            \"longest_streak\": longest_streak,\n            \"total_checkins\": args.get(\"total_checkins\", 0),\n            \"weekly_completion_rate\": args.get(\"weekly_completion_rate\", 0),\n            \"monthly_stats\": args.get(\"monthly_stats\", {}),\n            \"achievements\": args.get(\"achievements\", []),\n            \"motivation\": motivation,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 展示工具 - V1 保留 (使用 @tool_handler 重写)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_pattern_insight\")\nasync def show_pattern_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行为模式洞察卡片\n    \"\"\"\n    pattern_type = args.get(\"pattern_type\", \"behavior\")\n\n    type_labels = {\n        \"behavior\": \"行为模式\",\n        \"stuck\": \"卡点分析\",\n        \"conflict\": \"目标冲突\",\n        \"protection\": \"自我保护\"\n    }\n\n    return {\n        \"card_type\": \"pattern_insight\",\n        \"data\": {\n            \"type\": pattern_type,\n            \"type_label\": type_labels.get(pattern_type, \"模式分析\"),\n            \"surface_pattern\": args.get(\"surface_pattern\", \"\"),\n            \"hidden_goal\": args.get(\"hidden_goal\"),\n            \"cost\": args.get(\"cost\"),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_identity_design\")\nasync def show_identity_design(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示身份设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"identity_design\",\n        \"data\": {\n            \"old_identity\": args.get(\"old_identity\"),\n            \"new_identity\": args.get(\"new_identity\", \"\"),\n            \"bridge_belief\": args.get(\"bridge_belief\"),\n            \"anchor_behaviors\": args.get(\"anchor_behaviors\", []),\n            \"transformation_arrow\": \"→\" if args.get(\"old_identity\") else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_vision_map\")\nasync def show_vision_map(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示愿景/反愿景地图\n    \"\"\"\n    map_type = args.get(\"map_type\", \"vision\")\n\n    return {\n        \"card_type\": \"vision_map\",\n        \"data\": {\n            \"map_type\": map_type,\n            \"vision\": {\n                \"statement\": args.get(\"vision_statement\"),\n                \"three_year_picture\": args.get(\"three_year_picture\"),\n                \"identity_belief\": args.get(\"identity_belief\"),\n                \"one_year_milestone\": args.get(\"one_year_milestone\")\n            } if map_type in [\"vision\", \"both\"] else None,\n            \"anti_vision\": {\n                \"statement\": args.get(\"anti_vision_statement\"),\n                \"five_year_picture\": args.get(\"five_year_picture\")\n            } if map_type in [\"anti_vision\", \"both\"] else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_action_plan\")\nasync def show_action_plan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行动计划卡片\n    \"\"\"\n    return {\n        \"card_type\": \"action_plan\",\n        \"data\": {\n            \"context\": args.get(\"context\"),\n            \"hierarchy\": {\n                \"one_year_goal\": args.get(\"one_year_goal\"),\n                \"one_month_project\": args.get(\"one_month_project\"),\n                \"daily_actions\": args.get(\"daily_actions\", [])\n            },\n            \"first_step\": args.get(\"first_step\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_life_game\")\nasync def show_life_game(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生游戏设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"life_game\",\n        \"data\": {\n            \"win_condition\": args.get(\"win_condition\", \"\"),\n            \"lose_condition\": args.get(\"lose_condition\", \"\"),\n            \"main_mission\": args.get(\"main_mission\", \"\"),\n            \"current_boss\": {\n                \"name\": args.get(\"current_boss\"),\n                \"reward\": args.get(\"boss_reward\")\n            } if args.get(\"current_boss\") else None,\n            \"daily_quests\": args.get(\"daily_quests\", []),\n            \"game_rules\": args.get(\"game_rules\", []),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n","numLines":649,"startLine":1,"totalLines":649}},"sourceToolAssistantUUID":"7fffd7e1-c618-41a0-8910-2b0b01796c97"}
{"parentUuid":"2597ed1c-fbfa-4c9f-bc06-3a524ba54835","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NTnWjPK9iVLiypsEf8V3Yf","type":"tool_result","content":"     1→\"\"\"\n     2→TriggerDetector - 触发条件检测器\n     3→\n     4→支持三种触发类型:\n     5→1. time_based - 基于时间 (cron 表达式)\n     6→2. event_based - 基于事件 (节气、月相、生日、大运交接等)\n     7→3. threshold_based - 基于阈值 (运势分数等)\n     8→\n     9→设计原则:\n    10→- 从 unified_profiles 读取数据\n    11→- 支持 Skill 级自定义事件\n    12→- 智能化: 事件触发 + 阈值触发\n    13→\"\"\"\n    14→\n    15→import logging\n    16→from datetime import datetime, date, timedelta\n    17→from typing import Dict, Any, Optional, Tuple, List\n    18→\n    19→import pytz\n    20→\n    21→from skills.zodiac.services.events import ZodiacEvents\n    22→\n    23→logger = logging.getLogger(__name__)\n    24→\n    25→\n    26→class TriggerDetector:\n    27→    \"\"\"触发条件检测器\"\"\"\n    28→\n    29→    def __init__(self):\n    30→        self._event_detectors = {\n    31→            \"birthday\": self._detect_birthday,\n    32→            \"dayun_change\": self._detect_dayun_change,\n    33→            \"new_year\": self._detect_new_year,\n    34→            \"solar_term\": self._detect_solar_term,\n    35→            \"lunar_phase\": self._detect_lunar_phase,\n    36→            \"mercury_retrograde\": self._detect_mercury_retrograde,\n    37→            \"significant_transit\": self._detect_significant_transit,\n    38→            # Lifecoach 事件\n    39→            \"streak_broken\": self._detect_streak_broken,\n    40→        }\n    41→\n    42→        # Lifecoach 条件检查器 (用于 reminders.yaml conditions)\n    43→        self._condition_checkers = {\n    44→            \"has_data\": self._check_has_data,\n    45→            \"not_checked_in_today\": self._check_not_checked_in_today,\n    46→            \"checked_in_today\": self._check_checked_in_today,\n    47→            \"has_weekly_data\": self._check_has_weekly_data,\n    48→            \"not_reviewed_this_week\": self._check_not_reviewed_this_week,\n    49→            \"not_planned_this_week\": self._check_not_planned_this_week,\n    50→            \"has_pending_levers\": self._check_has_pending_levers,\n    51→            \"had_streak\": self._check_had_streak,\n    52→        }\n    53→\n    54→    async def should_trigger(\n    55→        self,\n    56→        trigger_config: Dict[str, Any],\n    57→        profile: Dict[str, Any],\n    58→        skill_id: str,\n    59→        conditions: Optional[List[Dict]] = None,\n    60→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n    61→        \"\"\"\n    62→        检测是否应该触发\n    63→\n    64→        Args:\n    65→            trigger_config: 触发配置 (type, schedule 等)\n    66→            profile: 用户 profile\n    67→            skill_id: Skill ID\n    68→            conditions: 额外条件列表 (来自 reminders.yaml)\n    69→\n    70→        Returns:\n    71→            (should_trigger, event_info)\n    72→            - should_trigger: 是否触发\n    73→            - event_info: 事件信息 (event_name, event_date 等)\n    74→        \"\"\"\n    75→        trigger_type = trigger_config.get(\"type\")\n    76→\n    77→        # 1. 检查触发条件\n    78→        if trigger_type == \"time_based\":\n    79→            triggered = self._check_time_based(trigger_config, profile)\n    80→            event_info = None\n    81→        elif trigger_type == \"event_based\":\n    82→            triggered, event_info = await self._check_event_based(trigger_config, profile, skill_id)\n    83→        elif trigger_type == \"threshold_based\":\n    84→            triggered, event_info = await self._check_threshold_based(trigger_config, profile, skill_id)\n    85→        else:\n    86→            return False, None\n    87→\n    88→        if not triggered:\n    89→            return False, None\n    90→\n    91→        # 2. 检查额外条件 (所有条件必须满足)\n    92→        if conditions:\n    93→            for condition in conditions:\n    94→                if not await self._check_condition(condition, profile, skill_id):\n    95→                    return False, None\n    96→\n    97→        return True, event_info\n    98→\n    99→    async def _check_condition(\n   100→        self,\n   101→        condition: Dict[str, Any],\n   102→        profile: Dict[str, Any],\n   103→        skill_id: str,\n   104→    ) -> bool:\n   105→        \"\"\"检查单个条件\"\"\"\n   106→        condition_type = condition.get(\"type\")\n   107→        checker = self._condition_checkers.get(condition_type)\n   108→\n   109→        if not checker:\n   110→            logger.warning(f\"Unknown condition type: {condition_type}\")\n   111→            return True  # 未知条件默认通过\n   112→\n   113→        try:\n   114→            return await checker(condition, profile, skill_id)\n   115→        except Exception as e:\n   116→            logger.error(f\"Failed to check condition {condition_type}: {e}\")\n   117→            return False\n   118→\n   119→    def _check_time_based(self, config: Dict, profile: Dict) -> bool:\n   120→        \"\"\"\n   121→        检查时间触发条件\n   122→\n   123→        支持简化的 cron 格式: \"0 4 * * *\" (分 时 日 月 周)\n   124→        \"\"\"\n   125→        schedule = config.get(\"schedule\", \"\")\n   126→        timezone_aware = config.get(\"timezone_aware\", True)\n   127→\n   128→        if not schedule:\n   129→            return False\n   130→\n   131→        # 获取用户时区\n   132→        if timezone_aware:\n   133→            user_tz = profile.get(\"preferences\", {}).get(\"timezone\", \"Asia/Shanghai\")\n   134→            try:\n   135→                now = datetime.now(pytz.timezone(user_tz))\n   136→            except Exception:\n   137→                now = datetime.now(pytz.timezone(\"Asia/Shanghai\"))\n   138→        else:\n   139→            now = datetime.now(pytz.UTC)\n   140→\n   141→        # 解析 cron 表达式\n   142→        return self._match_cron(schedule, now)\n   143→\n   144→    def _match_cron(self, schedule: str, now: datetime) -> bool:\n   145→        \"\"\"匹配简化的 cron 表达式\"\"\"\n   146→        try:\n   147→            parts = schedule.split()\n   148→            if len(parts) != 5:\n   149→                return False\n   150→\n   151→            minute, hour, day, month, weekday = parts\n   152→\n   153→            # 检查各字段\n   154→            if minute != \"*\" and int(minute) != now.minute:\n   155→                return False\n   156→            if hour != \"*\" and int(hour) != now.hour:\n   157→                return False\n   158→            if day != \"*\" and int(day) != now.day:\n   159→                return False\n   160→            if month != \"*\" and int(month) != now.month:\n   161→                return False\n   162→            if weekday != \"*\" and int(weekday) != now.weekday():\n   163→                return False\n   164→\n   165→            return True\n   166→        except Exception as e:\n   167→            logger.error(f\"Failed to parse cron schedule '{schedule}': {e}\")\n   168→            return False\n   169→\n   170→    async def _check_event_based(\n   171→        self,\n   172→        config: Dict,\n   173→        profile: Dict,\n   174→        skill_id: str,\n   175→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   176→        \"\"\"检查事件触发条件\"\"\"\n   177→        event = config.get(\"event\")\n   178→        advance_days = config.get(\"advance_days\", [0])\n   179→\n   180→        # 确保 advance_days 是列表\n   181→        if isinstance(advance_days, int):\n   182→            advance_days = [advance_days]\n   183→\n   184→        detector = self._event_detectors.get(event)\n   185→        if not detector:\n   186→            logger.warning(f\"Unknown event type: {event}\")\n   187→            return False, None\n   188→\n   189→        return await detector(profile, advance_days, skill_id)\n   190→\n   191→    async def _check_threshold_based(\n   192→        self,\n   193→        config: Dict,\n   194→        profile: Dict,\n   195→        skill_id: str,\n   196→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   197→        \"\"\"检查阈值触发条件\"\"\"\n   198→        metric = config.get(\"metric\")\n   199→        condition = config.get(\"condition\")\n   200→        threshold = config.get(\"threshold\")\n   201→        cooldown = config.get(\"cooldown\", 0)\n   202→\n   203→        # 获取指标值\n   204→        value = await self._get_metric_value(metric, profile, skill_id)\n   205→        if value is None:\n   206→            return False, None\n   207→\n   208→        # TODO: 检查冷却期 (需要记录上次触发时间)\n   209→\n   210→        # 检查条件\n   211→        triggered = False\n   212→        if condition == \"<\":\n   213→            triggered = value < threshold\n   214→        elif condition == \">\":\n   215→            triggered = value > threshold\n   216→        elif condition == \"<=\":\n   217→            triggered = value <= threshold\n   218→        elif condition == \">=\":\n   219→            triggered = value >= threshold\n   220→        elif condition == \"==\":\n   221→            triggered = value == threshold\n   222→\n   223→        if triggered:\n   224→            return True, {\"metric\": metric, \"value\": value, \"threshold\": threshold}\n   225→\n   226→        return False, None\n   227→\n   228→    async def _get_metric_value(\n   229→        self,\n   230→        metric: str,\n   231→        profile: Dict,\n   232→        skill_id: str,\n   233→    ) -> Optional[float]:\n   234→        \"\"\"获取指标值\"\"\"\n   235→        if metric == \"daily_fortune_score\":\n   236→            # 计算今日运势分数\n   237→            from skills.bazi.services import BaziComputer\n   238→            computer = BaziComputer()\n   239→            return await computer.get_daily_fortune_score(profile)\n   240→\n   241→        # 可扩展其他指标\n   242→        return None\n   243→\n   244→    # ═════════════════���═════════════════════════════════════════════════════════\n   245→    # 事件检测器\n   246→    # ═══════════════════════════════════════════════════════════════════════════\n   247→\n   248→    async def _detect_birthday(\n   249→        self,\n   250→        profile: Dict,\n   251→        advance_days: List[int],\n   252→        skill_id: str,\n   253→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   254→        \"\"\"检测生日\"\"\"\n   255→        birth_info = profile.get(\"birth_info\", {})\n   256→        birth_date_str = birth_info.get(\"date\")\n   257→\n   258→        if not birth_date_str:\n   259→            return False, None\n   260→\n   261→        try:\n   262→            birth = datetime.strptime(birth_date_str, \"%Y-%m-%d\").date()\n   263→        except ValueError:\n   264→            return False, None\n   265→\n   266→        today = date.today()\n   267→        birthday_this_year = date(today.year, birth.month, birth.day)\n   268→\n   269→        # 如果今年生日已过，检查明年\n   270→        if birthday_this_year < today:\n   271→            birthday_this_year = date(today.year + 1, birth.month, birth.day)\n   272→\n   273→        days_until = (birthday_this_year - today).days\n   274→\n   275→        if days_until in advance_days:\n   276→            event_name = \"birthday\" if days_until == 0 else f\"birthday_{days_until}days\"\n   277→            return True, {\n   278→                \"event_name\": event_name,\n   279→                \"event_date\": birthday_this_year,\n   280→                \"days_until\": days_until,\n   281→            }\n   282→\n   283→        return False, None\n   284→\n   285→    async def _detect_dayun_change(\n   286→        self,\n   287→        profile: Dict,\n   288→        advance_days: List[int],\n   289→        skill_id: str,\n   290→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   291→        \"\"\"检测大运交接\"\"\"\n   292→        from skills.bazi.services import BaziComputer\n   293→\n   294→        computer = BaziComputer()\n   295→        inflection_points = await computer.get_inflection_points(profile)\n   296→\n   297→        today = date.today()\n   298→\n   299→        for point in inflection_points:\n   300→            if point.get(\"type\") == \"major_cycle_change\":\n   301→                point_year = point.get(\"year\")\n   302→                if point_year:\n   303→                    # 大运交接通常在年初\n   304→                    point_date = date(point_year, 1, 1)\n   305→                    days_until = (point_date - today).days\n   306→\n   307→                    if days_until in advance_days:\n   308→                        return True, {\n   309→                            \"event_name\": point.get(\"title\", \"大运交接\"),\n   310→                            \"event_date\": point_date,\n   311→                            \"days_until\": days_until,\n   312→                            \"point\": point,\n   313→                        }\n   314→\n   315→        return False, None\n   316→\n   317→    async def _detect_new_year(\n   318→        self,\n   319→        profile: Dict,\n   320→        advance_days: List[int],\n   321→        skill_id: str,\n   322→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   323→        \"\"\"检测新年\"\"\"\n   324→        today = date.today()\n   325→        next_new_year = date(today.year + 1, 1, 1)\n   326→\n   327→        # 如果今天是元旦\n   328→        if today.month == 1 and today.day == 1:\n   329→            if 0 in advance_days:\n   330→                return True, {\n   331→                    \"event_name\": \"new_year\",\n   332→                    \"event_date\": today,\n   333→                    \"days_until\": 0,\n   334→                }\n   335→\n   336→        days_until = (next_new_year - today).days\n   337→\n   338→        if days_until in advance_days:\n   339→            return True, {\n   340→                \"event_name\": \"new_year\",\n   341→                \"event_date\": next_new_year,\n   342→                \"days_until\": days_until,\n   343→            }\n   344→\n   345→        return False, None\n   346→\n   347→    async def _detect_solar_term(\n   348→        self,\n   349→        profile: Dict,\n   350→        advance_days: List[int],\n   351→        skill_id: str,\n   352→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   353→        \"\"\"检测节气\"\"\"\n   354→        # 使用 ZodiacEvents 获取节气信息\n   355→        today = date.today()\n   356→\n   357→        try:\n   358→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n   359→\n   360→            for event in events:\n   361→                if event.event_type == \"solar_term\":\n   362→                    days_until = (event.start_date - today).days\n   363→                    if days_until in advance_days:\n   364→                        return True, {\n   365→                            \"event_name\": event.name,\n   366→                            \"event_date\": event.start_date,\n   367→                            \"days_until\": days_until,\n   368→                            \"description\": event.description,\n   369→                        }\n   370→        except Exception as e:\n   371→            logger.error(f\"Failed to detect solar term: {e}\")\n   372→\n   373→        return False, None\n   374→\n   375→    async def _detect_lunar_phase(\n   376→        self,\n   377→        profile: Dict,\n   378→        advance_days: List[int],\n   379→        skill_id: str,\n   380→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   381→        \"\"\"检测月相 (新月/满月)\"\"\"\n   382→        today = date.today()\n   383→\n   384→        try:\n   385→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n   386→\n   387→            for event in events:\n   388→                if event.event_type in (\"new_moon\", \"full_moon\"):\n   389→                    days_until = (event.start_date - today).days\n   390→                    if days_until in advance_days:\n   391→                        return True, {\n   392→                            \"event_name\": event.name,\n   393→                            \"event_date\": event.start_date,\n   394→                            \"days_until\": days_until,\n   395→                            \"phase\": event.event_type,\n   396→                        }\n   397→        except Exception as e:\n   398→            logger.error(f\"Failed to detect lunar phase: {e}\")\n   399→\n   400→        return False, None\n   401→\n   402→    async def _detect_mercury_retrograde(\n   403→        self,\n   404→        profile: Dict,\n   405→        advance_days: List[int],\n   406→        skill_id: str,\n   407→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   408→        \"\"\"检测水逆\"\"\"\n   409→        today = date.today()\n   410→\n   411→        try:\n   412→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n   413→\n   414→            for event in events:\n   415→                if event.event_type == \"mercury_retrograde\":\n   416→                    days_until = (event.start_date - today).days\n   417→                    if days_until in advance_days:\n   418→                        return True, {\n   419→                            \"event_name\": event.name,\n   420→                            \"event_date\": event.start_date,\n   421→                            \"days_until\": days_until,\n   422→                            \"end_date\": event.end_date,\n   423→                        }\n   424→        except Exception as e:\n   425→            logger.error(f\"Failed to detect mercury retrograde: {e}\")\n   426→\n   427→        return False, None\n   428→\n   429→    async def _detect_significant_transit(\n   430→        self,\n   431→        profile: Dict,\n   432→        advance_days: List[int],\n   433→        skill_id: str,\n   434→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   435→        \"\"\"检测重要行星过境\"\"\"\n   436→        today = date.today()\n   437→\n   438→        try:\n   439→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n   440→\n   441→            significant_types = (\"saturn_return\", \"jupiter_transit\", \"eclipse\")\n   442→\n   443→            for event in events:\n   444→                if event.event_type in significant_types:\n   445→                    days_until = (event.start_date - today).days\n   446→                    if days_until in advance_days:\n   447→                        return True, {\n   448→                            \"event_name\": event.name,\n   449→                            \"event_date\": event.start_date,\n   450→                            \"days_until\": days_until,\n   451→                            \"transit_type\": event.event_type,\n   452→                        }\n   453→        except Exception as e:\n   454→            logger.error(f\"Failed to detect significant transit: {e}\")\n   455→\n   456→        return False, None\n   457→\n   458→    # ═══════════════════════════════════════════════════════════════════════════\n   459→    # Lifecoach 事件检测器\n   460→    # ═══════════════════════════════════════════════════════════════════════════\n   461→\n   462→    async def _detect_streak_broken(\n   463→        self,\n   464→        profile: Dict,\n   465→        advance_days: List[int],\n   466→        skill_id: str,\n   467→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   468→        \"\"\"检测断签事件\"\"\"\n   469→        lifecoach = profile.get(\"life_context\", {}).get(\"_paths\", {}).get(\"lifecoach\", {})\n   470→        progress = lifecoach.get(\"progress\", {})\n   471→\n   472→        last_checkin = progress.get(\"last_checkin_date\")\n   473→        previous_streak = progress.get(\"current_streak\", 0)\n   474→\n   475→        if not last_checkin:\n   476→            return False, None\n   477→\n   478→        try:\n   479→            last_date = datetime.strptime(last_checkin, \"%Y-%m-%d\").date()\n   480→            days_since = (date.today() - last_date).days\n   481→\n   482→            # 断签：超过1天未签到，且之前有连续签到记录\n   483→            if days_since >= 2 and previous_streak >= 3:\n   484→                return True, {\n   485→                    \"event_name\": \"streak_broken\",\n   486→                    \"event_date\": date.today(),\n   487→                    \"days_since_checkin\": days_since,\n   488→                    \"previous_streak\": previous_streak,\n   489→                }\n   490→        except Exception as e:\n   491→            logger.error(f\"Failed to detect streak broken: {e}\")\n   492→\n   493→        return False, None\n   494→\n   495→    # ═══════════════════════════════════════════════════════════════════════════\n   496→    # Lifecoach 条件检查器\n   497→    # ═══════════════════════════════════════════════════════════════════════════\n   498→\n   499→    def _get_lifecoach_data(self, profile: Dict) -> Dict:\n   500→        \"\"\"获取 lifecoach 数据\"\"\"\n   501→        life_context = profile.get(\"life_context\", {})\n   502→        paths = life_context.get(\"_paths\", {})\n   503→        return paths.get(\"lifecoach\", {})\n   504→\n   505→    async def _check_has_data(\n   506→        self,\n   507→        condition: Dict,\n   508→        profile: Dict,\n   509→        skill_id: str,\n   510→    ) -> bool:\n   511→        \"\"\"检查指定路径是否有数据\"\"\"\n   512→        path = condition.get(\"path\", \"\")\n   513→        if not path:\n   514→            return False\n   515→\n   516→        # 解析路径 (e.g., \"lifecoach.north_star.vision_statement\")\n   517→        parts = path.split(\".\")\n   518→        data = profile\n   519→\n   520→        # 处理 life_context._paths 前缀\n   521→        if parts[0] == \"lifecoach\":\n   522→            data = self._get_lifecoach_data(profile)\n   523→            parts = parts[1:]  # 去掉 lifecoach 前缀\n   524→\n   525→        for part in parts:\n   526→            if isinstance(data, dict) and part in data:\n   527→                data = data[part]\n   528→            else:\n   529→                return False\n   530→\n   531→        return bool(data)\n   532→\n   533→    async def _check_not_checked_in_today(\n   534→        self,\n   535→        condition: Dict,\n   536→        profile: Dict,\n   537→        skill_id: str,\n   538→    ) -> bool:\n   539→        \"\"\"检查今天是否未签到\"\"\"\n   540→        lifecoach = self._get_lifecoach_data(profile)\n   541→        progress = lifecoach.get(\"progress\", {})\n   542→        last_checkin = progress.get(\"last_checkin_date\")\n   543→\n   544→        if not last_checkin:\n   545→            return True  # 从未签到\n   546→\n   547→        return last_checkin != date.today().isoformat()\n   548→\n   549→    async def _check_checked_in_today(\n   550→        self,\n   551→        condition: Dict,\n   552→        profile: Dict,\n   553→        skill_id: str,\n   554→    ) -> bool:\n   555→        \"\"\"检查今天是否已签到\"\"\"\n   556→        lifecoach = self._get_lifecoach_data(profile)\n   557→        progress = lifecoach.get(\"progress\", {})\n   558→        last_checkin = progress.get(\"last_checkin_date\")\n   559→\n   560→        if not last_checkin:\n   561→            return False\n   562→\n   563→        return last_checkin == date.today().isoformat()\n   564→\n   565→    async def _check_has_weekly_data(\n   566→        self,\n   567→        condition: Dict,\n   568→        profile: Dict,\n   569→        skill_id: str,\n   570→    ) -> bool:\n   571→        \"\"\"检查是否有本周数据\"\"\"\n   572→        lifecoach = self._get_lifecoach_data(profile)\n   573→        current = lifecoach.get(\"current\", {})\n   574→        week = current.get(\"week\", {})\n   575→\n   576→        return bool(week.get(\"rocks\"))\n   577→\n   578→    async def _check_not_reviewed_this_week(\n   579→        self,\n   580→        condition: Dict,\n   581→        profile: Dict,\n   582→        skill_id: str,\n   583→    ) -> bool:\n   584→        \"\"\"检查本周是否未复盘\"\"\"\n   585→        lifecoach = self._get_lifecoach_data(profile)\n   586→        journal = lifecoach.get(\"journal\", [])\n   587→\n   588→        if not journal:\n   589→            return True\n   590→\n   591→        # 获取本周一的日期\n   592→        today = date.today()\n   593→        monday = today - timedelta(days=today.weekday())\n   594→\n   595→        # 检查是否有本周的 weekly 复盘\n   596→        for entry in journal:\n   597→            if entry.get(\"type\") == \"weekly\":\n   598→                entry_date_str = entry.get(\"date\")\n   599→                if entry_date_str:\n   600→                    try:\n   601→                        entry_date = datetime.strptime(entry_date_str, \"%Y-%m-%d\").date()\n   602→                        if entry_date >= monday:\n   603→                            return False  # 本周已复盘\n   604→                    except ValueError:\n   605→                        continue\n   606→\n   607→        return True\n   608→\n   609→    async def _check_not_planned_this_week(\n   610→        self,\n   611→        condition: Dict,\n   612→        profile: Dict,\n   613→        skill_id: str,\n   614→    ) -> bool:\n   615→        \"\"\"检查本周是否未规划\"\"\"\n   616→        lifecoach = self._get_lifecoach_data(profile)\n   617→        current = lifecoach.get(\"current\", {})\n   618→        week = current.get(\"week\", {})\n   619→\n   620→        week_start = week.get(\"week_start\")\n   621→        if not week_start:\n   622→            return True\n   623→\n   624→        # 获取本周一的日期\n   625→        today = date.today()\n   626→        monday = today - timedelta(days=today.weekday())\n   627→\n   628→        try:\n   629→            planned_week_start = datetime.strptime(week_start, \"%Y-%m-%d\").date()\n   630→            return planned_week_start < monday  # 规划日期在本周之前，说明未规划\n   631→        except ValueError:\n   632→            return True\n   633→\n   634→    async def _check_has_pending_levers(\n   635→        self,\n   636→        condition: Dict,\n   637→        profile: Dict,\n   638→        skill_id: str,\n   639→    ) -> bool:\n   640→        \"\"\"检查是否有未完成的杠杆\"\"\"\n   641→        lifecoach = self._get_lifecoach_data(profile)\n   642→        current = lifecoach.get(\"current\", {})\n   643→        daily = current.get(\"daily\", {})\n   644→        levers = daily.get(\"levers\", [])\n   645→\n   646→        if not levers:\n   647→            return False\n   648→\n   649→        # 检查今天的杠杆\n   650→        today_str = date.today().isoformat()\n   651→        daily_date = daily.get(\"date\")\n   652→\n   653→        if daily_date != today_str:\n   654→            return False  # 不是今天的数据\n   655→\n   656→        pending_count = sum(1 for lever in levers if lever.get(\"status\") != \"completed\")\n   657→        return pending_count > 0\n   658→\n   659→    async def _check_had_streak(\n   660→        self,\n   661→        condition: Dict,\n   662→        profile: Dict,\n   663→        skill_id: str,\n   664→    ) -> bool:\n   665→        \"\"\"检查之前是否有连续签到记录\"\"\"\n   666→        min_days = condition.get(\"min_days\", 3)\n   667→\n   668→        lifecoach = self._get_lifecoach_data(profile)\n   669→        progress = lifecoach.get(\"progress\", {})\n   670→\n   671→        # 检查当前或历史最长连续\n   672→        current_streak = progress.get(\"current_streak\", 0)\n   673→        longest_streak = progress.get(\"longest_streak\", 0)\n   674→\n   675→        return max(current_streak, longest_streak) >= min_days\n   676→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f921451b-6ad5-48e6-aa14-e5dbea97fe3d","timestamp":"2026-01-19T12:16:08.082Z","toolUseResult":{"type":"text","file":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py","content":"\"\"\"\nTriggerDetector - 触发条件检测器\n\n支持三种触发类型:\n1. time_based - 基于时间 (cron 表达式)\n2. event_based - 基于事件 (节气、月相、生日、大运交接等)\n3. threshold_based - 基于阈值 (运势分数等)\n\n设计原则:\n- 从 unified_profiles 读取数据\n- 支持 Skill 级自定义事件\n- 智能化: 事件触发 + 阈值触发\n\"\"\"\n\nimport logging\nfrom datetime import datetime, date, timedelta\nfrom typing import Dict, Any, Optional, Tuple, List\n\nimport pytz\n\nfrom skills.zodiac.services.events import ZodiacEvents\n\nlogger = logging.getLogger(__name__)\n\n\nclass TriggerDetector:\n    \"\"\"触发条件检测器\"\"\"\n\n    def __init__(self):\n        self._event_detectors = {\n            \"birthday\": self._detect_birthday,\n            \"dayun_change\": self._detect_dayun_change,\n            \"new_year\": self._detect_new_year,\n            \"solar_term\": self._detect_solar_term,\n            \"lunar_phase\": self._detect_lunar_phase,\n            \"mercury_retrograde\": self._detect_mercury_retrograde,\n            \"significant_transit\": self._detect_significant_transit,\n            # Lifecoach 事件\n            \"streak_broken\": self._detect_streak_broken,\n        }\n\n        # Lifecoach 条件检查器 (用于 reminders.yaml conditions)\n        self._condition_checkers = {\n            \"has_data\": self._check_has_data,\n            \"not_checked_in_today\": self._check_not_checked_in_today,\n            \"checked_in_today\": self._check_checked_in_today,\n            \"has_weekly_data\": self._check_has_weekly_data,\n            \"not_reviewed_this_week\": self._check_not_reviewed_this_week,\n            \"not_planned_this_week\": self._check_not_planned_this_week,\n            \"has_pending_levers\": self._check_has_pending_levers,\n            \"had_streak\": self._check_had_streak,\n        }\n\n    async def should_trigger(\n        self,\n        trigger_config: Dict[str, Any],\n        profile: Dict[str, Any],\n        skill_id: str,\n        conditions: Optional[List[Dict]] = None,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"\n        检测是否应该触发\n\n        Args:\n            trigger_config: 触发配置 (type, schedule 等)\n            profile: 用户 profile\n            skill_id: Skill ID\n            conditions: 额外条件列表 (来自 reminders.yaml)\n\n        Returns:\n            (should_trigger, event_info)\n            - should_trigger: 是否触发\n            - event_info: 事件信息 (event_name, event_date 等)\n        \"\"\"\n        trigger_type = trigger_config.get(\"type\")\n\n        # 1. 检查触发条件\n        if trigger_type == \"time_based\":\n            triggered = self._check_time_based(trigger_config, profile)\n            event_info = None\n        elif trigger_type == \"event_based\":\n            triggered, event_info = await self._check_event_based(trigger_config, profile, skill_id)\n        elif trigger_type == \"threshold_based\":\n            triggered, event_info = await self._check_threshold_based(trigger_config, profile, skill_id)\n        else:\n            return False, None\n\n        if not triggered:\n            return False, None\n\n        # 2. 检查额外条件 (所有条件必须满足)\n        if conditions:\n            for condition in conditions:\n                if not await self._check_condition(condition, profile, skill_id):\n                    return False, None\n\n        return True, event_info\n\n    async def _check_condition(\n        self,\n        condition: Dict[str, Any],\n        profile: Dict[str, Any],\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查单个条件\"\"\"\n        condition_type = condition.get(\"type\")\n        checker = self._condition_checkers.get(condition_type)\n\n        if not checker:\n            logger.warning(f\"Unknown condition type: {condition_type}\")\n            return True  # 未知条件默认通过\n\n        try:\n            return await checker(condition, profile, skill_id)\n        except Exception as e:\n            logger.error(f\"Failed to check condition {condition_type}: {e}\")\n            return False\n\n    def _check_time_based(self, config: Dict, profile: Dict) -> bool:\n        \"\"\"\n        检查时间触发条件\n\n        支持简化的 cron 格式: \"0 4 * * *\" (分 时 日 月 周)\n        \"\"\"\n        schedule = config.get(\"schedule\", \"\")\n        timezone_aware = config.get(\"timezone_aware\", True)\n\n        if not schedule:\n            return False\n\n        # 获取用户时区\n        if timezone_aware:\n            user_tz = profile.get(\"preferences\", {}).get(\"timezone\", \"Asia/Shanghai\")\n            try:\n                now = datetime.now(pytz.timezone(user_tz))\n            except Exception:\n                now = datetime.now(pytz.timezone(\"Asia/Shanghai\"))\n        else:\n            now = datetime.now(pytz.UTC)\n\n        # 解析 cron 表达式\n        return self._match_cron(schedule, now)\n\n    def _match_cron(self, schedule: str, now: datetime) -> bool:\n        \"\"\"匹配简化的 cron 表达式\"\"\"\n        try:\n            parts = schedule.split()\n            if len(parts) != 5:\n                return False\n\n            minute, hour, day, month, weekday = parts\n\n            # 检查各字段\n            if minute != \"*\" and int(minute) != now.minute:\n                return False\n            if hour != \"*\" and int(hour) != now.hour:\n                return False\n            if day != \"*\" and int(day) != now.day:\n                return False\n            if month != \"*\" and int(month) != now.month:\n                return False\n            if weekday != \"*\" and int(weekday) != now.weekday():\n                return False\n\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to parse cron schedule '{schedule}': {e}\")\n            return False\n\n    async def _check_event_based(\n        self,\n        config: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检查事件触发条件\"\"\"\n        event = config.get(\"event\")\n        advance_days = config.get(\"advance_days\", [0])\n\n        # 确保 advance_days 是列表\n        if isinstance(advance_days, int):\n            advance_days = [advance_days]\n\n        detector = self._event_detectors.get(event)\n        if not detector:\n            logger.warning(f\"Unknown event type: {event}\")\n            return False, None\n\n        return await detector(profile, advance_days, skill_id)\n\n    async def _check_threshold_based(\n        self,\n        config: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检查阈值触发条件\"\"\"\n        metric = config.get(\"metric\")\n        condition = config.get(\"condition\")\n        threshold = config.get(\"threshold\")\n        cooldown = config.get(\"cooldown\", 0)\n\n        # 获取指标值\n        value = await self._get_metric_value(metric, profile, skill_id)\n        if value is None:\n            return False, None\n\n        # TODO: 检查冷却期 (需要记录上次触发时间)\n\n        # 检查条件\n        triggered = False\n        if condition == \"<\":\n            triggered = value < threshold\n        elif condition == \">\":\n            triggered = value > threshold\n        elif condition == \"<=\":\n            triggered = value <= threshold\n        elif condition == \">=\":\n            triggered = value >= threshold\n        elif condition == \"==\":\n            triggered = value == threshold\n\n        if triggered:\n            return True, {\"metric\": metric, \"value\": value, \"threshold\": threshold}\n\n        return False, None\n\n    async def _get_metric_value(\n        self,\n        metric: str,\n        profile: Dict,\n        skill_id: str,\n    ) -> Optional[float]:\n        \"\"\"获取指标值\"\"\"\n        if metric == \"daily_fortune_score\":\n            # 计算今日运势分数\n            from skills.bazi.services import BaziComputer\n            computer = BaziComputer()\n            return await computer.get_daily_fortune_score(profile)\n\n        # 可扩展其他指标\n        return None\n\n    # ═════════════════���═════════════════════════════════════════════════════════\n    # 事件检测器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    async def _detect_birthday(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测生日\"\"\"\n        birth_info = profile.get(\"birth_info\", {})\n        birth_date_str = birth_info.get(\"date\")\n\n        if not birth_date_str:\n            return False, None\n\n        try:\n            birth = datetime.strptime(birth_date_str, \"%Y-%m-%d\").date()\n        except ValueError:\n            return False, None\n\n        today = date.today()\n        birthday_this_year = date(today.year, birth.month, birth.day)\n\n        # 如果今年生日已过，检查明年\n        if birthday_this_year < today:\n            birthday_this_year = date(today.year + 1, birth.month, birth.day)\n\n        days_until = (birthday_this_year - today).days\n\n        if days_until in advance_days:\n            event_name = \"birthday\" if days_until == 0 else f\"birthday_{days_until}days\"\n            return True, {\n                \"event_name\": event_name,\n                \"event_date\": birthday_this_year,\n                \"days_until\": days_until,\n            }\n\n        return False, None\n\n    async def _detect_dayun_change(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测大运交接\"\"\"\n        from skills.bazi.services import BaziComputer\n\n        computer = BaziComputer()\n        inflection_points = await computer.get_inflection_points(profile)\n\n        today = date.today()\n\n        for point in inflection_points:\n            if point.get(\"type\") == \"major_cycle_change\":\n                point_year = point.get(\"year\")\n                if point_year:\n                    # 大运交接通常在年初\n                    point_date = date(point_year, 1, 1)\n                    days_until = (point_date - today).days\n\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": point.get(\"title\", \"大运交接\"),\n                            \"event_date\": point_date,\n                            \"days_until\": days_until,\n                            \"point\": point,\n                        }\n\n        return False, None\n\n    async def _detect_new_year(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测新年\"\"\"\n        today = date.today()\n        next_new_year = date(today.year + 1, 1, 1)\n\n        # 如果今天是元旦\n        if today.month == 1 and today.day == 1:\n            if 0 in advance_days:\n                return True, {\n                    \"event_name\": \"new_year\",\n                    \"event_date\": today,\n                    \"days_until\": 0,\n                }\n\n        days_until = (next_new_year - today).days\n\n        if days_until in advance_days:\n            return True, {\n                \"event_name\": \"new_year\",\n                \"event_date\": next_new_year,\n                \"days_until\": days_until,\n            }\n\n        return False, None\n\n    async def _detect_solar_term(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测节气\"\"\"\n        # 使用 ZodiacEvents 获取节气信息\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"solar_term\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"description\": event.description,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect solar term: {e}\")\n\n        return False, None\n\n    async def _detect_lunar_phase(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测月相 (新月/满月)\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type in (\"new_moon\", \"full_moon\"):\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"phase\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect lunar phase: {e}\")\n\n        return False, None\n\n    async def _detect_mercury_retrograde(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测水逆\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"mercury_retrograde\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"end_date\": event.end_date,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect mercury retrograde: {e}\")\n\n        return False, None\n\n    async def _detect_significant_transit(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测重要行星过境\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            significant_types = (\"saturn_return\", \"jupiter_transit\", \"eclipse\")\n\n            for event in events:\n                if event.event_type in significant_types:\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"transit_type\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect significant transit: {e}\")\n\n        return False, None\n\n    # ═══════════════════════════════════════════════════════════════════════════\n    # Lifecoach 事件检测器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    async def _detect_streak_broken(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测断签事件\"\"\"\n        lifecoach = profile.get(\"life_context\", {}).get(\"_paths\", {}).get(\"lifecoach\", {})\n        progress = lifecoach.get(\"progress\", {})\n\n        last_checkin = progress.get(\"last_checkin_date\")\n        previous_streak = progress.get(\"current_streak\", 0)\n\n        if not last_checkin:\n            return False, None\n\n        try:\n            last_date = datetime.strptime(last_checkin, \"%Y-%m-%d\").date()\n            days_since = (date.today() - last_date).days\n\n            # 断签：超过1天未签到，且之前有连续签到记录\n            if days_since >= 2 and previous_streak >= 3:\n                return True, {\n                    \"event_name\": \"streak_broken\",\n                    \"event_date\": date.today(),\n                    \"days_since_checkin\": days_since,\n                    \"previous_streak\": previous_streak,\n                }\n        except Exception as e:\n            logger.error(f\"Failed to detect streak broken: {e}\")\n\n        return False, None\n\n    # ═══════════════════════════════════════════════════════════════════════════\n    # Lifecoach 条件检查器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    def _get_lifecoach_data(self, profile: Dict) -> Dict:\n        \"\"\"获取 lifecoach 数据\"\"\"\n        life_context = profile.get(\"life_context\", {})\n        paths = life_context.get(\"_paths\", {})\n        return paths.get(\"lifecoach\", {})\n\n    async def _check_has_data(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查指定路径是否有数据\"\"\"\n        path = condition.get(\"path\", \"\")\n        if not path:\n            return False\n\n        # 解析路径 (e.g., \"lifecoach.north_star.vision_statement\")\n        parts = path.split(\".\")\n        data = profile\n\n        # 处理 life_context._paths 前缀\n        if parts[0] == \"lifecoach\":\n            data = self._get_lifecoach_data(profile)\n            parts = parts[1:]  # 去掉 lifecoach 前缀\n\n        for part in parts:\n            if isinstance(data, dict) and part in data:\n                data = data[part]\n            else:\n                return False\n\n        return bool(data)\n\n    async def _check_not_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否未签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return True  # 从未签到\n\n        return last_checkin != date.today().isoformat()\n\n    async def _check_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否已签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return False\n\n        return last_checkin == date.today().isoformat()\n\n    async def _check_has_weekly_data(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查是否有本周数据\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        week = current.get(\"week\", {})\n\n        return bool(week.get(\"rocks\"))\n\n    async def _check_not_reviewed_this_week(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查本周是否未复盘\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        journal = lifecoach.get(\"journal\", [])\n\n        if not journal:\n            return True\n\n        # 获取本周一的日期\n        today = date.today()\n        monday = today - timedelta(days=today.weekday())\n\n        # 检查是否有本周的 weekly 复盘\n        for entry in journal:\n            if entry.get(\"type\") == \"weekly\":\n                entry_date_str = entry.get(\"date\")\n                if entry_date_str:\n                    try:\n                        entry_date = datetime.strptime(entry_date_str, \"%Y-%m-%d\").date()\n                        if entry_date >= monday:\n                            return False  # 本周已复盘\n                    except ValueError:\n                        continue\n\n        return True\n\n    async def _check_not_planned_this_week(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查本周是否未规划\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        week = current.get(\"week\", {})\n\n        week_start = week.get(\"week_start\")\n        if not week_start:\n            return True\n\n        # 获取本周一的日期\n        today = date.today()\n        monday = today - timedelta(days=today.weekday())\n\n        try:\n            planned_week_start = datetime.strptime(week_start, \"%Y-%m-%d\").date()\n            return planned_week_start < monday  # 规划日期在本周之前，说明未规划\n        except ValueError:\n            return True\n\n    async def _check_has_pending_levers(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查是否有未完成的杠杆\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        daily = current.get(\"daily\", {})\n        levers = daily.get(\"levers\", [])\n\n        if not levers:\n            return False\n\n        # 检查今天的杠杆\n        today_str = date.today().isoformat()\n        daily_date = daily.get(\"date\")\n\n        if daily_date != today_str:\n            return False  # 不是今天的数据\n\n        pending_count = sum(1 for lever in levers if lever.get(\"status\") != \"completed\")\n        return pending_count > 0\n\n    async def _check_had_streak(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查之前是否有连续签到记录\"\"\"\n        min_days = condition.get(\"min_days\", 3)\n\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n\n        # 检查当前或历史最长连续\n        current_streak = progress.get(\"current_streak\", 0)\n        longest_streak = progress.get(\"longest_streak\", 0)\n\n        return max(current_streak, longest_streak) >= min_days\n","numLines":676,"startLine":1,"totalLines":676}},"sourceToolAssistantUUID":"2597ed1c-fbfa-4c9f-bc06-3a524ba54835"}
{"parentUuid":"f921451b-6ad5-48e6-aa14-e5dbea97fe3d","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Hd8ZyFMvh6LLDe1UcskhG6","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me analyze these files for simplification opportunities.\n\n## Analysis\n\n### handlers.py\n\nThe code is generally well-structured, but I found several opportunities for simplification:\n\n1. **Lines 415-425 in `show_role_balance`**: The balance score calculation logic could be cleaner\n2. **Lines 294-314 in `update_progress`**: The streak update logic has redundant conditions\n3. **Lines 446-461 and 475-490**: The stats calculation pattern is duplicated between `show_weekly_rocks` and `show_daily_levers`\n\n### trigger_detector.py\n\nThe file has good structure but some redundant patterns:\n\n1. **Lines 347-456**: The event detectors `_detect_solar_term`, `_detect_lunar_phase`, `_detect_mercury_retrograde`, and `_detect_significant_transit` share nearly identical structure - they can be consolidated\n2. **Lines 533-563**: `_check_not_checked_in_today` and `_check_checked_in_today` are exact inverses and share logic\n\nLet me apply simplifications."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":17494,"cache_read_input_tokens":21660,"cache_creation":{"ephemeral_5m_input_tokens":17494,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CXGikg7MydcsGqSq9haED","type":"assistant","uuid":"3ae44c31-3017-4721-8055-1a874d5fafd8","timestamp":"2026-01-19T12:16:19.083Z"}
{"parentUuid":"3ae44c31-3017-4721-8055-1a874d5fafd8","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Hd8ZyFMvh6LLDe1UcskhG6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UKR1B6FCnbZdxxDAPvCDiK","name":"Edit","input":{"replace_all":false,"file_path":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py","old_string":"@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n\n    # 计算平衡分数\n    if roles:\n        scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n        if scores:\n            avg = sum(scores) / len(scores)\n            variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n            # 平衡分数：平均分越高、方差越小，分数越高\n            balance_score = min(100, max(0, avg * 10 - variance * 2))\n        else:\n            balance_score = 0\n    else:\n        balance_score = args.get(\"balance_score\", 0)","new_string":"def _calculate_balance_score(roles: List[Dict]) -> float:\n    \"\"\"计算角色平衡分数：平均分越高、方差越小，分数越高\"\"\"\n    scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n    if not scores:\n        return 0\n    avg = sum(scores) / len(scores)\n    variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n    return min(100, max(0, avg * 10 - variance * 2))\n\n\n@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n    balance_score = _calculate_balance_score(roles) if roles else args.get(\"balance_score\", 0)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":17494,"cache_read_input_tokens":21660,"cache_creation":{"ephemeral_5m_input_tokens":17494,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CXGikg7MydcsGqSq9haED","type":"assistant","uuid":"5585caaa-2ebc-43e2-b853-1142e45729eb","timestamp":"2026-01-19T12:16:25.794Z"}
{"parentUuid":"5585caaa-2ebc-43e2-b853-1142e45729eb","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UKR1B6FCnbZdxxDAPvCDiK","type":"tool_result","content":"The file /home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   403→        }\n   404→    }\n   405→\n   406→\n   407→def _calculate_balance_score(roles: List[Dict]) -> float:\n   408→    \"\"\"计算角色平衡分数：平均分越高、方差越小，分数越高\"\"\"\n   409→    scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n   410→    if not scores:\n   411→        return 0\n   412→    avg = sum(scores) / len(scores)\n   413→    variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n   414→    return min(100, max(0, avg * 10 - variance * 2))\n   415→\n   416→\n   417→@tool_handler(\"show_role_balance\")\n   418→async def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   419→    \"\"\"\n   420→    展示目标平衡轮卡片\n   421→    \"\"\"\n   422→    roles = args.get(\"roles\", [])\n   423→    balance_score = _calculate_balance_score(roles) if roles else args.get(\"balance_score\", 0)\n   424→\n   425→    return {\n   426→        \"card_type\": \"role_balance\",\n   427→        \"data\": {"}]},"uuid":"caffc289-db81-41c8-bb7b-bd0fea587b88","timestamp":"2026-01-19T12:16:28.497Z","toolUseResult":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py","oldString":"@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n\n    # 计算平衡分数\n    if roles:\n        scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n        if scores:\n            avg = sum(scores) / len(scores)\n            variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n            # 平衡分数：平均分越高、方差越小，分数越高\n            balance_score = min(100, max(0, avg * 10 - variance * 2))\n        else:\n            balance_score = 0\n    else:\n        balance_score = args.get(\"balance_score\", 0)","newString":"def _calculate_balance_score(roles: List[Dict]) -> float:\n    \"\"\"计算角色平衡分数：平均分越高、方差越小，分数越高\"\"\"\n    scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n    if not scores:\n        return 0\n    avg = sum(scores) / len(scores)\n    variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n    return min(100, max(0, avg * 10 - variance * 2))\n\n\n@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n    balance_score = _calculate_balance_score(roles) if roles else args.get(\"balance_score\", 0)","originalFile":"\"\"\"\nLifecoach Skill - Tool Handlers V2\n\n使用 @tool_handler 装饰器注册工具执行器。\n支持数据持久化和展示卡片生成。\n\n数据结构 (与 DATA-STRUCTURE.md 对齐):\n- system: 系统配置（方法论、角色设定）\n- north_star: 北极星愿景、反愿景、使命、原则\n- goals: 核心目标（最多3个），包含年度目标\n- roadmap: 路线图（年度、季度）\n- current: 当前焦点（月度项目 current.month、周大石头 current.week、每日杠杆 current.daily）\n- identity: 身份设计（当前身份、目标身份、锚定行为）\n- progress: 进度追踪（签到、连续天数）\n- journal: 复盘日志（数组）\n\"\"\"\n\nimport uuid\nfrom typing import Any, Dict, List, Optional\nfrom datetime import datetime, date\n\nfrom services.agent.tool_registry import tool_handler, ToolContext\nfrom stores.unified_profile_repo import UnifiedProfileRepository\n\n\n# 有效的 section 列表（与 DATA-STRUCTURE.md 对齐）\nVALID_SECTIONS = [\"system\", \"north_star\", \"goals\", \"roadmap\", \"current\", \"identity\", \"progress\", \"journal\"]\n\n\ndef deep_merge(base: Dict, update: Dict) -> Dict:\n    \"\"\"深度合并两个字典\"\"\"\n    result = base.copy()\n    for key, value in update.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        elif value is not None:\n            result[key] = value\n    return result\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 数据工具 (V2 - 与 DATA-STRUCTURE.md 对齐)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"read_lifecoach_state\")\nasync def read_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    读取用户的人生地图状态\n\n    从 unified_profile 的 life_context.lifecoach 路径读取数据\n    支持的 sections: system, north_star, goals, roadmap, current, identity, progress, journal\n    \"\"\"\n    sections = args.get(\"sections\", [\"north_star\", \"goals\", \"current\", \"progress\"])\n\n    try:\n        # 从 unified_profile 读取 lifecoach 数据\n        data = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        if not data or not data.content:\n            return {\n                \"status\": \"empty\",\n                \"message\": \"尚未建立人生地图，让我们开始吧！\",\n                \"data\": {}\n            }\n\n        # 按请求的 sections 过滤返回\n        result = {}\n        content = data.content\n        for section in sections:\n            if section in content:\n                result[section] = content[section]\n\n        return {\n            \"status\": \"success\",\n            \"data\": result,\n            \"version\": data.version,\n            \"updated_at\": data.updated_at.isoformat() if data.updated_at else None\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"读取状态失败: {str(e)}\",\n            \"data\": {}\n        }\n\n\n@tool_handler(\"write_lifecoach_state\")\nasync def write_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    写入用户的人生地图状态\n\n    支持的 section: system, north_star, goals, roadmap, current, identity, progress\n    使用深度合并，避免覆盖已有数据\n\n    特别说明 - current 的嵌套结构:\n    - current.month: 月度项目\n    - current.week: 周大石头\n    - current.daily: 每日杠杆\n\n    示例：\n    write_lifecoach_state(section=\"current\", data={\"week\": {\"rocks\": [...]}})\n    会合并到 current.week，不会覆盖 current.month 和 current.daily\n    \"\"\"\n    section = args.get(\"section\")\n    data = args.get(\"data\")\n\n    if not section or not data:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: section 和 data\"\n        }\n\n    # 验证 section 有效性\n    if section not in VALID_SECTIONS:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"无效的 section: {section}。有效值: {', '.join(VALID_SECTIONS)}\"\n        }\n\n    try:\n        # 先读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        # 深度合并数据\n        content = existing.content if existing else {}\n\n        # 如果是 current 或其他嵌套结构，使用深度合并\n        if section in content and isinstance(content[section], dict) and isinstance(data, dict):\n            content[section] = deep_merge(content[section], data)\n        else:\n            content[section] = data\n\n        # 更新元信息\n        content[\"_last_updated\"] = datetime.utcnow().isoformat()\n        content[\"_last_section\"] = section\n\n        # 写入\n        result = await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            content\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": f\"已保存 {section}\",\n            \"version\": result.version\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"保存失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"add_journal_entry\")\nasync def add_journal_entry(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    添加复盘日志条目\n\n    与 DATA-STRUCTURE.md 的 journal 结构对齐:\n    journal 是一个数组，每个条目包含:\n    - date: 日期\n    - type: daily | weekly | monthly | quarterly | insight\n    - mood: 心情 (1-10)\n    - energy: 能量 (1-10)\n    - rocks_completed: 完成的大石头数\n    - rocks_total: 总大石头数\n    - goal_balance: 目标平衡统计 (周复盘)\n    - wins: 胜利列表\n    - struggles: 挑战列表\n    - insight: 洞察\n    - gratitude: 感恩\n    - tomorrow: 明天计划\n    - next_week_focus: 下周聚焦\n    \"\"\"\n    entry_type = args.get(\"entry_type\")\n    content = args.get(\"content\")\n\n    if not entry_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: entry_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        # journal 是一个数组（与 DATA-STRUCTURE.md 对齐）\n        journal = lifecoach_data.get(\"journal\", [])\n        if isinstance(journal, dict):\n            # 兼容旧格式：从 entries 数组迁移\n            journal = journal.get(\"entries\", [])\n\n        today = date.today().isoformat()\n\n        # 创建新条目（与 DATA-STRUCTURE.md 字段对齐）\n        entry = {\n            \"date\": args.get(\"date\", today),\n            \"type\": entry_type,\n            \"content\": content,  # 额外字段：摘要内容\n            \"mood\": args.get(\"mood\"),\n            \"energy\": args.get(\"energy\"),\n            \"rocks_completed\": args.get(\"rocks_completed\"),\n            \"rocks_total\": args.get(\"rocks_total\"),\n            \"goal_balance\": args.get(\"goal_balance\"),  # 周复盘用\n            \"wins\": args.get(\"wins\", []),\n            \"struggles\": args.get(\"blockers\", []),  # 兼容旧参数名\n            \"insight\": args.get(\"insight\"),\n            \"gratitude\": args.get(\"gratitude\"),\n            \"tomorrow\": args.get(\"tomorrow\"),\n            \"next_week_focus\": args.get(\"next_week_focus\"),\n            \"adjustments\": args.get(\"adjustments\", []),\n            \"learnings\": args.get(\"learnings\", []),\n            \"_created_at\": datetime.utcnow().isoformat(),\n        }\n\n        # 清理 None 值\n        entry = {k: v for k, v in entry.items() if v is not None}\n\n        # 添加到日志列表（最新在前）\n        journal = [entry] + journal[:99]  # 保留最近100条\n\n        # 保存\n        lifecoach_data[\"journal\"] = journal\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"日志已记录\",\n            \"date\": entry[\"date\"],\n            \"type\": entry_type\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"记录失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"update_progress\")\nasync def update_progress(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    更新进度/签到\n    \"\"\"\n    action_type = args.get(\"action_type\")\n\n    if not action_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: action_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        progress = lifecoach_data.get(\"progress\", {\n            \"current_streak\": 0,\n            \"longest_streak\": 0,\n            \"total_checkins\": 0,\n            \"last_checkin_date\": None,\n            \"checkin_history\": [],\n            \"completed_levers\": [],\n            \"completed_rocks\": [],\n            \"milestones\": []\n        })\n\n        today = date.today().isoformat()\n        now = datetime.utcnow().isoformat()\n\n        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到\n            last_date = progress.get(\"last_checkin_date\")\n            if last_date:\n                last = date.fromisoformat(last_date)\n                today_date = date.today()\n                diff = (today_date - last).days\n                if diff == 1:\n                    progress[\"current_streak\"] += 1\n                elif diff > 1:\n                    progress[\"current_streak\"] = 1\n            else:\n                progress[\"current_streak\"] = 1\n\n            # 更新最长连续\n            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):\n                progress[\"longest_streak\"] = progress[\"current_streak\"]\n\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史\n            history = progress.get(\"checkin_history\", [])\n            history.append({\n                \"date\": today,\n                \"time\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天\n\n        elif action_type == \"lever_complete\":\n            lever_id = args.get(\"lever_id\")\n            if lever_id:\n                completed = progress.get(\"completed_levers\", [])\n                completed.append({\n                    \"id\": lever_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_levers\"] = completed[-100:]\n\n        elif action_type == \"rock_complete\":\n            rock_id = args.get(\"rock_id\")\n            if rock_id:\n                completed = progress.get(\"completed_rocks\", [])\n                completed.append({\n                    \"id\": rock_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_rocks\"] = completed[-50:]\n\n        elif action_type == \"milestone_reached\":\n            milestones = progress.get(\"milestones\", [])\n            milestones.append({\n                \"reached_at\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"milestones\"] = milestones\n\n        # 保存\n        lifecoach_data[\"progress\"] = progress\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"进度已更新\",\n            \"current_streak\": progress.get(\"current_streak\", 0),\n            \"total_checkins\": progress.get(\"total_checkins\", 0)\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"更新失败: {str(e)}\"\n        }\n\n\n# ══════════════════��════════════════════════════════════════════════════════\n# 展示工具 - V2 新增\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_life_roadmap\")\nasync def show_life_roadmap(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生路线图卡片\n    \"\"\"\n    north_star = args.get(\"north_star\", {})\n\n    return {\n        \"card_type\": \"life_roadmap\",\n        \"data\": {\n            \"north_star\": north_star,\n            \"yearly_theme\": args.get(\"yearly_theme\"),\n            \"quarterly_milestones\": args.get(\"quarterly_milestones\", []),\n            \"current_focus\": args.get(\"current_focus\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n\n    # 计算平衡分数\n    if roles:\n        scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n        if scores:\n            avg = sum(scores) / len(scores)\n            variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n            # 平衡分数：平均分越高、方差越小，分数越高\n            balance_score = min(100, max(0, avg * 10 - variance * 2))\n        else:\n            balance_score = 0\n    else:\n        balance_score = args.get(\"balance_score\", 0)\n\n    return {\n        \"card_type\": \"role_balance\",\n        \"data\": {\n            \"roles\": roles,\n            \"balance_score\": round(balance_score, 1),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    # 计算完成进度\n    total = len(rocks)\n    completed = sum(1 for r in rocks if r.get(\"status\") == \"completed\")\n    in_progress = sum(1 for r in rocks if r.get(\"status\") == \"in_progress\")\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"in_progress\": in_progress,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    # 计算完成进度\n    total = len(levers)\n    completed = sum(1 for l in levers if l.get(\"status\") == \"completed\")\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_progress_streak\")\nasync def show_progress_streak(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示连续签到和进度统计卡片\n    \"\"\"\n    current_streak = args.get(\"current_streak\", 0)\n    longest_streak = args.get(\"longest_streak\", current_streak)\n\n    # 计算激励消息\n    if current_streak >= 30:\n        motivation = \"太棒了！一个月的坚持，你正在重塑自己！\"\n    elif current_streak >= 14:\n        motivation = \"两周了！习惯正在形成，继续保持！\"\n    elif current_streak >= 7:\n        motivation = \"一周连续签到！你已经超越了大多数人！\"\n    elif current_streak >= 3:\n        motivation = \"连续三天，好的开始！\"\n    elif current_streak >= 1:\n        motivation = \"今天是新的开始！\"\n    else:\n        motivation = \"准备好开始你的旅程了吗？\"\n\n    return {\n        \"card_type\": \"progress_streak\",\n        \"data\": {\n            \"current_streak\": current_streak,\n            \"longest_streak\": longest_streak,\n            \"total_checkins\": args.get(\"total_checkins\", 0),\n            \"weekly_completion_rate\": args.get(\"weekly_completion_rate\", 0),\n            \"monthly_stats\": args.get(\"monthly_stats\", {}),\n            \"achievements\": args.get(\"achievements\", []),\n            \"motivation\": motivation,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 展示工具 - V1 保留 (使用 @tool_handler 重写)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_pattern_insight\")\nasync def show_pattern_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行为模式洞察卡片\n    \"\"\"\n    pattern_type = args.get(\"pattern_type\", \"behavior\")\n\n    type_labels = {\n        \"behavior\": \"行为模式\",\n        \"stuck\": \"卡点分析\",\n        \"conflict\": \"目标冲突\",\n        \"protection\": \"自我保护\"\n    }\n\n    return {\n        \"card_type\": \"pattern_insight\",\n        \"data\": {\n            \"type\": pattern_type,\n            \"type_label\": type_labels.get(pattern_type, \"模式分析\"),\n            \"surface_pattern\": args.get(\"surface_pattern\", \"\"),\n            \"hidden_goal\": args.get(\"hidden_goal\"),\n            \"cost\": args.get(\"cost\"),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_identity_design\")\nasync def show_identity_design(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示身份设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"identity_design\",\n        \"data\": {\n            \"old_identity\": args.get(\"old_identity\"),\n            \"new_identity\": args.get(\"new_identity\", \"\"),\n            \"bridge_belief\": args.get(\"bridge_belief\"),\n            \"anchor_behaviors\": args.get(\"anchor_behaviors\", []),\n            \"transformation_arrow\": \"→\" if args.get(\"old_identity\") else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_vision_map\")\nasync def show_vision_map(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示愿景/反愿景地图\n    \"\"\"\n    map_type = args.get(\"map_type\", \"vision\")\n\n    return {\n        \"card_type\": \"vision_map\",\n        \"data\": {\n            \"map_type\": map_type,\n            \"vision\": {\n                \"statement\": args.get(\"vision_statement\"),\n                \"three_year_picture\": args.get(\"three_year_picture\"),\n                \"identity_belief\": args.get(\"identity_belief\"),\n                \"one_year_milestone\": args.get(\"one_year_milestone\")\n            } if map_type in [\"vision\", \"both\"] else None,\n            \"anti_vision\": {\n                \"statement\": args.get(\"anti_vision_statement\"),\n                \"five_year_picture\": args.get(\"five_year_picture\")\n            } if map_type in [\"anti_vision\", \"both\"] else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_action_plan\")\nasync def show_action_plan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行动计划卡片\n    \"\"\"\n    return {\n        \"card_type\": \"action_plan\",\n        \"data\": {\n            \"context\": args.get(\"context\"),\n            \"hierarchy\": {\n                \"one_year_goal\": args.get(\"one_year_goal\"),\n                \"one_month_project\": args.get(\"one_month_project\"),\n                \"daily_actions\": args.get(\"daily_actions\", [])\n            },\n            \"first_step\": args.get(\"first_step\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_life_game\")\nasync def show_life_game(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生游戏设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"life_game\",\n        \"data\": {\n            \"win_condition\": args.get(\"win_condition\", \"\"),\n            \"lose_condition\": args.get(\"lose_condition\", \"\"),\n            \"main_mission\": args.get(\"main_mission\", \"\"),\n            \"current_boss\": {\n                \"name\": args.get(\"current_boss\"),\n                \"reward\": args.get(\"boss_reward\")\n            } if args.get(\"current_boss\") else None,\n            \"daily_quests\": args.get(\"daily_quests\", []),\n            \"game_rules\": args.get(\"game_rules\", []),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n","structuredPatch":[{"oldStart":404,"oldLines":26,"newStart":404,"newLines":24,"lines":["     }"," "," ","+def _calculate_balance_score(roles: List[Dict]) -> float:","+    \"\"\"计算角色平衡分数：平均分越高、方差越小，分数越高\"\"\"","+    scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]","+    if not scores:","+        return 0","+    avg = sum(scores) / len(scores)","+    variance = sum((s - avg) ** 2 for s in scores) / len(scores)","+    return min(100, max(0, avg * 10 - variance * 2))","+","+"," @tool_handler(\"show_role_balance\")"," async def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:","     \"\"\"","     展示目标平衡轮卡片","     \"\"\"","     roles = args.get(\"roles\", [])","+    balance_score = _calculate_balance_score(roles) if roles else args.get(\"balance_score\", 0)"," ","-    # 计算平衡分数","-    if roles:","-        scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]","-        if scores:","-            avg = sum(scores) / len(scores)","-            variance = sum((s - avg) ** 2 for s in scores) / len(scores)","-            # 平衡分数：平均分越高、方差越小，分数越高","-            balance_score = min(100, max(0, avg * 10 - variance * 2))","-        else:","-            balance_score = 0","-    else:","-        balance_score = args.get(\"balance_score\", 0)","-","     return {","         \"card_type\": \"role_balance\",","         \"data\": {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5585caaa-2ebc-43e2-b853-1142e45729eb"}
{"parentUuid":"caffc289-db81-41c8-bb7b-bd0fea587b88","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WoTaMrvXbUd1SoNKkfWE4n","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01As94vivcz4PWGnpegUB7H4","name":"Edit","input":{"replace_all":false,"file_path":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py","old_string":"@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    # 计算完成进度\n    total = len(rocks)\n    completed = sum(1 for r in rocks if r.get(\"status\") == \"completed\")\n    in_progress = sum(1 for r in rocks if r.get(\"status\") == \"in_progress\")\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"in_progress\": in_progress,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    # 计算完成进度\n    total = len(levers)\n    completed = sum(1 for l in levers if l.get(\"status\") == \"completed\")\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }","new_string":"def _calculate_completion_stats(items: List[Dict], include_in_progress: bool = False) -> Dict[str, Any]:\n    \"\"\"计算完成统计\"\"\"\n    total = len(items)\n    completed = sum(1 for item in items if item.get(\"status\") == \"completed\")\n    stats = {\n        \"total\": total,\n        \"completed\": completed,\n        \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n    }\n    if include_in_progress:\n        stats[\"in_progress\"] = sum(1 for item in items if item.get(\"status\") == \"in_progress\")\n    return stats\n\n\n@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": _calculate_completion_stats(rocks, include_in_progress=True),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": _calculate_completion_stats(levers),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1312,"cache_read_input_tokens":39154,"cache_creation":{"ephemeral_5m_input_tokens":1312,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CXGin9B5GjFe99v9Pm8yJ","type":"assistant","uuid":"f765d616-ae7e-4d6d-8ad5-6686feccae2b","timestamp":"2026-01-19T12:16:43.387Z"}
{"parentUuid":"f765d616-ae7e-4d6d-8ad5-6686feccae2b","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01As94vivcz4PWGnpegUB7H4","type":"tool_result","content":"The file /home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   432→        }\n   433→    }\n   434→\n   435→\n   436→def _calculate_completion_stats(items: List[Dict], include_in_progress: bool = False) -> Dict[str, Any]:\n   437→    \"\"\"计算完成统计\"\"\"\n   438→    total = len(items)\n   439→    completed = sum(1 for item in items if item.get(\"status\") == \"completed\")\n   440→    stats = {\n   441→        \"total\": total,\n   442→        \"completed\": completed,\n   443→        \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n   444→    }\n   445→    if include_in_progress:\n   446→        stats[\"in_progress\"] = sum(1 for item in items if item.get(\"status\") == \"in_progress\")\n   447→    return stats\n   448→\n   449→\n   450→@tool_handler(\"show_weekly_rocks\")\n   451→async def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   452→    \"\"\"\n   453→    展示周大石头卡片\n   454→    \"\"\"\n   455→    rocks = args.get(\"rocks\", [])\n   456→\n   457→    return {\n   458→        \"card_type\": \"weekly_rocks\",\n   459→        \"data\": {\n   460→            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n   461→            \"rocks\": rocks,\n   462→            \"theme\": args.get(\"theme\"),\n   463→            \"energy_budget\": args.get(\"energy_budget\"),\n   464→            \"stats\": _calculate_completion_stats(rocks, include_in_progress=True),\n   465→            \"generated_at\": datetime.utcnow().isoformat()\n   466→        }\n   467→    }\n   468→\n   469→\n   470→@tool_handler(\"show_daily_levers\")\n   471→async def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   472→    \"\"\"\n   473→    展示每日杠杆行动卡片\n   474→    \"\"\"\n   475→    levers = args.get(\"levers\", [])\n   476→\n   477→    return {\n   478→        \"card_type\": \"daily_levers\",\n   479→        \"data\": {\n   480→            \"date\": args.get(\"date\", date.today().isoformat()),\n   481→            \"levers\": levers,\n   482→            \"energy_level\": args.get(\"energy_level\"),\n   483→            \"intention\": args.get(\"intention\"),\n   484→            \"stats\": _calculate_completion_stats(levers),\n   485→            \"generated_at\": datetime.utcnow().isoformat()\n   486→        }\n   487→    }\n   488→\n   489→\n   490→@tool_handler(\"show_progress_streak\")\n   491→async def show_progress_streak(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:"}]},"uuid":"55e1b40b-5dca-44b2-9684-6b8539392f48","timestamp":"2026-01-19T12:16:46.118Z","toolUseResult":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py","oldString":"@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    # 计算完成进度\n    total = len(rocks)\n    completed = sum(1 for r in rocks if r.get(\"status\") == \"completed\")\n    in_progress = sum(1 for r in rocks if r.get(\"status\") == \"in_progress\")\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"in_progress\": in_progress,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    # 计算完成进度\n    total = len(levers)\n    completed = sum(1 for l in levers if l.get(\"status\") == \"completed\")\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }","newString":"def _calculate_completion_stats(items: List[Dict], include_in_progress: bool = False) -> Dict[str, Any]:\n    \"\"\"计算完成统计\"\"\"\n    total = len(items)\n    completed = sum(1 for item in items if item.get(\"status\") == \"completed\")\n    stats = {\n        \"total\": total,\n        \"completed\": completed,\n        \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n    }\n    if include_in_progress:\n        stats[\"in_progress\"] = sum(1 for item in items if item.get(\"status\") == \"in_progress\")\n    return stats\n\n\n@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": _calculate_completion_stats(rocks, include_in_progress=True),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": _calculate_completion_stats(levers),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }","originalFile":"\"\"\"\nLifecoach Skill - Tool Handlers V2\n\n使用 @tool_handler 装饰器注册工具执行器。\n支持数据持久化和展示卡片生成。\n\n数据结构 (与 DATA-STRUCTURE.md 对齐):\n- system: 系统配置（方法论、角色设定）\n- north_star: 北极星愿景、反愿景、使命、原则\n- goals: 核心目标（最多3个），包含年度目标\n- roadmap: 路线图（年度、季度）\n- current: 当前焦点（月度项目 current.month、周大石头 current.week、每日杠杆 current.daily）\n- identity: 身份设计（当前身份、目标身份、锚定行为）\n- progress: 进度追踪（签到、连续天数）\n- journal: 复盘日志（数组）\n\"\"\"\n\nimport uuid\nfrom typing import Any, Dict, List, Optional\nfrom datetime import datetime, date\n\nfrom services.agent.tool_registry import tool_handler, ToolContext\nfrom stores.unified_profile_repo import UnifiedProfileRepository\n\n\n# 有效的 section 列表（与 DATA-STRUCTURE.md 对齐）\nVALID_SECTIONS = [\"system\", \"north_star\", \"goals\", \"roadmap\", \"current\", \"identity\", \"progress\", \"journal\"]\n\n\ndef deep_merge(base: Dict, update: Dict) -> Dict:\n    \"\"\"深度合并两个字典\"\"\"\n    result = base.copy()\n    for key, value in update.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        elif value is not None:\n            result[key] = value\n    return result\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 数据工具 (V2 - 与 DATA-STRUCTURE.md 对齐)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"read_lifecoach_state\")\nasync def read_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    读取用户的人生地图状态\n\n    从 unified_profile 的 life_context.lifecoach 路径读取数据\n    支持的 sections: system, north_star, goals, roadmap, current, identity, progress, journal\n    \"\"\"\n    sections = args.get(\"sections\", [\"north_star\", \"goals\", \"current\", \"progress\"])\n\n    try:\n        # 从 unified_profile 读取 lifecoach 数据\n        data = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        if not data or not data.content:\n            return {\n                \"status\": \"empty\",\n                \"message\": \"尚未建立人生地图，让我们开始吧！\",\n                \"data\": {}\n            }\n\n        # 按请求的 sections 过滤返回\n        result = {}\n        content = data.content\n        for section in sections:\n            if section in content:\n                result[section] = content[section]\n\n        return {\n            \"status\": \"success\",\n            \"data\": result,\n            \"version\": data.version,\n            \"updated_at\": data.updated_at.isoformat() if data.updated_at else None\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"读取状态失败: {str(e)}\",\n            \"data\": {}\n        }\n\n\n@tool_handler(\"write_lifecoach_state\")\nasync def write_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    写入用户的人生地图状态\n\n    支持的 section: system, north_star, goals, roadmap, current, identity, progress\n    使用深度合并，避免覆盖已有数据\n\n    特别说明 - current 的嵌套结构:\n    - current.month: 月度项目\n    - current.week: 周大石头\n    - current.daily: 每日杠杆\n\n    示例：\n    write_lifecoach_state(section=\"current\", data={\"week\": {\"rocks\": [...]}})\n    会合并到 current.week，不会覆盖 current.month 和 current.daily\n    \"\"\"\n    section = args.get(\"section\")\n    data = args.get(\"data\")\n\n    if not section or not data:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: section 和 data\"\n        }\n\n    # 验证 section 有效性\n    if section not in VALID_SECTIONS:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"无效的 section: {section}。有效值: {', '.join(VALID_SECTIONS)}\"\n        }\n\n    try:\n        # 先读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        # 深度合并数据\n        content = existing.content if existing else {}\n\n        # 如果是 current 或其他嵌套结构，使用深度合并\n        if section in content and isinstance(content[section], dict) and isinstance(data, dict):\n            content[section] = deep_merge(content[section], data)\n        else:\n            content[section] = data\n\n        # 更新元信息\n        content[\"_last_updated\"] = datetime.utcnow().isoformat()\n        content[\"_last_section\"] = section\n\n        # 写入\n        result = await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            content\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": f\"已保存 {section}\",\n            \"version\": result.version\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"保存失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"add_journal_entry\")\nasync def add_journal_entry(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    添加复盘日志条目\n\n    与 DATA-STRUCTURE.md 的 journal 结构对齐:\n    journal 是一个数组，每个条目包含:\n    - date: 日期\n    - type: daily | weekly | monthly | quarterly | insight\n    - mood: 心情 (1-10)\n    - energy: 能量 (1-10)\n    - rocks_completed: 完成的大石头数\n    - rocks_total: 总大石头数\n    - goal_balance: 目标平衡统计 (周复盘)\n    - wins: 胜利列表\n    - struggles: 挑战列表\n    - insight: 洞察\n    - gratitude: 感恩\n    - tomorrow: 明天计划\n    - next_week_focus: 下周聚焦\n    \"\"\"\n    entry_type = args.get(\"entry_type\")\n    content = args.get(\"content\")\n\n    if not entry_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: entry_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        # journal 是一个数组（与 DATA-STRUCTURE.md 对齐）\n        journal = lifecoach_data.get(\"journal\", [])\n        if isinstance(journal, dict):\n            # 兼容旧格式：从 entries 数组迁移\n            journal = journal.get(\"entries\", [])\n\n        today = date.today().isoformat()\n\n        # 创建新条目（与 DATA-STRUCTURE.md 字段对齐）\n        entry = {\n            \"date\": args.get(\"date\", today),\n            \"type\": entry_type,\n            \"content\": content,  # 额外字段：摘要内容\n            \"mood\": args.get(\"mood\"),\n            \"energy\": args.get(\"energy\"),\n            \"rocks_completed\": args.get(\"rocks_completed\"),\n            \"rocks_total\": args.get(\"rocks_total\"),\n            \"goal_balance\": args.get(\"goal_balance\"),  # 周复盘用\n            \"wins\": args.get(\"wins\", []),\n            \"struggles\": args.get(\"blockers\", []),  # 兼容旧参数名\n            \"insight\": args.get(\"insight\"),\n            \"gratitude\": args.get(\"gratitude\"),\n            \"tomorrow\": args.get(\"tomorrow\"),\n            \"next_week_focus\": args.get(\"next_week_focus\"),\n            \"adjustments\": args.get(\"adjustments\", []),\n            \"learnings\": args.get(\"learnings\", []),\n            \"_created_at\": datetime.utcnow().isoformat(),\n        }\n\n        # 清理 None 值\n        entry = {k: v for k, v in entry.items() if v is not None}\n\n        # 添加到日志列表（最新在前）\n        journal = [entry] + journal[:99]  # 保留最近100条\n\n        # 保存\n        lifecoach_data[\"journal\"] = journal\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"日志已记录\",\n            \"date\": entry[\"date\"],\n            \"type\": entry_type\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"记录失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"update_progress\")\nasync def update_progress(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    更新进度/签到\n    \"\"\"\n    action_type = args.get(\"action_type\")\n\n    if not action_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: action_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        progress = lifecoach_data.get(\"progress\", {\n            \"current_streak\": 0,\n            \"longest_streak\": 0,\n            \"total_checkins\": 0,\n            \"last_checkin_date\": None,\n            \"checkin_history\": [],\n            \"completed_levers\": [],\n            \"completed_rocks\": [],\n            \"milestones\": []\n        })\n\n        today = date.today().isoformat()\n        now = datetime.utcnow().isoformat()\n\n        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到\n            last_date = progress.get(\"last_checkin_date\")\n            if last_date:\n                last = date.fromisoformat(last_date)\n                today_date = date.today()\n                diff = (today_date - last).days\n                if diff == 1:\n                    progress[\"current_streak\"] += 1\n                elif diff > 1:\n                    progress[\"current_streak\"] = 1\n            else:\n                progress[\"current_streak\"] = 1\n\n            # 更新最长连续\n            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):\n                progress[\"longest_streak\"] = progress[\"current_streak\"]\n\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史\n            history = progress.get(\"checkin_history\", [])\n            history.append({\n                \"date\": today,\n                \"time\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天\n\n        elif action_type == \"lever_complete\":\n            lever_id = args.get(\"lever_id\")\n            if lever_id:\n                completed = progress.get(\"completed_levers\", [])\n                completed.append({\n                    \"id\": lever_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_levers\"] = completed[-100:]\n\n        elif action_type == \"rock_complete\":\n            rock_id = args.get(\"rock_id\")\n            if rock_id:\n                completed = progress.get(\"completed_rocks\", [])\n                completed.append({\n                    \"id\": rock_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_rocks\"] = completed[-50:]\n\n        elif action_type == \"milestone_reached\":\n            milestones = progress.get(\"milestones\", [])\n            milestones.append({\n                \"reached_at\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"milestones\"] = milestones\n\n        # 保存\n        lifecoach_data[\"progress\"] = progress\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"进度已更新\",\n            \"current_streak\": progress.get(\"current_streak\", 0),\n            \"total_checkins\": progress.get(\"total_checkins\", 0)\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"更新失败: {str(e)}\"\n        }\n\n\n# ══════════════════��════════════════════════════════════════════════════════\n# 展示工具 - V2 新增\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_life_roadmap\")\nasync def show_life_roadmap(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生路线图卡片\n    \"\"\"\n    north_star = args.get(\"north_star\", {})\n\n    return {\n        \"card_type\": \"life_roadmap\",\n        \"data\": {\n            \"north_star\": north_star,\n            \"yearly_theme\": args.get(\"yearly_theme\"),\n            \"quarterly_milestones\": args.get(\"quarterly_milestones\", []),\n            \"current_focus\": args.get(\"current_focus\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\ndef _calculate_balance_score(roles: List[Dict]) -> float:\n    \"\"\"计算角色平衡分数：平均分越高、方差越小，分数越高\"\"\"\n    scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n    if not scores:\n        return 0\n    avg = sum(scores) / len(scores)\n    variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n    return min(100, max(0, avg * 10 - variance * 2))\n\n\n@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n    balance_score = _calculate_balance_score(roles) if roles else args.get(\"balance_score\", 0)\n\n    return {\n        \"card_type\": \"role_balance\",\n        \"data\": {\n            \"roles\": roles,\n            \"balance_score\": round(balance_score, 1),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    # 计算完成进度\n    total = len(rocks)\n    completed = sum(1 for r in rocks if r.get(\"status\") == \"completed\")\n    in_progress = sum(1 for r in rocks if r.get(\"status\") == \"in_progress\")\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"in_progress\": in_progress,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    # 计算完成进度\n    total = len(levers)\n    completed = sum(1 for l in levers if l.get(\"status\") == \"completed\")\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": {\n                \"total\": total,\n                \"completed\": completed,\n                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n            },\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_progress_streak\")\nasync def show_progress_streak(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示连续签到和进度统计卡片\n    \"\"\"\n    current_streak = args.get(\"current_streak\", 0)\n    longest_streak = args.get(\"longest_streak\", current_streak)\n\n    # 计算激励消息\n    if current_streak >= 30:\n        motivation = \"太棒了！一个月的坚持，你正在重塑自己！\"\n    elif current_streak >= 14:\n        motivation = \"两周了！习惯正在形成，继续保持！\"\n    elif current_streak >= 7:\n        motivation = \"一周连续签到！你已经超越了大多数人！\"\n    elif current_streak >= 3:\n        motivation = \"连续三天，好的开始！\"\n    elif current_streak >= 1:\n        motivation = \"今天是新的开始！\"\n    else:\n        motivation = \"准备好开始你的旅程了吗？\"\n\n    return {\n        \"card_type\": \"progress_streak\",\n        \"data\": {\n            \"current_streak\": current_streak,\n            \"longest_streak\": longest_streak,\n            \"total_checkins\": args.get(\"total_checkins\", 0),\n            \"weekly_completion_rate\": args.get(\"weekly_completion_rate\", 0),\n            \"monthly_stats\": args.get(\"monthly_stats\", {}),\n            \"achievements\": args.get(\"achievements\", []),\n            \"motivation\": motivation,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 展示工具 - V1 保留 (使用 @tool_handler 重写)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_pattern_insight\")\nasync def show_pattern_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行为模式洞察卡片\n    \"\"\"\n    pattern_type = args.get(\"pattern_type\", \"behavior\")\n\n    type_labels = {\n        \"behavior\": \"行为模式\",\n        \"stuck\": \"卡点分析\",\n        \"conflict\": \"目标冲突\",\n        \"protection\": \"自我保护\"\n    }\n\n    return {\n        \"card_type\": \"pattern_insight\",\n        \"data\": {\n            \"type\": pattern_type,\n            \"type_label\": type_labels.get(pattern_type, \"模式分析\"),\n            \"surface_pattern\": args.get(\"surface_pattern\", \"\"),\n            \"hidden_goal\": args.get(\"hidden_goal\"),\n            \"cost\": args.get(\"cost\"),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_identity_design\")\nasync def show_identity_design(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示身份设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"identity_design\",\n        \"data\": {\n            \"old_identity\": args.get(\"old_identity\"),\n            \"new_identity\": args.get(\"new_identity\", \"\"),\n            \"bridge_belief\": args.get(\"bridge_belief\"),\n            \"anchor_behaviors\": args.get(\"anchor_behaviors\", []),\n            \"transformation_arrow\": \"→\" if args.get(\"old_identity\") else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_vision_map\")\nasync def show_vision_map(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示愿景/反愿景地图\n    \"\"\"\n    map_type = args.get(\"map_type\", \"vision\")\n\n    return {\n        \"card_type\": \"vision_map\",\n        \"data\": {\n            \"map_type\": map_type,\n            \"vision\": {\n                \"statement\": args.get(\"vision_statement\"),\n                \"three_year_picture\": args.get(\"three_year_picture\"),\n                \"identity_belief\": args.get(\"identity_belief\"),\n                \"one_year_milestone\": args.get(\"one_year_milestone\")\n            } if map_type in [\"vision\", \"both\"] else None,\n            \"anti_vision\": {\n                \"statement\": args.get(\"anti_vision_statement\"),\n                \"five_year_picture\": args.get(\"five_year_picture\")\n            } if map_type in [\"anti_vision\", \"both\"] else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_action_plan\")\nasync def show_action_plan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行动计划卡片\n    \"\"\"\n    return {\n        \"card_type\": \"action_plan\",\n        \"data\": {\n            \"context\": args.get(\"context\"),\n            \"hierarchy\": {\n                \"one_year_goal\": args.get(\"one_year_goal\"),\n                \"one_month_project\": args.get(\"one_month_project\"),\n                \"daily_actions\": args.get(\"daily_actions\", [])\n            },\n            \"first_step\": args.get(\"first_step\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_life_game\")\nasync def show_life_game(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生游戏设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"life_game\",\n        \"data\": {\n            \"win_condition\": args.get(\"win_condition\", \"\"),\n            \"lose_condition\": args.get(\"lose_condition\", \"\"),\n            \"main_mission\": args.get(\"main_mission\", \"\"),\n            \"current_boss\": {\n                \"name\": args.get(\"current_boss\"),\n                \"reward\": args.get(\"boss_reward\")\n            } if args.get(\"current_boss\") else None,\n            \"daily_quests\": args.get(\"daily_quests\", []),\n            \"game_rules\": args.get(\"game_rules\", []),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n","structuredPatch":[{"oldStart":433,"oldLines":6,"newStart":433,"newLines":20,"lines":["     }"," "," ","+def _calculate_completion_stats(items: List[Dict], include_in_progress: bool = False) -> Dict[str, Any]:","+    \"\"\"计算完成统计\"\"\"","+    total = len(items)","+    completed = sum(1 for item in items if item.get(\"status\") == \"completed\")","+    stats = {","+        \"total\": total,","+        \"completed\": completed,","+        \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0","+    }","+    if include_in_progress:","+        stats[\"in_progress\"] = sum(1 for item in items if item.get(\"status\") == \"in_progress\")","+    return stats","+","+"," @tool_handler(\"show_weekly_rocks\")"," async def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:","     \"\"\""]},{"oldStart":440,"oldLines":11,"newStart":454,"newLines":6,"lines":["     \"\"\"","     rocks = args.get(\"rocks\", [])"," ","-    # 计算完成进度","-    total = len(rocks)","-    completed = sum(1 for r in rocks if r.get(\"status\") == \"completed\")","-    in_progress = sum(1 for r in rocks if r.get(\"status\") == \"in_progress\")","-","     return {","         \"card_type\": \"weekly_rocks\",","         \"data\": {"]},{"oldStart":452,"oldLines":12,"newStart":461,"newLines":7,"lines":["             \"rocks\": rocks,","             \"theme\": args.get(\"theme\"),","             \"energy_budget\": args.get(\"energy_budget\"),","-            \"stats\": {","-                \"total\": total,","-                \"completed\": completed,","-                \"in_progress\": in_progress,","-                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0","-            },","+            \"stats\": _calculate_completion_stats(rocks, include_in_progress=True),","             \"generated_at\": datetime.utcnow().isoformat()","         }","     }"]},{"oldStart":470,"oldLines":10,"newStart":474,"newLines":6,"lines":["     \"\"\"","     levers = args.get(\"levers\", [])"," ","-    # 计算完成进度","-    total = len(levers)","-    completed = sum(1 for l in levers if l.get(\"status\") == \"completed\")","-","     return {","         \"card_type\": \"daily_levers\",","         \"data\": {"]},{"oldStart":481,"oldLines":11,"newStart":481,"newLines":7,"lines":["             \"levers\": levers,","             \"energy_level\": args.get(\"energy_level\"),","             \"intention\": args.get(\"intention\"),","-            \"stats\": {","-                \"total\": total,","-                \"completed\": completed,","-                \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0","-            },","+            \"stats\": _calculate_completion_stats(levers),","             \"generated_at\": datetime.utcnow().isoformat()","         }","     }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f765d616-ae7e-4d6d-8ad5-6686feccae2b"}
{"parentUuid":"55e1b40b-5dca-44b2-9684-6b8539392f48","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kf3XmQNJCkQ5GVN3HbCML1","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me simplify the streak update logic in `update_progress`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2125,"cache_read_input_tokens":40466,"cache_creation":{"ephemeral_5m_input_tokens":2125,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXGioSQgo4GvfBJehwfjw","type":"assistant","uuid":"87a7fb75-9f62-4ec6-94f7-d13f502285e6","timestamp":"2026-01-19T12:16:51.536Z"}
{"parentUuid":"87a7fb75-9f62-4ec6-94f7-d13f502285e6","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kf3XmQNJCkQ5GVN3HbCML1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Twz744tVHhrocYMwYJAR4z","name":"Edit","input":{"replace_all":false,"file_path":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py","old_string":"        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到\n            last_date = progress.get(\"last_checkin_date\")\n            if last_date:\n                last = date.fromisoformat(last_date)\n                today_date = date.today()\n                diff = (today_date - last).days\n                if diff == 1:\n                    progress[\"current_streak\"] += 1\n                elif diff > 1:\n                    progress[\"current_streak\"] = 1\n            else:\n                progress[\"current_streak\"] = 1\n\n            # 更新最长连续\n            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):\n                progress[\"longest_streak\"] = progress[\"current_streak\"]\n\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史\n            history = progress.get(\"checkin_history\", [])\n            history.append({\n                \"date\": today,\n                \"time\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天","new_string":"        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到：连续则+1，断签则重置为1\n            last_date = progress.get(\"last_checkin_date\")\n            days_since_last = (date.today() - date.fromisoformat(last_date)).days if last_date else None\n            progress[\"current_streak\"] = progress[\"current_streak\"] + 1 if days_since_last == 1 else 1\n\n            # 更新最长连续\n            progress[\"longest_streak\"] = max(progress[\"current_streak\"], progress.get(\"longest_streak\", 0))\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史（保留最近30天）\n            history = progress.get(\"checkin_history\", [])\n            history.append({\"date\": today, \"time\": now, \"notes\": args.get(\"notes\")})\n            progress[\"checkin_history\"] = history[-30:]"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2125,"cache_read_input_tokens":40466,"cache_creation":{"ephemeral_5m_input_tokens":2125,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXGioSQgo4GvfBJehwfjw","type":"assistant","uuid":"12df4d0f-bfac-44d8-a625-ddb8824cdaaa","timestamp":"2026-01-19T12:17:00.183Z"}
{"parentUuid":"12df4d0f-bfac-44d8-a625-ddb8824cdaaa","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Twz744tVHhrocYMwYJAR4z","type":"tool_result","content":"The file /home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   290→\n   291→        today = date.today().isoformat()\n   292→        now = datetime.utcnow().isoformat()\n   293→\n   294→        if action_type == \"daily_checkin\":\n   295→            # 检查是否今天已签到\n   296→            if progress.get(\"last_checkin_date\") == today:\n   297→                return {\n   298→                    \"status\": \"already_checked_in\",\n   299→                    \"message\": \"今天已经签到过了！\",\n   300→                    \"current_streak\": progress[\"current_streak\"]\n   301→                }\n   302→\n   303→            # 更新连续签到：连续则+1，断签则重置为1\n   304→            last_date = progress.get(\"last_checkin_date\")\n   305→            days_since_last = (date.today() - date.fromisoformat(last_date)).days if last_date else None\n   306→            progress[\"current_streak\"] = progress[\"current_streak\"] + 1 if days_since_last == 1 else 1\n   307→\n   308→            # 更新最长连续\n   309→            progress[\"longest_streak\"] = max(progress[\"current_streak\"], progress.get(\"longest_streak\", 0))\n   310→            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n   311→            progress[\"last_checkin_date\"] = today\n   312→\n   313→            # 记录签到历史（保留最近30天）\n   314→            history = progress.get(\"checkin_history\", [])\n   315→            history.append({\"date\": today, \"time\": now, \"notes\": args.get(\"notes\")})\n   316→            progress[\"checkin_history\"] = history[-30:]\n   317→\n   318→        elif action_type == \"lever_complete\":\n   319→            lever_id = args.get(\"lever_id\")\n   320→            if lever_id:"}]},"uuid":"270efb10-3e8d-492e-9d54-40620735c0f5","timestamp":"2026-01-19T12:17:02.839Z","toolUseResult":{"filePath":"/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py","oldString":"        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到\n            last_date = progress.get(\"last_checkin_date\")\n            if last_date:\n                last = date.fromisoformat(last_date)\n                today_date = date.today()\n                diff = (today_date - last).days\n                if diff == 1:\n                    progress[\"current_streak\"] += 1\n                elif diff > 1:\n                    progress[\"current_streak\"] = 1\n            else:\n                progress[\"current_streak\"] = 1\n\n            # 更新最长连续\n            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):\n                progress[\"longest_streak\"] = progress[\"current_streak\"]\n\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史\n            history = progress.get(\"checkin_history\", [])\n            history.append({\n                \"date\": today,\n                \"time\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天","newString":"        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到：连续则+1，断签则重置为1\n            last_date = progress.get(\"last_checkin_date\")\n            days_since_last = (date.today() - date.fromisoformat(last_date)).days if last_date else None\n            progress[\"current_streak\"] = progress[\"current_streak\"] + 1 if days_since_last == 1 else 1\n\n            # 更新最长连续\n            progress[\"longest_streak\"] = max(progress[\"current_streak\"], progress.get(\"longest_streak\", 0))\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史（保留最近30天）\n            history = progress.get(\"checkin_history\", [])\n            history.append({\"date\": today, \"time\": now, \"notes\": args.get(\"notes\")})\n            progress[\"checkin_history\"] = history[-30:]","originalFile":"\"\"\"\nLifecoach Skill - Tool Handlers V2\n\n使用 @tool_handler 装饰器注册工具执行器。\n支持数据持久化和展示卡片生成。\n\n数据结构 (与 DATA-STRUCTURE.md 对齐):\n- system: 系统配置（方法论、角色设定）\n- north_star: 北极星愿景、反愿景、使命、原则\n- goals: 核心目标（最多3个），包含年度目标\n- roadmap: 路线图（年度、季度）\n- current: 当前焦点（月度项目 current.month、周大石头 current.week、每日杠杆 current.daily）\n- identity: 身份设计（当前身份、目标身份、锚定行为）\n- progress: 进度追踪（签到、连续天数）\n- journal: 复盘日志（数组）\n\"\"\"\n\nimport uuid\nfrom typing import Any, Dict, List, Optional\nfrom datetime import datetime, date\n\nfrom services.agent.tool_registry import tool_handler, ToolContext\nfrom stores.unified_profile_repo import UnifiedProfileRepository\n\n\n# 有效的 section 列表（与 DATA-STRUCTURE.md 对齐）\nVALID_SECTIONS = [\"system\", \"north_star\", \"goals\", \"roadmap\", \"current\", \"identity\", \"progress\", \"journal\"]\n\n\ndef deep_merge(base: Dict, update: Dict) -> Dict:\n    \"\"\"深度合并两个字典\"\"\"\n    result = base.copy()\n    for key, value in update.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        elif value is not None:\n            result[key] = value\n    return result\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 数据工具 (V2 - 与 DATA-STRUCTURE.md 对齐)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"read_lifecoach_state\")\nasync def read_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    读取用户的人生地图状态\n\n    从 unified_profile 的 life_context.lifecoach 路径读取数据\n    支持的 sections: system, north_star, goals, roadmap, current, identity, progress, journal\n    \"\"\"\n    sections = args.get(\"sections\", [\"north_star\", \"goals\", \"current\", \"progress\"])\n\n    try:\n        # 从 unified_profile 读取 lifecoach 数据\n        data = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        if not data or not data.content:\n            return {\n                \"status\": \"empty\",\n                \"message\": \"尚未建立人生地图，让我们开始吧！\",\n                \"data\": {}\n            }\n\n        # 按请求的 sections 过滤返回\n        result = {}\n        content = data.content\n        for section in sections:\n            if section in content:\n                result[section] = content[section]\n\n        return {\n            \"status\": \"success\",\n            \"data\": result,\n            \"version\": data.version,\n            \"updated_at\": data.updated_at.isoformat() if data.updated_at else None\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"读取状态失败: {str(e)}\",\n            \"data\": {}\n        }\n\n\n@tool_handler(\"write_lifecoach_state\")\nasync def write_lifecoach_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    写入用户的人生地图状态\n\n    支持的 section: system, north_star, goals, roadmap, current, identity, progress\n    使用深度合并，避免覆盖已有数据\n\n    特别说明 - current 的嵌套结构:\n    - current.month: 月度项目\n    - current.week: 周大石头\n    - current.daily: 每日杠杆\n\n    示例：\n    write_lifecoach_state(section=\"current\", data={\"week\": {\"rocks\": [...]}})\n    会合并到 current.week，不会覆盖 current.month 和 current.daily\n    \"\"\"\n    section = args.get(\"section\")\n    data = args.get(\"data\")\n\n    if not section or not data:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: section 和 data\"\n        }\n\n    # 验证 section 有效性\n    if section not in VALID_SECTIONS:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"无效的 section: {section}。有效值: {', '.join(VALID_SECTIONS)}\"\n        }\n\n    try:\n        # 先读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        # 深度合并数据\n        content = existing.content if existing else {}\n\n        # 如果是 current 或其他嵌套结构，使用深度合并\n        if section in content and isinstance(content[section], dict) and isinstance(data, dict):\n            content[section] = deep_merge(content[section], data)\n        else:\n            content[section] = data\n\n        # 更新元信息\n        content[\"_last_updated\"] = datetime.utcnow().isoformat()\n        content[\"_last_section\"] = section\n\n        # 写入\n        result = await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            content\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": f\"已保存 {section}\",\n            \"version\": result.version\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"保存失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"add_journal_entry\")\nasync def add_journal_entry(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    添加复盘日志条目\n\n    与 DATA-STRUCTURE.md 的 journal 结构对齐:\n    journal 是一个数组，每个条目包含:\n    - date: 日期\n    - type: daily | weekly | monthly | quarterly | insight\n    - mood: 心情 (1-10)\n    - energy: 能量 (1-10)\n    - rocks_completed: 完成的大石头数\n    - rocks_total: 总大石头数\n    - goal_balance: 目标平衡统计 (周复盘)\n    - wins: 胜利列表\n    - struggles: 挑战列表\n    - insight: 洞察\n    - gratitude: 感恩\n    - tomorrow: 明天计划\n    - next_week_focus: 下周聚焦\n    \"\"\"\n    entry_type = args.get(\"entry_type\")\n    content = args.get(\"content\")\n\n    if not entry_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: entry_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        # journal 是一个数组（与 DATA-STRUCTURE.md 对齐）\n        journal = lifecoach_data.get(\"journal\", [])\n        if isinstance(journal, dict):\n            # 兼容旧格式：从 entries 数组迁移\n            journal = journal.get(\"entries\", [])\n\n        today = date.today().isoformat()\n\n        # 创建新条目（与 DATA-STRUCTURE.md 字段对齐）\n        entry = {\n            \"date\": args.get(\"date\", today),\n            \"type\": entry_type,\n            \"content\": content,  # 额外字段：摘要内容\n            \"mood\": args.get(\"mood\"),\n            \"energy\": args.get(\"energy\"),\n            \"rocks_completed\": args.get(\"rocks_completed\"),\n            \"rocks_total\": args.get(\"rocks_total\"),\n            \"goal_balance\": args.get(\"goal_balance\"),  # 周复盘用\n            \"wins\": args.get(\"wins\", []),\n            \"struggles\": args.get(\"blockers\", []),  # 兼容旧参数名\n            \"insight\": args.get(\"insight\"),\n            \"gratitude\": args.get(\"gratitude\"),\n            \"tomorrow\": args.get(\"tomorrow\"),\n            \"next_week_focus\": args.get(\"next_week_focus\"),\n            \"adjustments\": args.get(\"adjustments\", []),\n            \"learnings\": args.get(\"learnings\", []),\n            \"_created_at\": datetime.utcnow().isoformat(),\n        }\n\n        # 清理 None 值\n        entry = {k: v for k, v in entry.items() if v is not None}\n\n        # 添加到日志列表（最新在前）\n        journal = [entry] + journal[:99]  # 保留最近100条\n\n        # 保存\n        lifecoach_data[\"journal\"] = journal\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"日志已记录\",\n            \"date\": entry[\"date\"],\n            \"type\": entry_type\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"记录失败: {str(e)}\"\n        }\n\n\n@tool_handler(\"update_progress\")\nasync def update_progress(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    更新进度/签到\n    \"\"\"\n    action_type = args.get(\"action_type\")\n\n    if not action_type:\n        return {\n            \"status\": \"error\",\n            \"message\": \"缺少必要参数: action_type\"\n        }\n\n    try:\n        # 读取现有数据\n        existing = await UnifiedProfileRepository.read_life_context_path(\n            context.user_id,\n            \"lifecoach\"\n        )\n\n        lifecoach_data = existing.content if existing else {}\n        progress = lifecoach_data.get(\"progress\", {\n            \"current_streak\": 0,\n            \"longest_streak\": 0,\n            \"total_checkins\": 0,\n            \"last_checkin_date\": None,\n            \"checkin_history\": [],\n            \"completed_levers\": [],\n            \"completed_rocks\": [],\n            \"milestones\": []\n        })\n\n        today = date.today().isoformat()\n        now = datetime.utcnow().isoformat()\n\n        if action_type == \"daily_checkin\":\n            # 检查是否今天已签到\n            if progress.get(\"last_checkin_date\") == today:\n                return {\n                    \"status\": \"already_checked_in\",\n                    \"message\": \"今天已经签到过了！\",\n                    \"current_streak\": progress[\"current_streak\"]\n                }\n\n            # 更新连续签到\n            last_date = progress.get(\"last_checkin_date\")\n            if last_date:\n                last = date.fromisoformat(last_date)\n                today_date = date.today()\n                diff = (today_date - last).days\n                if diff == 1:\n                    progress[\"current_streak\"] += 1\n                elif diff > 1:\n                    progress[\"current_streak\"] = 1\n            else:\n                progress[\"current_streak\"] = 1\n\n            # 更新最长连续\n            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):\n                progress[\"longest_streak\"] = progress[\"current_streak\"]\n\n            progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1\n            progress[\"last_checkin_date\"] = today\n\n            # 记录签到历史\n            history = progress.get(\"checkin_history\", [])\n            history.append({\n                \"date\": today,\n                \"time\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天\n\n        elif action_type == \"lever_complete\":\n            lever_id = args.get(\"lever_id\")\n            if lever_id:\n                completed = progress.get(\"completed_levers\", [])\n                completed.append({\n                    \"id\": lever_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_levers\"] = completed[-100:]\n\n        elif action_type == \"rock_complete\":\n            rock_id = args.get(\"rock_id\")\n            if rock_id:\n                completed = progress.get(\"completed_rocks\", [])\n                completed.append({\n                    \"id\": rock_id,\n                    \"completed_at\": now,\n                    \"notes\": args.get(\"notes\")\n                })\n                progress[\"completed_rocks\"] = completed[-50:]\n\n        elif action_type == \"milestone_reached\":\n            milestones = progress.get(\"milestones\", [])\n            milestones.append({\n                \"reached_at\": now,\n                \"notes\": args.get(\"notes\")\n            })\n            progress[\"milestones\"] = milestones\n\n        # 保存\n        lifecoach_data[\"progress\"] = progress\n        await UnifiedProfileRepository.write_life_context_path(\n            context.user_id,\n            \"lifecoach\",\n            lifecoach_data\n        )\n\n        return {\n            \"status\": \"success\",\n            \"message\": \"进度已更新\",\n            \"current_streak\": progress.get(\"current_streak\", 0),\n            \"total_checkins\": progress.get(\"total_checkins\", 0)\n        }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"更新失败: {str(e)}\"\n        }\n\n\n# ══════════════════��════════════════════════════════════════════════════════\n# 展示工具 - V2 新增\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_life_roadmap\")\nasync def show_life_roadmap(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生路线图卡片\n    \"\"\"\n    north_star = args.get(\"north_star\", {})\n\n    return {\n        \"card_type\": \"life_roadmap\",\n        \"data\": {\n            \"north_star\": north_star,\n            \"yearly_theme\": args.get(\"yearly_theme\"),\n            \"quarterly_milestones\": args.get(\"quarterly_milestones\", []),\n            \"current_focus\": args.get(\"current_focus\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\ndef _calculate_balance_score(roles: List[Dict]) -> float:\n    \"\"\"计算角色平衡分数：平均分越高、方差越小，分数越高\"\"\"\n    scores = [r.get(\"current_score\", 0) for r in roles if r.get(\"current_score\") is not None]\n    if not scores:\n        return 0\n    avg = sum(scores) / len(scores)\n    variance = sum((s - avg) ** 2 for s in scores) / len(scores)\n    return min(100, max(0, avg * 10 - variance * 2))\n\n\n@tool_handler(\"show_role_balance\")\nasync def show_role_balance(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示目标平衡轮卡片\n    \"\"\"\n    roles = args.get(\"roles\", [])\n    balance_score = _calculate_balance_score(roles) if roles else args.get(\"balance_score\", 0)\n\n    return {\n        \"card_type\": \"role_balance\",\n        \"data\": {\n            \"roles\": roles,\n            \"balance_score\": round(balance_score, 1),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\ndef _calculate_completion_stats(items: List[Dict], include_in_progress: bool = False) -> Dict[str, Any]:\n    \"\"\"计算完成统计\"\"\"\n    total = len(items)\n    completed = sum(1 for item in items if item.get(\"status\") == \"completed\")\n    stats = {\n        \"total\": total,\n        \"completed\": completed,\n        \"completion_rate\": round(completed / total * 100, 1) if total > 0 else 0\n    }\n    if include_in_progress:\n        stats[\"in_progress\"] = sum(1 for item in items if item.get(\"status\") == \"in_progress\")\n    return stats\n\n\n@tool_handler(\"show_weekly_rocks\")\nasync def show_weekly_rocks(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示周大石头卡片\n    \"\"\"\n    rocks = args.get(\"rocks\", [])\n\n    return {\n        \"card_type\": \"weekly_rocks\",\n        \"data\": {\n            \"week_start\": args.get(\"week_start\", date.today().isoformat()),\n            \"rocks\": rocks,\n            \"theme\": args.get(\"theme\"),\n            \"energy_budget\": args.get(\"energy_budget\"),\n            \"stats\": _calculate_completion_stats(rocks, include_in_progress=True),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_daily_levers\")\nasync def show_daily_levers(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示每日杠杆行动卡片\n    \"\"\"\n    levers = args.get(\"levers\", [])\n\n    return {\n        \"card_type\": \"daily_levers\",\n        \"data\": {\n            \"date\": args.get(\"date\", date.today().isoformat()),\n            \"levers\": levers,\n            \"energy_level\": args.get(\"energy_level\"),\n            \"intention\": args.get(\"intention\"),\n            \"stats\": _calculate_completion_stats(levers),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_progress_streak\")\nasync def show_progress_streak(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示连续签到和进度统计卡片\n    \"\"\"\n    current_streak = args.get(\"current_streak\", 0)\n    longest_streak = args.get(\"longest_streak\", current_streak)\n\n    # 计算激励消息\n    if current_streak >= 30:\n        motivation = \"太棒了！一个月的坚持，你正在重塑自己！\"\n    elif current_streak >= 14:\n        motivation = \"两周了！习惯正在形成，继续保持！\"\n    elif current_streak >= 7:\n        motivation = \"一周连续签到！你已经超越了大多数人！\"\n    elif current_streak >= 3:\n        motivation = \"连续三天，好的开始！\"\n    elif current_streak >= 1:\n        motivation = \"今天是新的开始！\"\n    else:\n        motivation = \"准备好开始你的旅程了吗？\"\n\n    return {\n        \"card_type\": \"progress_streak\",\n        \"data\": {\n            \"current_streak\": current_streak,\n            \"longest_streak\": longest_streak,\n            \"total_checkins\": args.get(\"total_checkins\", 0),\n            \"weekly_completion_rate\": args.get(\"weekly_completion_rate\", 0),\n            \"monthly_stats\": args.get(\"monthly_stats\", {}),\n            \"achievements\": args.get(\"achievements\", []),\n            \"motivation\": motivation,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 展示工具 - V1 保留 (使用 @tool_handler 重写)\n# ═══════════════════════════════════════════════════════════════════════════\n\n@tool_handler(\"show_pattern_insight\")\nasync def show_pattern_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行为模式洞察卡片\n    \"\"\"\n    pattern_type = args.get(\"pattern_type\", \"behavior\")\n\n    type_labels = {\n        \"behavior\": \"行为模式\",\n        \"stuck\": \"卡点分析\",\n        \"conflict\": \"目标冲突\",\n        \"protection\": \"自我保护\"\n    }\n\n    return {\n        \"card_type\": \"pattern_insight\",\n        \"data\": {\n            \"type\": pattern_type,\n            \"type_label\": type_labels.get(pattern_type, \"模式分析\"),\n            \"surface_pattern\": args.get(\"surface_pattern\", \"\"),\n            \"hidden_goal\": args.get(\"hidden_goal\"),\n            \"cost\": args.get(\"cost\"),\n            \"insight\": args.get(\"insight\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_identity_design\")\nasync def show_identity_design(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示身份设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"identity_design\",\n        \"data\": {\n            \"old_identity\": args.get(\"old_identity\"),\n            \"new_identity\": args.get(\"new_identity\", \"\"),\n            \"bridge_belief\": args.get(\"bridge_belief\"),\n            \"anchor_behaviors\": args.get(\"anchor_behaviors\", []),\n            \"transformation_arrow\": \"→\" if args.get(\"old_identity\") else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_vision_map\")\nasync def show_vision_map(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示愿景/反愿景地图\n    \"\"\"\n    map_type = args.get(\"map_type\", \"vision\")\n\n    return {\n        \"card_type\": \"vision_map\",\n        \"data\": {\n            \"map_type\": map_type,\n            \"vision\": {\n                \"statement\": args.get(\"vision_statement\"),\n                \"three_year_picture\": args.get(\"three_year_picture\"),\n                \"identity_belief\": args.get(\"identity_belief\"),\n                \"one_year_milestone\": args.get(\"one_year_milestone\")\n            } if map_type in [\"vision\", \"both\"] else None,\n            \"anti_vision\": {\n                \"statement\": args.get(\"anti_vision_statement\"),\n                \"five_year_picture\": args.get(\"five_year_picture\")\n            } if map_type in [\"anti_vision\", \"both\"] else None,\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_action_plan\")\nasync def show_action_plan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示行动计划卡片\n    \"\"\"\n    return {\n        \"card_type\": \"action_plan\",\n        \"data\": {\n            \"context\": args.get(\"context\"),\n            \"hierarchy\": {\n                \"one_year_goal\": args.get(\"one_year_goal\"),\n                \"one_month_project\": args.get(\"one_month_project\"),\n                \"daily_actions\": args.get(\"daily_actions\", [])\n            },\n            \"first_step\": args.get(\"first_step\"),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n\n\n@tool_handler(\"show_life_game\")\nasync def show_life_game(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"\n    展示人生游戏设计卡片\n    \"\"\"\n    return {\n        \"card_type\": \"life_game\",\n        \"data\": {\n            \"win_condition\": args.get(\"win_condition\", \"\"),\n            \"lose_condition\": args.get(\"lose_condition\", \"\"),\n            \"main_mission\": args.get(\"main_mission\", \"\"),\n            \"current_boss\": {\n                \"name\": args.get(\"current_boss\"),\n                \"reward\": args.get(\"boss_reward\")\n            } if args.get(\"current_boss\") else None,\n            \"daily_quests\": args.get(\"daily_quests\", []),\n            \"game_rules\": args.get(\"game_rules\", []),\n            \"generated_at\": datetime.utcnow().isoformat()\n        }\n    }\n","structuredPatch":[{"oldStart":300,"oldLines":34,"newStart":300,"newLines":20,"lines":["                     \"current_streak\": progress[\"current_streak\"]","                 }"," ","-            # 更新连续签到","+            # 更新连续签到：连续则+1，断签则重置为1","             last_date = progress.get(\"last_checkin_date\")","-            if last_date:","-                last = date.fromisoformat(last_date)","-                today_date = date.today()","-                diff = (today_date - last).days","-                if diff == 1:","-                    progress[\"current_streak\"] += 1","-                elif diff > 1:","-                    progress[\"current_streak\"] = 1","-            else:","-                progress[\"current_streak\"] = 1","+            days_since_last = (date.today() - date.fromisoformat(last_date)).days if last_date else None","+            progress[\"current_streak\"] = progress[\"current_streak\"] + 1 if days_since_last == 1 else 1"," ","             # 更新最长连续","-            if progress[\"current_streak\"] > progress.get(\"longest_streak\", 0):","-                progress[\"longest_streak\"] = progress[\"current_streak\"]","-","+            progress[\"longest_streak\"] = max(progress[\"current_streak\"], progress.get(\"longest_streak\", 0))","             progress[\"total_checkins\"] = progress.get(\"total_checkins\", 0) + 1","             progress[\"last_checkin_date\"] = today"," ","-            # 记录签到历史","+            # 记录签到历史（保留最近30天）","             history = progress.get(\"checkin_history\", [])","-            history.append({","-                \"date\": today,","-                \"time\": now,","-                \"notes\": args.get(\"notes\")","-            })","-            progress[\"checkin_history\"] = history[-30:]  # 保留最近30天","+            history.append({\"date\": today, \"time\": now, \"notes\": args.get(\"notes\")})","+            progress[\"checkin_history\"] = history[-30:]"," ","         elif action_type == \"lever_complete\":","             lever_id = args.get(\"lever_id\")"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"12df4d0f-bfac-44d8-a625-ddb8824cdaaa"}
{"parentUuid":"270efb10-3e8d-492e-9d54-40620735c0f5","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BUZxWoVPcL1g19qhwntGzt","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me simplify the trigger_detector.py. The event detectors for zodiac events share similar patterns:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1454,"cache_read_input_tokens":42591,"cache_creation":{"ephemeral_5m_input_tokens":1454,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXGipfy3eqRp4fskURxaE","type":"assistant","uuid":"beda2990-ce5f-42b8-bb0d-ff8414dbc492","timestamp":"2026-01-19T12:17:09.478Z"}
{"parentUuid":"beda2990-ce5f-42b8-bb0d-ff8414dbc492","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BUZxWoVPcL1g19qhwntGzt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MWGtkwoUqtL43Y7fEgSHPd","name":"Edit","input":{"replace_all":false,"file_path":"/home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py","old_string":"    async def _detect_solar_term(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测节气\"\"\"\n        # 使用 ZodiacEvents 获取节气信息\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"solar_term\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"description\": event.description,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect solar term: {e}\")\n\n        return False, None\n\n    async def _detect_lunar_phase(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测月相 (新月/满月)\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type in (\"new_moon\", \"full_moon\"):\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"phase\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect lunar phase: {e}\")\n\n        return False, None\n\n    async def _detect_mercury_retrograde(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测水逆\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"mercury_retrograde\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"end_date\": event.end_date,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect mercury retrograde: {e}\")\n\n        return False, None\n\n    async def _detect_significant_transit(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测重要行星过境\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            significant_types = (\"saturn_return\", \"jupiter_transit\", \"eclipse\")\n\n            for event in events:\n                if event.event_type in significant_types:\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"transit_type\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect significant transit: {e}\")\n\n        return False, None","new_string":"    async def _detect_zodiac_event(\n        self,\n        advance_days: List[int],\n        event_types: Tuple[str, ...],\n        extra_fields: Optional[Dict[str, str]] = None,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"通用星象事件检测器\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type in event_types:\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        result = {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                        }\n                        # 添加事件特定字段\n                        if extra_fields:\n                            for key, attr in extra_fields.items():\n                                result[key] = getattr(event, attr, None) if attr != \"event_type\" else event.event_type\n                        return True, result\n        except Exception as e:\n            logger.error(f\"Failed to detect zodiac event {event_types}: {e}\")\n\n        return False, None\n\n    async def _detect_solar_term(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测节气\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"solar_term\",),\n            {\"description\": \"description\"}\n        )\n\n    async def _detect_lunar_phase(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测月相 (新月/满月)\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"new_moon\", \"full_moon\"),\n            {\"phase\": \"event_type\"}\n        )\n\n    async def _detect_mercury_retrograde(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测水逆\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"mercury_retrograde\",),\n            {\"end_date\": \"end_date\"}\n        )\n\n    async def _detect_significant_transit(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测重要行星过境\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"saturn_return\", \"jupiter_transit\", \"eclipse\"),\n            {\"transit_type\": \"event_type\"}\n        )"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1454,"cache_read_input_tokens":42591,"cache_creation":{"ephemeral_5m_input_tokens":1454,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXGipfy3eqRp4fskURxaE","type":"assistant","uuid":"378d633e-0d9b-4c08-a2e2-09d2f61ff5c9","timestamp":"2026-01-19T12:17:26.654Z"}
{"parentUuid":"378d633e-0d9b-4c08-a2e2-09d2f61ff5c9","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MWGtkwoUqtL43Y7fEgSHPd","type":"tool_result","content":"The file /home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   343→            }\n   344→\n   345→        return False, None\n   346→\n   347→    async def _detect_zodiac_event(\n   348→        self,\n   349→        advance_days: List[int],\n   350→        event_types: Tuple[str, ...],\n   351→        extra_fields: Optional[Dict[str, str]] = None,\n   352→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   353→        \"\"\"通用星象事件检测器\"\"\"\n   354→        today = date.today()\n   355→\n   356→        try:\n   357→            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n   358→\n   359→            for event in events:\n   360→                if event.event_type in event_types:\n   361→                    days_until = (event.start_date - today).days\n   362→                    if days_until in advance_days:\n   363→                        result = {\n   364→                            \"event_name\": event.name,\n   365→                            \"event_date\": event.start_date,\n   366→                            \"days_until\": days_until,\n   367→                        }\n   368→                        # 添加事件特定字段\n   369→                        if extra_fields:\n   370→                            for key, attr in extra_fields.items():\n   371→                                result[key] = getattr(event, attr, None) if attr != \"event_type\" else event.event_type\n   372→                        return True, result\n   373→        except Exception as e:\n   374→            logger.error(f\"Failed to detect zodiac event {event_types}: {e}\")\n   375→\n   376→        return False, None\n   377→\n   378→    async def _detect_solar_term(\n   379→        self,\n   380→        profile: Dict,\n   381→        advance_days: List[int],\n   382→        skill_id: str,\n   383→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   384→        \"\"\"检测节气\"\"\"\n   385→        return await self._detect_zodiac_event(\n   386→            advance_days,\n   387→            (\"solar_term\",),\n   388→            {\"description\": \"description\"}\n   389→        )\n   390→\n   391→    async def _detect_lunar_phase(\n   392→        self,\n   393→        profile: Dict,\n   394→        advance_days: List[int],\n   395→        skill_id: str,\n   396→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   397→        \"\"\"检测月相 (新月/满月)\"\"\"\n   398→        return await self._detect_zodiac_event(\n   399→            advance_days,\n   400→            (\"new_moon\", \"full_moon\"),\n   401→            {\"phase\": \"event_type\"}\n   402→        )\n   403→\n   404→    async def _detect_mercury_retrograde(\n   405→        self,\n   406→        profile: Dict,\n   407→        advance_days: List[int],\n   408→        skill_id: str,\n   409→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   410→        \"\"\"检测水逆\"\"\"\n   411→        return await self._detect_zodiac_event(\n   412→            advance_days,\n   413→            (\"mercury_retrograde\",),\n   414→            {\"end_date\": \"end_date\"}\n   415→        )\n   416→\n   417→    async def _detect_significant_transit(\n   418→        self,\n   419→        profile: Dict,\n   420→        advance_days: List[int],\n   421→        skill_id: str,\n   422→    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n   423→        \"\"\"检测重要行星过境\"\"\"\n   424→        return await self._detect_zodiac_event(\n   425→            advance_days,\n   426→            (\"saturn_return\", \"jupiter_transit\", \"eclipse\"),\n   427→            {\"transit_type\": \"event_type\"}\n   428→        )\n   429→\n   430→    # ═══════════════════════════════════════════════════════════════════════════\n   431→    # Lifecoach 事件检测器\n   432→    # ═══════════════════════════════════════════════════════════════════════════"}]},"uuid":"ca055b05-12dd-4adb-93b8-beeef382a47a","timestamp":"2026-01-19T12:17:29.377Z","toolUseResult":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py","oldString":"    async def _detect_solar_term(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测节气\"\"\"\n        # 使用 ZodiacEvents 获取节气信息\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"solar_term\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"description\": event.description,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect solar term: {e}\")\n\n        return False, None\n\n    async def _detect_lunar_phase(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测月相 (新月/满月)\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type in (\"new_moon\", \"full_moon\"):\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"phase\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect lunar phase: {e}\")\n\n        return False, None\n\n    async def _detect_mercury_retrograde(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测水逆\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"mercury_retrograde\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"end_date\": event.end_date,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect mercury retrograde: {e}\")\n\n        return False, None\n\n    async def _detect_significant_transit(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测重要行星过境\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            significant_types = (\"saturn_return\", \"jupiter_transit\", \"eclipse\")\n\n            for event in events:\n                if event.event_type in significant_types:\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"transit_type\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect significant transit: {e}\")\n\n        return False, None","newString":"    async def _detect_zodiac_event(\n        self,\n        advance_days: List[int],\n        event_types: Tuple[str, ...],\n        extra_fields: Optional[Dict[str, str]] = None,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"通用星象事件检测器\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type in event_types:\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        result = {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                        }\n                        # 添加事件特定字段\n                        if extra_fields:\n                            for key, attr in extra_fields.items():\n                                result[key] = getattr(event, attr, None) if attr != \"event_type\" else event.event_type\n                        return True, result\n        except Exception as e:\n            logger.error(f\"Failed to detect zodiac event {event_types}: {e}\")\n\n        return False, None\n\n    async def _detect_solar_term(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测节气\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"solar_term\",),\n            {\"description\": \"description\"}\n        )\n\n    async def _detect_lunar_phase(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测月相 (新月/满月)\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"new_moon\", \"full_moon\"),\n            {\"phase\": \"event_type\"}\n        )\n\n    async def _detect_mercury_retrograde(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测水逆\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"mercury_retrograde\",),\n            {\"end_date\": \"end_date\"}\n        )\n\n    async def _detect_significant_transit(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测重要行星过境\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"saturn_return\", \"jupiter_transit\", \"eclipse\"),\n            {\"transit_type\": \"event_type\"}\n        )","originalFile":"\"\"\"\nTriggerDetector - 触发条件检测器\n\n支持三种触发类型:\n1. time_based - 基于时间 (cron 表达式)\n2. event_based - 基于事件 (节气、月相、生日、大运交接等)\n3. threshold_based - 基于阈值 (运势分数等)\n\n设计原则:\n- 从 unified_profiles 读取数据\n- 支持 Skill 级自定义事件\n- 智能化: 事件触发 + 阈值触发\n\"\"\"\n\nimport logging\nfrom datetime import datetime, date, timedelta\nfrom typing import Dict, Any, Optional, Tuple, List\n\nimport pytz\n\nfrom skills.zodiac.services.events import ZodiacEvents\n\nlogger = logging.getLogger(__name__)\n\n\nclass TriggerDetector:\n    \"\"\"触发条件检测器\"\"\"\n\n    def __init__(self):\n        self._event_detectors = {\n            \"birthday\": self._detect_birthday,\n            \"dayun_change\": self._detect_dayun_change,\n            \"new_year\": self._detect_new_year,\n            \"solar_term\": self._detect_solar_term,\n            \"lunar_phase\": self._detect_lunar_phase,\n            \"mercury_retrograde\": self._detect_mercury_retrograde,\n            \"significant_transit\": self._detect_significant_transit,\n            # Lifecoach 事件\n            \"streak_broken\": self._detect_streak_broken,\n        }\n\n        # Lifecoach 条件检查器 (用于 reminders.yaml conditions)\n        self._condition_checkers = {\n            \"has_data\": self._check_has_data,\n            \"not_checked_in_today\": self._check_not_checked_in_today,\n            \"checked_in_today\": self._check_checked_in_today,\n            \"has_weekly_data\": self._check_has_weekly_data,\n            \"not_reviewed_this_week\": self._check_not_reviewed_this_week,\n            \"not_planned_this_week\": self._check_not_planned_this_week,\n            \"has_pending_levers\": self._check_has_pending_levers,\n            \"had_streak\": self._check_had_streak,\n        }\n\n    async def should_trigger(\n        self,\n        trigger_config: Dict[str, Any],\n        profile: Dict[str, Any],\n        skill_id: str,\n        conditions: Optional[List[Dict]] = None,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"\n        检测是否应该触发\n\n        Args:\n            trigger_config: 触发配置 (type, schedule 等)\n            profile: 用户 profile\n            skill_id: Skill ID\n            conditions: 额外条件列表 (来自 reminders.yaml)\n\n        Returns:\n            (should_trigger, event_info)\n            - should_trigger: 是否触发\n            - event_info: 事件信息 (event_name, event_date 等)\n        \"\"\"\n        trigger_type = trigger_config.get(\"type\")\n\n        # 1. 检查触发条件\n        if trigger_type == \"time_based\":\n            triggered = self._check_time_based(trigger_config, profile)\n            event_info = None\n        elif trigger_type == \"event_based\":\n            triggered, event_info = await self._check_event_based(trigger_config, profile, skill_id)\n        elif trigger_type == \"threshold_based\":\n            triggered, event_info = await self._check_threshold_based(trigger_config, profile, skill_id)\n        else:\n            return False, None\n\n        if not triggered:\n            return False, None\n\n        # 2. 检查额外条件 (所有条件必须满足)\n        if conditions:\n            for condition in conditions:\n                if not await self._check_condition(condition, profile, skill_id):\n                    return False, None\n\n        return True, event_info\n\n    async def _check_condition(\n        self,\n        condition: Dict[str, Any],\n        profile: Dict[str, Any],\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查单个条件\"\"\"\n        condition_type = condition.get(\"type\")\n        checker = self._condition_checkers.get(condition_type)\n\n        if not checker:\n            logger.warning(f\"Unknown condition type: {condition_type}\")\n            return True  # 未知条件默认通过\n\n        try:\n            return await checker(condition, profile, skill_id)\n        except Exception as e:\n            logger.error(f\"Failed to check condition {condition_type}: {e}\")\n            return False\n\n    def _check_time_based(self, config: Dict, profile: Dict) -> bool:\n        \"\"\"\n        检查时间触发条件\n\n        支持简化的 cron 格式: \"0 4 * * *\" (分 时 日 月 周)\n        \"\"\"\n        schedule = config.get(\"schedule\", \"\")\n        timezone_aware = config.get(\"timezone_aware\", True)\n\n        if not schedule:\n            return False\n\n        # 获取用户时区\n        if timezone_aware:\n            user_tz = profile.get(\"preferences\", {}).get(\"timezone\", \"Asia/Shanghai\")\n            try:\n                now = datetime.now(pytz.timezone(user_tz))\n            except Exception:\n                now = datetime.now(pytz.timezone(\"Asia/Shanghai\"))\n        else:\n            now = datetime.now(pytz.UTC)\n\n        # 解析 cron 表达式\n        return self._match_cron(schedule, now)\n\n    def _match_cron(self, schedule: str, now: datetime) -> bool:\n        \"\"\"匹配简化的 cron 表达式\"\"\"\n        try:\n            parts = schedule.split()\n            if len(parts) != 5:\n                return False\n\n            minute, hour, day, month, weekday = parts\n\n            # 检查各字段\n            if minute != \"*\" and int(minute) != now.minute:\n                return False\n            if hour != \"*\" and int(hour) != now.hour:\n                return False\n            if day != \"*\" and int(day) != now.day:\n                return False\n            if month != \"*\" and int(month) != now.month:\n                return False\n            if weekday != \"*\" and int(weekday) != now.weekday():\n                return False\n\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to parse cron schedule '{schedule}': {e}\")\n            return False\n\n    async def _check_event_based(\n        self,\n        config: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检查事件触发条件\"\"\"\n        event = config.get(\"event\")\n        advance_days = config.get(\"advance_days\", [0])\n\n        # 确保 advance_days 是列表\n        if isinstance(advance_days, int):\n            advance_days = [advance_days]\n\n        detector = self._event_detectors.get(event)\n        if not detector:\n            logger.warning(f\"Unknown event type: {event}\")\n            return False, None\n\n        return await detector(profile, advance_days, skill_id)\n\n    async def _check_threshold_based(\n        self,\n        config: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检查阈值触发条件\"\"\"\n        metric = config.get(\"metric\")\n        condition = config.get(\"condition\")\n        threshold = config.get(\"threshold\")\n        cooldown = config.get(\"cooldown\", 0)\n\n        # 获取指标值\n        value = await self._get_metric_value(metric, profile, skill_id)\n        if value is None:\n            return False, None\n\n        # TODO: 检查冷却期 (需要记录上次触发时间)\n\n        # 检查条件\n        triggered = False\n        if condition == \"<\":\n            triggered = value < threshold\n        elif condition == \">\":\n            triggered = value > threshold\n        elif condition == \"<=\":\n            triggered = value <= threshold\n        elif condition == \">=\":\n            triggered = value >= threshold\n        elif condition == \"==\":\n            triggered = value == threshold\n\n        if triggered:\n            return True, {\"metric\": metric, \"value\": value, \"threshold\": threshold}\n\n        return False, None\n\n    async def _get_metric_value(\n        self,\n        metric: str,\n        profile: Dict,\n        skill_id: str,\n    ) -> Optional[float]:\n        \"\"\"获取指标值\"\"\"\n        if metric == \"daily_fortune_score\":\n            # 计算今日运势分数\n            from skills.bazi.services import BaziComputer\n            computer = BaziComputer()\n            return await computer.get_daily_fortune_score(profile)\n\n        # 可扩展其他指标\n        return None\n\n    # ═════════════════���═════════════════════════════════════════════════════════\n    # 事件检测器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    async def _detect_birthday(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测生日\"\"\"\n        birth_info = profile.get(\"birth_info\", {})\n        birth_date_str = birth_info.get(\"date\")\n\n        if not birth_date_str:\n            return False, None\n\n        try:\n            birth = datetime.strptime(birth_date_str, \"%Y-%m-%d\").date()\n        except ValueError:\n            return False, None\n\n        today = date.today()\n        birthday_this_year = date(today.year, birth.month, birth.day)\n\n        # 如果今年生日已过，检查明年\n        if birthday_this_year < today:\n            birthday_this_year = date(today.year + 1, birth.month, birth.day)\n\n        days_until = (birthday_this_year - today).days\n\n        if days_until in advance_days:\n            event_name = \"birthday\" if days_until == 0 else f\"birthday_{days_until}days\"\n            return True, {\n                \"event_name\": event_name,\n                \"event_date\": birthday_this_year,\n                \"days_until\": days_until,\n            }\n\n        return False, None\n\n    async def _detect_dayun_change(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测大运交接\"\"\"\n        from skills.bazi.services import BaziComputer\n\n        computer = BaziComputer()\n        inflection_points = await computer.get_inflection_points(profile)\n\n        today = date.today()\n\n        for point in inflection_points:\n            if point.get(\"type\") == \"major_cycle_change\":\n                point_year = point.get(\"year\")\n                if point_year:\n                    # 大运交接通常在年初\n                    point_date = date(point_year, 1, 1)\n                    days_until = (point_date - today).days\n\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": point.get(\"title\", \"大运交接\"),\n                            \"event_date\": point_date,\n                            \"days_until\": days_until,\n                            \"point\": point,\n                        }\n\n        return False, None\n\n    async def _detect_new_year(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测新年\"\"\"\n        today = date.today()\n        next_new_year = date(today.year + 1, 1, 1)\n\n        # 如果今天是元旦\n        if today.month == 1 and today.day == 1:\n            if 0 in advance_days:\n                return True, {\n                    \"event_name\": \"new_year\",\n                    \"event_date\": today,\n                    \"days_until\": 0,\n                }\n\n        days_until = (next_new_year - today).days\n\n        if days_until in advance_days:\n            return True, {\n                \"event_name\": \"new_year\",\n                \"event_date\": next_new_year,\n                \"days_until\": days_until,\n            }\n\n        return False, None\n\n    async def _detect_solar_term(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测节气\"\"\"\n        # 使用 ZodiacEvents 获取节气信息\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"solar_term\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"description\": event.description,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect solar term: {e}\")\n\n        return False, None\n\n    async def _detect_lunar_phase(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测月相 (新月/满月)\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type in (\"new_moon\", \"full_moon\"):\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"phase\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect lunar phase: {e}\")\n\n        return False, None\n\n    async def _detect_mercury_retrograde(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测水逆\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type == \"mercury_retrograde\":\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"end_date\": event.end_date,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect mercury retrograde: {e}\")\n\n        return False, None\n\n    async def _detect_significant_transit(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测重要行星过境\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            significant_types = (\"saturn_return\", \"jupiter_transit\", \"eclipse\")\n\n            for event in events:\n                if event.event_type in significant_types:\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                            \"transit_type\": event.event_type,\n                        }\n        except Exception as e:\n            logger.error(f\"Failed to detect significant transit: {e}\")\n\n        return False, None\n\n    # ═══════════════════════════════════════════════════════════════════════════\n    # Lifecoach 事件检测器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    async def _detect_streak_broken(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测断签事件\"\"\"\n        lifecoach = profile.get(\"life_context\", {}).get(\"_paths\", {}).get(\"lifecoach\", {})\n        progress = lifecoach.get(\"progress\", {})\n\n        last_checkin = progress.get(\"last_checkin_date\")\n        previous_streak = progress.get(\"current_streak\", 0)\n\n        if not last_checkin:\n            return False, None\n\n        try:\n            last_date = datetime.strptime(last_checkin, \"%Y-%m-%d\").date()\n            days_since = (date.today() - last_date).days\n\n            # 断签：超过1天未签到，且之前有连续签到记录\n            if days_since >= 2 and previous_streak >= 3:\n                return True, {\n                    \"event_name\": \"streak_broken\",\n                    \"event_date\": date.today(),\n                    \"days_since_checkin\": days_since,\n                    \"previous_streak\": previous_streak,\n                }\n        except Exception as e:\n            logger.error(f\"Failed to detect streak broken: {e}\")\n\n        return False, None\n\n    # ═══════════════════════════════════════════════════════════════════════════\n    # Lifecoach 条件检查器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    def _get_lifecoach_data(self, profile: Dict) -> Dict:\n        \"\"\"获取 lifecoach 数据\"\"\"\n        life_context = profile.get(\"life_context\", {})\n        paths = life_context.get(\"_paths\", {})\n        return paths.get(\"lifecoach\", {})\n\n    async def _check_has_data(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查指定路径是否有数据\"\"\"\n        path = condition.get(\"path\", \"\")\n        if not path:\n            return False\n\n        # 解析路径 (e.g., \"lifecoach.north_star.vision_statement\")\n        parts = path.split(\".\")\n        data = profile\n\n        # 处理 life_context._paths 前缀\n        if parts[0] == \"lifecoach\":\n            data = self._get_lifecoach_data(profile)\n            parts = parts[1:]  # 去掉 lifecoach 前缀\n\n        for part in parts:\n            if isinstance(data, dict) and part in data:\n                data = data[part]\n            else:\n                return False\n\n        return bool(data)\n\n    async def _check_not_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否未签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return True  # 从未签到\n\n        return last_checkin != date.today().isoformat()\n\n    async def _check_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否已签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return False\n\n        return last_checkin == date.today().isoformat()\n\n    async def _check_has_weekly_data(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查是否有本周数据\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        week = current.get(\"week\", {})\n\n        return bool(week.get(\"rocks\"))\n\n    async def _check_not_reviewed_this_week(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查本周是否未复盘\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        journal = lifecoach.get(\"journal\", [])\n\n        if not journal:\n            return True\n\n        # 获取本周一的日期\n        today = date.today()\n        monday = today - timedelta(days=today.weekday())\n\n        # 检查是否有本周的 weekly 复盘\n        for entry in journal:\n            if entry.get(\"type\") == \"weekly\":\n                entry_date_str = entry.get(\"date\")\n                if entry_date_str:\n                    try:\n                        entry_date = datetime.strptime(entry_date_str, \"%Y-%m-%d\").date()\n                        if entry_date >= monday:\n                            return False  # 本周已复盘\n                    except ValueError:\n                        continue\n\n        return True\n\n    async def _check_not_planned_this_week(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查本周是否未规划\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        week = current.get(\"week\", {})\n\n        week_start = week.get(\"week_start\")\n        if not week_start:\n            return True\n\n        # 获取本周一的日期\n        today = date.today()\n        monday = today - timedelta(days=today.weekday())\n\n        try:\n            planned_week_start = datetime.strptime(week_start, \"%Y-%m-%d\").date()\n            return planned_week_start < monday  # 规划日期在本周之前，说明未规划\n        except ValueError:\n            return True\n\n    async def _check_has_pending_levers(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查是否有未完成的杠杆\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        daily = current.get(\"daily\", {})\n        levers = daily.get(\"levers\", [])\n\n        if not levers:\n            return False\n\n        # 检查今天的杠杆\n        today_str = date.today().isoformat()\n        daily_date = daily.get(\"date\")\n\n        if daily_date != today_str:\n            return False  # 不是今天的数据\n\n        pending_count = sum(1 for lever in levers if lever.get(\"status\") != \"completed\")\n        return pending_count > 0\n\n    async def _check_had_streak(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查之前是否有连续签到记录\"\"\"\n        min_days = condition.get(\"min_days\", 3)\n\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n\n        # 检查当前或历史最长连续\n        current_streak = progress.get(\"current_streak\", 0)\n        longest_streak = progress.get(\"longest_streak\", 0)\n\n        return max(current_streak, longest_streak) >= min_days\n","structuredPatch":[{"oldStart":344,"oldLines":34,"newStart":344,"newLines":50,"lines":[" ","         return False, None"," ","-    async def _detect_solar_term(","+    async def _detect_zodiac_event(","         self,","-        profile: Dict,","         advance_days: List[int],","-        skill_id: str,","+        event_types: Tuple[str, ...],","+        extra_fields: Optional[Dict[str, str]] = None,","     ) -> Tuple[bool, Optional[Dict[str, Any]]]:","-        \"\"\"检测节气\"\"\"","-        # 使用 ZodiacEvents 获取节气信息","+        \"\"\"通用星象事件检测器\"\"\"","         today = date.today()"," ","         try:","             events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)"," ","             for event in events:","-                if event.event_type == \"solar_term\":","+                if event.event_type in event_types:","                     days_until = (event.start_date - today).days","                     if days_until in advance_days:","-                        return True, {","+                        result = {","                             \"event_name\": event.name,","                             \"event_date\": event.start_date,","                             \"days_until\": days_until,","-                            \"description\": event.description,","                         }","+                        # 添加事件特定字段","+                        if extra_fields:","+                            for key, attr in extra_fields.items():","+                                result[key] = getattr(event, attr, None) if attr != \"event_type\" else event.event_type","+                        return True, result","         except Exception as e:","-            logger.error(f\"Failed to detect solar term: {e}\")","+            logger.error(f\"Failed to detect zodiac event {event_types}: {e}\")"," ","         return False, None"," ","+    async def _detect_solar_term(","+        self,","+        profile: Dict,","+        advance_days: List[int],","+        skill_id: str,","+    ) -> Tuple[bool, Optional[Dict[str, Any]]]:","+        \"\"\"检测节气\"\"\"","+        return await self._detect_zodiac_event(","+            advance_days,","+            (\"solar_term\",),","+            {\"description\": \"description\"}","+        )","+","     async def _detect_lunar_phase(","         self,","         profile: Dict,"]},{"oldStart":379,"oldLines":26,"newStart":395,"newLines":12,"lines":["         skill_id: str,","     ) -> Tuple[bool, Optional[Dict[str, Any]]]:","         \"\"\"检测月相 (新月/满月)\"\"\"","-        today = date.today()","+        return await self._detect_zodiac_event(","+            advance_days,","+            (\"new_moon\", \"full_moon\"),","+            {\"phase\": \"event_type\"}","+        )"," ","-        try:","-            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)","-","-            for event in events:","-                if event.event_type in (\"new_moon\", \"full_moon\"):","-                    days_until = (event.start_date - today).days","-                    if days_until in advance_days:","-                        return True, {","-                            \"event_name\": event.name,","-                            \"event_date\": event.start_date,","-                            \"days_until\": days_until,","-                            \"phase\": event.event_type,","-                        }","-        except Exception as e:","-            logger.error(f\"Failed to detect lunar phase: {e}\")","-","-        return False, None","-","     async def _detect_mercury_retrograde(","         self,","         profile: Dict,"]},{"oldStart":406,"oldLines":26,"newStart":408,"newLines":12,"lines":["         skill_id: str,","     ) -> Tuple[bool, Optional[Dict[str, Any]]]:","         \"\"\"检测水逆\"\"\"","-        today = date.today()","+        return await self._detect_zodiac_event(","+            advance_days,","+            (\"mercury_retrograde\",),","+            {\"end_date\": \"end_date\"}","+        )"," ","-        try:","-            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)","-","-            for event in events:","-                if event.event_type == \"mercury_retrograde\":","-                    days_until = (event.start_date - today).days","-                    if days_until in advance_days:","-                        return True, {","-                            \"event_name\": event.name,","-                            \"event_date\": event.start_date,","-                            \"days_until\": days_until,","-                            \"end_date\": event.end_date,","-                        }","-        except Exception as e:","-            logger.error(f\"Failed to detect mercury retrograde: {e}\")","-","-        return False, None","-","     async def _detect_significant_transit(","         self,","         profile: Dict,"]},{"oldStart":433,"oldLines":28,"newStart":421,"newLines":12,"lines":["         skill_id: str,","     ) -> Tuple[bool, Optional[Dict[str, Any]]]:","         \"\"\"检测重要行星过境\"\"\"","-        today = date.today()","+        return await self._detect_zodiac_event(","+            advance_days,","+            (\"saturn_return\", \"jupiter_transit\", \"eclipse\"),","+            {\"transit_type\": \"event_type\"}","+        )"," ","-        try:","-            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)","-","-            significant_types = (\"saturn_return\", \"jupiter_transit\", \"eclipse\")","-","-            for event in events:","-                if event.event_type in significant_types:","-                    days_until = (event.start_date - today).days","-                    if days_until in advance_days:","-                        return True, {","-                            \"event_name\": event.name,","-                            \"event_date\": event.start_date,","-                            \"days_until\": days_until,","-                            \"transit_type\": event.event_type,","-                        }","-        except Exception as e:","-            logger.error(f\"Failed to detect significant transit: {e}\")","-","-        return False, None","-","     # ═══════════════════════════════════════════════════════════════════════════","     # Lifecoach 事件检测器","     # ═══════════════════════════════════════════════════════════════════════════"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"378d633e-0d9b-4c08-a2e2-09d2f61ff5c9"}
{"parentUuid":"ca055b05-12dd-4adb-93b8-beeef382a47a","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NbS5utdNKW5RAEfyUUTe7Q","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me simplify the check-in condition checkers which share logic:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3283,"cache_read_input_tokens":44045,"cache_creation":{"ephemeral_5m_input_tokens":3283,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXGirik3BHkSYXExwQCyt","type":"assistant","uuid":"4d994344-794b-4ec5-9545-3a018d5532f8","timestamp":"2026-01-19T12:17:36.278Z"}
{"parentUuid":"4d994344-794b-4ec5-9545-3a018d5532f8","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NbS5utdNKW5RAEfyUUTe7Q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nu8jrTR1pNw37wfgHVoDpr","name":"Edit","input":{"replace_all":false,"file_path":"/home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py","old_string":"    async def _check_not_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否未签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return True  # 从未签到\n\n        return last_checkin != date.today().isoformat()\n\n    async def _check_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否已签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return False\n\n        return last_checkin == date.today().isoformat()","new_string":"    def _is_checked_in_today(self, profile: Dict) -> bool:\n        \"\"\"判断今天是否已签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        last_checkin = lifecoach.get(\"progress\", {}).get(\"last_checkin_date\")\n        return last_checkin == date.today().isoformat() if last_checkin else False\n\n    async def _check_not_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否未签到\"\"\"\n        return not self._is_checked_in_today(profile)\n\n    async def _check_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否已签到\"\"\"\n        return self._is_checked_in_today(profile)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3283,"cache_read_input_tokens":44045,"cache_creation":{"ephemeral_5m_input_tokens":3283,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXGirik3BHkSYXExwQCyt","type":"assistant","uuid":"5f3369db-854e-4125-9d9f-a30297b384f1","timestamp":"2026-01-19T12:17:41.949Z"}
{"parentUuid":"5f3369db-854e-4125-9d9f-a30297b384f1","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nu8jrTR1pNw37wfgHVoDpr","type":"tool_result","content":"The file /home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   501→                return False\n   502→\n   503→        return bool(data)\n   504→\n   505→    def _is_checked_in_today(self, profile: Dict) -> bool:\n   506→        \"\"\"判断今天是否已签到\"\"\"\n   507→        lifecoach = self._get_lifecoach_data(profile)\n   508→        last_checkin = lifecoach.get(\"progress\", {}).get(\"last_checkin_date\")\n   509→        return last_checkin == date.today().isoformat() if last_checkin else False\n   510→\n   511→    async def _check_not_checked_in_today(\n   512→        self,\n   513→        condition: Dict,\n   514→        profile: Dict,\n   515→        skill_id: str,\n   516→    ) -> bool:\n   517→        \"\"\"检查今天是否未签到\"\"\"\n   518→        return not self._is_checked_in_today(profile)\n   519→\n   520→    async def _check_checked_in_today(\n   521→        self,\n   522→        condition: Dict,\n   523→        profile: Dict,\n   524→        skill_id: str,\n   525→    ) -> bool:\n   526→        \"\"\"检查今天是否已签到\"\"\"\n   527→        return self._is_checked_in_today(profile)\n   528→\n   529→    async def _check_has_weekly_data(\n   530→        self,\n   531→        condition: Dict,"}]},"uuid":"1a4c6315-ed65-4be8-bd60-33b4055838d4","timestamp":"2026-01-19T12:17:44.628Z","toolUseResult":{"filePath":"/home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py","oldString":"    async def _check_not_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否未签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return True  # 从未签到\n\n        return last_checkin != date.today().isoformat()\n\n    async def _check_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否已签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return False\n\n        return last_checkin == date.today().isoformat()","newString":"    def _is_checked_in_today(self, profile: Dict) -> bool:\n        \"\"\"判断今天是否已签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        last_checkin = lifecoach.get(\"progress\", {}).get(\"last_checkin_date\")\n        return last_checkin == date.today().isoformat() if last_checkin else False\n\n    async def _check_not_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否未签到\"\"\"\n        return not self._is_checked_in_today(profile)\n\n    async def _check_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否已签到\"\"\"\n        return self._is_checked_in_today(profile)","originalFile":"\"\"\"\nTriggerDetector - 触发条件检测器\n\n支持三种触发类型:\n1. time_based - 基于时间 (cron 表达式)\n2. event_based - 基于事件 (节气、月相、生日、大运交接等)\n3. threshold_based - 基于阈值 (运势分数等)\n\n设计原则:\n- 从 unified_profiles 读取数据\n- 支持 Skill 级自定义事件\n- 智能化: 事件触发 + 阈值触发\n\"\"\"\n\nimport logging\nfrom datetime import datetime, date, timedelta\nfrom typing import Dict, Any, Optional, Tuple, List\n\nimport pytz\n\nfrom skills.zodiac.services.events import ZodiacEvents\n\nlogger = logging.getLogger(__name__)\n\n\nclass TriggerDetector:\n    \"\"\"触发条件检测器\"\"\"\n\n    def __init__(self):\n        self._event_detectors = {\n            \"birthday\": self._detect_birthday,\n            \"dayun_change\": self._detect_dayun_change,\n            \"new_year\": self._detect_new_year,\n            \"solar_term\": self._detect_solar_term,\n            \"lunar_phase\": self._detect_lunar_phase,\n            \"mercury_retrograde\": self._detect_mercury_retrograde,\n            \"significant_transit\": self._detect_significant_transit,\n            # Lifecoach 事件\n            \"streak_broken\": self._detect_streak_broken,\n        }\n\n        # Lifecoach 条件检查器 (用于 reminders.yaml conditions)\n        self._condition_checkers = {\n            \"has_data\": self._check_has_data,\n            \"not_checked_in_today\": self._check_not_checked_in_today,\n            \"checked_in_today\": self._check_checked_in_today,\n            \"has_weekly_data\": self._check_has_weekly_data,\n            \"not_reviewed_this_week\": self._check_not_reviewed_this_week,\n            \"not_planned_this_week\": self._check_not_planned_this_week,\n            \"has_pending_levers\": self._check_has_pending_levers,\n            \"had_streak\": self._check_had_streak,\n        }\n\n    async def should_trigger(\n        self,\n        trigger_config: Dict[str, Any],\n        profile: Dict[str, Any],\n        skill_id: str,\n        conditions: Optional[List[Dict]] = None,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"\n        检测是否应该触发\n\n        Args:\n            trigger_config: 触发配置 (type, schedule 等)\n            profile: 用户 profile\n            skill_id: Skill ID\n            conditions: 额外条件列表 (来自 reminders.yaml)\n\n        Returns:\n            (should_trigger, event_info)\n            - should_trigger: 是否触发\n            - event_info: 事件信息 (event_name, event_date 等)\n        \"\"\"\n        trigger_type = trigger_config.get(\"type\")\n\n        # 1. 检查触发条件\n        if trigger_type == \"time_based\":\n            triggered = self._check_time_based(trigger_config, profile)\n            event_info = None\n        elif trigger_type == \"event_based\":\n            triggered, event_info = await self._check_event_based(trigger_config, profile, skill_id)\n        elif trigger_type == \"threshold_based\":\n            triggered, event_info = await self._check_threshold_based(trigger_config, profile, skill_id)\n        else:\n            return False, None\n\n        if not triggered:\n            return False, None\n\n        # 2. 检查额外条件 (所有条件必须满足)\n        if conditions:\n            for condition in conditions:\n                if not await self._check_condition(condition, profile, skill_id):\n                    return False, None\n\n        return True, event_info\n\n    async def _check_condition(\n        self,\n        condition: Dict[str, Any],\n        profile: Dict[str, Any],\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查单个条件\"\"\"\n        condition_type = condition.get(\"type\")\n        checker = self._condition_checkers.get(condition_type)\n\n        if not checker:\n            logger.warning(f\"Unknown condition type: {condition_type}\")\n            return True  # 未知条件默认通过\n\n        try:\n            return await checker(condition, profile, skill_id)\n        except Exception as e:\n            logger.error(f\"Failed to check condition {condition_type}: {e}\")\n            return False\n\n    def _check_time_based(self, config: Dict, profile: Dict) -> bool:\n        \"\"\"\n        检查时间触发条件\n\n        支持简化的 cron 格式: \"0 4 * * *\" (分 时 日 月 周)\n        \"\"\"\n        schedule = config.get(\"schedule\", \"\")\n        timezone_aware = config.get(\"timezone_aware\", True)\n\n        if not schedule:\n            return False\n\n        # 获取用户时区\n        if timezone_aware:\n            user_tz = profile.get(\"preferences\", {}).get(\"timezone\", \"Asia/Shanghai\")\n            try:\n                now = datetime.now(pytz.timezone(user_tz))\n            except Exception:\n                now = datetime.now(pytz.timezone(\"Asia/Shanghai\"))\n        else:\n            now = datetime.now(pytz.UTC)\n\n        # 解析 cron 表达式\n        return self._match_cron(schedule, now)\n\n    def _match_cron(self, schedule: str, now: datetime) -> bool:\n        \"\"\"匹配简化的 cron 表达式\"\"\"\n        try:\n            parts = schedule.split()\n            if len(parts) != 5:\n                return False\n\n            minute, hour, day, month, weekday = parts\n\n            # 检查各字段\n            if minute != \"*\" and int(minute) != now.minute:\n                return False\n            if hour != \"*\" and int(hour) != now.hour:\n                return False\n            if day != \"*\" and int(day) != now.day:\n                return False\n            if month != \"*\" and int(month) != now.month:\n                return False\n            if weekday != \"*\" and int(weekday) != now.weekday():\n                return False\n\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to parse cron schedule '{schedule}': {e}\")\n            return False\n\n    async def _check_event_based(\n        self,\n        config: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检查事件触发条件\"\"\"\n        event = config.get(\"event\")\n        advance_days = config.get(\"advance_days\", [0])\n\n        # 确保 advance_days 是列表\n        if isinstance(advance_days, int):\n            advance_days = [advance_days]\n\n        detector = self._event_detectors.get(event)\n        if not detector:\n            logger.warning(f\"Unknown event type: {event}\")\n            return False, None\n\n        return await detector(profile, advance_days, skill_id)\n\n    async def _check_threshold_based(\n        self,\n        config: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检查阈值触发条件\"\"\"\n        metric = config.get(\"metric\")\n        condition = config.get(\"condition\")\n        threshold = config.get(\"threshold\")\n        cooldown = config.get(\"cooldown\", 0)\n\n        # 获取指标值\n        value = await self._get_metric_value(metric, profile, skill_id)\n        if value is None:\n            return False, None\n\n        # TODO: 检查冷却期 (需要记录上次触发时间)\n\n        # 检查条件\n        triggered = False\n        if condition == \"<\":\n            triggered = value < threshold\n        elif condition == \">\":\n            triggered = value > threshold\n        elif condition == \"<=\":\n            triggered = value <= threshold\n        elif condition == \">=\":\n            triggered = value >= threshold\n        elif condition == \"==\":\n            triggered = value == threshold\n\n        if triggered:\n            return True, {\"metric\": metric, \"value\": value, \"threshold\": threshold}\n\n        return False, None\n\n    async def _get_metric_value(\n        self,\n        metric: str,\n        profile: Dict,\n        skill_id: str,\n    ) -> Optional[float]:\n        \"\"\"获取指标值\"\"\"\n        if metric == \"daily_fortune_score\":\n            # 计算今日运势分数\n            from skills.bazi.services import BaziComputer\n            computer = BaziComputer()\n            return await computer.get_daily_fortune_score(profile)\n\n        # 可扩展其他指标\n        return None\n\n    # ═════════════════���═════════════════════════════════════════════════════════\n    # 事件检测器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    async def _detect_birthday(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测生日\"\"\"\n        birth_info = profile.get(\"birth_info\", {})\n        birth_date_str = birth_info.get(\"date\")\n\n        if not birth_date_str:\n            return False, None\n\n        try:\n            birth = datetime.strptime(birth_date_str, \"%Y-%m-%d\").date()\n        except ValueError:\n            return False, None\n\n        today = date.today()\n        birthday_this_year = date(today.year, birth.month, birth.day)\n\n        # 如果今年生日已过，检查明年\n        if birthday_this_year < today:\n            birthday_this_year = date(today.year + 1, birth.month, birth.day)\n\n        days_until = (birthday_this_year - today).days\n\n        if days_until in advance_days:\n            event_name = \"birthday\" if days_until == 0 else f\"birthday_{days_until}days\"\n            return True, {\n                \"event_name\": event_name,\n                \"event_date\": birthday_this_year,\n                \"days_until\": days_until,\n            }\n\n        return False, None\n\n    async def _detect_dayun_change(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测大运交接\"\"\"\n        from skills.bazi.services import BaziComputer\n\n        computer = BaziComputer()\n        inflection_points = await computer.get_inflection_points(profile)\n\n        today = date.today()\n\n        for point in inflection_points:\n            if point.get(\"type\") == \"major_cycle_change\":\n                point_year = point.get(\"year\")\n                if point_year:\n                    # 大运交接通常在年初\n                    point_date = date(point_year, 1, 1)\n                    days_until = (point_date - today).days\n\n                    if days_until in advance_days:\n                        return True, {\n                            \"event_name\": point.get(\"title\", \"大运交接\"),\n                            \"event_date\": point_date,\n                            \"days_until\": days_until,\n                            \"point\": point,\n                        }\n\n        return False, None\n\n    async def _detect_new_year(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测新年\"\"\"\n        today = date.today()\n        next_new_year = date(today.year + 1, 1, 1)\n\n        # 如果今天是元旦\n        if today.month == 1 and today.day == 1:\n            if 0 in advance_days:\n                return True, {\n                    \"event_name\": \"new_year\",\n                    \"event_date\": today,\n                    \"days_until\": 0,\n                }\n\n        days_until = (next_new_year - today).days\n\n        if days_until in advance_days:\n            return True, {\n                \"event_name\": \"new_year\",\n                \"event_date\": next_new_year,\n                \"days_until\": days_until,\n            }\n\n        return False, None\n\n    async def _detect_zodiac_event(\n        self,\n        advance_days: List[int],\n        event_types: Tuple[str, ...],\n        extra_fields: Optional[Dict[str, str]] = None,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"通用星象事件检测器\"\"\"\n        today = date.today()\n\n        try:\n            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)\n\n            for event in events:\n                if event.event_type in event_types:\n                    days_until = (event.start_date - today).days\n                    if days_until in advance_days:\n                        result = {\n                            \"event_name\": event.name,\n                            \"event_date\": event.start_date,\n                            \"days_until\": days_until,\n                        }\n                        # 添加事件特定字段\n                        if extra_fields:\n                            for key, attr in extra_fields.items():\n                                result[key] = getattr(event, attr, None) if attr != \"event_type\" else event.event_type\n                        return True, result\n        except Exception as e:\n            logger.error(f\"Failed to detect zodiac event {event_types}: {e}\")\n\n        return False, None\n\n    async def _detect_solar_term(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测节气\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"solar_term\",),\n            {\"description\": \"description\"}\n        )\n\n    async def _detect_lunar_phase(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测月相 (新月/满月)\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"new_moon\", \"full_moon\"),\n            {\"phase\": \"event_type\"}\n        )\n\n    async def _detect_mercury_retrograde(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测水逆\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"mercury_retrograde\",),\n            {\"end_date\": \"end_date\"}\n        )\n\n    async def _detect_significant_transit(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测重要行星过境\"\"\"\n        return await self._detect_zodiac_event(\n            advance_days,\n            (\"saturn_return\", \"jupiter_transit\", \"eclipse\"),\n            {\"transit_type\": \"event_type\"}\n        )\n\n    # ═══════════════════════════════════════════════════════════════════════════\n    # Lifecoach 事件检测器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    async def _detect_streak_broken(\n        self,\n        profile: Dict,\n        advance_days: List[int],\n        skill_id: str,\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"检测断签事件\"\"\"\n        lifecoach = profile.get(\"life_context\", {}).get(\"_paths\", {}).get(\"lifecoach\", {})\n        progress = lifecoach.get(\"progress\", {})\n\n        last_checkin = progress.get(\"last_checkin_date\")\n        previous_streak = progress.get(\"current_streak\", 0)\n\n        if not last_checkin:\n            return False, None\n\n        try:\n            last_date = datetime.strptime(last_checkin, \"%Y-%m-%d\").date()\n            days_since = (date.today() - last_date).days\n\n            # 断签：超过1天未签到，且之前有连续签到记录\n            if days_since >= 2 and previous_streak >= 3:\n                return True, {\n                    \"event_name\": \"streak_broken\",\n                    \"event_date\": date.today(),\n                    \"days_since_checkin\": days_since,\n                    \"previous_streak\": previous_streak,\n                }\n        except Exception as e:\n            logger.error(f\"Failed to detect streak broken: {e}\")\n\n        return False, None\n\n    # ═══════════════════════════════════════════════════════════════════════════\n    # Lifecoach 条件检查器\n    # ═══════════════════════════════════════════════════════════════════════════\n\n    def _get_lifecoach_data(self, profile: Dict) -> Dict:\n        \"\"\"获取 lifecoach 数据\"\"\"\n        life_context = profile.get(\"life_context\", {})\n        paths = life_context.get(\"_paths\", {})\n        return paths.get(\"lifecoach\", {})\n\n    async def _check_has_data(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查指定路径是否有数据\"\"\"\n        path = condition.get(\"path\", \"\")\n        if not path:\n            return False\n\n        # 解析路径 (e.g., \"lifecoach.north_star.vision_statement\")\n        parts = path.split(\".\")\n        data = profile\n\n        # 处理 life_context._paths 前缀\n        if parts[0] == \"lifecoach\":\n            data = self._get_lifecoach_data(profile)\n            parts = parts[1:]  # 去掉 lifecoach 前缀\n\n        for part in parts:\n            if isinstance(data, dict) and part in data:\n                data = data[part]\n            else:\n                return False\n\n        return bool(data)\n\n    async def _check_not_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否未签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return True  # 从未签到\n\n        return last_checkin != date.today().isoformat()\n\n    async def _check_checked_in_today(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查今天是否已签到\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n        last_checkin = progress.get(\"last_checkin_date\")\n\n        if not last_checkin:\n            return False\n\n        return last_checkin == date.today().isoformat()\n\n    async def _check_has_weekly_data(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查是否有本周数据\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        week = current.get(\"week\", {})\n\n        return bool(week.get(\"rocks\"))\n\n    async def _check_not_reviewed_this_week(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查本周是否未复盘\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        journal = lifecoach.get(\"journal\", [])\n\n        if not journal:\n            return True\n\n        # 获取本周一的日期\n        today = date.today()\n        monday = today - timedelta(days=today.weekday())\n\n        # 检查是否有本周的 weekly 复盘\n        for entry in journal:\n            if entry.get(\"type\") == \"weekly\":\n                entry_date_str = entry.get(\"date\")\n                if entry_date_str:\n                    try:\n                        entry_date = datetime.strptime(entry_date_str, \"%Y-%m-%d\").date()\n                        if entry_date >= monday:\n                            return False  # 本周已复盘\n                    except ValueError:\n                        continue\n\n        return True\n\n    async def _check_not_planned_this_week(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查本周是否未规划\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        week = current.get(\"week\", {})\n\n        week_start = week.get(\"week_start\")\n        if not week_start:\n            return True\n\n        # 获取本周一的日期\n        today = date.today()\n        monday = today - timedelta(days=today.weekday())\n\n        try:\n            planned_week_start = datetime.strptime(week_start, \"%Y-%m-%d\").date()\n            return planned_week_start < monday  # 规划日期在本周之前，说明未规划\n        except ValueError:\n            return True\n\n    async def _check_has_pending_levers(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查是否有未完成的杠杆\"\"\"\n        lifecoach = self._get_lifecoach_data(profile)\n        current = lifecoach.get(\"current\", {})\n        daily = current.get(\"daily\", {})\n        levers = daily.get(\"levers\", [])\n\n        if not levers:\n            return False\n\n        # 检查今天的杠杆\n        today_str = date.today().isoformat()\n        daily_date = daily.get(\"date\")\n\n        if daily_date != today_str:\n            return False  # 不是今天的数据\n\n        pending_count = sum(1 for lever in levers if lever.get(\"status\") != \"completed\")\n        return pending_count > 0\n\n    async def _check_had_streak(\n        self,\n        condition: Dict,\n        profile: Dict,\n        skill_id: str,\n    ) -> bool:\n        \"\"\"检查之前是否有连续签到记录\"\"\"\n        min_days = condition.get(\"min_days\", 3)\n\n        lifecoach = self._get_lifecoach_data(profile)\n        progress = lifecoach.get(\"progress\", {})\n\n        # 检查当前或历史最长连续\n        current_streak = progress.get(\"current_streak\", 0)\n        longest_streak = progress.get(\"longest_streak\", 0)\n\n        return max(current_streak, longest_streak) >= min_days\n","structuredPatch":[{"oldStart":502,"oldLines":6,"newStart":502,"newLines":12,"lines":[" ","         return bool(data)"," ","+    def _is_checked_in_today(self, profile: Dict) -> bool:","+        \"\"\"判断今天是否已签到\"\"\"","+        lifecoach = self._get_lifecoach_data(profile)","+        last_checkin = lifecoach.get(\"progress\", {}).get(\"last_checkin_date\")","+        return last_checkin == date.today().isoformat() if last_checkin else False","+","     async def _check_not_checked_in_today(","         self,","         condition: Dict,"]},{"oldStart":509,"oldLines":15,"newStart":515,"newLines":8,"lines":["         skill_id: str,","     ) -> bool:","         \"\"\"检查今天是否未签到\"\"\"","-        lifecoach = self._get_lifecoach_data(profile)","-        progress = lifecoach.get(\"progress\", {})","-        last_checkin = progress.get(\"last_checkin_date\")","+        return not self._is_checked_in_today(profile)"," ","-        if not last_checkin:","-            return True  # 从未签到","-","-        return last_checkin != date.today().isoformat()","-","     async def _check_checked_in_today(","         self,","         condition: Dict,"]},{"oldStart":525,"oldLines":15,"newStart":524,"newLines":8,"lines":["         skill_id: str,","     ) -> bool:","         \"\"\"检查今天是否已签到\"\"\"","-        lifecoach = self._get_lifecoach_data(profile)","-        progress = lifecoach.get(\"progress\", {})","-        last_checkin = progress.get(\"last_checkin_date\")","+        return self._is_checked_in_today(profile)"," ","-        if not last_checkin:","-            return False","-","-        return last_checkin == date.today().isoformat()","-","     async def _check_has_weekly_data(","         self,","         condition: Dict,"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5f3369db-854e-4125-9d9f-a30297b384f1"}
{"parentUuid":"1a4c6315-ed65-4be8-bd60-33b4055838d4","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYf7Ta1RJc5E68DrfaWUdk","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me verify the changes are syntactically correct by checking for Python syntax errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1115,"cache_read_input_tokens":47328,"cache_creation":{"ephemeral_5m_input_tokens":1115,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXGiskmbsNKe3xLkeq9e3","type":"assistant","uuid":"b4816e40-6f86-43c9-9d68-ab3e7f40d94c","timestamp":"2026-01-19T12:17:49.798Z"}
{"parentUuid":"b4816e40-6f86-43c9-9d68-ab3e7f40d94c","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYf7Ta1RJc5E68DrfaWUdk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019RMHCEZPnx1aczWUeqv5ER","name":"Bash","input":{"command":"python -m py_compile skills/lifecoach/tools/handlers.py && echo \"handlers.py: OK\"","description":"Check handlers.py for syntax errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1115,"cache_read_input_tokens":47328,"cache_creation":{"ephemeral_5m_input_tokens":1115,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXGiskmbsNKe3xLkeq9e3","type":"assistant","uuid":"9ba070e0-53b0-42d2-8e64-6b7ebf717759","timestamp":"2026-01-19T12:17:51.096Z"}
{"parentUuid":"9ba070e0-53b0-42d2-8e64-6b7ebf717759","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYf7Ta1RJc5E68DrfaWUdk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NssZHSHEZiieamFXT7ERGk","name":"Bash","input":{"command":"python -m py_compile services/proactive/trigger_detector.py && echo \"trigger_detector.py: OK\"","description":"Check trigger_detector.py for syntax errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1115,"cache_read_input_tokens":47328,"cache_creation":{"ephemeral_5m_input_tokens":1115,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXGiskmbsNKe3xLkeq9e3","type":"assistant","uuid":"9e1f968f-11e0-4b00-89fb-b91c919aa223","timestamp":"2026-01-19T12:17:51.791Z"}
{"parentUuid":"9ba070e0-53b0-42d2-8e64-6b7ebf717759","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019RMHCEZPnx1aczWUeqv5ER","type":"tool_result","content":"handlers.py: OK","is_error":false}]},"uuid":"e9eafce8-7704-46d1-9bd9-6ac4c6dfb361","timestamp":"2026-01-19T12:17:57.663Z","toolUseResult":{"stdout":"handlers.py: OK","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"9ba070e0-53b0-42d2-8e64-6b7ebf717759"}
{"parentUuid":"9e1f968f-11e0-4b00-89fb-b91c919aa223","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NssZHSHEZiieamFXT7ERGk","type":"tool_result","content":"trigger_detector.py: OK","is_error":false}]},"uuid":"bb401b35-8f5c-438d-aa47-6e7d5ee25d38","timestamp":"2026-01-19T12:18:02.661Z","toolUseResult":{"stdout":"trigger_detector.py: OK","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"9e1f968f-11e0-4b00-89fb-b91c919aa223"}
{"parentUuid":"bb401b35-8f5c-438d-aa47-6e7d5ee25d38","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife/apps/api","sessionId":"f5a8dce9-4583-4016-8334-18395dea4350","version":"2.1.12","gitBranch":"master","agentId":"ac72ba2","slug":"graceful-fluttering-crayon","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TPPDwuhoV5TNNrc1o2SpNU","type":"message","role":"assistant","content":[{"type":"text","text":"Both files pass syntax checks. Let me provide a summary of the simplifications made.\n\n## Summary of Simplifications\n\n### `/home/aiscend/work/vibelife/apps/api/skills/lifecoach/tools/handlers.py`\n\n**1. Extracted `_calculate_balance_score` helper function (lines 407-414)**\n- Moved the balance score calculation logic from `show_role_balance` into a dedicated helper\n- Reduces nesting and improves readability\n\n**2. Extracted `_calculate_completion_stats` helper function (lines 436-447)**\n- Consolidated duplicate stats calculation logic from `show_weekly_rocks` and `show_daily_levers`\n- Added `include_in_progress` parameter to handle the slight variation between the two use cases\n\n**3. Simplified streak update logic in `update_progress` (lines 303-316)**\n- Reduced the nested if/elif chain for streak calculation to a single line using a conditional expression\n- Simplified the longest streak update using `max()`\n- Consolidated the history append statement\n\n### `/home/aiscend/work/vibelife/apps/api/services/proactive/trigger_detector.py`\n\n**1. Extracted `_detect_zodiac_event` generic helper (lines 347-376)**\n- Consolidated 4 nearly identical event detectors (`_detect_solar_term`, `_detect_lunar_phase`, `_detect_mercury_retrograde`, `_detect_significant_transit`) into a single parameterized method\n- Each specific detector now delegates to the generic helper with appropriate parameters\n- Reduced ~100 lines of duplicated code to ~30 lines\n\n**2. Extracted `_is_checked_in_today` helper (lines 505-509)**\n- Consolidated the shared logic between `_check_not_checked_in_today` and `_check_checked_in_today`\n- The two async methods now simply return `not self._is_checked_in_today(profile)` and `self._is_checked_in_today(profile)` respectively\n\nAll changes preserve the original functionality while improving code clarity and reducing duplication."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":278,"cache_read_input_tokens":48443,"cache_creation":{"ephemeral_5m_input_tokens":278,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXGiu3tXFk6eVoTxGPS6B","type":"assistant","uuid":"d9af44b9-1144-4d5f-b68f-82a3c15bf2ab","timestamp":"2026-01-19T12:18:15.579Z"}
