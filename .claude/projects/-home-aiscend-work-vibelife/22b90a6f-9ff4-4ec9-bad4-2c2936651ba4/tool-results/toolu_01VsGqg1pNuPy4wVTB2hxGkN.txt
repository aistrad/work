     1→"""
     2→Knowledge Repository v6 - PostgreSQL 知识库访问层
     3→支持知识检索、案例匹配、场景路由
     4→"""
     5→import logging
     6→from typing import List, Dict, Any, Optional
     7→from dataclasses import dataclass
     8→
     9→from stores.db import get_connection
    10→
    11→logger = logging.getLogger(__name__)
    12→
    13→
    14→@dataclass
    15→class KnowledgeChunk:
    16→    """知识块"""
    17→    id: str
    18→    skill_id: str
    19→    chunk_text: str
    20→    source_file: str
    21→    book_name: str
    22→    chapter: Optional[str]
    23→    score: float = 0.0
    24→
    25→
    26→@dataclass
    27→class Case:
    28→    """案例"""
    29→    id: str
    30→    name: str
    31→    core_data: Dict[str, Any]
    32→    analysis: Dict[str, Any]
    33→    conclusion: Dict[str, Any]
    34→    match_score: float = 0.0
    35→
    36→
    37→@dataclass
    38→class ScenarioMatch:
    39→    """场景匹配结果"""
    40→    scenario_id: str
    41→    score: float
    42→
    43→
    44→class KnowledgeRepository:
    45→    """知识库访问层"""
    46→
    47→    async def route_scenario(
    48→        self,
    49→        skill_id: str,
    50→        message: str,
    51→        top_k: int = 3
    52→    ) -> List[ScenarioMatch]:
    53→        """场景路由 - 根据用户消息匹配最佳场景"""
    54→        async with get_connection() as conn:
    55→            rows = await conn.fetch(
    56→                "SELECT * FROM route_scenario($1, $2)",
    57→                skill_id, message
    58→            )
    59→            return [
    60→                ScenarioMatch(scenario_id=r["scenario_id"], score=r["score"])
    61→                for r in rows[:top_k]
    62→            ]
    63→
    64→    async def search_knowledge(
    65→        self,
    66→        skill_id: str,
    67→        query: str,
    68→        embedding: Optional[List[float]] = None,
    69→        top_k: int = 5
    70→    ) -> List[KnowledgeChunk]:
    71→        """知识检索 - 支持全文检索和向量检索"""
    72→        async with get_connection() as conn:
    73→            if embedding:
    74→                rows = await conn.fetch(
    75→                    "SELECT * FROM search_knowledge($1, $2, $3::vector, $4)",
    76→                    skill_id, query, embedding, top_k
    77→                )
    78→            else:
    79→                rows = await conn.fetch(
    80→                    "SELECT * FROM search_knowledge($1, $2, NULL, $3)",
    81→                    skill_id, query, top_k
    82→                )
    83→            return [
    84→                KnowledgeChunk(
    85→                    id=r["chunk_id"],
    86→                    skill_id=skill_id,
    87→                    chunk_text=r["chunk_text"],
    88→                    source_file=r["source_file"],
    89→                    book_name=r["book_name"],
    90→                    chapter=r["chapter"],
    91→                    score=r["score"]
    92→                )
    93→                for r in rows
    94→            ]
    95→
    96→    async def match_cases(
    97→        self,
    98→        skill_id: str,
    99→        scenario_id: Optional[str] = None,
   100→        tags: Optional[List[str]] = None,
   101→        features: Optional[Dict[str, Any]] = None,
   102→        top_k: int = 3
   103→    ) -> List[Case]:
   104→        """案例匹配"""
   105→        async with get_connection() as conn:
   106→            rows = await conn.fetch(
   107→                "SELECT * FROM match_cases($1, $2, $3, $4, $5)",
   108→                skill_id, scenario_id, tags, features, top_k
   109→            )
   110→            return [
   111→                Case(
   112→                    id=r["case_id"],
   113→                    name=r["case_name"],
   114→                    core_data=r["core_data"],
   115→                    analysis=r["analysis"],
   116→                    conclusion=r["conclusion"],
   117→                    match_score=r["match_score"]
   118→                )
   119→                for r in rows
   120→            ]
   121→
   122→    async def get_skill_metadata(self, skill_id: str) -> Optional[Dict[str, Any]]:
   123→        """获取 Skill 元数据"""
   124→        async with get_connection() as conn:
   125→            row = await conn.fetchrow(
   126→                "SELECT * FROM skill_metadata WHERE skill_id = $1",
   127→                skill_id
   128→            )
   129→            if row:
   130→                return dict(row)
   131→            return None
   132→
   133→    async def search_db(
   134→        self,
   135→        table: str,
   136→        query: str,
   137→        filters: Optional[Dict[str, Any]] = None,
   138→        top_k: int = 5
   139→    ) -> List[Dict[str, Any]]:
   140→        """统一数据库查询 - V6 全局工具
   141→
   142→        Args:
   143→            table: 要查询的表 ("knowledge_chunks" 或 "cases")
   144→            query: 检索查询词
   145→            filters: 可选过滤条件 (skill_id, scenario_id, tags 等)
   146→            top_k: 返回结果数量
   147→        """
   148→        filters = filters or {}
   149→        skill_id = filters.get("skill_id")
   150→
   151→        if table == "knowledge_chunks":
   152→            chunks = await self.search_knowledge(
   153→                skill_id=skill_id or "bazi",
   154→                query=query,
   155→                top_k=top_k
   156→            )
   157→            return [
   158→                {
   159→                    "id": c.id,
   160→                    "text": c.chunk_text,
   161→                    "source": c.source_file,
   162→                    "book": c.book_name,
   163→                    "chapter": c.chapter,
   164→                    "score": c.score
   165→                }
   166→                for c in chunks
   167→            ]
   168→        elif table == "cases":
   169→            cases = await self.match_cases(
   170→                skill_id=skill_id or "bazi",
   171→                scenario_id=filters.get("scenario_id"),
   172→                tags=filters.get("tags"),
   173→                top_k=top_k
   174→            )
   175→            return [
   176→                {
   177→                    "id": c.id,
   178→                    "name": c.name,
   179→                    "core_data": c.core_data,
   180→                    "analysis": c.analysis,
   181→                    "conclusion": c.conclusion,
   182→                    "score": c.match_score
   183→                }
   184→                for c in cases
   185→            ]
   186→        else:
   187→            return []
   188→
   189→
   190→# 单例
   191→_repository: Optional[KnowledgeRepository] = None
   192→
   193→
   194→def get_knowledge_repository() -> KnowledgeRepository:
   195→    """获取知识库实例"""
   196→    global _repository
   197→    if _repository is None:
   198→        _repository = KnowledgeRepository()
   199→    return _repository
   200→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
