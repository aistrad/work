   155→        saved = await extractor.save_cases(cases)
   156→
   157→        logger.info(f"Stage 4a complete: {len(cases)} cases extracted, {saved} saved")
   158→        return saved
   159→
   160→    async def run_stage_4b(self, limit: int = 50):
   161→        """Stage 4b: Generate scenario candidates"""
   162→        logger.info("=" * 60)
   163→        logger.info("Stage 4b: Scenario Generation")
   164→        logger.info("=" * 60)
   165→
   166→        from workers.scenario_generator import ScenarioGenerator
   167→        from stores.db import get_connection
   168→
   169→        # Fetch chunks
   170→        async with get_connection() as conn:
   171→            rows = await conn.fetch(
   172→                """
   173→                SELECT id, chunk_text as content, chunk_type
   174→                FROM knowledge_chunks
   175→                WHERE skill_id = $1
   176→                ORDER BY chunk_type DESC
   177→                LIMIT $2
   178→                """,
   179→                self.skill_id,
   180→                limit,
   181→            )
   182→            chunks = [dict(row) for row in rows]
   183→
   184→        if not chunks:
   185→            logger.warning("No chunks found for scenario generation")
   186→            return 0
   187→
   188→        generator = ScenarioGenerator()
   189→        scenarios = await generator.generate_from_chunks(chunks, self.skill_id)
   190→        saved = await generator.save_candidates(scenarios)
   191→
   192→        logger.info(f"Stage 4b complete: {len(scenarios)} scenarios generated, {saved} saved")
   193→        return saved
   194→
   195→    async def run_stage_5(self, interactive: bool = True):
   196→        """Stage 5: Review & publish scenarios"""
   197→        logger.info("=" * 60)
   198→        logger.info("Stage 5: Scenario Review & Publish")
   199→        logger.info("=" * 60)
   200→
   201→        from workers.scenario_reviewer import ScenarioReviewer, review_cli
   202→
   203→        if interactive:
   204→            await review_cli()
   205→        else:
   206→            # Auto-approve all pending
   207→            reviewer = ScenarioReviewer()
   208→            pending = await reviewer.list_pending(self.skill_id)
   209→
   210→            for s in pending:
   211→                await reviewer.approve(s["skill_id"], s["scenario_id"])
   212→                logger.info(f"  Auto-approved: {s['scenario_id']}")
   213→
   214→            logger.info(f"Stage 5 complete: {len(pending)} scenarios approved")
   215→            return len(pending)
   216→
   217→    async def run_stage_6(self, save_report: bool = True):
   218→        """Stage 6: Quality check"""
   219→        logger.info("=" * 60)
   220→        logger.info("Stage 6: Quality Check")
   221→        logger.info("=" * 60)
   222→
   223→        from workers.quality_checker import QualityChecker
   224→
   225→        checker = QualityChecker()
   226→        report = await checker.generate_report(self.skill_id)
   227→
   228→        print(checker.format_report(report))
   229→
   230→        if save_report:
   231→            report_id = await checker.save_report(report)
   232→            logger.info(f"Report saved with ID: {report_id}")
   233→
   234→        return report.overall_score
   235→
   236→    async def run_all(self):
   237→        """Run complete pipeline"""
   238→        logger.info("=" * 60)
   239→        logger.info(f"Knowledge Builder Pipeline - {self.skill_id}")
   240→        logger.info(f"Started: {datetime.now().isoformat()}")
   241→        logger.info("=" * 60)
   242→
   243→        results = {}
   244→
   245→        # Stage 0
   246→        results["stage_0"] = await self.run_stage_0()
   247→
   248→        # Stages 1-3
   249→        results["stages_1_3"] = await self.run_stages_1_2_3()
   250→
   251→        # Stage 4a
   252→        results["stage_4a"] = await self.run_stage_4a()
   253→
   254→        # Stage 4b

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
