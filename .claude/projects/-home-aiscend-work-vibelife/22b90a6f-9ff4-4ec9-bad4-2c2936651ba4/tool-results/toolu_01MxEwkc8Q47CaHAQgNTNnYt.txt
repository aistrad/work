     1→"""
     2→Scenario Reviewer - Stage 5 of Knowledge Building Pipeline
     3→
     4→Human-in-the-loop review and publishing of scenario candidates.
     5→Supports CLI and API interfaces.
     6→"""
     7→import asyncio
     8→import json
     9→import logging
    10→from dataclasses import dataclass
    11→from datetime import datetime
    12→from pathlib import Path
    13→from typing import Optional
    14→
    15→logger = logging.getLogger(__name__)
    16→
    17→
    18→@dataclass
    19→class ReviewResult:
    20→    """Result of a scenario review"""
    21→    scenario_id: str
    22→    skill_id: str
    23→    status: str  # approved, rejected, needs_revision
    24→    notes: Optional[str] = None
    25→    reviewer: str = "human"
    26→    reviewed_at: Optional[str] = None
    27→
    28→
    29→class ScenarioReviewer:
    30→    """
    31→    Review and publish scenario candidates.
    32→    """
    33→
    34→    def __init__(self, skills_dir: str = "/home/aiscend/work/vibelife/apps/api/skills"):
    35→        self.skills_dir = Path(skills_dir)
    36→
    37→    async def list_pending(self, skill_id: Optional[str] = None) -> list[dict]:
    38→        """
    39→        List all pending scenario candidates.
    40→
    41→        Args:
    42→            skill_id: Optional filter by skill
    43→
    44→        Returns:
    45→            List of pending scenarios
    46→        """
    47→        from stores.db import get_connection
    48→
    49→        async with get_connection() as conn:
    50→            if skill_id:
    51→                rows = await conn.fetch(
    52→                    """
    53→                    SELECT * FROM scenario_candidates
    54→                    WHERE status = 'pending' AND skill_id = $1
    55→                    ORDER BY created_at DESC
    56→                    """,
    57→                    skill_id,
    58→                )
    59→            else:
    60→                rows = await conn.fetch(
    61→                    """
    62→                    SELECT * FROM scenario_candidates
    63→                    WHERE status = 'pending'
    64→                    ORDER BY skill_id, created_at DESC
    65→                    """
    66→                )
    67→            return [dict(row) for row in rows]
    68→
    69→    async def get_candidate(self, skill_id: str, scenario_id: str) -> Optional[dict]:
    70→        """Get a specific scenario candidate"""
    71→        from stores.db import get_connection
    72→
    73→        async with get_connection() as conn:
    74→            row = await conn.fetchrow(
    75→                """
    76→                SELECT * FROM scenario_candidates
    77→                WHERE skill_id = $1 AND scenario_id = $2
    78→                """,
    79→                skill_id,
    80→                scenario_id,
    81→            )
    82→            return dict(row) if row else None
    83→
    84→    async def approve(
    85→        self,
    86→        skill_id: str,
    87→        scenario_id: str,
    88→        notes: Optional[str] = None,
    89→        reviewer: str = "human",
    90→    ) -> ReviewResult:
    91→        """
    92→        Approve a scenario candidate and publish it.
    93→
    94→        Args:
    95→            skill_id: The skill ID
    96→            scenario_id: The scenario ID
    97→            notes: Optional review notes
    98→            reviewer: Reviewer identifier
    99→
   100→        Returns:
   101→            ReviewResult
   102→        """
   103→        from stores.db import get_connection
   104→
   105→        candidate = await self.get_candidate(skill_id, scenario_id)
   106→        if not candidate:
   107→            raise ValueError(f"Scenario not found: {skill_id}/{scenario_id}")
   108→
   109→        # Update status in database
   110→        async with get_connection() as conn:
   111→            await conn.execute(
   112→                """
   113→                UPDATE scenario_candidates
   114→                SET status = 'approved',
   115→                    review_notes = $1,
   116→                    updated_at = NOW()
   117→                WHERE skill_id = $2 AND scenario_id = $3
   118→                """,
   119→                notes,
   120→                skill_id,
   121→                scenario_id,
   122→            )
   123→
   124→            # Add triggers to scenario_index
   125→            primary_triggers = candidate.get("primary_triggers", [])
   126→            secondary_triggers = candidate.get("secondary_triggers", [])
   127→
   128→            for trigger in primary_triggers:
   129→                await conn.execute(
   130→                    """
   131→                    INSERT INTO scenario_index (skill_id, scenario_id, trigger_word, trigger_type, weight)
   132→                    VALUES ($1, $2, $3, 'primary', 2.0)
   133→                    ON CONFLICT (skill_id, scenario_id, trigger_word) DO NOTHING
   134→                    """,
   135→                    skill_id,
   136→                    scenario_id,
   137→                    trigger,
   138→                )
   139→
   140→            for trigger in secondary_triggers:
   141→                await conn.execute(
   142→                    """
   143→                    INSERT INTO scenario_index (skill_id, scenario_id, trigger_word, trigger_type, weight)
   144→                    VALUES ($1, $2, $3, 'secondary', 1.0)
   145→                    ON CONFLICT (skill_id, scenario_id, trigger_word) DO NOTHING
   146→                    """,
   147→                    skill_id,
   148→                    scenario_id,
   149→                    trigger,
   150→                )
   151→
   152→        # Generate and save scenario MD file
   153→        await self._publish_scenario_file(candidate)
   154→
   155→        # Update SKILL.md scenario list
   156→        await self._update_skill_md(skill_id, candidate)
   157→
   158→        logger.info(f"Approved and published: {skill_id}/{scenario_id}")
   159→
   160→        return ReviewResult(
   161→            scenario_id=scenario_id,
   162→            skill_id=skill_id,
   163→            status="approved",
   164→            notes=notes,
   165→            reviewer=reviewer,
   166→            reviewed_at=datetime.now().isoformat(),
   167→        )
   168→
   169→    async def reject(
   170→        self,
   171→        skill_id: str,
   172→        scenario_id: str,
   173→        reason: str,
   174→        reviewer: str = "human",
   175→    ) -> ReviewResult:
   176→        """
   177→        Reject a scenario candidate.
   178→
   179→        Args:
   180→            skill_id: The skill ID
   181→            scenario_id: The scenario ID
   182→            reason: Rejection reason
   183→            reviewer: Reviewer identifier
   184→
   185→        Returns:
   186→            ReviewResult
   187→        """
   188→        from stores.db import get_connection
   189→
   190→        async with get_connection() as conn:
   191→            await conn.execute(
   192→                """
   193→                UPDATE scenario_candidates
   194→                SET status = 'rejected',
   195→                    review_notes = $1,
   196→                    updated_at = NOW()
   197→                WHERE skill_id = $2 AND scenario_id = $3
   198→                """,
   199→                reason,
   200→                skill_id,
   201→                scenario_id,
   202→            )
   203→
   204→        logger.info(f"Rejected: {skill_id}/{scenario_id} - {reason}")
   205→
   206→        return ReviewResult(
   207→            scenario_id=scenario_id,
   208→            skill_id=skill_id,
   209→            status="rejected",
   210→            notes=reason,
   211→            reviewer=reviewer,
   212→            reviewed_at=datetime.now().isoformat(),
   213→        )
   214→
   215→    async def request_revision(
   216→        self,
   217→        skill_id: str,
   218→        scenario_id: str,
   219→        feedback: str,
   220→        reviewer: str = "human",
   221→    ) -> ReviewResult:
   222→        """
   223→        Request revision for a scenario candidate.
   224→
   225→        Args:
   226→            skill_id: The skill ID
   227→            scenario_id: The scenario ID
   228→            feedback: Revision feedback
   229→            reviewer: Reviewer identifier
   230→
   231→        Returns:
   232→            ReviewResult
   233→        """
   234→        from stores.db import get_connection
   235→
   236→        async with get_connection() as conn:
   237→            await conn.execute(
   238→                """
   239→                UPDATE scenario_candidates
   240→                SET status = 'needs_revision',
   241→                    review_notes = $1,
   242→                    updated_at = NOW()
   243→                WHERE skill_id = $2 AND scenario_id = $3
   244→                """,
   245→                feedback,
   246→                skill_id,
   247→                scenario_id,
   248→            )
   249→
   250→        logger.info(f"Revision requested: {skill_id}/{scenario_id}")
   251→
   252→        return ReviewResult(
   253→            scenario_id=scenario_id,
   254→            skill_id=skill_id,
   255→            status="needs_revision",
   256→            notes=feedback,
   257→            reviewer=reviewer,
   258→            reviewed_at=datetime.now().isoformat(),
   259→        )
   260→
   261→    async def _publish_scenario_file(self, candidate: dict):
   262→        """Generate and save scenario MD file"""
   263→        from workers.scenario_generator import GeneratedScenario, SOPPhase, ScenarioGenerator
   264→
   265→        # Reconstruct scenario object
   266→        sop_phases = []
   267→        for phase_data in json.loads(candidate.get("sop_phases", "[]")):
   268→            phase = SOPPhase(
   269→                phase=phase_data.get("phase", 0),
   270→                name=phase_data.get("name", ""),
   271→                type=phase_data.get("type", "required"),
   272→                description=phase_data.get("description", ""),
   273→                tools=phase_data.get("tools", []),
   274→                knowledge_queries=phase_data.get("knowledge_queries", []),
   275→            )
   276→            sop_phases.append(phase)
   277→
   278→        scenario = GeneratedScenario(
   279→            scenario_id=candidate["scenario_id"],
   280→            skill_id=candidate["skill_id"],
   281→            name=candidate["name"],
   282→            level=candidate["level"],
   283→            billing=candidate["billing"],
   284→            description=candidate.get("description", ""),
   285→            primary_triggers=candidate.get("primary_triggers", []),
   286→            secondary_triggers=candidate.get("secondary_triggers", []),
   287→            prerequisites=candidate.get("prerequisites", []),
   288→            sop_phases=sop_phases,
   289→            output_template=candidate.get("output_template", ""),
   290→            estimated_turns=candidate.get("estimated_turns", "3-5"),
   291→        )
   292→
   293→        # Generate MD content
   294→        generator = ScenarioGenerator()
   295→        md_content = generator.generate_scenario_md(scenario)
   296→
   297→        # Save to file
   298→        skill_dir = self.skills_dir / candidate["skill_id"]
   299→        scenarios_dir = skill_dir / "scenarios"
   300→        scenarios_dir.mkdir(parents=True, exist_ok=True)
   301→
   302→        file_path = scenarios_dir / f"{candidate['scenario_id']}.md"
   303→        file_path.write_text(md_content, encoding="utf-8")
   304→
   305→        logger.info(f"Published scenario file: {file_path}")
   306→
   307→    async def _update_skill_md(self, skill_id: str, candidate: dict):
   308→        """Update SKILL.md with new scenario entry"""
   309→        skill_md_path = self.skills_dir / skill_id / "SKILL.md"
   310→
   311→        if not skill_md_path.exists():
   312→            logger.warning(f"SKILL.md not found: {skill_md_path}")
   313→            return
   314→
   315→        # Read current content
   316→        content = skill_md_path.read_text(encoding="utf-8")
   317→
   318→        # Find the appropriate level section and add entry
   319→        level = candidate["level"]
   320→        level_headers = {
   321→            "entry": "### 入门级 (Entry)",
   322→            "standard": "### 标准级 (Standard)",
   323→            "professional": "### 专业级 (Professional)",
   324→        }
   325→
   326→        header = level_headers.get(level, "### 标准级 (Standard)")
   327→
   328→        # Create new table row
   329→        triggers = ", ".join(candidate.get("primary_triggers", [])[:3])
   330→        billing_map = {"free": "免费", "basic": "基础", "premium": "高级"}
   331→        billing = billing_map.get(candidate["billing"], candidate["billing"])
   332→
   333→        new_row = f"| {candidate['name']} | {candidate['scenario_id']}.md | {triggers} | {billing} |"
   334→
   335→        # Check if scenario already exists
   336→        if candidate["scenario_id"] in content:
   337→            logger.info(f"Scenario already in SKILL.md: {candidate['scenario_id']}")
   338→            return
   339→
   340→        # Find header and insert after table header
   341→        if header in content:
   342→            # Find the table after this header
   343→            header_pos = content.find(header)
   344→            table_start = content.find("|", header_pos)
   345→            if table_start > 0:
   346→                # Find end of table header row (second |---|)
   347→                first_separator = content.find("|---|", table_start)
   348→                if first_separator > 0:
   349→                    line_end = content.find("\n", first_separator)
   350→                    if line_end > 0:
   351→                        # Insert new row after separator
   352→                        content = content[:line_end + 1] + new_row + "\n" + content[line_end + 1:]
   353→                        skill_md_path.write_text(content, encoding="utf-8")
   354→                        logger.info(f"Updated SKILL.md with scenario: {candidate['scenario_id']}")
   355→                        return
   356→
   357→        logger.warning(f"Could not find appropriate section in SKILL.md for level: {level}")
   358→
   359→
   360→# CLI Interface
   361→async def review_cli():
   362→    """Interactive CLI for scenario review"""
   363→    reviewer = ScenarioReviewer()
   364→
   365→    print("\n" + "=" * 60)
   366→    print("Scenario Review CLI")
   367→    print("=" * 60)
   368→
   369→    while True:
   370→        print("\nCommands:")
   371→        print("  1. List pending scenarios")
   372→        print("  2. Review a scenario")
   373→        print("  3. Approve all pending for a skill")
   374→        print("  4. Exit")
   375→
   376→        choice = input("\nChoice: ").strip()
   377→
   378→        if choice == "1":
   379→            skill = input("Filter by skill (or press Enter for all): ").strip() or None
   380→            pending = await reviewer.list_pending(skill)
   381→
   382→            if not pending:
   383→                print("No pending scenarios found.")
   384→                continue
   385→
   386→            print(f"\nFound {len(pending)} pending scenarios:\n")
   387→            for s in pending:
   388→                print(f"  [{s['skill_id']}] {s['scenario_id']}: {s['name']} ({s['level']}/{s['billing']})")
   389→
   390→        elif choice == "2":
   391→            skill_id = input("Skill ID: ").strip()
   392→            scenario_id = input("Scenario ID: ").strip()
   393→
   394→            candidate = await reviewer.get_candidate(skill_id, scenario_id)
   395→            if not candidate:
   396→                print("Scenario not found.")
   397→                continue
   398→
   399→            print(f"\n{'=' * 40}")
   400→            print(f"Name: {candidate['name']}")
   401→            print(f"Level: {candidate['level']}")
   402→            print(f"Billing: {candidate['billing']}")
   403→            print(f"Description: {candidate.get('description', 'N/A')}")
   404→            print(f"Primary Triggers: {candidate.get('primary_triggers', [])}")
   405→            print(f"SOP Phases: {len(json.loads(candidate.get('sop_phases', '[]')))} phases")
   406→            print(f"{'=' * 40}")
   407→
   408→            action = input("\nAction (a=approve, r=reject, v=revision, s=skip): ").strip().lower()
   409→
   410→            if action == "a":
   411→                notes = input("Notes (optional): ").strip() or None
   412→                result = await reviewer.approve(skill_id, scenario_id, notes)
   413→                print(f"✓ Approved: {result.scenario_id}")
   414→
   415→            elif action == "r":
   416→                reason = input("Rejection reason: ").strip()
   417→                result = await reviewer.reject(skill_id, scenario_id, reason)
   418→                print(f"✗ Rejected: {result.scenario_id}")
   419→
   420→            elif action == "v":
   421→                feedback = input("Revision feedback: ").strip()
   422→                result = await reviewer.request_revision(skill_id, scenario_id, feedback)
   423→                print(f"↻ Revision requested: {result.scenario_id}")
   424→
   425→        elif choice == "3":
   426→            skill_id = input("Skill ID: ").strip()
   427→            pending = await reviewer.list_pending(skill_id)
   428→
   429→            if not pending:
   430→                print("No pending scenarios found.")
   431→                continue
   432→
   433→            confirm = input(f"Approve all {len(pending)} scenarios? (y/n): ").strip().lower()
   434→            if confirm == "y":
   435→                for s in pending:
   436→                    await reviewer.approve(s["skill_id"], s["scenario_id"])
   437→                    print(f"  ✓ {s['scenario_id']}")
   438→                print(f"\nApproved {len(pending)} scenarios.")
   439→
   440→        elif choice == "4":
   441→            print("Goodbye!")
   442→            break
   443→
   444→
   445→if __name__ == "__main__":
   446→    asyncio.run(review_cli())
   447→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
