  1018→@lru_cache(maxsize=32)
  1019→def _load_skill_md_content(skill_id: str) -> str:
  1020→    """加载 SKILL.md 全文内容（去掉 frontmatter）"""
  1021→    skill_path = SKILLS_DIR / skill_id / "SKILL.md"
  1022→    if not skill_path.exists():
  1023→        return ""
  1024→    text = skill_path.read_text(encoding='utf-8')
  1025→    _, content = parse_frontmatter(text)
  1026→    return content
  1027→
  1028→
  1029→def build_system_prompt(
  1030→    skill_id: str,
  1031→    scenario_id: Optional[str] = None,
  1032→    user_context: Optional[Dict] = None
  1033→) -> str:
  1034→    """构建完整的 System Prompt
  1035→
  1036→    v7 更新：支持 rules 架构，scenario_id 可以是 rule_id
  1037→    v8 更新：支持 persona 和 voice_mode 注入
  1038→    v10 更新：直接加载 SKILL.md 全文（去掉 frontmatter），确保所有规则都被加载
  1039→    """
  1040→    parts = []
  1041→
  1042→    # 加载 Skill
  1043→    skill = load_skill(skill_id)
  1044→    if not skill:
  1045→        return ""
  1046→
  1047→    # V2: Persona 注入（在专家身份之前）- 仅 lifecoach 支持
  1048→    persona_prompt = _build_persona_prompt(skill_id, user_context)
  1049→    if persona_prompt:
  1050→        parts.append(persona_prompt)
  1051→    else:
  1052→        # v10: 直接加载 SKILL.md 全文（去掉 frontmatter）
  1053→        skill_md_content = _load_skill_md_content(skill_id)
  1054→        if skill_md_content:
  1055→            parts.append(skill_md_content)
  1056→        else:
  1057→            # Fallback: 只加载专家身份
  1058→            parts.append(f"# {skill.name}\n\n{skill.expert_persona}")
  1059→
  1060→    # V2: Voice Mode 注入
  1061→    if user_context:
  1062→        preferences = user_context.get("preferences", {})
  1063→        voice_mode = preferences.get("voice_mode", "warm")
  1064→        if voice_mode in VOICE_MODE_PROMPTS:
  1065→            parts.append(VOICE_MODE_PROMPTS[voice_mode])
  1066→
  1067→    # 加载场景或规则
  1068→    if scenario_id:
  1069→        # v7: 优先尝试加载规则
  1070→        if has_rules(skill_id):
  1071→            rule = load_rule(skill_id, scenario_id)
  1072→            if rule:
  1073→                parts.append(f"\n---\n\n## 当前规则: {rule.name}\n")
  1074→                # 添加规则完整内容
  1075→                parts.append(rule.content)
  1076→            else:
  1077→                # 规则不存在，尝试加载场景（向后兼容）
  1078→                scenario = load_scenario(skill_id, scenario_id)
  1079→                if scenario:
  1080→                    parts.append(f"\n---\n\n## 当前场景: {scenario.name}\n\n{scenario.description}")
  1081→                    if scenario.sop:
  1082→                        sop_text = "\n## 服务流程 (SOP)\n\n"
  1083→                        for phase in scenario.sop:
  1084→                            sop_text += f"### Phase {phase['phase']}: {phase['name']}\n{phase['content']}\n\n"
  1085→                        parts.append(sop_text)
  1086→        else:
  1087→            # 旧架构：加载场景
  1088→            scenario = load_scenario(skill_id, scenario_id)
  1089→            if scenario:
  1090→                parts.append(f"\n---\n\n## 当前场景: {scenario.name}\n\n{scenario.description}")
  1091→                # SOP
  1092→                if scenario.sop:
  1093→                    sop_text = "\n## 服务流程 (SOP)\n\n"
  1094→                    for phase in scenario.sop:
  1095→                        sop_text += f"### Phase {phase['phase']}: {phase['name']}\n{phase['content']}\n\n"
  1096→                    parts.append(sop_text)
  1097→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
