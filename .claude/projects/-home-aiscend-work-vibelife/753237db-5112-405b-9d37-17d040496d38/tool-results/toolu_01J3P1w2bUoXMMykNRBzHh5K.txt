     1→"""
     2→Context Manager v10 - Context Engineering 核心
     3→
     4→管理 Agent 的"磁盘工作记忆"，实现：
     5→- 会话上下文持久化
     6→- 断点续传（checkpoint 机制）
     7→- 分析发现积累（findings）
     8→- 跨 Skill 共享上下文
     9→
    10→数据存储位置（v9.0 三层架构）：
    11→- profile.identity: 用户基本信息
    12→- profile.skills.{skill_id}: Skill 数据
    13→- profile.skills.{skill_id}._session: Skill 会话状态
    14→- profile.skills.{skill_id}._findings: 分析发现
    15→- profile.vibe.insight: 用户画像（我是谁）
    16→- profile.vibe.target: 用户目标（我要成为谁）
    17→"""
    18→import json
    19→import logging
    20→from dataclasses import dataclass, field, asdict
    21→from datetime import datetime, timezone
    22→from typing import Optional, Dict, Any, List
    23→from uuid import UUID
    24→
    25→logger = logging.getLogger(__name__)
    26→
    27→
    28→# ═══════════════════════════════════════════════════════════════════════════
    29→# Data Classes
    30→# ═══════════════════════════════════════════════════════════════════════════
    31→
    32→@dataclass
    33→class Checkpoint:
    34→    """执行检查点 - 支持断点续传"""
    35→    phase: Optional[int] = None
    36→    step: int = 0
    37→    total_steps: int = 0
    38→    collected_data: Dict[str, Any] = field(default_factory=dict)
    39→
    40→    def to_dict(self) -> Dict[str, Any]:
    41→        return asdict(self)
    42→
    43→    @classmethod
    44→    def from_dict(cls, data: Dict[str, Any]) -> "Checkpoint":
    45→        return cls(
    46→            phase=data.get("phase"),
    47→            step=data.get("step", 0),
    48→            total_steps=data.get("total_steps", 0),
    49→            collected_data=data.get("collected_data", {})
    50→        )
    51→
    52→
    53→@dataclass
    54→class SkillSession:
    55→    """Skill 会话状态"""
    56→    active: bool = False
    57→    rule_id: Optional[str] = None
    58→    started_at: Optional[str] = None
    59→    last_activity: Optional[str] = None
    60→    checkpoint: Optional[Checkpoint] = None
    61→    context: Dict[str, Any] = field(default_factory=dict)
    62→
    63→    def to_dict(self) -> Dict[str, Any]:
    64→        return {
    65→            "active": self.active,
    66→            "rule_id": self.rule_id,
    67→            "started_at": self.started_at,
    68→            "last_activity": self.last_activity,
    69→            "checkpoint": self.checkpoint.to_dict() if self.checkpoint else None,
    70→            "context": self.context
    71→        }
    72→
    73→    @classmethod
    74→    def from_dict(cls, data: Dict[str, Any]) -> "SkillSession":
    75→        checkpoint_data = data.get("checkpoint")
    76→        return cls(
    77→            active=data.get("active", False),
    78→            rule_id=data.get("rule_id"),
    79→            started_at=data.get("started_at"),
    80→            last_activity=data.get("last_activity"),
    81→            checkpoint=Checkpoint.from_dict(checkpoint_data) if checkpoint_data else None,
    82→            context=data.get("context", {})
    83→        )
    84→
    85→
    86→@dataclass
    87→class Finding:
    88→    """分析发现"""
    89→    type: str  # insight | pattern | concern | goal | milestone
    90→    content: str
    91→    rule_id: Optional[str] = None
    92→    created_at: Optional[str] = None
    93→    metadata: Dict[str, Any] = field(default_factory=dict)
    94→
    95→    def to_dict(self) -> Dict[str, Any]:
    96→        return asdict(self)
    97→
    98→    @classmethod
    99→    def from_dict(cls, data: Dict[str, Any]) -> "Finding":
   100→        return cls(
   101→            type=data.get("type", "insight"),
   102→            content=data.get("content", ""),
   103→            rule_id=data.get("rule_id"),
   104→            created_at=data.get("created_at"),
   105→            metadata=data.get("metadata", {})
   106→        )
   107→
   108→
   109→@dataclass
   110→class SessionContext:
   111→    """会话上下文（用于传递给 LLM）"""
   112→    skill_id: str
   113→    rule_id: Optional[str] = None
   114→    session: Optional[SkillSession] = None
   115→    findings: List[Finding] = field(default_factory=list)
   116→    shared_context: Dict[str, Any] = field(default_factory=dict)
   117→
   118→    @property
   119→    def has_checkpoint(self) -> bool:
   120→        """是否有可恢复的检查点"""
   121→        return (
   122→            self.session is not None and
   123→            self.session.checkpoint is not None and
   124→            self.session.checkpoint.step > 0
   125→        )
   126→
   127→    @property
   128→    def checkpoint(self) -> Optional[Checkpoint]:
   129→        """获取检查点"""
   130→        return self.session.checkpoint if self.session else None
   131→
   132→    def to_prompt_context(self) -> str:
   133→        """转换为 Prompt 上下文文本"""
   134→        if not self.has_checkpoint:
   135→            return ""
   136→
   137→        cp = self.checkpoint
   138→        lines = ["## 会话恢复上下文（断点续传）\n"]
   139→
   140→        # 会话信息
   141→        if self.session:
   142→            lines.append(f"**上次会话信息**：")
   143→            if self.rule_id:
   144→                lines.append(f"- 规则: {self.rule_id}")
   145→            lines.append(f"- 开始时间: {self.session.started_at}")
   146→            lines.append(f"- 上次活动: {self.session.last_activity}")
   147→            lines.append("")
   148→
   149→        # 进度信息
   150→        if cp:
   151→            lines.append(f"**当前进度**: 第 {cp.step}/{cp.total_steps} 步")
   152→            lines.append("")
   153→
   154→            # 已收集信息
   155→            if cp.collected_data:
   156→                lines.append("**已收集的信息**:")
   157→                for key, value in cp.collected_data.items():
   158→                    lines.append(f"- {key}: {value}")
   159→                lines.append("")
   160→
   161→        # 关键发现
   162→        if self.findings:
   163→            lines.append("**关键发现**:")
   164→            for finding in self.findings[-5:]:  # 只显示最近 5 条
   165→                lines.append(f"- [{finding.type}] {finding.content}")
   166→            lines.append("")
   167→
   168→        # 指引
   169→        if cp and cp.step > 0:
   170→            next_step = cp.step + 1
   171→            lines.append("---\n")
   172→            lines.append("**指引**:")
   173→            lines.append(f"1. 从第 {next_step} 个问题继续")
   174→            lines.append("2. 不要重复已问过的问题")
   175→            lines.append("3. 可以简短总结上次内容，但不要冗长")
   176→
   177→        return "\n".join(lines)
   178→
   179→
   180→# ═══════════════════════════════════════════════════════════════════════════
   181→# Context Manager
   182→# ═══════════════════════════════════════════════════════════════════════════
   183→
   184→class ContextManager:
   185→    """
   186→    Context Engineering 核心 - 管理 Agent 的"磁盘工作记忆"
   187→
   188→    职责：
   189→    1. 加载会话上下文（断点续传核心）
   190→    2. 保存进度检查点
   191→    3. 记录分析发现
   192→    4. 获取跨 Skill 共享上下文
   193→    5. 清理会话状态
   194→    """
   195→
   196→    def __init__(self):
   197→        self._cache: Dict[str, SessionContext] = {}
   198→
   199→    async def load_session_context(
   200→        self,
   201→        user_id: str,
   202→        skill_id: str,
   203→        rule_id: Optional[str] = None
   204→    ) -> SessionContext:
   205→        """
   206→        加载会话上下文（断点续传核心）
   207→
   208→        从 VibeProfile 读取：
   209→        - profile.skills.{skill_id}._session
   210→        - profile.skills.{skill_id}._findings
   211→        - profile.extracted (共享上下文)
   212→        """
   213→        from stores.unified_profile_repo import UnifiedProfileRepository
   214→
   215→        if user_id == "guest":
   216→            return SessionContext(skill_id=skill_id, rule_id=rule_id)
   217→
   218→        try:
   219→            user_uuid = UUID(user_id)
   220→
   221→            # 获取 skill 状态
   222→            skill_state = await UnifiedProfileRepository.get_skill_state(user_uuid, skill_id)
   223→
   224→            # 解析 _session
   225→            session_data = skill_state.get("_session", {})
   226→            session = SkillSession.from_dict(session_data) if session_data else None
   227→
   228→            # 解析 _findings
   229→            findings_data = skill_state.get("_findings", [])
   230→            findings = [Finding.from_dict(f) for f in findings_data]
   231→
   232→            # 获取共享上下文
   233→            shared_context = await self.get_shared_context(user_id)
   234→
   235→            context = SessionContext(
   236→                skill_id=skill_id,
   237→                rule_id=rule_id or (session.rule_id if session else None),
   238→                session=session,
   239→                findings=findings,
   240→                shared_context=shared_context
   241→            )
   242→
   243→            logger.info(f"[ContextManager] Loaded session context: user={user_id}, skill={skill_id}, has_checkpoint={context.has_checkpoint}")
   244→
   245→            return context
   246→
   247→        except Exception as e:
   248→            logger.error(f"[ContextManager] Failed to load session context: {e}")
   249→            return SessionContext(skill_id=skill_id, rule_id=rule_id)
   250→
   251→    async def save_checkpoint(
   252→        self,
   253→        user_id: str,
   254→        skill_id: str,
   255→        step: int,
   256→        total_steps: int = 0,
   257→        phase: Optional[int] = None,
   258→        collected_data: Optional[Dict[str, Any]] = None,
   259→        context: Optional[Dict[str, Any]] = None
   260→    ) -> None:
   261→        """
   262→        保存进度检查点
   263→
   264→        写入 profile.skills.{skill_id}._session.checkpoint
   265→        """
   266→        from stores.unified_profile_repo import UnifiedProfileRepository
   267→
   268→        if user_id == "guest":
   269→            logger.warning("[ContextManager] Cannot save checkpoint for guest user")
   270→            return
   271→
   272→        try:
   273→            user_uuid = UUID(user_id)
   274→            now = datetime.now(timezone.utc).isoformat()
   275→
   276→            # 获取现有 session 或创建新的
   277→            skill_state = await UnifiedProfileRepository.get_skill_state(user_uuid, skill_id)
   278→            session_data = skill_state.get("_session", {})
   279→
   280→            # 更新 session
   281→            session_data["active"] = True
   282→            session_data["last_activity"] = now
   283→            if not session_data.get("started_at"):
   284→                session_data["started_at"] = now
   285→
   286→            # 更新 checkpoint
   287→            session_data["checkpoint"] = {
   288→                "phase": phase,
   289→                "step": step,
   290→                "total_steps": total_steps,
   291→                "collected_data": collected_data or {}
   292→            }
   293→
   294→            # 更新 context
   295→            if context:
   296→                session_data["context"] = {
   297→                    **session_data.get("context", {}),
   298→                    **context
   299→                }
   300→
   301→            # 写入数据库
   302→            await UnifiedProfileRepository.update_skill_state(
   303→                user_uuid, skill_id, "_session", session_data
   304→            )
   305→
   306→            logger.info(f"[ContextManager] Saved checkpoint: user={user_id}, skill={skill_id}, step={step}/{total_steps}")
   307→
   308→        except Exception as e:
   309→            logger.error(f"[ContextManager] Failed to save checkpoint: {e}")
   310→
   311→    async def add_finding(
   312→        self,
   313→        user_id: str,
   314→        skill_id: str,
   315→        finding_type: str,
   316→        content: str,
   317→        rule_id: Optional[str] = None,
   318→        metadata: Optional[Dict[str, Any]] = None
   319→    ) -> None:
   320→        """
   321→        记录分析发现
   322→
   323→        追加到 profile.skills.{skill_id}._findings
   324→        """
   325→        from stores.unified_profile_repo import UnifiedProfileRepository
   326→
   327→        if user_id == "guest":
   328→            return
   329→
   330→        try:
   331→            user_uuid = UUID(user_id)
   332→            now = datetime.now(timezone.utc).isoformat()
   333→
   334→            finding = {
   335→                "type": finding_type,
   336→                "content": content,
   337→                "rule_id": rule_id,
   338→                "created_at": now,
   339→                "metadata": metadata or {}
   340→            }
   341→
   342→            # 追加到 _findings 列表
   343→            await UnifiedProfileRepository.append_to_skill_list(
   344→                user_uuid, skill_id, "_findings", finding, max_items=50
   345→            )
   346→
   347→            logger.info(f"[ContextManager] Added finding: user={user_id}, skill={skill_id}, type={finding_type}")
   348→
   349→        except Exception as e:
   350→            logger.error(f"[ContextManager] Failed to add finding: {e}")
   351→
   352→    async def get_profile_context(
   353→        self,
   354→        user_id: str,
   355→        skill_id: str
   356→    ) -> Dict[str, Any]:
   357→        """
   358→        Profile 注入 - 三层架构 (v9.0)
   359→
   360→        Layer 1: Identity（所有 Skill 共享，~200 tokens）
   361→        - identity.birth_info
   362→        - identity.display_name
   363→
   364→        Layer 2: Skills（当前 Skill 专属，~300 tokens）
   365→        - skills.{skill_id}
   366→
   367→        Layer 3: Vibe（共享深度信息，~200 tokens）
   368→        - vibe.insight（我是谁）
   369→        - vibe.target（我要成为谁）
   370→        """
   371→        from stores.unified_profile_repo import UnifiedProfileRepository
   372→
   373→        if user_id == "guest":
   374→            return {}
   375→
   376→        try:
   377→            user_uuid = UUID(user_id)
   378→            profile = await UnifiedProfileRepository.get_profile(user_uuid)
   379→
   380→            if not profile:
   381→                return {}
   382→
   383→            # Layer 1: Identity（共享）
   384→            identity = profile.get("identity", {})
   385→
   386→            context = {
   387→                "user": {
   388→                    "name": identity.get("display_name"),
   389→                    "birth": identity.get("birth_info"),
   390→                },
   391→            }
   392→
   393→            # Layer 2: Skills（v9.0: 只从 skills 读取）
   394→            from .skill_loader import get_skill_required_data
   395→            skills_store = profile.get("skills", {})
   396→            skill_ids = get_skill_required_data(skill_id)
   397→
   398→            if len(skill_ids) == 1:
   399→                context["skill_data"] = skills_store.get(skill_ids[0], {})
   400→            else:
   401→                # 跨 skill（如 jungastro 需要 bazi + zodiac）
   402→                context["skill_data"] = {
   403→                    sid: skills_store.get(sid, {})
   404→                    for sid in skill_ids
   405→                }
   406→
   407→            # Layer 3: Vibe（共享深度信息）
   408→            vibe = profile.get("vibe", {})
   409→            if vibe:
   410→                context["vibe"] = {
   411→                    "insight": vibe.get("insight", {}),
   412→                    "target": vibe.get("target", {})
   413→                }
   414→
   415→            logger.debug(f"[ContextManager] Profile context for {skill_id}: user={bool(context.get('user', {}).get('name'))}, skill_data={bool(context.get('skill_data'))}, vibe={bool(context.get('vibe'))}")
   416→
   417→            return context
   418→
   419→        except Exception as e:
   420→            logger.error(f"[ContextManager] Failed to get profile context: {e}")
   421→            return {}
   422→
   423→    async def get_shared_context(self, user_id: str) -> Dict[str, Any]:
   424→        """
   425→        获取跨 Skill 共享的上下文 (v9.0 三层架构)
   426→
   427→        从 profile 提取：
   428→        - identity: 用户基本信息
   429→        - vibe.insight: 用户画像（我是谁）
   430→        - vibe.target: 用户目标（我要成为谁）
   431→        """
   432→        from stores.unified_profile_repo import UnifiedProfileRepository
   433→
   434→        if user_id == "guest":
   435→            return {}
   436→
   437→        try:
   438→            user_uuid = UUID(user_id)
   439→            profile = await UnifiedProfileRepository.get_profile(user_uuid)
   440→
   441→            if not profile:
   442→                return {}
   443→
   444→            shared = {}
   445→
   446→            # Layer 1: Identity
   447→            identity = profile.get("identity", {})
   448→            if identity:
   449→                shared["identity"] = {
   450→                    "birth_info": identity.get("birth_info", {}),
   451→                    "display_name": identity.get("display_name")
   452→                }
   453→
   454→            # Layer 3: Vibe
   455→            vibe = profile.get("vibe", {})
   456→
   457→            # VibeInsight - 用户画像（我是谁）
   458→            insight = vibe.get("insight", {})
   459→            if insight:
   460→                shared["insight"] = insight
   461→
   462→            # VibeTarget - 用户目标（我要成为谁）
   463→            target = vibe.get("target", {})
   464→            if target:
   465→                shared["target"] = target
   466→
   467→            return shared
   468→
   469→        except Exception as e:
   470→            logger.error(f"[ContextManager] Failed to get shared context: {e}")
   471→            return {}
   472→
   473→    async def clear_session(
   474→        self,
   475→        user_id: str,
   476→        skill_id: str,
   477→        keep_findings: bool = True
   478→    ) -> None:
   479→        """
   480→        清理会话状态（完成或放弃时）
   481→
   482→        清除 profile.skills.{skill_id}._session
   483→        可选保留 _findings
   484→        """
   485→        from stores.unified_profile_repo import UnifiedProfileRepository
   486→
   487→        if user_id == "guest":
   488→            return
   489→
   490→        try:
   491→            user_uuid = UUID(user_id)
   492→
   493→            # 清除 _session
   494→            await UnifiedProfileRepository.update_skill_state(
   495→                user_uuid, skill_id, "_session", {
   496→                    "active": False,
   497→                    "last_activity": datetime.now(timezone.utc).isoformat(),
   498→                    "checkpoint": None,
   499→                    "context": {}
   500→                }
   501→            )
   502→
   503→            # 如果不保留 findings，也清除
   504→            if not keep_findings:
   505→                await UnifiedProfileRepository.update_skill_state(
   506→                    user_uuid, skill_id, "_findings", []
   507→                )
   508→
   509→            logger.info(f"[ContextManager] Cleared session: user={user_id}, skill={skill_id}, keep_findings={keep_findings}")
   510→
   511→        except Exception as e:
   512→            logger.error(f"[ContextManager] Failed to clear session: {e}")
   513→
   514→    async def start_session(
   515→        self,
   516→        user_id: str,
   517→        skill_id: str,
   518→        rule_id: Optional[str] = None,
   519→        goal: Optional[str] = None,
   520→        total_steps: int = 0
   521→    ) -> SkillSession:
   522→        """
   523→        开始新会话
   524→
   525→        初始化 profile.skills.{skill_id}._session
   526→        """
   527→        from stores.unified_profile_repo import UnifiedProfileRepository
   528→
   529→        if user_id == "guest":
   530→            return SkillSession(
   531→                active=True,
   532→                rule_id=rule_id,
   533→                started_at=datetime.now(timezone.utc).isoformat()
   534→            )
   535→
   536→        try:
   537→            user_uuid = UUID(user_id)
   538→            now = datetime.now(timezone.utc).isoformat()
   539→
   540→            session_data = {
   541→                "active": True,
   542→                "rule_id": rule_id,
   543→                "started_at": now,
   544→                "last_activity": now,
   545→                "checkpoint": {
   546→                    "phase": 1,
   547→                    "step": 0,
   548→                    "total_steps": total_steps,
   549→                    "collected_data": {}
   550→                },
   551→                "context": {
   552→                    "goal": goal
   553→                } if goal else {}
   554→            }
   555→
   556→            await UnifiedProfileRepository.update_skill_state(
   557→                user_uuid, skill_id, "_session", session_data
   558→            )
   559→
   560→            # 同时更新全局 active_session
   561→            await UnifiedProfileRepository.update_state(user_uuid, {
   562→                "active_session": {
   563→                    "skill_id": skill_id,
   564→                    "rule_id": rule_id,
   565→                    "conversation_id": None,  # 将在后续更新
   566→                    "started_at": now,
   567→                    "status": "in_progress",
   568→                    "goal": goal
   569→                }
   570→            })
   571→
   572→            logger.info(f"[ContextManager] Started session: user={user_id}, skill={skill_id}, rule={rule_id}")
   573→
   574→            return SkillSession.from_dict(session_data)
   575→
   576→        except Exception as e:
   577→            logger.error(f"[ContextManager] Failed to start session: {e}")
   578→            return SkillSession(active=True, rule_id=rule_id)
   579→
   580→    async def complete_session(
   581→        self,
   582→        user_id: str,
   583→        skill_id: str,
   584→        summary: Optional[str] = None
   585→    ) -> None:
   586→        """
   587→        完成会话
   588→
   589→        标记 session 为完成，清理 checkpoint，保留 findings
   590→        """
   591→        from stores.unified_profile_repo import UnifiedProfileRepository
   592→
   593→        if user_id == "guest":
   594→            return
   595→
   596→        try:
   597→            user_uuid = UUID(user_id)
   598→            now = datetime.now(timezone.utc).isoformat()
   599→
   600→            # 更新 _session
   601→            await UnifiedProfileRepository.update_skill_state(
   602→                user_uuid, skill_id, "_session", {
   603→                    "active": False,
   604→                    "completed_at": now,
   605→                    "last_activity": now,
   606→                    "checkpoint": None,
   607→                    "summary": summary
   608→                }
   609→            )
   610→
   611→            # 清除全局 active_session
   612→            await UnifiedProfileRepository.update_state(user_uuid, {
   613→                "active_session": None
   614→            })
   615→
   616→            # 如果有 summary，添加到 findings
   617→            if summary:
   618→                await self.add_finding(
   619→                    user_id, skill_id,
   620→                    finding_type="milestone",
   621→                    content=f"会话完成: {summary}"
   622→                )
   623→
   624→            logger.info(f"[ContextManager] Completed session: user={user_id}, skill={skill_id}")
   625→
   626→        except Exception as e:
   627→            logger.error(f"[ContextManager] Failed to complete session: {e}")
   628→
   629→
   630→# ═══════════════════════════════════════════════════════════════════════════
   631→# Singleton
   632→# ═══════════════════════════════════════════════════════════════════════════
   633→
   634→_context_manager: Optional[ContextManager] = None
   635→
   636→
   637→def get_context_manager() -> ContextManager:
   638→    """获取 ContextManager 单例"""
   639→    global _context_manager
   640→    if _context_manager is None:
   641→        _context_manager = ContextManager()
   642→    return _context_manager
   643→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
