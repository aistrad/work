     1→"""
     2→Tool Executor v10 - 工具执行器
     3→
     4→从 core.py 拆分出来的工具执行逻辑，支持：
     5→- 统一工具执行
     6→- 自动 checkpoint 保存
     7→- Phase 1 路由工具处理
     8→- 工具结果处理
     9→
    10→与 ContextManager 协作：
    11→- 工具执行后自动保存 checkpoint
    12→- 收集工具数据自动累积
    13→"""
    14→import json
    15→import logging
    16→from dataclasses import dataclass
    17→from typing import Optional, Dict, Any, Callable, Awaitable
    18→
    19→from .tool_registry import ToolRegistry, ToolContext
    20→from .skill_loader import load_skill, get_skill_rules, load_rule
    21→from .routing_config import get_protocol_meta
    22→
    23→logger = logging.getLogger(__name__)
    24→
    25→
    26→@dataclass
    27→class ToolResult:
    28→    """工具执行结果"""
    29→    data: Dict[str, Any]
    30→    should_checkpoint: bool = False
    31→    checkpoint_data: Optional[Dict[str, Any]] = None
    32→    should_reload_context: bool = False  # 是否需要重新加载上下文
    33→
    34→
    35→class ToolExecutor:
    36→    """
    37→    工具执行器
    38→
    39→    职责：
    40→    1. 执行工具调用
    41→    2. 处理 Phase 1 路由工具
    42→    3. 判断是否需要保存 checkpoint
    43→    4. 返回执行结果
    44→    """
    45→
    46→    # 需要保存 checkpoint 的工具
    47→    CHECKPOINT_TOOLS = {
    48→        "save_checkpoint",
    49→        "write_state",
    50→        "append_to_list",
    51→        "save_skill_data",
    52→        "request_info",  # 收集工具
    53→    }
    54→
    55→    # 收集型工具（返回的数据需要累积）
    56→    COLLECT_TOOLS = {
    57→        "request_info",
    58→        "ask_user_question",
    59→    }
    60→
    61→    def __init__(self):
    62→        from .context_manager import get_context_manager
    63→        self.context_manager = get_context_manager()
    64→
    65→    async def execute(
    66→        self,
    67→        tool_name: str,
    68→        tool_args: str,
    69→        context: ToolContext,
    70→        current_message: str = "",
    71→        reload_callback: Optional[Callable[[], Awaitable[None]]] = None
    72→    ) -> ToolResult:
    73→        """
    74→        执行工具调用
    75→
    76→        Args:
    77→            tool_name: 工具名称
    78→            tool_args: 工具参数（JSON 字符串）
    79→            context: 工具上下文
    80→            current_message: 当前用户消息（用于路由）
    81→            reload_callback: 上下文重载回调（用于 activate_skill 后重新构建 prompt）
    82→
    83→        Returns:
    84→            ToolResult 包含执行结果和 checkpoint 信息
    85→        """
    86→        try:
    87→            args = json.loads(tool_args) if tool_args else {}
    88→        except json.JSONDecodeError:
    89→            args = {}
    90→
    91→        # ═══════════════════════════════════════════════════════════════
    92→        # Phase 1 路由工具
    93→        # ═══════════════════════════════════════════════════════════════
    94→
    95→        if tool_name == "activate_skill":
    96→            return await self._handle_activate_skill(args, context, current_message, reload_callback)
    97→
    98→        if tool_name == "show_protocol_invitation":
    99→            return await self._handle_show_protocol_invitation(args, context)
   100→
   101→        if tool_name == "show_skill_intro":
   102→            return await self._handle_show_skill_intro(args, context)
   103→
   104→        if tool_name == "recommend_skills":
   105→            return await self._handle_recommend_skills(args, context)
   106→
   107→        # 兼容旧的 use_skill
   108→        if tool_name == "use_skill":
   109→            new_args = {
   110→                "skill": args.get("skill"),
   111→                "rule": args.get("scenario"),
   112→            }
   113→            return await self._handle_activate_skill(new_args, context, current_message, reload_callback)
   114→
   115→        # ═══════════════════════════════════════════════════════════════
   116→        # Session 管理工具（v10 新增）
   117→        # ═══════════════════════════════════════════════════════════════
   118→
   119→        if tool_name == "save_checkpoint":
   120→            return await self._handle_save_checkpoint(args, context)
   121→
   122→        if tool_name == "read_session_context":
   123→            return await self._handle_read_session_context(args, context)
   124→
   125→        if tool_name == "add_finding":
   126→            return await self._handle_add_finding(args, context)
   127→
   128→        if tool_name == "complete_session":
   129→            return await self._handle_complete_session(args, context)
   130→
   131→        # ═══════════════════════════════════════════════════════════════
   132→        # 通用工具执行
   133→        # ═══════════════════════════════════════════════════════════════
   134→
   135→        if ToolRegistry.has_handler(tool_name):
   136→            result = await ToolRegistry.execute(tool_name, args, context)
   137→
   138→            # 判断是否需要保存 checkpoint
   139→            should_checkpoint = tool_name in self.CHECKPOINT_TOOLS
   140→            checkpoint_data = None
   141→
   142→            if tool_name in self.COLLECT_TOOLS and result.get("status") == "success":
   143→                # 收集工具的数据需要累积
   144→                checkpoint_data = {
   145→                    "tool": tool_name,
   146→                    "data": result
   147→                }
   148→
   149→            return ToolResult(
   150→                data=result,
   151→                should_checkpoint=should_checkpoint,
   152→                checkpoint_data=checkpoint_data
   153→            )
   154→
   155→        # 未知工具
   156→        logger.warning(f"[ToolExecutor] Unknown tool: {tool_name}")
   157→        return ToolResult(
   158→            data={
   159→                "status": "unknown_tool",
   160→                "tool": tool_name,
   161→                "message": f"工具 {tool_name} 暂未实现"
   162→            }
   163→        )
   164→
   165→    async def _handle_activate_skill(
   166→        self,
   167→        args: Dict[str, Any],
   168→        context: ToolContext,
   169→        current_message: str,
   170→        reload_callback: Optional[Callable[[], Awaitable[None]]]
   171→    ) -> ToolResult:
   172→        """处理 activate_skill 工具"""
   173→        skill = args.get("skill")
   174→        rule = args.get("rule")
   175→
   176→        if not skill:
   177→            return ToolResult(
   178→                data={"status": "error", "message": "No skill specified"}
   179→            )
   180→
   181→        # 如果没有指定 rule，尝试自动匹配
   182→        if not rule and current_message:
   183→            rule = await self._route_rule(skill, current_message)
   184→            if rule:
   185→                logger.info(f"[ToolExecutor] Auto-routed rule: {rule}")
   186→
   187→        # 同步 skill 到数据库
   188→        if context.conversation_id:
   189→            try:
   190→                from stores.conversation_repo import update_conversation_skill
   191→                from uuid import UUID
   192→                conv_id = UUID(context.conversation_id)
   193→                await update_conversation_skill(conv_id, skill)
   194→            except Exception as e:
   195→                logger.warning(f"[ToolExecutor] Failed to sync skill to DB: {e}")
   196→
   197→        result = {
   198→            "status": "activated",
   199→            "skill": skill,
   200→            "rule": rule,
   201→            "message": f"已激活 {skill} 技能" + (f"，规则: {rule}" if rule else "")
   202→        }
   203→
   204→        # 触发上下文重载
   205→        if reload_callback:
   206→            await reload_callback()
   207→
   208→        return ToolResult(
   209→            data=result,
   210→            should_reload_context=True
   211→        )
   212→
   213→    async def _route_rule(self, skill_id: str, message: str) -> Optional[str]:
   214→        """自动路由规则"""
   215→        skill = load_skill(skill_id)
   216→        if not skill:
   217→            return None
   218→
   219→        rules = get_skill_rules(skill_id)
   220→        if not rules:
   221→            return skill.default_scenario
   222→
   223→        # v10.1: 让 LLM 选择，这里返回 None
   224→        return None
   225→
   226→    async def _handle_show_protocol_invitation(
   227→        self,
   228→        args: Dict[str, Any],
   229→        context: ToolContext
   230→    ) -> ToolResult:
   231→        """处理 show_protocol_invitation 工具"""
   232→        protocol_id = args.get("protocol_id")
   233→
   234→        if not protocol_id:
   235→            return ToolResult(
   236→                data={"status": "error", "message": "No protocol_id specified"}
   237→            )
   238→
   239→        meta = get_protocol_meta(protocol_id) or {}
   240→
   241→        return ToolResult(
   242→            data={
   243→                "status": "success",
   244→                "card_type": "protocol_invitation",
   245→                "protocol_id": protocol_id,
   246→                "title": meta.get("name", protocol_id),
   247→                "description": meta.get("description", ""),
   248→                "estimated_time": meta.get("estimated_time", "10分钟"),
   249→                "total_steps": meta.get("total_steps", 6),
   250→            }
   251→        )
   252→
   253→    async def _handle_show_skill_intro(
   254→        self,
   255→        args: Dict[str, Any],
   256→        context: ToolContext
   257→    ) -> ToolResult:
   258→        """处理 show_skill_intro 工具"""
   259→        skill_id = args.get("skill")
   260→        reason = args.get("reason", "功能介绍")
   261→
   262→        if not skill_id:
   263→            return ToolResult(
   264→                data={"status": "error", "message": "No skill specified"}
   265→            )
   266→
   267→        skill = load_skill(skill_id)
   268→        if not skill:
   269→            return ToolResult(
   270→                data={"status": "error", "message": f"Skill {skill_id} not found"}
   271→            )
   272→
   273→        return ToolResult(
   274→            data={
   275→                "status": "success",
   276→                "card_type": "skill_intro",
   277→                "skill_id": skill_id,
   278→                "name": skill.name,
   279→                "description": skill.description,
   280→                "triggers": skill.triggers[:5] if skill.triggers else [],
   281→                "reason": reason,
   282→                "action": {
   283→                    "type": "activate_skill",
   284→                    "skill": skill_id,
   285→                    "label": "开始使用"
   286→                }
   287→            }
   288→        )
   289→
   290→    async def _handle_recommend_skills(
   291→        self,
   292→        args: Dict[str, Any],
   293→        context: ToolContext
   294→    ) -> ToolResult:
   295→        """处理 recommend_skills 工具"""
   296→        skills = args.get("skills", [])
   297→        reason = args.get("reason", "")
   298→
   299→        if not skills:
   300→            return ToolResult(
   301→                data={"status": "error", "message": "No skills specified"}
   302→            )
   303→
   304→        skill_infos = []
   305→        for skill_id in skills:
   306→            skill = load_skill(skill_id)
   307→            if skill:
   308→                desc = skill.description
   309→                if "触发词" in desc:
   310→                    desc = desc.split("触发词")[0].strip().rstrip("。")
   311→                skill_infos.append({
   312→                    "id": skill_id,
   313→                    "name": skill.name,
   314→                    "description": desc[:100] if len(desc) > 100 else desc,
   315→                    "icon": skill.icon if hasattr(skill, 'icon') else None,
   316→                    "action": {
   317→                        "type": "activate_skill",
   318→                        "skill": skill_id
   319→                    }
   320→                })
   321→
   322→        return ToolResult(
   323→            data={
   324→                "status": "success",
   325→                "card_type": "skill_recommendations",
   326→                "skills": skill_infos,
   327→                "reason": reason,
   328→            }
   329→        )
   330→
   331→    async def _handle_save_checkpoint(
   332→        self,
   333→        args: Dict[str, Any],
   334→        context: ToolContext
   335→    ) -> ToolResult:
   336→        """处理 save_checkpoint 工具（v10 新增）"""
   337→        step = args.get("step", 0)
   338→        phase = args.get("phase")
   339→        collected_data = args.get("collected_data", {})
   340→
   341→        if not context.user_id or context.user_id == "guest":
   342→            return ToolResult(
   343→                data={"status": "error", "message": "需要登录才能保存进度"}
   344→            )
   345→
   346→        if not context.skill_id:
   347→            return ToolResult(
   348→                data={"status": "error", "message": "No active skill"}
   349→            )
   350→
   351→        await self.context_manager.save_checkpoint(
   352→            user_id=context.user_id,
   353→            skill_id=context.skill_id,
   354→            step=step,
   355→            phase=phase,
   356→            collected_data=collected_data
   357→        )
   358→
   359→        return ToolResult(
   360→            data={
   361→                "status": "success",
   362→                "message": f"进度已保存：第 {step} 步",
   363→                "step": step,
   364→                "skill_id": context.skill_id
   365→            },
   366→            should_checkpoint=False  # 已经保存了
   367→        )
   368→
   369→    async def _handle_read_session_context(
   370→        self,
   371→        args: Dict[str, Any],
   372→        context: ToolContext
   373→    ) -> ToolResult:
   374→        """处理 read_session_context 工具（v10 新增）"""
   375→        if not context.user_id or context.user_id == "guest":
   376→            return ToolResult(
   377→                data={"status": "error", "message": "需要登录才能读取会话"}
   378→            )
   379→
   380→        if not context.skill_id:
   381→            return ToolResult(
   382→                data={"status": "error", "message": "No active skill"}
   383→            )
   384→
   385→        session_context = await self.context_manager.load_session_context(
   386→            user_id=context.user_id,
   387→            skill_id=context.skill_id
   388→        )
   389→
   390→        result = {
   391→            "status": "success",
   392→            "has_checkpoint": session_context.has_checkpoint,
   393→            "skill_id": session_context.skill_id,
   394→            "rule_id": session_context.rule_id,
   395→        }
   396→
   397→        if session_context.session:
   398→            result["session"] = session_context.session.to_dict()
   399→
   400→        if session_context.checkpoint:
   401→            result["checkpoint"] = session_context.checkpoint.to_dict()
   402→
   403→        if session_context.findings:
   404→            result["findings"] = [f.to_dict() for f in session_context.findings[-5:]]
   405→
   406→        return ToolResult(data=result)
   407→
   408→    async def _handle_add_finding(
   409→        self,
   410→        args: Dict[str, Any],
   411→        context: ToolContext
   412→    ) -> ToolResult:
   413→        """处理 add_finding 工具（v10 新增）"""
   414→        finding_type = args.get("type", "insight")
   415→        content = args.get("content", "")
   416→
   417→        if not content:
   418→            return ToolResult(
   419→                data={"status": "error", "message": "content 不能为空"}
   420→            )
   421→
   422→        if not context.user_id or context.user_id == "guest":
   423→            return ToolResult(
   424→                data={"status": "error", "message": "需要登录才能记录发现"}
   425→            )
   426→
   427→        if not context.skill_id:
   428→            return ToolResult(
   429→                data={"status": "error", "message": "No active skill"}
   430→            )
   431→
   432→        await self.context_manager.add_finding(
   433→            user_id=context.user_id,
   434→            skill_id=context.skill_id,
   435→            finding_type=finding_type,
   436→            content=content,
   437→            rule_id=context.scenario_id
   438→        )
   439→
   440→        return ToolResult(
   441→            data={
   442→                "status": "success",
   443→                "message": f"已记录发现：[{finding_type}] {content[:50]}...",
   444→                "type": finding_type
   445→            }
   446→        )
   447→
   448→    async def _handle_complete_session(
   449→        self,
   450→        args: Dict[str, Any],
   451→        context: ToolContext
   452→    ) -> ToolResult:
   453→        """处理 complete_session 工具（v10 新增）"""
   454→        summary = args.get("summary", "")
   455→
   456→        if not context.user_id or context.user_id == "guest":
   457→            return ToolResult(
   458→                data={"status": "error", "message": "需要登录才能完成会话"}
   459→            )
   460→
   461→        if not context.skill_id:
   462→            return ToolResult(
   463→                data={"status": "error", "message": "No active skill"}
   464→            )
   465→
   466→        await self.context_manager.complete_session(
   467→            user_id=context.user_id,
   468→            skill_id=context.skill_id,
   469→            summary=summary
   470→        )
   471→
   472→        return ToolResult(
   473→            data={
   474→                "status": "success",
   475→                "message": "会话已完成",
   476→                "skill_id": context.skill_id,
   477→                "summary": summary
   478→            }
   479→        )
   480→
   481→
   482→# ═══════════════════════════════════════════════════════════════════════════
   483→# Singleton
   484→# ═══════════════════════════════════════════════════════════════════════════
   485→
   486→_tool_executor: Optional[ToolExecutor] = None
   487→
   488→
   489→def get_tool_executor() -> ToolExecutor:
   490→    """获取 ToolExecutor 单例"""
   491→    global _tool_executor
   492→    if _tool_executor is None:
   493→        _tool_executor = ToolExecutor()
   494→    return _tool_executor
   495→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
