{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":"探索 VibeLife 项目的 Agent/Skill 路由机制。\n\n重点查找：\n1. apps/api/services/agent/ 目录下的核心文件\n2. skill_loader.py - 技能加载机制\n3. 当用户提问时，系统如何决定使用哪个 skill（如 bazi, jungastro 等）\n4. prompt_builder.py - 提示词构建逻辑\n\n返回 skill 路由的完整流程，以及当用户问\"我的生日是哪天\"时，系统是如何路由到正确的 skill 的。"},"uuid":"24484597-eb6b-4730-b781-7375272d3a5c","timestamp":"2026-01-25T03:27:06.885Z"}
{"parentUuid":"24484597-eb6b-4730-b781-7375272d3a5c","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FydTdXf22syiZQV8N9VeXn","type":"message","role":"assistant","content":[{"type":"text","text":"我来探索 VibeLife 项目的 Agent/Skill 路由机制。让我系统地查找相关文件。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":31033,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":31033,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CXTPGDVmSor3YNZ9p2bfW","type":"assistant","uuid":"7dca2ca1-a0a0-415c-98e8-500c2732c85c","timestamp":"2026-01-25T03:27:10.087Z"}
{"parentUuid":"7dca2ca1-a0a0-415c-98e8-500c2732c85c","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FydTdXf22syiZQV8N9VeXn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015rKJXZZ11g7RujgjCPTuFb","name":"Glob","input":{"pattern":"/home/aiscend/work/vibelife/apps/api/services/agent/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":31033,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":31033,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CXTPGDVmSor3YNZ9p2bfW","type":"assistant","uuid":"8421ec7a-25bc-423e-9ac1-43fef47d2859","timestamp":"2026-01-25T03:27:10.359Z"}
{"parentUuid":"8421ec7a-25bc-423e-9ac1-43fef47d2859","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FydTdXf22syiZQV8N9VeXn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RENXoxnN6u4v5jxuDtwNUQ","name":"Glob","input":{"pattern":"/home/aiscend/work/vibelife/apps/api/skills/**/SKILL.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":31033,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":31033,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CXTPGDVmSor3YNZ9p2bfW","type":"assistant","uuid":"8831f5b6-5452-43e1-891c-565cc81c6d52","timestamp":"2026-01-25T03:27:10.607Z"}
{"parentUuid":"8831f5b6-5452-43e1-891c-565cc81c6d52","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FydTdXf22syiZQV8N9VeXn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HzkNgj4kK3Dz552THJf7Zd","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":31033,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":31033,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CXTPGDVmSor3YNZ9p2bfW","type":"assistant","uuid":"c7c2dcff-4298-47a9-a904-7dfea0c7ca29","timestamp":"2026-01-25T03:27:10.794Z"}
{"parentUuid":"c7c2dcff-4298-47a9-a904-7dfea0c7ca29","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"EISDIR: illegal operation on a directory, read","is_error":true,"tool_use_id":"toolu_01HzkNgj4kK3Dz552THJf7Zd"}]},"uuid":"694f039a-03d3-40be-a8b6-7e219945a52d","timestamp":"2026-01-25T03:27:11.029Z","toolUseResult":"Error: EISDIR: illegal operation on a directory, read","sourceToolAssistantUUID":"c7c2dcff-4298-47a9-a904-7dfea0c7ca29"}
{"parentUuid":"8831f5b6-5452-43e1-891c-565cc81c6d52","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RENXoxnN6u4v5jxuDtwNUQ","type":"tool_result","content":"/home/aiscend/work/vibelife/apps/api/skills/tarot/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/career/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/mindfulness/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/bazi/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/zodiac/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/psych/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/vibe_id/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/jungastro/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/synastry/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/core/SKILL.md\n/home/aiscend/work/vibelife/apps/api/skills/lifecoach/SKILL.md"}]},"uuid":"b51124ef-fafe-4b39-a19e-965b8f8c35b2","timestamp":"2026-01-25T03:27:11.669Z","sourceToolAssistantUUID":"8831f5b6-5452-43e1-891c-565cc81c6d52"}
{"parentUuid":"b51124ef-fafe-4b39-a19e-965b8f8c35b2","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Glob","command":"callback"},"parentToolUseID":"toolu_01RENXoxnN6u4v5jxuDtwNUQ","toolUseID":"toolu_01RENXoxnN6u4v5jxuDtwNUQ","timestamp":"2026-01-25T03:27:11.681Z","uuid":"e34e9e5e-18cb-4e7e-a4c6-bb65398183a9"}
{"parentUuid":"8421ec7a-25bc-423e-9ac1-43fef47d2859","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015rKJXZZ11g7RujgjCPTuFb","type":"tool_result","content":"/home/aiscend/work/vibelife/apps/api/services/agent/skill_service_registry.py\n/home/aiscend/work/vibelife/apps/api/services/agent/skill_validator.py\n/home/aiscend/work/vibelife/apps/api/services/agent/global_handlers.py\n/home/aiscend/work/vibelife/apps/api/services/agent/tool_schema.py\n/home/aiscend/work/vibelife/apps/api/services/agent/context_manager.py\n/home/aiscend/work/vibelife/apps/api/services/agent/prompt_builder.py\n/home/aiscend/work/vibelife/apps/api/services/agent/tool_registry.py\n/home/aiscend/work/vibelife/apps/api/services/agent/validators.py\n/home/aiscend/work/vibelife/apps/api/services/agent/schemas/cards.py\n/home/aiscend/work/vibelife/apps/api/services/agent/__init__.py\n/home/aiscend/work/vibelife/apps/api/services/agent/tool_executor.py\n/home/aiscend/work/vibelife/apps/api/services/agent/stream_adapter.py\n/home/aiscend/work/vibelife/apps/api/services/agent/skill_loader.py\n/home/aiscend/work/vibelife/apps/api/services/agent/case_index.py\n/home/aiscend/work/vibelife/apps/api/services/agent/session_manager.py\n/home/aiscend/work/vibelife/apps/api/services/agent/access_control.py\n/home/aiscend/work/vibelife/apps/api/services/agent/core.py"}]},"uuid":"7ba685cf-a3c9-4ff8-99c7-724c3eb12628","timestamp":"2026-01-25T03:27:11.799Z","sourceToolAssistantUUID":"8421ec7a-25bc-423e-9ac1-43fef47d2859"}
{"parentUuid":"7ba685cf-a3c9-4ff8-99c7-724c3eb12628","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Glob","command":"callback"},"parentToolUseID":"toolu_015rKJXZZ11g7RujgjCPTuFb","toolUseID":"toolu_015rKJXZZ11g7RujgjCPTuFb","timestamp":"2026-01-25T03:27:11.819Z","uuid":"967258f3-283a-41f4-8ffb-83e4c2e096e0"}
{"parentUuid":"967258f3-283a-41f4-8ffb-83e4c2e096e0","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JBR1YNPcAy3dHAzC58KByf","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我读取核心文件来理解路由机制："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":364,"cache_creation_input_tokens":994,"cache_read_input_tokens":31033,"cache_creation":{"ephemeral_5m_input_tokens":994,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPGau8aNPCum4mttUMd","type":"assistant","uuid":"8fe2b18d-6361-4c15-a97b-773bf55db759","timestamp":"2026-01-25T03:27:14.382Z"}
{"parentUuid":"8fe2b18d-6361-4c15-a97b-773bf55db759","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JBR1YNPcAy3dHAzC58KByf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HBVL1DswZz4end6utSXSxs","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/skill_loader.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":364,"cache_creation_input_tokens":994,"cache_read_input_tokens":31033,"cache_creation":{"ephemeral_5m_input_tokens":994,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPGau8aNPCum4mttUMd","type":"assistant","uuid":"a5426cad-4604-4bbb-af60-9ecb268005e8","timestamp":"2026-01-25T03:27:14.687Z"}
{"parentUuid":"a5426cad-4604-4bbb-af60-9ecb268005e8","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JBR1YNPcAy3dHAzC58KByf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nrqynd1Hx4Hm1MXMUiVdHx","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/prompt_builder.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":364,"cache_creation_input_tokens":994,"cache_read_input_tokens":31033,"cache_creation":{"ephemeral_5m_input_tokens":994,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPGau8aNPCum4mttUMd","type":"assistant","uuid":"57eb7a1a-d467-4862-8e3d-46a8b20d3efb","timestamp":"2026-01-25T03:27:14.889Z"}
{"parentUuid":"57eb7a1a-d467-4862-8e3d-46a8b20d3efb","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JBR1YNPcAy3dHAzC58KByf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TRK1rhpMaTQwAPoBBvjoEz","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/core.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":364,"cache_creation_input_tokens":994,"cache_read_input_tokens":31033,"cache_creation":{"ephemeral_5m_input_tokens":994,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPGau8aNPCum4mttUMd","type":"assistant","uuid":"46886d6a-8502-4d7d-9993-4e66e96087dc","timestamp":"2026-01-25T03:27:15.004Z"}
{"parentUuid":"46886d6a-8502-4d7d-9993-4e66e96087dc","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JBR1YNPcAy3dHAzC58KByf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012LFkVwkp6HE5UdzQqvWVde","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/tool_registry.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":364,"cache_creation_input_tokens":994,"cache_read_input_tokens":31033,"cache_creation":{"ephemeral_5m_input_tokens":994,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPGau8aNPCum4mttUMd","type":"assistant","uuid":"223885b9-05c4-4b60-b3f6-63aacd364307","timestamp":"2026-01-25T03:27:15.252Z"}
{"parentUuid":"57eb7a1a-d467-4862-8e3d-46a8b20d3efb","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nrqynd1Hx4Hm1MXMUiVdHx","type":"tool_result","content":"     1→\"\"\"\n     2→Prompt Builder v10 - System Prompt 构建\n     3→\n     4→从 core.py 拆分出来的 Prompt 构建逻辑，支持：\n     5→- Phase 1/Phase 2 分阶段 Prompt\n     6→- 会话恢复 Prompt（断点续传）\n     7→- SOP 规则注入\n     8→- 案例匹配\n     9→\n    10→与 ContextManager 协作：\n    11→- 读取会话上下文\n    12→- 注入断点信息\n    13→\"\"\"\n    14→import json\n    15→import logging\n    16→from typing import Optional, Dict, Any, List\n    17→\n    18→from .skill_loader import (\n    19→    load_skill, build_system_prompt,\n    20→    skill_requires_birth_info, skill_requires_compute,\n    21→    get_skill_compute_type, get_skill_compute_tool, get_skill_collect_tool,\n    22→    get_skill_required_data\n    23→)\n    24→# 简化：仅保留 inject_placeholders 的最小实现以兼容调用\n    25→def inject_placeholders(template: str, context: Optional[Dict[str, Any]] = None) -> str:\n    26→    if not template:\n    27→        return template\n    28→    replacements = dict(context or {})\n    29→    result = template\n    30→    for k, v in replacements.items():\n    31→        result = result.replace(\"{\" + k + \"}\", str(v))\n    32→    return result\n    33→from .context_manager import SessionContext\n    34→\n    35→logger = logging.getLogger(__name__)\n    36→\n    37→\n    38→class PromptBuilder:\n    39→    \"\"\"\n    40→    System Prompt 构建器\n    41→\n    42→    职责：\n    43→    1. 根据 Phase 构建不同的 Prompt\n    44→    2. 注入会话恢复上下文\n    45→    3. 注入 SOP 规则\n    46→    4. 动态加载案例\n    47→    5. v10.1: 用户画像注入（让 Coach 了解用户）\n    48→    \"\"\"\n    49→\n    50→    # 需要详细用户画像的 Skill（注入 goals, patterns, findings）\n    51→    PORTRAIT_FULL_SKILLS = {\"lifecoach\", \"career\"}\n    52→\n    53→    # 需要出生信息的 Skill\n    54→    BIRTH_INFO_SKILLS = {\"bazi\", \"zodiac\", \"jungastro\"}\n    55→\n    56→    def __init__(self):\n    57→        self.case_index = None  # Lazy init\n    58→\n    59→    async def build(\n    60→        self,\n    61→        skill_id: Optional[str],\n    62→        rule_id: Optional[str],\n    63→        message: str,\n    64→        profile: Optional[Dict[str, Any]] = None,\n    65→        skill_data: Optional[Dict[str, Any]] = None,\n    66→        session_context: Optional[SessionContext] = None,\n    67→        protocol_prompt: Optional[str] = None\n    68→    ) -> str:\n    69→        \"\"\"\n    70→        构建 System Prompt\n    71→\n    72→        Args:\n    73→            skill_id: 当前技能 ID\n    74→            rule_id: 当前规则 ID\n    75→            message: 用户消息\n    76→            profile: 用户 Profile\n    77→            skill_data: Skill 数据\n    78→            session_context: 会话上下文（断点续传）\n    79→            protocol_prompt: 协议专用 Prompt（可选）\n    80→\n    81→        Returns:\n    82→            完整的 System Prompt\n    83→        \"\"\"\n    84→        parts = []\n    85→\n    86→        # ═══════════════════════════════════════════════════════════════\n    87→        # 协议模式：使用协议专用 Prompt\n    88→        # ═══════════════════════════════════════════════════════════════\n    89→        if protocol_prompt:\n    90→            skill = load_skill(\"lifecoach\")\n    91→            if skill:\n    92→                parts.append(f\"# {skill.name}\\n\\n{skill.expert_persona}\")\n    93→            parts.append(\"\\n---\\n\")\n    94→            parts.append(protocol_prompt)\n    95→            return \"\\n\".join(parts)\n    96→\n    97→        if skill_id:\n    98→            # ═══════════════════════════════════════════════════════════════\n    99→            # Phase 2: Skill 执行阶段 - 完整上下文\n   100→            # ═══════════════════════════════════════════════════════════════\n   101→\n   102→            # 基础 Skill Prompt\n   103→            user_ctx = dict(profile) if profile else {}\n   104→            base_prompt = build_system_prompt(skill_id, rule_id, user_ctx)\n   105→            parts.append(base_prompt)\n   106→\n   107→            # ═══════════════════════════════════════════════════════════════\n   108→            # Profile 注入（简化版 v2.2）- 两层架构\n   109→            # ═══════════════════════════════════════════════════════════════\n   110→            profile_context = self._build_profile_context(profile, skill_data, skill_id)\n   111→            if profile_context:\n   112→                parts.append(profile_context)\n   113→\n   114→            # 会话恢复上下文（断点续传核心）\n   115→            if session_context and session_context.has_checkpoint:\n   116→                resume_context = session_context.to_prompt_context()\n   117→                if resume_context:\n   118→                    parts.append(resume_context)\n   119→\n   120→            # SOP 规则\n   121→            sop_rules = self._build_sop_rules(skill_id, profile, skill_data)\n   122→            if sop_rules:\n   123→                parts.append(sop_rules)\n   124→\n   125→            # 案例匹配\n   126→            cases_text = await self._match_cases(skill_id, skill_data)\n   127→            if cases_text:\n   128→                parts.append(cases_text)\n   129→\n   130→        else:\n   131→            # ═══════════════════════════════════════════════════════════════\n   132→            # Phase 1: Skill 选择阶段 - v11 个性化路由\n   133→            # ═══════════════════════════════════════════════════════════════\n   134→\n   135→            # LLM-First: 构建最小 Phase 1 提示（不依赖 routing.yaml）\n   136→            from .skill_loader import build_phase1_prompt\n   137→            core_prompt = build_phase1_prompt()\n   138→            # 注入用户画像和订阅信息（用于个性化路由）\n   139→            if profile:\n   140→                core_prompt = self._inject_phase1_context(core_prompt, profile)\n   141→            parts.append(core_prompt)\n   142→\n   143→        return \"\\n\".join(parts)\n   144→\n   145→    def _build_profile_context(\n   146→        self,\n   147→        profile: Optional[Dict[str, Any]],\n   148→        skill_data: Optional[Dict[str, Any]],\n   149→        skill_id: str\n   150→    ) -> str:\n   151→        \"\"\"\n   152→        构建 Profile 上下文（v3.0 三层架构）\n   153→\n   154→        三层架构：\n   155→        - Layer 1: Identity（共享）- 基本信息\n   156→        - Layer 2: Skills（当前 Skill 专属）- skills.{skill_id}\n   157→        - Layer 3: Vibe（共享深度信息）- vibe.insight + vibe.target\n   158→        \"\"\"\n   159→        parts = []\n   160→\n   161→        # ═══════════════════════════════════════════════════════════════\n   162→        # Layer 1: Identity（所有 Skill 共享，~200 tokens）\n   163→        # ═══════════════════════════════════════════════════════════════\n   164→        if profile:\n   165→            identity = profile.get(\"identity\", {})\n   166→\n   167→            base_info = []\n   168→\n   169→            # 用户名\n   170→            name = identity.get(\"display_name\")\n   171→            if name:\n   172→                base_info.append(f\"- 用户名：{name}\")\n   173→\n   174→            # 出生信息（如有）\n   175→            birth = identity.get(\"birth_info\", {})\n   176→            if birth:\n   177→                birth_date = birth.get(\"birth_date\") or birth.get(\"date\")\n   178→                if birth_date:\n   179→                    base_info.append(f\"- 出生日期：{birth_date}\")\n   180→                birth_time = birth.get(\"birth_time\") or birth.get(\"time\")\n   181→                if birth_time:\n   182→                    base_info.append(f\"- 出生时间：{birth_time}\")\n   183→                birth_place = birth.get(\"birth_place\") or birth.get(\"location\")\n   184→                if birth_place:\n   185→                    base_info.append(f\"- 出生地点：{birth_place}\")\n   186→\n   187→            if base_info:\n   188→                parts.append(\"## 用户信息\\n\\n\" + \"\\n\".join(base_info))\n   189→\n   190→        # ═══════════════════════════════════════════════════════════════\n   191→        # Layer 2: Skills（当前 Skill 专属，~300 tokens）\n   192→        # ═══════════════════════════════════════════════════════════════\n   193→        if skill_data:\n   194→            # 获取该 Skill 需要的 skill_data（从 SKILL.md 配置读取）\n   195→            skill_ids = get_skill_required_data(skill_id)\n   196→\n   197→            for sid in skill_ids:\n   198→                data = skill_data.get(sid, {})\n   199→                if data:\n   200→                    # 过滤掉内部字段（以 _ 开头）\n   201→                    filtered_data = {k: v for k, v in data.items() if not k.startswith(\"_\")}\n   202→                    if filtered_data:\n   203→                        parts.append(f\"\\n## {sid} 数据\\n\\n```json\\n{json.dumps(filtered_data, ensure_ascii=False, indent=2)}\\n```\")\n   204→\n   205→        # ═══════════════════════════════════════════════════════════════\n   206→        # Layer 3: Vibe（共享深度信息，~200 tokens）\n   207→        # ═══════════════════════════════════════════════════════════════\n   208→        if profile:\n   209→            vibe = profile.get(\"vibe\", {})\n   210→\n   211→            # VibeInsight - 我是谁\n   212→            insight = vibe.get(\"insight\", {})\n   213→            if insight:\n   214→                insight_parts = []\n   215→\n   216→                # 本质\n   217→                essence = insight.get(\"essence\", {})\n   218→                if essence:\n   219→                    archetype = essence.get(\"archetype\", {})\n   220→                    if archetype.get(\"primary\"):\n   221→                        insight_parts.append(f\"- 主要原型：{archetype['primary']}\")\n   222→                    traits = essence.get(\"traits\", [])\n   223→                    if traits:\n   224→                        trait_text = \", \".join([t.get(\"trait\", str(t)) if isinstance(t, dict) else str(t) for t in traits[:3]])\n   225→                        insight_parts.append(f\"- 核心特质：{trait_text}\")\n   226→\n   227→                # 动态\n   228→                dynamic = insight.get(\"dynamic\", {})\n   229→                if dynamic:\n   230→                    emotion = dynamic.get(\"emotion\", {})\n   231→                    if emotion.get(\"current\"):\n   232→                        insight_parts.append(f\"- 当前情绪：{emotion['current']}\")\n   233→                    energy = dynamic.get(\"energy\", {})\n   234→                    if energy.get(\"level\"):\n   235→                        insight_parts.append(f\"- 能量水平：{energy['level']}\")\n   236→\n   237→                # 规律\n   238→                pattern = insight.get(\"pattern\", {})\n   239→                if pattern:\n   240→                    insights_list = pattern.get(\"insights\", [])\n   241→                    if insights_list:\n   242→                        insight_parts.append(f\"- 洞察：{insights_list[0]}\")\n   243→\n   244→                if insight_parts:\n   245→                    parts.append(\"\\n## 用户画像\\n\\n\" + \"\\n\".join(insight_parts))\n   246→\n   247→            # VibeTarget - 我要成为谁\n   248→            target = vibe.get(\"target\", {})\n   249→            if target:\n   250→                target_parts = []\n   251→\n   252→                # 北极星\n   253→                north_star = target.get(\"north_star\", {})\n   254→                if north_star.get(\"vision_scene\"):\n   255→                    vision = north_star[\"vision_scene\"]\n   256→                    if len(vision) > 100:\n   257→                        vision = vision[:100] + \"...\"\n   258→                    target_parts.append(f\"- 愿景：{vision}\")\n   259→\n   260→                # 目标\n   261→                goals = target.get(\"goals\", [])\n   262→                if goals:\n   263→                    active_goals = [g for g in goals if g.get(\"status\") == \"in_progress\"][:2]\n   264→                    if active_goals:\n   265→                        goals_text = \", \".join([g.get(\"title\", \"\") for g in active_goals])\n   266→                        target_parts.append(f\"- 当前目标：{goals_text}\")\n   267→\n   268→                # 聚焦\n   269→                focus = target.get(\"focus\", {})\n   270→                if focus.get(\"primary\"):\n   271→                    target_parts.append(f\"- 关注领域：{focus['primary']}\")\n   272→\n   273→                if target_parts:\n   274→                    parts.append(\"\\n## 用户目标\\n\\n\" + \"\\n\".join(target_parts))\n   275→\n   276→        return \"\\n\".join(parts) if parts else \"\"\n   277→\n   278→    def _build_sop_rules(\n   279→        self,\n   280→        skill_id: str,\n   281→        profile: Optional[Dict[str, Any]],\n   282→        skill_data: Optional[Dict[str, Any]]\n   283→    ) -> str:\n   284→        \"\"\"\n   285→        构建 SOP 规则（自然语言版）\n   286→\n   287→        根据当前状态生成教练式指导。\n   288→        \"\"\"\n   289→        needs_birth = skill_requires_birth_info(skill_id)\n   290→        needs_compute = skill_requires_compute(skill_id)\n   291→\n   292→        # 计算当前状态\n   293→        status = self._compute_status(skill_id, profile, skill_data)\n   294→\n   295→        # 如果已经可以分析，使用简洁的状态提示\n   296→        if status[\"ready_for_analysis\"]:\n   297→            return self._get_ready_prompt()\n   298→\n   299→        rules_parts = []\n   300→\n   301→        # P1: 需要收集信息\n   302→        if needs_birth and not status[\"has_birth_info\"]:\n   303→            collect_tool = get_skill_collect_tool(skill_id) or \"request_info\"\n   304→            rules_parts.append(self._get_need_birth_prompt(collect_tool))\n   305→\n   306→        # P2: 需要计算\n   307→        elif needs_compute and not status[\"has_chart_data\"]:\n   308→            compute_type = get_skill_compute_type(skill_id) or skill_id\n   309→            compute_tool = get_skill_compute_tool(skill_id) or f\"calculate_{compute_type}\"\n   310→\n   311→            rules_parts.append(self._get_need_compute_prompt(compute_tool))\n   312→\n   313→        return \"\\n\".join(rules_parts)\n   314→\n   315→    def _compute_status(\n   316→        self,\n   317→        skill_id: str,\n   318→        profile: Optional[Dict[str, Any]],\n   319→        skill_data: Optional[Dict[str, Any]]\n   320→    ) -> Dict[str, Any]:\n   321→        \"\"\"计算当前 SOP 状态\"\"\"\n   322→        needs_birth = skill_requires_birth_info(skill_id)\n   323→        needs_compute = skill_requires_compute(skill_id)\n   324→\n   325→        # 检查出生信息\n   326→        has_birth = False\n   327→        if profile:\n   328→            identity = profile.get(\"identity\", {})\n   329→            birth_info = identity.get(\"birth_info\", {})\n   330→            has_birth = bool(birth_info.get(\"birth_date\") or birth_info.get(\"date\"))\n   331→\n   332→        # 检查命盘数据\n   333→        has_chart = False\n   334→        if skill_data:\n   335→            compute_type = get_skill_compute_type(skill_id) or skill_id\n   336→            data = skill_data.get(compute_type, {})\n   337→            has_chart = bool(data.get(\"chart\") or data.get(\"cards\"))\n   338→\n   339→        return {\n   340→            \"skill_id\": skill_id,\n   341→            \"needs_birth_info\": needs_birth,\n   342→            \"has_birth_info\": has_birth,\n   343→            \"needs_compute\": needs_compute,\n   344→            \"has_chart_data\": has_chart,\n   345→            \"ready_for_analysis\": (not needs_birth or has_birth) and (not needs_compute or has_chart)\n   346→        }\n   347→\n   348→    def _extract_chart_summary(\n   349→        self,\n   350→        skill_id: str,\n   351→        skill_data: Optional[Dict[str, Any]]\n   352→    ) -> str:\n   353→        \"\"\"从命盘数据中提取关键摘要\"\"\"\n   354→        if not skill_data:\n   355→            return \"无命盘数据\"\n   356→\n   357→        compute_type = get_skill_compute_type(skill_id) or skill_id\n   358→        data = skill_data.get(compute_type, {})\n   359→\n   360→        if not data:\n   361→            return \"无命盘数据\"\n   362→\n   363→        summary_parts = []\n   364→\n   365→        # 八字\n   366→        if compute_type == \"bazi\" and \"chart\" in data:\n   367→            chart = data[\"chart\"]\n   368→            if \"pillars\" in chart and len(chart[\"pillars\"]) > 2:\n   369→                day_pillar = chart[\"pillars\"][2]\n   370→                summary_parts.append(f\"日主{day_pillar.get('day_stem', '')}{day_pillar.get('day_branch', '')}\")\n   371→            if \"month_order\" in chart:\n   372→                summary_parts.append(f\"月令{chart['month_order']}\")\n   373→\n   374→        # 星盘\n   375→        elif compute_type == \"zodiac\" and \"chart\" in data:\n   376→            chart = data[\"chart\"]\n   377→            planets = chart.get(\"planets\", {})\n   378→            if \"sun\" in planets:\n   379→                summary_parts.append(f\"太阳{planets['sun'].get('sign', '')}\")\n   380→            if \"moon\" in planets:\n   381→                summary_parts.append(f\"月亮{planets['moon'].get('sign', '')}\")\n   382→\n   383→        # 塔罗\n   384→        elif compute_type == \"tarot\" and \"cards\" in data:\n   385→            cards = data[\"cards\"]\n   386→            if isinstance(cards, list) and len(cards) > 0:\n   387→                summary_parts.append(f\"{len(cards)}张牌\")\n   388→\n   389→        if summary_parts:\n   390→            return \"、\".join(summary_parts)\n   391→        else:\n   392→            return \"已生成命盘\"\n   393→\n   394→    async def _match_cases(\n   395→        self,\n   396→        skill_id: str,\n   397→        skill_data: Optional[Dict[str, Any]]\n   398→    ) -> str:\n   399→        \"\"\"匹配相关案例\"\"\"\n   400→        if not skill_data:\n   401→            return \"\"\n   402→\n   403→        try:\n   404→            from .case_index import get_case_index, extract_features\n   405→\n   406→            if self.case_index is None:\n   407→                self.case_index = get_case_index()\n   408→\n   409→            features = extract_features(skill_data)\n   410→            if not features:\n   411→                return \"\"\n   412→\n   413→            cases = await self.case_index.get_matched_cases(skill_id, features, top_k=2)\n   414→            if not cases:\n   415→                return \"\"\n   416→\n   417→            cases_text = \"\\n## 相关案例\\n\\n\"\n   418→            for case in cases:\n   419→                cases_text += f\"### {case.name}\\n{case.content}\\n\\n\"\n   420→\n   421→            return cases_text\n   422→\n   423→        except Exception as e:\n   424→            logger.warning(f\"[PromptBuilder] Case matching failed: {e}\")\n   425→            return \"\"\n   426→\n   427→    # ═══════════════════════════════════════════════════════════════════════════\n   428→    # Phase 1 个性化路由 (v11 新增)\n   429→    # ═══════════════════════════════════════════════════════════════════════════\n   430→\n   431→    def _inject_phase1_context(self, prompt: str, profile: Dict[str, Any]) -> str:\n   432→        \"\"\"\n   433→        注入 Phase 1 上下文（v11 个性化路由）\n   434→\n   435→        将以下占位符替换为实际内容：\n   436→        - {user_portrait} - 用户画像\n   437→        - {subscribed_skills} - 已订阅服务\n   438→        - {recommendable_skills} - 可推荐服务\n   439→        - {personalization_hint} - 个性化提示\n   440→        - {boundary_rules_shared} - 能力边界规则 (v2.0)\n   441→        \"\"\"\n   442→        # v2.0: 注入能力边界规则\n   443→        prompt = inject_placeholders(prompt, {})\n   444→\n   445→        # 用户画像\n   446→        user_portrait = self._build_user_portrait(profile)\n   447→        prompt = prompt.replace(\"{user_portrait}\", user_portrait)\n   448→\n   449→        # 已订阅服务\n   450→        subscribed = profile.get(\"subscribed_skills\", [])\n   451→        subscribed_text = self._build_subscribed_skills_text(subscribed)\n   452→        prompt = prompt.replace(\"{subscribed_skills}\", subscribed_text)\n   453→\n   454→        # 可推荐服务\n   455→        recommendable_text = self._build_recommendable_skills_text(subscribed)\n   456→        prompt = prompt.replace(\"{recommendable_skills}\", recommendable_text)\n   457→\n   458→        # 个性化提示\n   459→        hint = self._build_personalization_hint(profile)\n   460→        prompt = prompt.replace(\"{personalization_hint}\", hint)\n   461→\n   462→        return prompt\n   463→\n   464→    def _build_user_portrait(self, profile: Dict[str, Any]) -> str:\n   465→        \"\"\"构建用户画像（~100 tokens）\"\"\"\n   466→        if not profile:\n   467→            return \"\"\n   468→\n   469→        lines = []\n   470→\n   471→        # 身份\n   472→        identity = profile.get(\"identity\", {})\n   473→        if identity.get(\"display_name\"):\n   474→            lines.append(f\"- 用户名：{identity['display_name']}\")\n   475→\n   476→        # v2.0: 出生信息（用于直接回答 Profile 查询）\n   477→        birth_info = identity.get(\"birth_info\", {})\n   478→        if birth_info:\n   479→            birth_date = birth_info.get(\"birth_date\") or birth_info.get(\"date\")\n   480→            if birth_date:\n   481→                lines.append(f\"- 出生日期：{birth_date}\")\n   482→            birth_time = birth_info.get(\"birth_time\") or birth_info.get(\"time\")\n   483→            if birth_time:\n   484→                lines.append(f\"- 出生时间：{birth_time}\")\n   485→            birth_place = birth_info.get(\"birth_place\") or birth_info.get(\"location\")\n   486→            if birth_place:\n   487→                lines.append(f\"- 出生地点：{birth_place}\")\n   488→\n   489→        # Vibe.insight（原型）\n   490→        vibe = profile.get(\"vibe\", {})\n   491→        insight = vibe.get(\"insight\", {})\n   492→        essence = insight.get(\"essence\", {})\n   493→\n   494→        archetype = essence.get(\"archetype\", {})\n   495→        if archetype.get(\"primary\"):\n   496→            lines.append(f\"- 原型：{archetype['primary']}\")\n   497→\n   498→        traits = essence.get(\"traits\", [])\n   499→        if traits:\n   500→            trait_names = [t.get(\"trait\", str(t)) if isinstance(t, dict) else str(t) for t in traits[:3]]\n   501→            lines.append(f\"- 特质：{', '.join(trait_names)}\")\n   502→\n   503→        # Vibe.target（关注领域）\n   504→        target = vibe.get(\"target\", {})\n   505→\n   506→        north_star = target.get(\"north_star\", {})\n   507→        if north_star.get(\"statement\"):\n   508→            statement = north_star[\"statement\"]\n   509→            if len(statement) > 50:\n   510→                statement = statement[:50] + \"...\"\n   511→            lines.append(f\"- 愿景：{statement}\")\n   512→\n   513→        focus = target.get(\"focus\", {})\n   514→        if focus.get(\"primary\"):\n   515→            lines.append(f\"- 关注：{focus['primary']}\")\n   516→\n   517→        if not lines:\n   518→            return \"\"\n   519→\n   520→        return \"## 用户画像\\n\\n\" + \"\\n\".join(lines)\n   521→\n   522→    def _build_subscribed_skills_text(self, subscribed: List[str]) -> str:\n   523→        \"\"\"构建已订阅服务列表（LLM-First，不依赖 routing.yaml）\"\"\"\n   524→        from .skill_loader import load_skill\n   525→\n   526→        if not subscribed:\n   527→            return \"用户暂未订阅任何服务。\"\n   528→\n   529→        lines = [\"用户已订阅的服务，可直接激活：\\n\"]\n   530→\n   531→        for skill_id in subscribed:\n   532→            skill = load_skill(skill_id)\n   533→            if skill:\n   534→                desc = (skill.description or \"\").strip().replace('\\n', ' ')\n   535→                if len(desc) > 30:\n   536→                    desc = desc[:30] + \"...\"\n   537→                lines.append(f\"- **{skill_id}**: {desc}\")\n   538→\n   539→        return \"\\n\".join(lines)\n   540→\n   541→    def _build_recommendable_skills_text(self, subscribed: List[str]) -> str:\n   542→        \"\"\"构建可推荐服务列表（LLM-First，不依赖 routing.yaml）\"\"\"\n   543→        from .skill_loader import load_skill, get_available_skills\n   544→\n   545→        all_skills = [s for s in get_available_skills() if s != \"core\"]\n   546→        not_subscribed = [s for s in all_skills if s not in subscribed]\n   547→\n   548→        if not not_subscribed:\n   549→            return \"用户已订阅所有服务。\"\n   550→\n   551→        lines = [\"用户未订阅但可能感兴趣：\\n\"]\n   552→\n   553→        for skill_id in not_subscribed[:4]:  # 最多显示 4 个\n   554→            skill = load_skill(skill_id)\n   555→            if skill:\n   556→                desc = (skill.description or \"\").strip().replace('\\n', ' ')\n   557→                if len(desc) > 30:\n   558→                    desc = desc[:30] + \"...\"\n   559→                lines.append(f\"- **{skill_id}**: {desc}\")\n   560→\n   561→        return \"\\n\".join(lines)\n   562→\n   563→    def _build_personalization_hint(self, profile: Dict[str, Any]) -> str:\n   564→        \"\"\"根据用户画像生成个性化路由提示\"\"\"\n   565→        if not profile:\n   566→            return \"\"\n   567→\n   568→        hints = []\n   569→\n   570→        vibe = profile.get(\"vibe\", {})\n   571→        target = vibe.get(\"target\", {})\n   572→        insight = vibe.get(\"insight\", {})\n   573→\n   574→        # 如果有北极星目标\n   575→        if target.get(\"north_star\", {}).get(\"vision_scene\"):\n   576→            hints.append(\"用户有明确的人生愿景，优先考虑 lifecoach\")\n   577→\n   578→        # 如果有关注领域\n   579→        focus = target.get(\"focus\", {}).get(\"primary\")\n   580→        if focus:\n   581→            if \"career\" in focus.lower() or \"职业\" in focus:\n   582→                hints.append(\"用户关注职业发展，优先考虑 career/lifecoach\")\n   583→            elif \"relationship\" in focus.lower() or \"关系\" in focus or \"感情\" in focus:\n   584→                hints.append(\"用户关注关系，适合 bazi/zodiac 合盘分析\")\n   585→            elif \"health\" in focus.lower() or \"健康\" in focus:\n   586→                hints.append(\"用户关注健康，适合 mindfulness\")\n   587→\n   588→        # 如果有原型\n   589→        archetype = insight.get(\"essence\", {}).get(\"archetype\", {}).get(\"primary\")\n   590→        if archetype:\n   591→            if archetype in [\"成长者\", \"探索者\"]:\n   592→                hints.append(f\"用户是{archetype}人格，适合规划类服务\")\n   593→            elif archetype in [\"智慧者\", \"洞察者\"]:\n   594→                hints.append(f\"用户是{archetype}人格，适合深度分析服务\")\n   595→            elif archetype in [\"稳定者\", \"守护者\"]:\n   596→                hints.append(f\"用户是{archetype}人格，适合陪伴类服务\")\n   597→\n   598→        if hints:\n   599→            return \"\\n## 个性化提示\\n\\n\" + \"\\n\".join(f\"- {h}\" for h in hints)\n   600→        return \"\"\n   601→\n   602→    def _get_fallback_phase1_prompt(self) -> str:\n   603→        \"\"\"Fallback Phase 1 Prompt\"\"\"\n   604→        return \"\"\"# Vibe\n   605→\n   606→你是 Vibe，生命对话者。你的任务是理解用户意图，引导 Ta 到合适的服务。\n   607→\n   608→## 行为准则\n   609→\n   610→1. **识别意图 → 调用工具**：不要只用文字回复，要调用工具\n   611→2. **简短回应 + 工具**：调用工具时配合一句暖心的话\n   612→3. **不确定 → 推荐**：调用 recommend_skills 让用户选择\n   613→\n   614→## 语气\n   615→\n   616→温暖、简洁、不啰嗦。像一个懂你的老朋友。\n   617→\n   618→示例：\n   619→- \"嗨～ 今天想聊点什么？\"\n   620→- \"好的，让我来帮你看看～\"\n   621→- \"迷茫的时候来找我就对了。\"\n   622→\"\"\"\n   623→\n   624→    def _get_ready_prompt(self) -> str:\n   625→        \"\"\"已准备好分析的 Prompt\"\"\"\n   626→        return \"\"\"## 当前状态\n   627→\n   628→用户信息已完整，命盘已生成。你可以开始分析了。\n   629→\n   630→**分析流程**：\n   631→1. 快速扫描命盘中的关键特征\n   632→2. 根据用户问题聚焦分析\n   633→3. 用 `show_xxx` 工具展示分析结果\n   634→4. 回答用户的追问\n   635→\"\"\"\n   636→\n   637→    def _get_need_birth_prompt(self, collect_tool: str) -> str:\n   638→        \"\"\"需要收集出生信息的 Prompt\"\"\"\n   639→        return f\"\"\"## 当前状态\n   640→\n   641→用户还没有告诉你出生信息。在深入分析之前，你需要先了解 Ta 的出生时间。\n   642→\n   643→**下一步**：调用 `{collect_tool}` 工具，让用户填写出生信息表单。\n   644→不要用文字问\"请问你的生日是？\"——表单体验更好。\n   645→\"\"\"\n   646→\n   647→    def _get_need_compute_prompt(self, compute_tool: str) -> str:\n   648→        \"\"\"需要计算的 Prompt\"\"\"\n   649→        return f\"\"\"## 当前状态\n   650→\n   651→用户已提供出生信息，但还没有生成命盘。\n   652→\n   653→**下一步**：调用 `{compute_tool}` 工具生成命盘数据。\n   654→计算完成后你就可以开始分析了。\n   655→\"\"\"\n   656→\n   657→    def build_session_resume_prompt(\n   658→        self,\n   659→        session_context: SessionContext,\n   660→        rule_name: Optional[str] = None\n   661→    ) -> str:\n   662→        \"\"\"\n   663→        构建会话恢复 Prompt（用于 SOP 模板）\n   664→\n   665→        专门用于断点续传场景\n   666→        \"\"\"\n   667→        if not session_context or not session_context.has_checkpoint:\n   668→            return \"\"\n   669→\n   670→        cp = session_context.checkpoint\n   671→        session = session_context.session\n   672→\n   673→        lines = [\"## 会话恢复模式\\n\"]\n   674→\n   675→        if cp:\n   676→            lines.append(f\"用户上次完成了 {cp.step} 个步骤。\\n\")\n   677→\n   678→            if cp.collected_data:\n   679→                lines.append(\"**已收集信息**：\")\n   680→                for key, value in cp.collected_data.items():\n   681→                    lines.append(f\"- {key}: {value}\")\n   682→                lines.append(\"\")\n   683→\n   684→            next_step = cp.step + 1\n   685→            lines.append(f\"**下一步**：\")\n   686→            lines.append(f\"继续第 {next_step} 个问题\\n\")\n   687→\n   688→        lines.append(\"**处理方式**：\")\n   689→        lines.append(\"1. 简短问候：「欢迎回来！上次我们聊到了...」\")\n   690→        lines.append(\"2. 快速回顾（1-2 句）\")\n   691→        lines.append(\"3. 直接问下一个问题\")\n   692→\n   693→        return \"\\n\".join(lines)\n   694→\n   695→\n   696→# ═══════════════════════════════════════════════════════════════════════════\n   697→# Singleton\n   698→# ═══════════════════════════════════════════════════════════════════════════\n   699→\n   700→_prompt_builder: Optional[PromptBuilder] = None\n   701→\n   702→\n   703→def get_prompt_builder() -> PromptBuilder:\n   704→    \"\"\"获取 PromptBuilder 单例\"\"\"\n   705→    global _prompt_builder\n   706→    if _prompt_builder is None:\n   707→        _prompt_builder = PromptBuilder()\n   708→    return _prompt_builder\n   709→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5382ac47-7567-4313-b7f0-681ea41d303d","timestamp":"2026-01-25T03:27:15.424Z","sourceToolAssistantUUID":"57eb7a1a-d467-4862-8e3d-46a8b20d3efb"}
{"parentUuid":"223885b9-05c4-4b60-b3f6-63aacd364307","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012LFkVwkp6HE5UdzQqvWVde","type":"tool_result","content":"     1→\"\"\"\n     2→Unified Tool Registry v6 - 统一工具注册表\n     3→\n     4→解决工具注册的硬编码问题：\n     5→1. 从 YAML 加载工具定义 (Single Source of Truth)\n     6→2. 使用 @tool_handler 装饰器动态注册执行器\n     7→3. 消除 if-elif 分发，使用注册表查找\n     8→\n     9→V6.1 更新：\n    10→- 全局工具从 skills/core/tools/ 加载\n    11→- 移除对 GLOBAL_TOOLS 硬编码的依赖\n    12→\n    13→新增工具只需修改 2 处：\n    14→1. skills/{skill_id}/tools/tools.yaml - 工具定义\n    15→2. skills/{skill_id}/tools/handlers.py - @tool_handler 执行器\n    16→\n    17→用法：\n    18→    from services.agent.tool_registry import tool_handler, ToolRegistry\n    19→\n    20→    @tool_handler(\"show_bazi_chart\")\n    21→    async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:\n    22→        return {\"chart\": ...}\n    23→\n    24→    # CoreAgent 中使用\n    25→    tools = ToolRegistry.get_tools_for_skill(\"bazi\")\n    26→    result = await ToolRegistry.execute(\"show_bazi_chart\", args, context)\n    27→\"\"\"\n    28→import logging\n    29→import importlib\n    30→import asyncio\n    31→from pathlib import Path\n    32→from typing import Dict, Any, List, Optional, Callable, Awaitable, Union\n    33→from dataclasses import dataclass, field\n    34→from functools import wraps\n    35→\n    36→from .tool_schema import ToolDef, load_skill_tools, get_global_tools\n    37→\n    38→logger = logging.getLogger(__name__)\n    39→\n    40→SKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n    41→\n    42→\n    43→@dataclass\n    44→class ToolContext:\n    45→    \"\"\"工具执行上下文\"\"\"\n    46→    user_id: str\n    47→    user_tier: str = \"free\"\n    48→    profile: Dict[str, Any] = field(default_factory=dict)\n    49→    skill_data: Dict[str, Any] = field(default_factory=dict)\n    50→    skill_id: Optional[str] = None\n    51→    scenario_id: Optional[str] = None\n    52→    conversation_id: Optional[str] = None\n    53→\n    54→\n    55→# 工具执行器类型: 同步或异步函数\n    56→ToolHandler = Callable[[Dict[str, Any], ToolContext], Union[Dict[str, Any], Awaitable[Dict[str, Any]]]]\n    57→\n    58→\n    59→class UnifiedToolRegistry:\n    60→    \"\"\"\n    61→    统一工具注册表\n    62→\n    63→    - 工具定义从 YAML 加载\n    64→    - 执行器通过 @tool_handler 装饰器注册\n    65→    - 支持全局工具和 Skill 专属工具\n    66→    \"\"\"\n    67→\n    68→    # 工具定义缓存: {tool_name: ToolDef}\n    69→    _tool_defs: Dict[str, ToolDef] = {}\n    70→\n    71→    # 工具执行器: {tool_name: handler_function}\n    72→    _handlers: Dict[str, ToolHandler] = {}\n    73→\n    74→    # 已加载的 Skill\n    75→    _loaded_skills: set = set()\n    76→\n    77→    # 是否已初始化\n    78→    _initialized: bool = False\n    79→\n    80→    @classmethod\n    81→    def initialize(cls):\n    82→        \"\"\"初始化注册表，加载全局工具\"\"\"\n    83→        if cls._initialized:\n    84→            return\n    85→\n    86→        # 从 core skill 加载全局工具定义\n    87→        global_tools = get_global_tools()\n    88→        for tool in global_tools:\n    89→            tool.is_global = True\n    90→            cls._tool_defs[tool.name] = tool\n    91→\n    92→        # 加载 core skill 的 handlers\n    93→        cls._load_handlers_module(\"core\")\n    94→\n    95→        # 自动发现并加载所有 Skill 的工具\n    96→        cls._auto_discover_skills()\n    97→\n    98→        cls._initialized = True\n    99→        logger.info(f\"ToolRegistry initialized: {len(cls._tool_defs)} tools, {len(cls._handlers)} handlers\")\n   100→\n   101→    @classmethod\n   102→    def _auto_discover_skills(cls):\n   103→        \"\"\"自动发现并加载所有 Skill\"\"\"\n   104→        if not SKILLS_DIR.exists():\n   105→            logger.warning(f\"Skills directory not found: {SKILLS_DIR}\")\n   106→            return\n   107→\n   108→        for skill_dir in SKILLS_DIR.iterdir():\n   109→            if skill_dir.is_dir() and skill_dir.name != \"__pycache__\":\n   110→                skill_id = skill_dir.name\n   111→                cls.load_skill(skill_id)\n   112→\n   113→    @classmethod\n   114→    def load_skill(cls, skill_id: str):\n   115→        \"\"\"加载 Skill 的工具定义和执行器\"\"\"\n   116→        if skill_id in cls._loaded_skills:\n   117→            return\n   118→\n   119→        # 1. 从 YAML 加载工具定义\n   120→        tools = load_skill_tools(skill_id)\n   121→        for tool in tools:\n   122→            tool.skill_id = skill_id  # 标记所属 Skill\n   123→            cls._tool_defs[tool.name] = tool\n   124→\n   125→        # 2. 尝试加载执行器模块\n   126→        cls._load_handlers_module(skill_id)\n   127→\n   128→        cls._loaded_skills.add(skill_id)\n   129→        logger.debug(f\"Loaded skill '{skill_id}': {len(tools)} tools\")\n   130→\n   131→    @classmethod\n   132→    def _load_handlers_module(cls, skill_id: str):\n   133→        \"\"\"加载 Skill 的 handlers 模块\"\"\"\n   134→        handlers_path = SKILLS_DIR / skill_id / \"tools\" / \"handlers.py\"\n   135→        if not handlers_path.exists():\n   136→            logger.debug(f\"No handlers module for skill '{skill_id}'\")\n   137→            return\n   138→\n   139→        try:\n   140→            module_name = f\"skills.{skill_id}.tools.handlers\"\n   141→            importlib.import_module(module_name)\n   142→            logger.debug(f\"Loaded handlers module: {module_name}\")\n   143→        except ImportError as e:\n   144→            logger.warning(f\"Failed to import handlers for '{skill_id}': {e}\")\n   145→\n   146→    @classmethod\n   147→    def register_handler(cls, tool_name: str, handler: ToolHandler):\n   148→        \"\"\"注册工具执行器\"\"\"\n   149→        cls._handlers[tool_name] = handler\n   150→        logger.debug(f\"Registered handler: {tool_name}\")\n   151→\n   152→    @classmethod\n   153→    def get_tool_def(cls, tool_name: str) -> Optional[ToolDef]:\n   154→        \"\"\"获取工具定义\"\"\"\n   155→        cls.initialize()\n   156→        return cls._tool_defs.get(tool_name)\n   157→\n   158→    @classmethod\n   159→    def get_tools_for_skill(cls, skill_id: str) -> List[Dict[str, Any]]:\n   160→        \"\"\"获取 Skill 的所有工具 (OpenAI 格式)\n   161→\n   162→        V6.2 更新：按需加载全局工具\n   163→        V12 更新：支持 includes 从 routing.yaml 加载其他 Skill 的工具\n   164→\n   165→        工具加载顺序：\n   166→        1. 全局工具（从 core skill 加载）\n   167→        2. 自身工具\n   168→        3. includes 中声明的 Skill 的工具（v12）\n   169→        4. external_tools 中声明的特定工具（v7.3 兼容）\n   170→        \"\"\"\n   171→        cls.initialize()\n   172→\n   173→        tools = []\n   174→        added_tool_names = set()  # 避免重复添加\n   175→\n   176→        # 获取 Skill 声明需要的全局工具（LLM-First：仅从 SKILL.md）\n   177→        from .skill_loader import get_skill_global_tools\n   178→        declared_global_tools = get_skill_global_tools(skill_id)\n   179→\n   180→        # 全局工具（从 core skill 加载）\n   181→        all_global_tools = get_global_tools()\n   182→        for tool in all_global_tools:\n   183→            # 如果声明了 global_tools，只加载声明的；否则加载全部\n   184→            if declared_global_tools:\n   185→                if tool.name in declared_global_tools:\n   186→                    tools.append(tool.to_openai_format())\n   187→                    added_tool_names.add(tool.name)\n   188→            else:\n   189→                # 向后兼容：没有声明则加载全部\n   190→                tools.append(tool.to_openai_format())\n   191→                added_tool_names.add(tool.name)\n   192→\n   193→        # Skill 专属工具（跳过 core，因为已经加载了）\n   194→        if skill_id != \"core\":\n   195→            for name, tool in cls._tool_defs.items():\n   196→                if getattr(tool, 'skill_id', None) == skill_id:\n   197→                    if name not in added_tool_names:\n   198→                        tools.append(tool.to_openai_format())\n   199→                        added_tool_names.add(name)\n   200→\n   201→        # includes（v12）已移除：不再从 routing.yaml 聚合其他 Skill 工具\n   202→        \n   203→        # v7.3: 外部工具（从其他 skill 导入）- 兼容旧配置\n   204→        from .skill_loader import get_skill_external_tools\n   205→        external_tool_names = get_skill_external_tools(skill_id)\n   206→        if external_tool_names:\n   207→            for name, tool in cls._tool_defs.items():\n   208→                if name in external_tool_names:\n   209→                    if name not in added_tool_names:\n   210→                        tools.append(tool.to_openai_format())\n   211→                        added_tool_names.add(name)\n   212→\n   213→        return tools\n   214→\n   215→    @classmethod\n   216→    def get_all_tools(cls) -> List[Dict[str, Any]]:\n   217→        \"\"\"获取所有已注册的工具 (OpenAI 格式)\"\"\"\n   218→        cls.initialize()\n   219→        return [tool.to_openai_format() for tool in cls._tool_defs.values()]\n   220→\n   221→    @classmethod\n   222→    def get_card_type(cls, tool_name: str) -> Optional[str]:\n   223→        \"\"\"获取工具对应的卡片类型\"\"\"\n   224→        tool = cls.get_tool_def(tool_name)\n   225→        return tool.card_type if tool else None\n   226→\n   227→    @classmethod\n   228→    def has_handler(cls, tool_name: str) -> bool:\n   229→        \"\"\"检查是否有注册的执行器\"\"\"\n   230→        cls.initialize()\n   231→        return tool_name in cls._handlers\n   232→\n   233→    @classmethod\n   234→    async def execute(\n   235→        cls,\n   236→        tool_name: str,\n   237→        args: Dict[str, Any],\n   238→        context: ToolContext\n   239→    ) -> Dict[str, Any]:\n   240→        \"\"\"执行工具\"\"\"\n   241→        cls.initialize()\n   242→\n   243→        if tool_name not in cls._handlers:\n   244→            logger.warning(f\"No handler for tool: {tool_name}\")\n   245→            return {\"error\": f\"Tool handler not found: {tool_name}\"}\n   246→\n   247→        handler = cls._handlers[tool_name]\n   248→\n   249→        try:\n   250→            # 支持同步和异步处理器\n   251→            result = handler(args, context)\n   252→            if asyncio.iscoroutine(result):\n   253→                result = await result\n   254→            return result\n   255→        except Exception as e:\n   256→            logger.error(f\"Tool execution failed: {tool_name}, error: {e}\")\n   257→            return {\"error\": str(e)}\n   258→\n   259→    @classmethod\n   260→    def get_schema(cls, skill_id: Optional[str] = None) -> Dict[str, Any]:\n   261→        \"\"\"获取工具 Schema (用于前端)\n   262→\n   263→        V12 更新：支持 includes 从 routing.yaml\n   264→        \"\"\"\n   265→        cls.initialize()\n   266→\n   267→        global_tool_names = {t.name for t in get_global_tools()}\n   268→\n   269→        # v7.3: 获取外部工具名\n   270→        external_tool_names = set()\n   271→        if skill_id:\n   272→            from .skill_loader import get_skill_external_tools\n   273→            external_tool_names = set(get_skill_external_tools(skill_id))\n   274→\n   275→        # LLM-First: 不再支持 includes（移除 routing.yaml 聚合）\n   276→        includes_skill_ids = set()\n   277→\n   278→        tools = []\n   279→        for name, tool in cls._tool_defs.items():\n   280→            tool_skill_id = getattr(tool, 'skill_id', None)\n   281→\n   282→            if skill_id:\n   283→                # 包含条件: 自身工具 OR 全局工具 OR 外部工具\n   284→                is_own_tool = tool_skill_id == skill_id\n   285→                is_global = name in global_tool_names\n   286→                is_external = name in external_tool_names\n   287→\n   288→                if not (is_own_tool or is_global or is_external):\n   289→                    continue\n   290→\n   291→            tools.append({\n   292→                \"name\": tool.name,\n   293→                \"description\": tool.description,\n   294→                \"tool_type\": tool.tool_type,\n   295→                \"card_type\": tool.card_type,\n   296→                \"fallback_type\": tool.fallback_type,  # V7.1: 降级类型\n   297→                \"card_props\": tool.card_props,  # 新增: 表单配置等\n   298→                \"parameters\": [\n   299→                    {\n   300→                        \"name\": p.name,\n   301→                        \"type\": p.type,\n   302→                        \"required\": p.required,\n   303→                        \"description\": p.description,\n   304→                        \"enum\": p.enum,\n   305→                        \"default\": p.default,\n   306→                    }\n   307→                    for p in tool.parameters\n   308→                ],\n   309→                \"when_to_call\": tool.when_to_call,\n   310→            })\n   311→\n   312→        return {\n   313→            \"version\": \"12.0\",\n   314→            \"skill_id\": skill_id,\n   315→            \"tools\": tools,\n   316→        }\n   317→\n   318→    @classmethod\n   319→    def clear(cls):\n   320→        \"\"\"清除所有注册 (用于测试)\"\"\"\n   321→        cls._tool_defs.clear()\n   322→        cls._handlers.clear()\n   323→        cls._loaded_skills.clear()\n   324→        cls._initialized = False\n   325→\n   326→\n   327→def tool_handler(tool_name: str):\n   328→    \"\"\"\n   329→    工具执行器装饰器\n   330→\n   331→    用法:\n   332→        @tool_handler(\"show_bazi_chart\")\n   333→        async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:\n   334→            return {\"chart\": ...}\n   335→    \"\"\"\n   336→    def decorator(func: ToolHandler) -> ToolHandler:\n   337→        @wraps(func)\n   338→        async def wrapper(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   339→            result = func(args, context)\n   340→            if asyncio.iscoroutine(result):\n   341→                return await result\n   342→            return result\n   343→\n   344→        # 注册到 Registry\n   345→        UnifiedToolRegistry.register_handler(tool_name, wrapper)\n   346→        return wrapper\n   347→\n   348→    return decorator\n   349→\n   350→\n   351→# 便捷别名\n   352→ToolRegistry = UnifiedToolRegistry\n   353→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f1eb5feb-26a8-41d3-a0de-4d9cf46e0f86","timestamp":"2026-01-25T03:27:15.424Z","sourceToolAssistantUUID":"223885b9-05c4-4b60-b3f6-63aacd364307"}
{"parentUuid":"f1eb5feb-26a8-41d3-a0de-4d9cf46e0f86","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Nrqynd1Hx4Hm1MXMUiVdHx","toolUseID":"toolu_01Nrqynd1Hx4Hm1MXMUiVdHx","timestamp":"2026-01-25T03:27:15.459Z","uuid":"6ce1d8b8-c013-4bed-99ac-b47849a4c51b"}
{"parentUuid":"6ce1d8b8-c013-4bed-99ac-b47849a4c51b","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_012LFkVwkp6HE5UdzQqvWVde","toolUseID":"toolu_012LFkVwkp6HE5UdzQqvWVde","timestamp":"2026-01-25T03:27:15.460Z","uuid":"d0573636-7105-4db5-8797-4699ff29ab00"}
{"parentUuid":"a5426cad-4604-4bbb-af60-9ecb268005e8","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HBVL1DswZz4end6utSXSxs","type":"tool_result","content":"     1→\"\"\"\n     2→SkillLoader v9 - 渐进式 Skill 加载器\n     3→\n     4→v9 架构（遵循 Claude Agent SDK 原则）：\n     5→- Core Skill 全程激活，全文加载\n     6→- 其他 Skill 渐进式加载：\n     7→  - Phase 1: 只加载 frontmatter（SkillMeta）\n     8→  - Phase 2: 按需加载完整内容（SkillFull）\n     9→- 支持多 Skill 并行激活\n    10→- LLM 自主编排，删除硬编码路由\n    11→\n    12→v7 架构（保留兼容）：\n    13→- SKILL.md: 核心定义（专家身份、能力索引、伦理边界）\n    14→- rules/*.md: 规则文件（分析要点、输出要求、常见问题）\n    15→- scenarios/*.md: (旧架构兼容) MiniSkill 场景文件\n    16→- tools/*.py: 工具定义（收集/计算/展示/检索）\n    17→\n    18→v7.4 新增：\n    19→- Skill Management 支持：category, pricing, showcase, subscription 字段\n    20→\n    21→v7.5 新增：\n    22→- 数据库优先元数据加载（skill_catalog 表）\n    23→- async 函数支持：load_skill_metadata_async, get_all_skill_metadata_async\n    24→- SKILL.md 作为 fallback\n    25→\"\"\"\n    26→import re\n    27→import json\n    28→import logging\n    29→import yaml\n    30→from pathlib import Path\n    31→from dataclasses import dataclass, field\n    32→from typing import Dict, List, Optional, Any\n    33→from functools import lru_cache\n    34→\n    35→logger = logging.getLogger(__name__)\n    36→\n    37→SKILLS_DIR = Path(__file__).parent.parent.parent / \"skills\"\n    38→\n    39→\n    40→# ═══════════════════════════════════════════════════════════════════════════\n    41→# 数据结构\n    42→# ═══════════════════════════════════════════════════════════════════════════\n    43→\n    44→@dataclass\n    45→class SkillPricing:\n    46→    \"\"\"Skill 定价配置\"\"\"\n    47→    type: str = \"free\"  # free | premium | credits\n    48→    trial_messages: int = 3\n    49→    credits_per_use: Optional[int] = None\n    50→\n    51→\n    52→@dataclass\n    53→class SkillShowcase:\n    54→    \"\"\"Skill 展示配置（用于 Skill 市场）\"\"\"\n    55→    tagline: str = \"\"\n    56→    highlights: List[str] = field(default_factory=list)\n    57→    preview_image: Optional[str] = None\n    58→    demo_prompts: List[str] = field(default_factory=list)\n    59→\n    60→\n    61→@dataclass\n    62→class SkillSubscription:\n    63→    \"\"\"Skill 订阅配置\"\"\"\n    64→    auto_subscribe: bool = False\n    65→    can_unsubscribe: bool = True\n    66→    push_default: bool = True\n    67→    min_subscription_days: int = 0\n    68→\n    69→\n    70→@dataclass\n    71→class SkillFeature:\n    72→    \"\"\"Skill 功能特性\"\"\"\n    73→    name: str\n    74→    description: str = \"\"\n    75→    icon: str = \"📌\"\n    76→    tier: str = \"free\"  # free | basic | premium\n    77→\n    78→\n    79→@dataclass\n    80→class SkillMetadata:\n    81→    \"\"\"Skill 元数据（用于 Skill Management API）\"\"\"\n    82→    id: str\n    83→    name: str\n    84→    description: str\n    85→    version: str = \"1.0.0\"\n    86→    category: str = \"professional\"  # core | default | professional\n    87→    icon: str = \"💡\"\n    88→    color: str = \"#6B7280\"\n    89→    triggers: List[str] = field(default_factory=list)\n    90→    pricing: SkillPricing = field(default_factory=SkillPricing)\n    91→    features: List[SkillFeature] = field(default_factory=list)\n    92→    showcase: SkillShowcase = field(default_factory=SkillShowcase)\n    93→    subscription: SkillSubscription = field(default_factory=SkillSubscription)\n    94→\n    95→    def to_dict(self) -> Dict[str, Any]:\n    96→        \"\"\"转换为 API 响应格式\"\"\"\n    97→        return {\n    98→            \"id\": self.id,\n    99→            \"name\": self.name,\n   100→            \"description\": self.description,\n   101→            \"version\": self.version,\n   102→            \"category\": self.category,\n   103→            \"icon\": self.icon,\n   104→            \"color\": self.color,\n   105→            \"triggers\": self.triggers,\n   106→            \"pricing\": {\n   107→                \"type\": self.pricing.type,\n   108→                \"trial_messages\": self.pricing.trial_messages,\n   109→                \"credits_per_use\": self.pricing.credits_per_use,\n   110→            },\n   111→            \"features\": [\n   112→                {\"name\": f.name, \"description\": f.description, \"icon\": f.icon, \"tier\": f.tier}\n   113→                for f in self.features\n   114→            ],\n   115→            \"showcase\": {\n   116→                \"tagline\": self.showcase.tagline,\n   117→                \"highlights\": self.showcase.highlights,\n   118→                \"preview_image\": self.showcase.preview_image,\n   119→                \"demo_prompts\": self.showcase.demo_prompts,\n   120→            },\n   121→            \"subscription\": {\n   122→                \"auto_subscribe\": self.subscription.auto_subscribe,\n   123→                \"can_unsubscribe\": self.subscription.can_unsubscribe,\n   124→                \"push_default\": self.subscription.push_default,\n   125→            },\n   126→        }\n   127→\n   128→\n   129→@dataclass\n   130→class SkillConfig:\n   131→    \"\"\"Skill 核心配置（从 SKILL.md 加载）\"\"\"\n   132→    id: str\n   133→    name: str\n   134→    description: str\n   135→    expert_persona: str\n   136→    scenarios: Dict[str, List[str]]  # {entry: [...], standard: [...], professional: [...]}\n   137→    ethics: Dict[str, Any]\n   138→    tools: List[str]\n   139→    default_scenario: str = \"basic_reading\"\n   140→    triggers: List[str] = field(default_factory=list)\n   141→    global_tools: List[str] = field(default_factory=list)  # 需要的全局工具\n   142→    # v7.1: SOP 配置驱动\n   143→    requires_birth_info: bool = False  # 是否需要出生信息\n   144→    requires_compute: bool = False     # 是否需要计算（排盘）\n   145→    compute_type: Optional[str] = None # 计算类型：bazi/zodiac/tarot，None 表示使用自身\n   146→    compute_tool: Optional[str] = None # 计算工具名，None 时使用默认约定 calculate_{compute_type}\n   147→    collect_tool: Optional[str] = None # 收集工具名，None 时使用默认约定 request_info\n   148→    external_tools: List[str] = field(default_factory=list)  # v7.3: 从其他 skill 导入的工具\n   149→    # v2.2: Profile 注入配置\n   150→    requires_skill_data: List[str] = field(default_factory=list)  # 需要的 skill_data，空列表表示只需自身\n   151→\n   152→\n   153→@dataclass\n   154→class ServiceItem:\n   155→    \"\"\"服务项（用于服务目录展示）\"\"\"\n   156→    scenario_id: str\n   157→    name: str\n   158→    icon: str\n   159→    description: str\n   160→    tier: str  # entry/standard/professional\n   161→    billing: str  # 免费/基础/高级\n   162→    highlights: List[str] = field(default_factory=list)  # 价值点\n   163→\n   164→\n   165→@dataclass\n   166→class ScenarioConfig:\n   167→    \"\"\"场景配置（从 scenarios/*.md 加载）\"\"\"\n   168→    id: str\n   169→    name: str\n   170→    level: str  # entry/standard/professional\n   171→    billing: str  # free/basic/premium\n   172→    description: str\n   173→    triggers: Dict[str, List[str]]  # {primary: [...], secondary: [...]}\n   174→    prerequisites: List[str]\n   175→    sop: List[Dict[str, Any]]  # SOP 阶段列表\n   176→    knowledge_config: Dict[str, Any]  # 知识检索配置\n   177→    output_config: Dict[str, Any]  # 输出配置\n   178→    tools: List[str]\n   179→\n   180→\n   181→@dataclass\n   182→class ToolMetadata:\n   183→    \"\"\"工具元数据\"\"\"\n   184→    name: str\n   185→    description: str\n   186→    tool_type: str  # collect/calculate/display/search\n   187→    card_type: Optional[str] = None\n   188→    card_props_schema: Optional[Dict] = None\n   189→    parameters: Dict[str, Any] = field(default_factory=dict)\n   190→    when_to_call: Optional[str] = None\n   191→\n   192→\n   193→@dataclass\n   194→class RuleConfig:\n   195→    \"\"\"规则配置（从 rules/*.md 加载）- v7 新增\"\"\"\n   196→    id: str\n   197→    name: str\n   198→    impact: str  # CRITICAL/HIGH/MEDIUM/LOW\n   199→    impact_description: str\n   200→    tags: List[str]\n   201→    content: str  # 完整的规则内容\n   202→    analysis_steps: List[Dict[str, Any]]  # 分析要点表格\n   203→    output_requirements: str  # 输出要求\n   204→    common_questions: str  # 常见问题\n   205→\n   206→\n   207→# ═══════════════════════════════════════════════════════════════════════════\n   208→# V9: 渐进式加载数据结构\n   209→# ═══════════════════════════════════════════════════════════════════════════\n   210→\n   211→@dataclass\n   212→class SkillMeta:\n   213→    \"\"\"Skill 元数据摘要（Phase 1 展示）- V9 新增\n   214→\n   215→    只包含 frontmatter 信息，用于 Phase 1 路由。\n   216→    description 内嵌工具列表，tools_list 为从 tools.yaml 抽取的机器可读清单。\n   217→    \"\"\"\n   218→    id: str\n   219→    name: str\n   220→    description: str  # 内含工具列表，如 \"星盘计算与解读。工具：calculate_zodiac, show_zodiac_chart\"\n   221→    triggers: List[str] = field(default_factory=list)\n   222→    category: str = \"professional\"\n   223→    tools_list: List[str] = field(default_factory=list)\n   224→\n   225→\n   226→@dataclass\n   227→class ToolDef:\n   228→    \"\"\"工具定义（用于 SkillFull）- V9 新增\"\"\"\n   229→    name: str\n   230→    description: str\n   231→    parameters: Dict[str, Any] = field(default_factory=dict)\n   232→    tool_type: str = \"action\"  # routing/collect/action/search/display/trigger\n   233→\n   234→\n   235→@dataclass\n   236→class SkillFull:\n   237→    \"\"\"Skill 完整内容（Phase 2 加载）- V9 新增\n   238→\n   239→    包含 SKILL.md 全文、工具定义、规则文件。\n   240→    \"\"\"\n   241→    meta: SkillMeta\n   242→    content: str  # SKILL.md 全文（不含 frontmatter）\n   243→    tools: List[ToolDef] = field(default_factory=list)\n   244→    rules: Dict[str, str] = field(default_factory=dict)  # rule_id -> content\n   245→\n   246→\n   247→# V9: Core Skill 全局缓存\n   248→_core_skill_cache: Optional[SkillFull] = None\n   249→\n   250→# V9: 所有 Skill Meta 缓存\n   251→_skill_metas_cache: Optional[Dict[str, SkillMeta]] = None\n   252→\n   253→\n   254→# ═══════════════════════════════════════════════════════════════════════════\n   255→# 解析函数\n   256→# ═══════════════════════════════════════════════════════════════════════════\n   257→\n   258→def parse_frontmatter(text: str) -> tuple[Dict, str]:\n   259→    \"\"\"解析 YAML frontmatter（支持嵌套对象）\"\"\"\n   260→    pattern = r'^---\\s*\\n(.*?)\\n---\\s*\\n(.*)$'\n   261→    match = re.match(pattern, text, re.DOTALL)\n   262→    if not match:\n   263→        return {}, text\n   264→\n   265→    frontmatter_str, content = match.groups()\n   266→\n   267→    # 使用 YAML 解析以支持嵌套对象\n   268→    try:\n   269→        metadata = yaml.safe_load(frontmatter_str) or {}\n   270→    except yaml.YAMLError as e:\n   271→        logger.warning(f\"YAML parse error in frontmatter: {e}, falling back to simple parse\")\n   272→        # 回退到简单解析\n   273→        metadata = {}\n   274→        current_key = None\n   275→        current_list = None\n   276→\n   277→        for line in frontmatter_str.strip().split('\\n'):\n   278→            stripped = line.strip()\n   279→            if not stripped:\n   280→                continue\n   281→            if stripped.startswith('- ') and current_key:\n   282→                if current_list is None:\n   283→                    current_list = []\n   284→                current_list.append(stripped[2:].strip())\n   285→                metadata[current_key] = current_list\n   286→            elif ':' in line and not line.startswith(' '):\n   287→                current_list = None\n   288→                key, value = line.split(':', 1)\n   289→                current_key = key.strip()\n   290→                value = value.strip()\n   291→                if value in ('|', ''):\n   292→                    continue\n   293→                elif value.lower() == 'true':\n   294→                    metadata[current_key] = True\n   295→                elif value.lower() == 'false':\n   296→                    metadata[current_key] = False\n   297→                else:\n   298→                    metadata[current_key] = value\n   299→\n   300→    return metadata, content.strip()\n   301→\n   302→\n   303→def parse_skill_md(text: str) -> Dict[str, Any]:\n   304→    \"\"\"解析 SKILL.md 内容，提取结构化信息\n   305→\n   306→    支持两种触发词格式：\n   307→    1. 旧格式：frontmatter 中的 triggers: 列表\n   308→    2. 新格式：description 中的 \"触发词：xxx、xxx、xxx\"\n   309→    \"\"\"\n   310→    metadata, content = parse_frontmatter(text)\n   311→\n   312→    # 从 frontmatter 获取触发词（旧格式）\n   313→    triggers = metadata.get(\"triggers\", [])\n   314→\n   315→    # 如果 frontmatter 没有 triggers，尝试从 description 中提取（新格式）\n   316→    if not triggers:\n   317→        description = metadata.get(\"description\", \"\")\n   318→        # 匹配 \"触发词：xxx、xxx、xxx\" 或 \"触发词:xxx,xxx,xxx\"\n   319→        trigger_match = re.search(r'触发词[：:]\\s*([^。.]+)', description)\n   320→        if trigger_match:\n   321→            trigger_str = trigger_match.group(1)\n   322→            # 支持顿号、逗号分隔\n   323→            triggers = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]\n   324→\n   325→    result = {\n   326→        \"id\": metadata.get(\"id\", \"\"),\n   327→        \"name\": metadata.get(\"name\", \"\"),\n   328→        \"description\": metadata.get(\"description\", \"\"),\n   329→        \"triggers\": triggers,\n   330→        \"default_scenario\": metadata.get(\"default_scenario\", \"basic_reading\"),\n   331→        \"global_tools\": metadata.get(\"global_tools\", []),  # 从 frontmatter 读取\n   332→        # v7.1: SOP 配置驱动\n   333→        \"requires_birth_info\": metadata.get(\"requires_birth_info\", False),\n   334→        \"requires_compute\": metadata.get(\"requires_compute\", False),\n   335→        \"compute_type\": metadata.get(\"compute_type\", None),\n   336→        \"compute_tool\": metadata.get(\"compute_tool\", None),\n   337→        \"collect_tool\": metadata.get(\"collect_tool\", None),\n   338→        \"external_tools\": metadata.get(\"external_tools\", []),  # v7.3\n   339→        # v2.2: Profile 注入配置\n   340→        \"requires_skill_data\": metadata.get(\"requires_skill_data\", []),\n   341→    }\n   342→\n   343→    # 提取专家身份\n   344→    expert_match = re.search(r'## 专家身份\\s*\\n(.*?)(?=\\n## |\\Z)', content, re.DOTALL)\n   345→    result[\"expert_persona\"] = expert_match.group(1).strip() if expert_match else \"\"\n   346→\n   347→    # 提取场景目录\n   348→    scenarios = {\"entry\": [], \"standard\": [], \"professional\": []}\n   349→    for level in scenarios.keys():\n   350→        pattern = rf'### {level.capitalize()}.*?\\n\\|.*?\\n\\|.*?\\n((?:\\|.*?\\n)*)'\n   351→        match = re.search(pattern, content, re.IGNORECASE | re.DOTALL)\n   352→        if match:\n   353→            for row in match.group(1).strip().split('\\n'):\n   354→                cols = [c.strip() for c in row.split('|')[1:-1]]\n   355→                if len(cols) >= 2:\n   356→                    scenarios[level].append(cols[1])  # 文件名\n   357→    result[\"scenarios\"] = scenarios\n   358→\n   359→    # 提取伦理边界\n   360→    ethics = {\"forbidden\": [], \"sensitive\": [], \"principles\": []}\n   361→    forbidden_match = re.search(r'### 绝对禁止\\s*\\n((?:- .*?\\n)*)', content)\n   362→    if forbidden_match:\n   363→        ethics[\"forbidden\"] = [l[2:].strip() for l in forbidden_match.group(1).strip().split('\\n')]\n   364→    result[\"ethics\"] = ethics\n   365→\n   366→    # 提取工具列表\n   367→    tools = []\n   368→    tools_match = re.search(r'## 工具列表\\s*\\n\\|.*?\\n\\|.*?\\n((?:\\|.*?\\n)*)', content)\n   369→    if tools_match:\n   370→        for row in tools_match.group(1).strip().split('\\n'):\n   371→            cols = [c.strip() for c in row.split('|')[1:-1]]\n   372→            if len(cols) >= 1:\n   373→                tools.append(cols[0])\n   374→    result[\"tools\"] = tools\n   375→\n   376→    return result\n   377→\n   378→\n   379→def parse_scenario_md(text: str) -> Dict[str, Any]:\n   380→    \"\"\"解析 scenario.md 内容\"\"\"\n   381→    metadata, content = parse_frontmatter(text)\n   382→\n   383→    result = {\n   384→        \"id\": metadata.get(\"id\", \"\"),\n   385→        \"name\": metadata.get(\"name\", \"\"),\n   386→        \"level\": metadata.get(\"level\", \"entry\"),\n   387→        \"billing\": metadata.get(\"billing\", \"free\"),\n   388→        \"description\": metadata.get(\"description\", \"\"),\n   389→    }\n   390→\n   391→    # 提取触发条件\n   392→    triggers = {\"primary\": [], \"secondary\": []}\n   393→    primary_match = re.search(r'\\*\\*主要触发词\\*\\*:\\s*(.*?)(?:\\n|$)', content)\n   394→    if primary_match:\n   395→        triggers[\"primary\"] = [t.strip() for t in primary_match.group(1).split(',')]\n   396→    secondary_match = re.search(r'\\*\\*次要触发词\\*\\*:\\s*(.*?)(?:\\n|$)', content)\n   397→    if secondary_match:\n   398→        triggers[\"secondary\"] = [t.strip() for t in secondary_match.group(1).split(',')]\n   399→    result[\"triggers\"] = triggers\n   400→\n   401→    # 提取前置要求\n   402→    prereq_match = re.search(r'## 前置要求\\s*\\n((?:- .*?\\n)*)', content)\n   403→    result[\"prerequisites\"] = []\n   404→    if prereq_match:\n   405→        result[\"prerequisites\"] = [l[2:].strip() for l in prereq_match.group(1).strip().split('\\n')]\n   406→\n   407→    # 提取 SOP 阶段\n   408→    sop = []\n   409→    phase_pattern = r'### Phase (\\d+):\\s*(.*?)\\n(.*?)(?=### Phase|\\Z)'\n   410→    for match in re.finditer(phase_pattern, content, re.DOTALL):\n   411→        phase_num, phase_name, phase_content = match.groups()\n   412→        phase = {\n   413→            \"phase\": int(phase_num),\n   414→            \"name\": phase_name.strip(),\n   415→            \"content\": phase_content.strip()\n   416→        }\n   417→        # 提取类型\n   418→        type_match = re.search(r'\\*\\*类型\\*\\*:\\s*(\\w+)', phase_content)\n   419→        if type_match:\n   420→            phase[\"type\"] = type_match.group(1)\n   421→        sop.append(phase)\n   422→    result[\"sop\"] = sop\n   423→\n   424→    # 提取工具列表\n   425→    tools_match = re.search(r'\\*\\*使用工具\\*\\*:\\s*\\n((?:- .*?\\n)*)', content)\n   426→    result[\"tools\"] = []\n   427→    if tools_match:\n   428→        result[\"tools\"] = [l[2:].strip() for l in tools_match.group(1).strip().split('\\n')]\n   429→\n   430→    # 知识检索配置\n   431→    result[\"knowledge_config\"] = {}\n   432→    result[\"output_config\"] = {}\n   433→\n   434→    return result\n   435→\n   436→\n   437→def parse_rule_md(text: str) -> Dict[str, Any]:\n   438→    \"\"\"解析 rules/*.md 内容 - v7 新增\"\"\"\n   439→    metadata, content = parse_frontmatter(text)\n   440→\n   441→    # 解析 tags（支持逗号分隔的字符串或列表）\n   442→    tags_raw = metadata.get(\"tags\", [])\n   443→    if isinstance(tags_raw, str):\n   444→        tags = [t.strip() for t in re.split(r'[,，、]', tags_raw) if t.strip()]\n   445→    else:\n   446→        tags = tags_raw\n   447→\n   448→    result = {\n   449→        \"id\": metadata.get(\"id\", \"\"),\n   450→        \"name\": metadata.get(\"name\", \"\"),\n   451→        \"impact\": metadata.get(\"impact\", \"MEDIUM\"),\n   452→        \"impact_description\": metadata.get(\"impactDescription\", \"\"),\n   453→        \"tags\": tags,\n   454→        \"content\": content,\n   455→    }\n   456→\n   457→    # 提取分析要点表格\n   458→    analysis_steps = []\n   459→    table_match = re.search(r'## 分析要点\\s*\\n\\|[^\\n]+\\n\\|[-\\s|]+\\n((?:\\|[^\\n]+\\n)*)', content)\n   460→    if table_match:\n   461→        for row in table_match.group(1).strip().split('\\n'):\n   462→            cols = [c.strip() for c in row.split('|')[1:-1]]\n   463→            if len(cols) >= 4:\n   464→                analysis_steps.append({\n   465→                    \"step\": cols[0],\n   466→                    \"point\": cols[1],\n   467→                    \"query\": cols[2],\n   468→                    \"priority\": cols[3],\n   469→                })\n   470→    result[\"analysis_steps\"] = analysis_steps\n   471→\n   472→    # 提取输出要求\n   473→    output_match = re.search(r'## 输出要求\\s*\\n(.*?)(?=\\n## |\\Z)', content, re.DOTALL)\n   474→    result[\"output_requirements\"] = output_match.group(1).strip() if output_match else \"\"\n   475→\n   476→    # 提取常见问题\n   477→    faq_match = re.search(r'## 常见问题\\s*\\n(.*?)(?=\\n## |\\Z)', content, re.DOTALL)\n   478→    result[\"common_questions\"] = faq_match.group(1).strip() if faq_match else \"\"\n   479→\n   480→    return result\n   481→\n   482→\n   483→def parse_skill_services(text: str) -> Dict[str, List[Dict[str, Any]]]:\n   484→    \"\"\"解析 SKILL.md 中的服务目录，提取展示信息\"\"\"\n   485→    services = {\"entry\": [], \"standard\": [], \"professional\": []}\n   486→\n   487→    tier_map = {\n   488→        \"entry\": \"entry\",\n   489→        \"standard\": \"standard\",\n   490→        \"professional\": \"professional\"\n   491→    }\n   492→\n   493→    for tier_name, tier_key in tier_map.items():\n   494→        # 匹配表格头和内容\n   495→        pattern = rf'### {tier_name.capitalize()}.*?\\n\\|[^\\n]+\\n\\|[-\\s|]+\\n((?:\\|[^\\n]+\\n)*)'\n   496→        match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n   497→        if not match:\n   498→            continue\n   499→\n   500→        table_content = match.group(1).strip()\n   501→        if not table_content:\n   502→            continue\n   503→\n   504→        for row in table_content.split('\\n'):\n   505→            cols = [c.strip() for c in row.split('|')[1:-1]]\n   506→            if len(cols) < 7:  # 至少需要 7 列（场景、文件、触发词、计费、展示名称、图标、简介）\n   507→                continue\n   508→\n   509→            service = {\n   510→                \"scenario_id\": cols[1].replace('.md', '') if cols[1] else cols[0].lower().replace(' ', '_'),\n   511→                \"name\": cols[4] if len(cols) > 4 and cols[4] else cols[0],\n   512→                \"icon\": cols[5] if len(cols) > 5 and cols[5] else \"📌\",\n   513→                \"description\": cols[6] if len(cols) > 6 and cols[6] else \"\",\n   514→                \"tier\": tier_key,\n   515→                \"billing\": cols[3] if len(cols) > 3 else \"免费\",\n   516→                \"highlights\": []\n   517→            }\n   518→\n   519→            # 解析价值点（第8列，如果存在）\n   520→            if len(cols) > 7 and cols[7]:\n   521→                service[\"highlights\"] = [h.strip() for h in cols[7].split(',')]\n   522→\n   523→            services[tier_key].append(service)\n   524→\n   525→    return services\n   526→\n   527→\n   528→def get_skill_services(skill_id: str) -> Optional[Dict[str, Any]]:\n   529→    \"\"\"获取 Skill 的服务目录数据（用于 show_skill_services 工具）\"\"\"\n   530→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   531→    if not skill_path.exists():\n   532→        return None\n   533→\n   534→    text = skill_path.read_text(encoding='utf-8')\n   535→    metadata, _ = parse_frontmatter(text)\n   536→    services = parse_skill_services(text)\n   537→\n   538→    return {\n   539→        \"skill_id\": skill_id,\n   540→        \"skill_name\": metadata.get(\"name\", skill_id),\n   541→        \"description\": metadata.get(\"description\", \"\"),\n   542→        \"services\": services\n   543→    }\n   544→\n   545→\n   546→# ═══════════════════════════════════════════════════════════════════════════\n   547→# 加载函数\n   548→# ═══════════════════════════════════════════════════════════════════════════\n   549→\n   550→@lru_cache(maxsize=32)\n   551→def load_skill(skill_id: str) -> Optional[SkillConfig]:\n   552→    \"\"\"加载 Skill 核心配置\"\"\"\n   553→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   554→    if not skill_path.exists():\n   555→        return None\n   556→\n   557→    text = skill_path.read_text(encoding='utf-8')\n   558→    data = parse_skill_md(text)\n   559→\n   560→    return SkillConfig(\n   561→        id=data.get(\"id\", skill_id),\n   562→        name=data.get(\"name\", skill_id),\n   563→        description=data.get(\"description\", \"\"),\n   564→        expert_persona=data.get(\"expert_persona\", \"\"),\n   565→        scenarios=data.get(\"scenarios\", {}),\n   566→        ethics=data.get(\"ethics\", {}),\n   567→        tools=data.get(\"tools\", []),\n   568→        default_scenario=data.get(\"default_scenario\", \"basic_reading\"),\n   569→        triggers=data.get(\"triggers\", []),\n   570→        global_tools=data.get(\"global_tools\", []),\n   571→        # v7.1: SOP 配置驱动\n   572→        requires_birth_info=data.get(\"requires_birth_info\", False),\n   573→        requires_compute=data.get(\"requires_compute\", False),\n   574→        compute_type=data.get(\"compute_type\", None),\n   575→        compute_tool=data.get(\"compute_tool\", None),\n   576→        collect_tool=data.get(\"collect_tool\", None),\n   577→        external_tools=data.get(\"external_tools\", []),  # v7.3\n   578→        # v2.2: Profile 注入配置\n   579→        requires_skill_data=data.get(\"requires_skill_data\", []),\n   580→    )\n   581→\n   582→\n   583→@lru_cache(maxsize=32)\n   584→def load_skill_metadata(skill_id: str) -> Optional[SkillMetadata]:\n   585→    \"\"\"加载 Skill 元数据（用于 Skill Management API）- v7.4 新增\n   586→\n   587→    从 SKILL.md 的 frontmatter 中读取完整的元数据配置，\n   588→    包括 category, pricing, showcase, subscription 等字段。\n   589→    \"\"\"\n   590→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   591→    if not skill_path.exists():\n   592→        return None\n   593→\n   594→    text = skill_path.read_text(encoding='utf-8')\n   595→    metadata, _ = parse_frontmatter(text)\n   596→\n   597→    # 从 description 中提取触发词（如果 frontmatter 中没有）\n   598→    triggers = metadata.get(\"triggers\", [])\n   599→    if not triggers:\n   600→        description = metadata.get(\"description\", \"\")\n   601→        trigger_match = re.search(r'触发词[：:]\\s*([^。.]+)', description)\n   602→        if trigger_match:\n   603→            trigger_str = trigger_match.group(1)\n   604→            triggers = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]\n   605→\n   606→    # 解析 pricing\n   607→    pricing_data = metadata.get(\"pricing\", {})\n   608→    pricing = SkillPricing(\n   609→        type=pricing_data.get(\"type\", \"free\") if isinstance(pricing_data, dict) else \"free\",\n   610→        trial_messages=pricing_data.get(\"trial_messages\", 3) if isinstance(pricing_data, dict) else 3,\n   611→        credits_per_use=pricing_data.get(\"credits_per_use\") if isinstance(pricing_data, dict) else None,\n   612→    )\n   613→\n   614→    # 解析 features\n   615→    features_data = metadata.get(\"features\", [])\n   616→    features = []\n   617→    if isinstance(features_data, list):\n   618→        for f in features_data:\n   619→            if isinstance(f, dict):\n   620→                features.append(SkillFeature(\n   621→                    name=f.get(\"name\", \"\"),\n   622→                    description=f.get(\"description\", \"\"),\n   623→                    icon=f.get(\"icon\", \"📌\"),\n   624→                    tier=f.get(\"tier\", \"free\"),\n   625→                ))\n   626→\n   627→    # 解析 showcase\n   628→    showcase_data = metadata.get(\"showcase\", {})\n   629→    showcase = SkillShowcase(\n   630→        tagline=showcase_data.get(\"tagline\", \"\") if isinstance(showcase_data, dict) else \"\",\n   631→        highlights=showcase_data.get(\"highlights\", []) if isinstance(showcase_data, dict) else [],\n   632→        preview_image=showcase_data.get(\"preview_image\") if isinstance(showcase_data, dict) else None,\n   633→        demo_prompts=showcase_data.get(\"demo_prompts\", []) if isinstance(showcase_data, dict) else [],\n   634→    )\n   635→\n   636→    # 解析 subscription\n   637→    subscription_data = metadata.get(\"subscription\", {})\n   638→    category = metadata.get(\"category\", \"professional\")\n   639→    subscription = SkillSubscription(\n   640→        auto_subscribe=subscription_data.get(\"auto_subscribe\", category == \"default\") if isinstance(subscription_data, dict) else (category == \"default\"),\n   641→        can_unsubscribe=subscription_data.get(\"can_unsubscribe\", category != \"core\") if isinstance(subscription_data, dict) else (category != \"core\"),\n   642→        push_default=subscription_data.get(\"push_default\", True) if isinstance(subscription_data, dict) else True,\n   643→        min_subscription_days=subscription_data.get(\"min_subscription_days\", 0) if isinstance(subscription_data, dict) else 0,\n   644→    )\n   645→\n   646→    return SkillMetadata(\n   647→        id=metadata.get(\"id\", skill_id),\n   648→        name=metadata.get(\"name\", skill_id),\n   649→        description=metadata.get(\"description\", \"\"),\n   650→        version=metadata.get(\"version\", \"1.0.0\"),\n   651→        category=category,\n   652→        icon=metadata.get(\"icon\", \"💡\"),\n   653→        color=metadata.get(\"color\", \"#6B7280\"),\n   654→        triggers=triggers,\n   655→        pricing=pricing,\n   656→        features=features,\n   657→        showcase=showcase,\n   658→        subscription=subscription,\n   659→    )\n   660→\n   661→\n   662→def get_all_skill_metadata() -> List[SkillMetadata]:\n   663→    \"\"\"获取所有可用 Skill 的元数据（用于 Skill 列表 API）- v7.4 新增\"\"\"\n   664→    skills = []\n   665→    for skill_id in get_available_skills():\n   666→        metadata = load_skill_metadata(skill_id)\n   667→        if metadata:\n   668→            skills.append(metadata)\n   669→    return skills\n   670→\n   671→\n   672→def get_skills_by_category(category: str) -> List[SkillMetadata]:\n   673→    \"\"\"按分类获取 Skill 列表 - v7.4 新增\n   674→\n   675→    Args:\n   676→        category: core | default | professional\n   677→\n   678→    Returns:\n   679→        该分类下所有 Skill 的元数据列表\n   680→    \"\"\"\n   681→    return [s for s in get_all_skill_metadata() if s.category == category]\n   682→\n   683→\n   684→@lru_cache(maxsize=64)\n   685→def load_scenario(skill_id: str, scenario_id: str) -> Optional[ScenarioConfig]:\n   686→    \"\"\"加载场景配置\"\"\"\n   687→    scenario_path = SKILLS_DIR / skill_id / \"scenarios\" / f\"{scenario_id}.md\"\n   688→    if not scenario_path.exists():\n   689→        return None\n   690→\n   691→    text = scenario_path.read_text(encoding='utf-8')\n   692→    data = parse_scenario_md(text)\n   693→\n   694→    return ScenarioConfig(\n   695→        id=data.get(\"id\", scenario_id),\n   696→        name=data.get(\"name\", scenario_id),\n   697→        level=data.get(\"level\", \"entry\"),\n   698→        billing=data.get(\"billing\", \"free\"),\n   699→        description=data.get(\"description\", \"\"),\n   700→        triggers=data.get(\"triggers\", {}),\n   701→        prerequisites=data.get(\"prerequisites\", []),\n   702→        sop=data.get(\"sop\", []),\n   703→        knowledge_config=data.get(\"knowledge_config\", {}),\n   704→        output_config=data.get(\"output_config\", {}),\n   705→        tools=data.get(\"tools\", [])\n   706→    )\n   707→\n   708→\n   709→@lru_cache(maxsize=128)\n   710→def load_rule(skill_id: str, rule_id: str) -> Optional[RuleConfig]:\n   711→    \"\"\"加载规则配置 - v7 新增\n   712→\n   713→    支持两种格式：\n   714→    1. 根目录规则: rule_id=\"dankoe\" -> rules/dankoe.md\n   715→    2. 子目录规则: rule_id=\"companion/weekly-review\" -> rules/companion/weekly-review.md\n   716→\n   717→    容错处理：\n   718→    - 自动处理已带 .md 后缀的 rule_id\n   719→    - 拒绝目录路径\n   720→    \"\"\"\n   721→    # 先尝试标准格式（自动添加 .md 后缀）\n   722→    rule_path = SKILLS_DIR / skill_id / \"rules\" / f\"{rule_id}.md\"\n   723→\n   724→    if not rule_path.exists():\n   725→        # Fallback: 尝试直接作为路径（处理已带 .md 后缀的情况）\n   726→        rule_path = SKILLS_DIR / skill_id / \"rules\" / rule_id\n   727→\n   728→        # 拒绝目录\n   729→        if rule_path.is_dir():\n   730→            logger.warning(f\"load_rule: {rule_id} is a directory, not a rule file\")\n   731→            return None\n   732→\n   733→        # 如果没有后缀，添加 .md\n   734→        if not rule_path.suffix:\n   735→            rule_path = rule_path.with_suffix(\".md\")\n   736→\n   737→        # 仍然不存在，返回 None\n   738→        if not rule_path.exists():\n   739→            return None\n   740→\n   741→    try:\n   742→        text = rule_path.read_text(encoding='utf-8')\n   743→        data = parse_rule_md(text)\n   744→\n   745→        return RuleConfig(\n   746→            id=data.get(\"id\", rule_id),\n   747→            name=data.get(\"name\", rule_id),\n   748→            impact=data.get(\"impact\", \"MEDIUM\"),\n   749→            impact_description=data.get(\"impact_description\", \"\"),\n   750→            tags=data.get(\"tags\", []),\n   751→            content=data.get(\"content\", \"\"),\n   752→            analysis_steps=data.get(\"analysis_steps\", []),\n   753→            output_requirements=data.get(\"output_requirements\", \"\"),\n   754→            common_questions=data.get(\"common_questions\", \"\"),\n   755→        )\n   756→    except Exception as e:\n   757→        logger.error(f\"load_rule: Failed to load {skill_id}/{rule_id}: {e}\")\n   758→        return None\n   759→\n   760→\n   761→def get_skill_rules(skill_id: str) -> List[str]:\n   762→    \"\"\"获取 Skill 的所有规则 ID - v7 新增\n   763→\n   764→    返回格式：\n   765→    - 根目录规则: \"dankoe\"\n   766→    - 子目录规则: \"companion/weekly-review\"\n   767→    \"\"\"\n   768→    rules_dir = SKILLS_DIR / skill_id / \"rules\"\n   769→    if not rules_dir.exists():\n   770→        return []\n   771→\n   772→    rule_ids = []\n   773→\n   774→    # 递归查找所有 .md 文件（支持子目录）\n   775→    for md_file in rules_dir.rglob(\"*.md\"):\n   776→        # 跳过 _index.md 等\n   777→        if md_file.stem.startswith(\"_\"):\n   778→            continue\n   779→\n   780→        # 计算相对路径（去掉 .md 扩展名）\n   781→        relative_path = md_file.relative_to(rules_dir)\n   782→        rule_id = str(relative_path.with_suffix(\"\"))\n   783→\n   784→        # 转换 Windows 路径分隔符为 Unix 格式\n   785→        rule_id = rule_id.replace(\"\\\\\", \"/\")\n   786→\n   787→        rule_ids.append(rule_id)\n   788→\n   789→    return sorted(rule_ids)\n   790→\n   791→\n   792→def has_rules(skill_id: str) -> bool:\n   793→    \"\"\"检查 Skill 是否使用 rules 架构 - v7 新增\"\"\"\n   794→    rules_dir = SKILLS_DIR / skill_id / \"rules\"\n   795→    if not rules_dir.exists():\n   796→        return False\n   797→    rules = list(rules_dir.glob(\"*.md\"))\n   798→    return len(rules) > 0\n   799→\n   800→\n   801→def get_available_skills() -> List[str]:\n   802→    \"\"\"获取所有可用的 Skill\"\"\"\n   803→    if not SKILLS_DIR.exists():\n   804→        return []\n   805→    return [p.name for p in SKILLS_DIR.iterdir()\n   806→            if p.is_dir() and (p / \"SKILL.md\").exists()]\n   807→\n   808→\n   809→# ═══════════════════════════════════════════════════════════════════════════\n   810→# Protocol/Rule 元信息（用于消除硬编码）\n   811→# ═══════════════════════════════════════════════════════════════════════════\n   812→\n   813→@lru_cache(maxsize=32)\n   814→def get_protocols_meta(skill_id: str) -> Dict[str, Dict[str, Any]]:\n   815→    \"\"\"扫描 rules 顶层 .md 作为“协议”，解析 frontmatter 返回 meta 映射。\n   816→\n   817→    返回: {protocol_id: {id, name, estimated_time?, total_steps?, order?, enabled?}}\n   818→    仅扫描规则根目录，忽略子目录（如 companion/）。\n   819→    \"\"\"\n   820→    rules_dir = SKILLS_DIR / skill_id / \"rules\"\n   821→    metas: Dict[str, Dict[str, Any]] = {}\n   822→    if not rules_dir.exists():\n   823→        return metas\n   824→\n   825→    for md in rules_dir.glob(\"*.md\"):\n   826→        if md.stem.startswith(\"_\"):\n   827→            continue\n   828→        try:\n   829→            text = md.read_text(encoding=\"utf-8\")\n   830→            fm, _ = parse_frontmatter(text)\n   831→            pid = fm.get(\"id\", md.stem)\n   832→            metas[pid] = {\n   833→                \"id\": pid,\n   834→                \"name\": fm.get(\"name\", pid),\n   835→                \"estimated_time\": fm.get(\"estimated_time\"),\n   836→                \"total_steps\": fm.get(\"total_steps\"),\n   837→                \"order\": fm.get(\"order\", 0),\n   838→                \"enabled\": fm.get(\"enabled\", True),\n   839→            }\n   840→        except Exception:\n   841→            # 忽略单个文件错误\n   842→            continue\n   843→    return metas\n   844→\n   845→\n   846→@lru_cache(maxsize=32)\n   847→def get_protocol_ids(skill_id: str) -> List[str]:\n   848→    \"\"\"返回启用的协议 ID 列表（按 order/name 排序）。\"\"\"\n   849→    metas = get_protocols_meta(skill_id)\n   850→    enabled = [m for m in metas.values() if m.get(\"enabled\", True)]\n   851→    enabled.sort(key=lambda m: (m.get(\"order\", 0), m.get(\"name\", m.get(\"id\"))))\n   852→    return [m[\"id\"] for m in enabled]\n   853→\n   854→\n   855→def get_rule_name(skill_id: str, rule_id: str) -> str:\n   856→    \"\"\"返回规则显示名（frontmatter.name），失败则回退 rule_id。\"\"\"\n   857→    rc = load_rule(skill_id, rule_id)\n   858→    return rc.name if rc else rule_id\n   859→\n   860→\n   861→# ═══════════════════════════════════════════════════════════════════════════\n   862→# Case Index 配置（用于提取特征字段，消除硬编码）\n   863→# ═══════════════════════════════════════════════════════════════════════════\n   864→\n   865→@lru_cache(maxsize=64)\n   866→def get_case_index_config(skill_id: str) -> Dict[str, Any]:\n   867→    \"\"\"从 SKILL.md frontmatter 读取 case_index 配置。\n   868→\n   869→    约定：\n   870→    case_index:\n   871→      nested_key: \"chart\"   # 可选\n   872→      fields: [\"daymaster\", \"strength\", \"pattern\"]  # 必选\n   873→    或简写：case_fields: [\"...\"]\n   874→    \"\"\"\n   875→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   876→    if not skill_path.exists():\n   877→        return {}\n   878→    try:\n   879→        text = skill_path.read_text(encoding=\"utf-8\")\n   880→        fm, _ = parse_frontmatter(text)\n   881→        cfg = fm.get(\"case_index\") or {}\n   882→        if not cfg and fm.get(\"case_fields\"):\n   883→            cfg = {\"fields\": fm.get(\"case_fields\")}\n   884→        # 规范化\n   885→        nested_key = cfg.get(\"nested_key\")\n   886→        fields = cfg.get(\"fields\") if isinstance(cfg.get(\"fields\"), list) else []\n   887→        return {\"nested_key\": nested_key, \"fields\": fields}\n   888→    except Exception:\n   889→        return {}\n   890→\n   891→\n   892→def get_skill_scenarios(skill_id: str) -> List[str]:\n   893→    \"\"\"获取 Skill 的所有场景\n   894→\n   895→    支持两种架构：\n   896→    1. 旧架构：scenarios/*.md\n   897→    2. 新架构：rules/*.md（Agentic 架构，支持子目录）\n   898→\n   899→    返回格式：\n   900→    - 根目录规则: \"dankoe\"\n   901→    - 子目录规则: \"companion/weekly-review\"\n   902→    \"\"\"\n   903→    # 优先检查 rules 目录（新架构）\n   904→    rules_dir = SKILLS_DIR / skill_id / \"rules\"\n   905→    if rules_dir.exists():\n   906→        rule_ids = []\n   907→        # 递归查找所有 .md 文件（支持子目录）\n   908→        for md_file in rules_dir.rglob(\"*.md\"):\n   909→            # 跳过 _index.md 等\n   910→            if md_file.stem.startswith(\"_\"):\n   911→                continue\n   912→\n   913→            # 计算相对路径（去掉 .md 扩展名）\n   914→            relative_path = md_file.relative_to(rules_dir)\n   915→            rule_id = str(relative_path.with_suffix(\"\"))\n   916→\n   917→            # 转换 Windows 路径分隔符为 Unix 格式\n   918→            rule_id = rule_id.replace(\"\\\\\", \"/\")\n   919→\n   920→            rule_ids.append(rule_id)\n   921→\n   922→        if rule_ids:\n   923→            return sorted(rule_ids)\n   924→\n   925→    # 回退到 scenarios 目录（旧架构）\n   926→    scenarios_dir = SKILLS_DIR / skill_id / \"scenarios\"\n   927→    if not scenarios_dir.exists():\n   928→        return []\n   929→    return [p.stem for p in scenarios_dir.glob(\"*.md\")]\n   930→\n   931→\n   932→def get_skill_triggers() -> Dict[str, List[str]]:\n   933→    \"\"\"获取所有 Skill 的触发词\"\"\"\n   934→    triggers = {}\n   935→    for skill_id in get_available_skills():\n   936→        if skill_id == \"core\":\n   937→            continue\n   938→        skill = load_skill(skill_id)\n   939→        if skill and skill.triggers:\n   940→            triggers[skill_id] = skill.triggers\n   941→    return triggers\n   942→\n   943→\n   944→def get_skill_global_tools(skill_id: str) -> List[str]:\n   945→    \"\"\"获取 Skill 声明需要的全局工具列表\"\"\"\n   946→    skill = load_skill(skill_id)\n   947→    if skill and skill.global_tools:\n   948→        return skill.global_tools\n   949→    # 默认返回所有全局工具（向后兼容）\n   950→    return []\n   951→\n   952→\n   953→def get_skill_external_tools(skill_id: str) -> List[str]:\n   954→    \"\"\"获取 Skill 声明需要从其他 Skill 导入的工具列表 (v7.3)\"\"\"\n   955→    skill = load_skill(skill_id)\n   956→    if skill and skill.external_tools:\n   957→        return skill.external_tools\n   958→    return []\n   959→\n   960→\n   961→# ═══════════════════════════════════════════════════════════════════════════\n   962→# V9: 渐进式加载函数\n   963→# ═══════════════════════════════════════════════════════════════════════════\n   964→\n   965→def get_core_skill() -> SkillFull:\n   966→    \"\"\"获取 Core Skill（全程可用，全文加载）- V9 新增\n   967→\n   968→    Core Skill 始终全文加载，不参与渐进式加载。\n   969→    返回包含 SKILL.md 全文和工具定义的 SkillFull 对象。\n   970→    \"\"\"\n   971→    global _core_skill_cache\n   972→\n   973→    if _core_skill_cache is not None:\n   974→        return _core_skill_cache\n   975→\n   976→    skill_id = \"core\"\n   977→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n   978→\n   979→    if not skill_path.exists():\n   980→        # 返回空的 Core Skill\n   981→        _core_skill_cache = SkillFull(\n   982→            meta=SkillMeta(id=\"core\", name=\"Vibe\", description=\"生命对话者\"),\n   983→            content=\"\",\n   984→            tools=[],\n   985→            rules={}\n   986→        )\n   987→        return _core_skill_cache\n   988→\n   989→    text = skill_path.read_text(encoding='utf-8')\n   990→    metadata, content = parse_frontmatter(text)\n   991→\n   992→    # 构建 SkillMeta\n   993→    meta = SkillMeta(\n   994→        id=metadata.get(\"id\", skill_id),\n   995→        name=metadata.get(\"name\", \"Vibe\"),\n   996→        description=metadata.get(\"description\", \"\"),\n   997→        triggers=metadata.get(\"triggers\", []),\n   998→        category=metadata.get(\"category\", \"core\"),\n   999→    )\n  1000→\n  1001→    # 加载工具定义\n  1002→    tools = _load_skill_tools(skill_id)\n  1003→\n  1004→    # 加载规则文件\n  1005→    rules = _load_skill_rules_content(skill_id)\n  1006→\n  1007→    _core_skill_cache = SkillFull(\n  1008→        meta=meta,\n  1009→        content=content,\n  1010→        tools=tools,\n  1011→        rules=rules,\n  1012→    )\n  1013→\n  1014→    logger.info(f\"[V9] Core skill loaded: {len(content)} chars, {len(tools)} tools, {len(rules)} rules\")\n  1015→    return _core_skill_cache\n  1016→\n  1017→\n  1018→def load_all_skill_metas() -> Dict[str, SkillMeta]:\n  1019→    \"\"\"启动时加载所有非 Core Skill 的 frontmatter - V9 新增\n  1020→\n  1021→    只加载 frontmatter（SkillMeta），用于 Phase 1 路由。\n  1022→    description 内嵌工具列表，无需额外加载。\n  1023→    \"\"\"\n  1024→    global _skill_metas_cache\n  1025→\n  1026→    if _skill_metas_cache is not None:\n  1027→        return _skill_metas_cache\n  1028→\n  1029→    _skill_metas_cache = {}\n  1030→\n  1031→    for skill_id in get_available_skills():\n  1032→        if skill_id == \"core\":\n  1033→            continue\n  1034→\n  1035→        skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n  1036→        if not skill_path.exists():\n  1037→            continue\n  1038→\n  1039→        try:\n  1040→            text = skill_path.read_text(encoding='utf-8')\n  1041→            metadata, _ = parse_frontmatter(text)\n  1042→\n  1043→            # 从 description 中提取触发词（如果 frontmatter 中没有）\n  1044→            triggers = metadata.get(\"triggers\", [])\n  1045→            if not triggers:\n  1046→                description = metadata.get(\"description\", \"\")\n  1047→                trigger_match = re.search(r'触发词[：:]\\s*([^。.]+)', description)\n  1048→                if trigger_match:\n  1049→                    trigger_str = trigger_match.group(1)\n  1050→                    triggers = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]\n  1051→\n  1052→            tools_list = _extract_tools_list(skill_id, metadata.get(\"description\", \"\"))\n  1053→\n  1054→            _skill_metas_cache[skill_id] = SkillMeta(\n  1055→                id=metadata.get(\"id\", skill_id),\n  1056→                name=metadata.get(\"name\", skill_id),\n  1057→                description=metadata.get(\"description\", \"\"),\n  1058→                triggers=triggers,\n  1059→                category=metadata.get(\"category\", \"professional\"),\n  1060→                tools_list=tools_list,\n  1061→            )\n  1062→        except Exception as e:\n  1063→            logger.warning(f\"[V9] Failed to load skill meta for {skill_id}: {e}\")\n  1064→\n  1065→    logger.info(f\"[V9] Loaded {len(_skill_metas_cache)} skill metas\")\n  1066→    return _skill_metas_cache\n  1067→\n  1068→\n  1069→def load_skill_full(skill_id: str) -> Optional[SkillFull]:\n  1070→    \"\"\"按需加载 Skill 完整内容 - V9 新增\n  1071→\n  1072→    Phase 2 时调用，加载 SKILL.md 全文、工具定义、规则文件。\n  1073→    \"\"\"\n  1074→    if skill_id == \"core\":\n  1075→        return get_core_skill()\n  1076→\n  1077→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n  1078→    if not skill_path.exists():\n  1079→        return None\n  1080→\n  1081→    try:\n  1082→        text = skill_path.read_text(encoding='utf-8')\n  1083→        metadata, content = parse_frontmatter(text)\n  1084→\n  1085→        # 从 description 中提取触发词\n  1086→        triggers = metadata.get(\"triggers\", [])\n  1087→        if not triggers:\n  1088→            description = metadata.get(\"description\", \"\")\n  1089→            trigger_match = re.search(r'触发词[：:]\\s*([^。.]+)', description)\n  1090→            if trigger_match:\n  1091→                trigger_str = trigger_match.group(1)\n  1092→                triggers = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]\n  1093→\n  1094→        meta = SkillMeta(\n  1095→            id=metadata.get(\"id\", skill_id),\n  1096→            name=metadata.get(\"name\", skill_id),\n  1097→            description=metadata.get(\"description\", \"\"),\n  1098→            triggers=triggers,\n  1099→            category=metadata.get(\"category\", \"professional\"),\n  1100→        )\n  1101→\n  1102→        # 加载工具定义\n  1103→        tools = _load_skill_tools(skill_id)\n  1104→\n  1105→        # 加载规则文件\n  1106→        rules = _load_skill_rules_content(skill_id)\n  1107→\n  1108→        skill_full = SkillFull(\n  1109→            meta=meta,\n  1110→            content=content,\n  1111→            tools=tools,\n  1112→            rules=rules,\n  1113→        )\n  1114→\n  1115→        logger.info(f\"[V9] Skill {skill_id} full loaded: {len(content)} chars, {len(tools)} tools, {len(rules)} rules\")\n  1116→        return skill_full\n  1117→\n  1118→    except Exception as e:\n  1119→        logger.error(f\"[V9] Failed to load skill full for {skill_id}: {e}\")\n  1120→        return None\n  1121→\n  1122→\n  1123→def _load_skill_tools(skill_id: str) -> List[ToolDef]:\n  1124→    \"\"\"加载 Skill 的工具定义 - V9 内部函数\"\"\"\n  1125→    tools_path = SKILLS_DIR / skill_id / \"tools\" / \"tools.yaml\"\n  1126→    if not tools_path.exists():\n  1127→        return []\n  1128→\n  1129→    try:\n  1130→        text = tools_path.read_text(encoding='utf-8')\n  1131→        data = yaml.safe_load(text) or {}\n  1132→\n  1133→        tools = []\n  1134→        # V9 格式：tools 列表\n  1135→        if \"tools\" in data:\n  1136→            for tool in data[\"tools\"]:\n  1137→                tools.append(ToolDef(\n  1138→                    name=tool.get(\"name\", \"\"),\n  1139→                    description=tool.get(\"description\", \"\"),\n  1140→                    parameters={p.get(\"name\", \"\"): p for p in tool.get(\"parameters\", [])},\n  1141→                    tool_type=tool.get(\"type\", \"action\"),\n  1142→                ))\n  1143→        else:\n  1144→            # V2 格式：按类别分组\n  1145→            for category in [\"routing\", \"collect\", \"action\", \"search\", \"display\", \"trigger\"]:\n  1146→                for tool in data.get(category, []):\n  1147→                    tools.append(ToolDef(\n  1148→                        name=tool.get(\"name\", \"\"),\n  1149→                        description=tool.get(\"description\", \"\"),\n  1150→                        parameters={p.get(\"name\", \"\"): p for p in tool.get(\"parameters\", [])},\n  1151→                        tool_type=category,\n  1152→                    ))\n  1153→\n  1154→        return tools\n  1155→    except Exception as e:\n  1156→        logger.warning(f\"[V9] Failed to load tools for {skill_id}: {e}\")\n  1157→        return []\n  1158→\n  1159→\n  1160→def _load_skill_rules_content(skill_id: str) -> Dict[str, str]:\n  1161→    \"\"\"加载 Skill 的所有规则文件内容 - V9 内部函数\"\"\"\n  1162→    rules_dir = SKILLS_DIR / skill_id / \"rules\"\n  1163→    if not rules_dir.exists():\n  1164→        return {}\n  1165→\n  1166→    rules = {}\n  1167→    for md_file in rules_dir.rglob(\"*.md\"):\n  1168→        if md_file.stem.startswith(\"_\"):\n  1169→            continue\n  1170→\n  1171→        try:\n  1172→            relative_path = md_file.relative_to(rules_dir)\n  1173→            rule_id = str(relative_path.with_suffix(\"\")).replace(\"\\\\\", \"/\")\n  1174→            rules[rule_id] = md_file.read_text(encoding='utf-8')\n  1175→        except Exception as e:\n  1176→            logger.warning(f\"[V9] Failed to load rule {md_file}: {e}\")\n  1177→\n  1178→    return rules\n  1179→\n  1180→\n  1181→def build_phase1_prompt() -> str:\n  1182→    \"\"\"构建 Phase 1 System Prompt - V9 新增\n  1183→\n  1184→    Phase 1 提供：\n  1185→    - Core Skill 全文（精简版）\n  1186→    - 其他 Skill 的 frontmatter 列表（id, name, description）\n  1187→\n  1188→    LLM 基于此选择 Skill(s)。\n  1189→    \"\"\"\n  1190→    parts = []\n  1191→\n  1192→    # 1. Core Skill 全文（精简文本优先：若超过 5000 字符则截断）\n  1193→    core = get_core_skill()\n  1194→    core_text = core.content\n  1195→    if len(core_text) > 5000:\n  1196→        core_text = core_text[:5000] + \"\\n\\n…\"\n  1197→    parts.append(f\"# {core.meta.name}\\n\\n{core_text}\")\n  1198→\n  1199→    # 2. 可用 Skill 列表\n  1200→    skill_metas = load_all_skill_metas()\n  1201→    if skill_metas:\n  1202→        parts.append(\"\\n---\\n\\n## 可用功能\\n\")\n  1203→        parts.append(\"根据用户意图，可调用 activate_skills 激活一个或多个技能：\\n\")\n  1204→\n  1205→        for skill_id, meta in sorted(skill_metas.items()):\n  1206→            desc = meta.description.strip().replace('\\n', ' ')\n  1207→            if len(desc) > 120:\n  1208→                desc = desc[:120] + '…'\n  1209→            line = f\"- **{meta.name}** (`{skill_id}`): {desc}\"\n  1210→            if meta.tools_list:\n  1211→                tools_text = \", \".join(meta.tools_list[:6])\n  1212→                line += f\"（工具：{tools_text}）\"\n  1213→            parts.append(line)\n  1214→\n  1215→    # 3. 边界规则（来自 core/rules/boundary.md）\n  1216→    boundary = load_boundary_rules_text()\n  1217→    if boundary:\n  1218→        parts.append(\"\\n---\\n\")\n  1219→        parts.append(boundary)\n  1220→\n  1221→    # 4. Phase 1 约束\n  1222→    parts.append(\"\\n---\\n## 约束\\n- 本轮只允许：activate_skills、ask、show\\n- 禁止假设未激活 Skill 的工具存在\\n- 禁止编造：不要假装知道用户的命盘/星座数据\\n\")\n  1223→\n  1224→    return \"\\n\".join(parts)\n  1225→\n  1226→\n  1227→def _extract_tools_list(skill_id: str, description: str) -> List[str]:\n  1228→    \"\"\"提取工具名清单（优先 tools.yaml，其次从 description 正则解析）。\"\"\"\n  1229→    try:\n  1230→        import yaml  # 本地依赖\n  1231→        tools_yaml = SKILLS_DIR / skill_id / \"tools\" / \"tools.yaml\"\n  1232→        if tools_yaml.exists():\n  1233→            data = yaml.safe_load(tools_yaml.read_text(encoding='utf-8')) or {}\n  1234→            tools = []\n  1235→            # 兼容两种结构：顶层 tools: [] 或 按分组键 []\n  1236→            if isinstance(data.get(\"tools\"), list):\n  1237→                for item in data[\"tools\"]:\n  1238→                    if isinstance(item, dict) and item.get(\"name\"):\n  1239→                        tools.append(item[\"name\"])\n  1240→            # 遍历所有一级分组键\n  1241→            for k, v in data.items():\n  1242→                if k in {\"version\", \"skill_id\", \"description\", \"phase1_tools\"}:\n  1243→                    continue\n  1244→                if isinstance(v, list):\n  1245→                    for item in v:\n  1246→                        if isinstance(item, dict) and item.get(\"name\"):\n  1247→                            tools.append(item[\"name\"])\n  1248→            # 去重保持顺序\n  1249→            seen = set()\n  1250→            dedup = []\n  1251→            for t in tools:\n  1252→                if t not in seen:\n  1253→                    seen.add(t)\n  1254→                    dedup.append(t)\n  1255→            return dedup\n  1256→    except Exception as e:\n  1257→        logger.debug(f\"[V9] extract tools_list failed for {skill_id}: {e}\")\n  1258→\n  1259→    # 回退：从 description 提取\n  1260→    match = re.search(r'工具[：:]\\s*([^\\n。]+)', description or \"\")\n  1261→    if match:\n  1262→        return [t.strip() for t in re.split(r'[、,，]', match.group(1)) if t.strip()]\n  1263→    return []\n  1264→\n  1265→\n  1266→def load_boundary_rules_text() -> str:\n  1267→    \"\"\"读取 Core 边界规则（core/rules/boundary.md）。找不到则返回空。\"\"\"\n  1268→    path = SKILLS_DIR / \"core\" / \"rules\" / \"boundary.md\"\n  1269→    try:\n  1270→        if path.exists():\n  1271→            return path.read_text(encoding='utf-8')\n  1272→    except Exception as e:\n  1273→        logger.debug(f\"[V9] load boundary rules failed: {e}\")\n  1274→    return \"\"\n  1275→\n  1276→\n  1277→def build_phase2_prompt(\n  1278→    active_skills: List[str],\n  1279→    user_context: Optional[Dict] = None,\n  1280→    active_rule: Optional[str] = None\n  1281→) -> str:\n  1282→    \"\"\"构建 Phase 2 System Prompt - V9 新增\n  1283→\n  1284→    Phase 2 提供：\n  1285→    - Core Skill 全文（始终存在）\n  1286→    - 已激活 Skill 的完整 SKILL.md\n  1287→    - 相关 rules/*.md\n  1288→    - Profile + Skill Data\n  1289→\n  1290→    Args:\n  1291→        active_skills: 已激活的 Skill ID 列表\n  1292→        user_context: 用户上下文\n  1293→        active_rule: 当前激活的规则 ID\n  1294→\n  1295→    Returns:\n  1296→        完整的 System Prompt\n  1297→    \"\"\"\n  1298→    parts = []\n  1299→\n  1300→    # 1. Core Skill 全文\n  1301→    core = get_core_skill()\n  1302→    parts.append(f\"# {core.meta.name}\\n\\n{core.content}\")\n  1303→\n  1304→    # 2. 已激活 Skill 的完整内容\n  1305→    for skill_id in active_skills:\n  1306→        if skill_id == \"core\":\n  1307→            continue\n  1308→\n  1309→        skill_full = load_skill_full(skill_id)\n  1310→        if skill_full:\n  1311→            parts.append(f\"\\n---\\n\\n# {skill_full.meta.name}\\n\\n{skill_full.content}\")\n  1312→\n  1313→            # 如果有激活的规则，加载规则内容\n  1314→            if active_rule and active_rule in skill_full.rules:\n  1315→                rule_content = skill_full.rules[active_rule]\n  1316→                _, rule_body = parse_frontmatter(rule_content)\n  1317→                parts.append(f\"\\n## 当前规则\\n{rule_body}\")\n  1318→\n  1319→    # 3. 边界规则（来自 core/rules/boundary.md）\n  1320→    boundary = load_boundary_rules_text()\n  1321→    if boundary:\n  1322→        parts.append(boundary)\n  1323→\n  1324→    # 4. 用户上下文\n  1325→    if user_context:\n  1326→        ctx_text = \"\\n## 用户上下文\\n\"\n  1327→\n  1328→        # 出生信息\n  1329→        if user_context.get(\"birth_info\"):\n  1330→            birth_info = user_context['birth_info']\n  1331→            ctx_text += f\"\\n### 出生信息（已收集）\\n\"\n  1332→            ctx_text += f\"{json.dumps(birth_info, ensure_ascii=False)}\\n\"\n  1333→\n  1334→        # VibeInsight\n  1335→        vibe = user_context.get(\"vibe\", {})\n  1336→        if vibe.get(\"insight\"):\n  1337→            insight = vibe[\"insight\"]\n  1338→            ctx_text += f\"\\n### 用户画像\\n\"\n  1339→            if insight.get(\"essence\", {}).get(\"archetype\", {}).get(\"primary\"):\n  1340→                ctx_text += f\"- 主要原型: {insight['essence']['archetype']['primary']}\\n\"\n  1341→\n  1342→        # VibeTarget\n  1343→        if vibe.get(\"target\"):\n  1344→            target = vibe[\"target\"]\n  1345→            if target.get(\"north_star\", {}).get(\"vision_scene\"):\n  1346→                ctx_text += f\"\\n### 愿景\\n{target['north_star']['vision_scene'][:200]}\\n\"\n  1347→\n  1348→        parts.append(ctx_text)\n  1349→\n  1350→    return \"\\n\".join(parts)\n  1351→\n  1352→\n  1353→def clear_v9_cache():\n  1354→    \"\"\"清除 V9 缓存 - V9 新增\"\"\"\n  1355→    global _core_skill_cache, _skill_metas_cache\n  1356→    _core_skill_cache = None\n  1357→    _skill_metas_cache = None\n  1358→    logger.info(\"[V9] Cache cleared\")\n  1359→\n  1360→\n  1361→# ═══════════════════════════════════════════════════════════════════════════\n  1362→# v7.1: SOP 配置查询函数\n  1363→# ═══════════════════════════════════════════════════════════════════════════\n  1364→\n  1365→def skill_requires_birth_info(skill_id: str) -> bool:\n  1366→    \"\"\"检查 Skill 是否需要出生信息（配置驱动）\"\"\"\n  1367→    skill = load_skill(skill_id)\n  1368→    return skill.requires_birth_info if skill else False\n  1369→\n  1370→\n  1371→def skill_requires_compute(skill_id: str) -> bool:\n  1372→    \"\"\"检查 Skill 是否需要计算/排盘（配置驱动）\"\"\"\n  1373→    skill = load_skill(skill_id)\n  1374→    return skill.requires_compute if skill else False\n  1375→\n  1376→\n  1377→def get_skill_compute_type(skill_id: str) -> Optional[str]:\n  1378→    \"\"\"获取 Skill 的计算类型（配置驱动）\n  1379→\n  1380→    返回值：\n  1381→    - None: 使用自身的计算器\n  1382→    - \"zodiac\": 使用 zodiac 计算器（如 jungastro）\n  1383→    - \"bazi\": 使用 bazi 计算器\n  1384→    \"\"\"\n  1385→    skill = load_skill(skill_id)\n  1386→    return skill.compute_type if skill else None\n  1387→\n  1388→\n  1389→def get_skill_compute_tool(skill_id: str) -> Optional[str]:\n  1390→    \"\"\"获取 Skill 的计算工具名（配置驱动）\n  1391→\n  1392→    返回值：\n  1393→    - 配置的工具名（如 \"calculate_zodiac\"）\n  1394→    - None: 使用默认约定 calculate_{compute_type}\n  1395→    \"\"\"\n  1396→    skill = load_skill(skill_id)\n  1397→    return skill.compute_tool if skill else None\n  1398→\n  1399→\n  1400→def get_skill_collect_tool(skill_id: str) -> Optional[str]:\n  1401→    \"\"\"获取 Skill 的收集工具名（配置驱动）\n  1402→\n  1403→    返回值：\n  1404→    - 配置的工具名（如 \"collect_birth_info\"）\n  1405→    - None: 使用默认约定 request_info\n  1406→    \"\"\"\n  1407→    skill = load_skill(skill_id)\n  1408→    return skill.collect_tool if skill else None\n  1409→\n  1410→\n  1411→def get_skill_required_data(skill_id: str) -> List[str]:\n  1412→    \"\"\"获取 Skill 需要的 skill_data 列表（配置驱动）- v2.2\n  1413→\n  1414→    返回值：\n  1415→    - 配置的 skill_data 列表（如 [\"bazi\", \"zodiac\"]）\n  1416→    - 空列表时返回 [skill_id]（默认只需自身数据）\n  1417→\n  1418→    示例：\n  1419→    - bazi → [\"bazi\"]（默认，只需自身）\n  1420→    - jungastro → [\"bazi\", \"zodiac\"]（配置了 requires_skill_data）\n  1421→    - vibe_id → [\"bazi\", \"zodiac\"]（配置了 requires_skill_data）\n  1422→    \"\"\"\n  1423→    skill = load_skill(skill_id)\n  1424→    if skill and skill.requires_skill_data:\n  1425→        return skill.requires_skill_data\n  1426→    return [skill_id]  # 默认只需自身\n  1427→\n  1428→\n  1429→# ═══════════════════════════════════════════════════════════════════════════\n  1430→# System Prompt 构建\n  1431→# ═══════════════════════════════════════════════════════════════════════════\n  1432→\n  1433→# V2: 语气模式 Prompt 模板\n  1434→# 与数据库约束一致：warm, sarcastic, wise\n  1435→VOICE_MODE_PROMPTS = {\n  1436→    \"warm\": \"\"\"## 语气风格：温暖支持型\n  1437→像一个理解你的老朋友，温暖但不失洞察。\n  1438→- 用\"我们\"而非\"你应该\"\n  1439→- 先肯定感受，再引导思考\n  1440→- 用问题代替建议\n  1441→\"\"\",\n  1442→    \"sarcastic\": \"\"\"## 语气风格：直接挑战型（毒舌但有爱）\n  1443→用幽默和犀利的方式戳破你的自欺欺人，推动你面对真相。\n  1444→- 直接指出问题，不绕弯子\n  1445→- 用幽默缓解犀利，避免伤害\n  1446→- 在吐槽中带着期待和关心\n  1447→- 敢说真话，但从不恶意攻击\n  1448→\"\"\",\n  1449→    \"wise\": \"\"\"## 语气风格：睿智导师型\n  1450→像一位经历丰富的长辈，用深度和理性引导思考。\n  1451→- 从更高视角看待问题\n  1452→- 引用经典智慧和原理\n  1453→- 温和但坚定地指点迷津\n  1454→- 帮助看到更长远的意义\n  1455→\"\"\"\n  1456→}\n  1457→\n  1458→\n  1459→def _build_persona_prompt(skill_id: str, user_context: Optional[Dict] = None) -> Optional[str]:\n  1460→    \"\"\"\n  1461→    V3: 构建 Persona Prompt - 增强版 Future Self (v8.0)\n  1462→\n  1463→    根据用户的 lifecoach 状态动态生成 persona prompt。\n  1464→    基于 vision_scene 内容生成个性化的 future_self 人格。\n  1465→\n  1466→    Args:\n  1467→        skill_id: Skill ID\n  1468→        user_context: 用户上下文，包含 skills.lifecoach 或 vibe.target 数据\n  1469→\n  1470→    Returns:\n  1471→        Persona prompt 字符串，或 None（如果不需要 persona）\n  1472→    \"\"\"\n  1473→    # 只有 lifecoach 支持 persona\n  1474→    if skill_id != \"lifecoach\":\n  1475→        return None\n  1476→\n  1477→    # 获取用户的 lifecoach 状态 (v9.0: 只从 skills.lifecoach 读取)\n  1478→    lifecoach_data = {}\n  1479→    if user_context:\n  1480→        skills = user_context.get(\"skills\", {})\n  1481→        lifecoach_data = skills.get(\"lifecoach\", {})\n  1482→\n  1483→    # 获取 persona 设置\n  1484→    system_config = lifecoach_data.get(\"system\", {})\n  1485→    persona_id = system_config.get(\"persona\", \"future_self\")\n  1486→\n  1487→    if persona_id == \"future_self\":\n  1488→        # 从用户的北极星愿景构建 future_self persona\n  1489→        north_star = lifecoach_data.get(\"north_star\", {})\n  1490→        identity_data = lifecoach_data.get(\"identity\", {})\n  1491→        vision_scene = north_star.get(\"vision_scene\", \"\")\n  1492→        vision_timeframe = north_star.get(\"vision_timeframe\", \"3年后\")\n  1493→        identity_target = identity_data.get(\"target\", \"\")\n  1494→\n  1495→        if vision_scene or identity_target:\n  1496→            persona_prompt = f\"\"\"## 你的身份：来自未来的 TA\n  1497→\n  1498→你是{vision_timeframe}的用户自己——那个已经实现愿景的版本。\n  1499→\n  1500→**你的愿景场景**：\n  1501→{vision_scene if vision_scene else \"（用户尚未设定具体愿景场景）\"}\n  1502→\n  1503→**你的身份**：\n  1504→{identity_target if identity_target else \"（用户尚未设定身份宣言）\"}\n  1505→\n  1506→**问候生成规则**（由你根据愿景场景自行生成）：\n  1507→- 基于上面的「愿景场景」，想象你（未来的TA）此刻正在做什么\n  1508→- 用第一人称描述你当前的场景，让用户\"看见\"那个未来\n  1509→- 问候要简短、温暖、有画面感\n  1510→- 示例格式：\"早上好！我是[场景描述]的你。[当前状态]。你那边怎么样？\"\n  1511→\n  1512→**对话原则**：\n  1513→- 以\"过来人\"的视角分享，而非说教\n  1514→- 问候时描述你（未来的TA）当前的场景，让用户\"看见\"那个未来\n  1515→- 用\"我当时也...\"开头，建立共鸣\n  1516→- 温和但坚定地指出现在的选择如何影响未来\n  1517→- 当用户迷茫时，提醒他们\"你已经知道答案了\"\n  1518→- 当用户完成行动时，真诚庆祝\n  1519→\n  1520→**禁止行为**：\n  1521→- 不说\"你应该\"、\"你必须\"\n  1522→- 不说\"你昨天没签到\"、\"你断签了\"\n  1523→- 不施加压力，总是给用户选择权\n  1524→\"\"\"\n  1525→        else:\n  1526→            # 用户还没有设定愿景，使用默认教练身份\n  1527→            persona_prompt = \"\"\"## 你的身份：人生教练\n  1528→\n  1529→用户尚未设定愿景。作为教练，你的首要任务是：\n  1530→1. 先连接，后诊断——回应情绪，再探索问题\n  1531→2. 一次一个问题——不列选项清单\n  1532→3. 跟随用户线索——用户提到什么就深入什么\n  1533→\n  1534→当识别出 2-3 个核心困扰后，可以提议：\n  1535→\"想花10分钟做一次快速梳理吗？我会问你6个问题，帮你看清方向。\"\n  1536→\n  1537→一旦用户完成愿景设计，你将切换为\"来自未来的 TA\"视角。\n  1538→\"\"\"\n  1539→        return persona_prompt\n  1540→\n  1541→    elif persona_id == \"coach\":\n  1542→        return \"\"\"## 你的身份：专业教练\n  1543→\n  1544→你是一位专业、温暖但直接的人生教练。\n  1545→\n  1546→**对话原则**：\n  1547→- 专业但不冷漠\n  1548→- 直接但有温度\n  1549→- 挑战但不伤害\n  1550→- 用问题引导觉察\n  1551→\"\"\"\n  1552→\n  1553→    return None\n  1554→\n  1555→\n  1556→@lru_cache(maxsize=32)\n  1557→def _load_skill_md_content(skill_id: str) -> str:\n  1558→    \"\"\"加载 SKILL.md 全文内容（去掉 frontmatter）\"\"\"\n  1559→    skill_path = SKILLS_DIR / skill_id / \"SKILL.md\"\n  1560→    if not skill_path.exists():\n  1561→        return \"\"\n  1562→    text = skill_path.read_text(encoding='utf-8')\n  1563→    _, content = parse_frontmatter(text)\n  1564→    return content\n  1565→\n  1566→\n  1567→def build_system_prompt(\n  1568→    skill_id: str,\n  1569→    scenario_id: Optional[str] = None,\n  1570→    user_context: Optional[Dict] = None\n  1571→) -> str:\n  1572→    \"\"\"构建完整的 System Prompt\n  1573→\n  1574→    v7 更新：支持 rules 架构，scenario_id 可以是 rule_id\n  1575→    v8 更新：支持 persona 和 voice_mode 注入\n  1576→    v10 更新：直接加载 SKILL.md 全文（去掉 frontmatter），确保所有规则都被加载\n  1577→    \"\"\"\n  1578→    parts = []\n  1579→\n  1580→    # 加载 Skill\n  1581→    skill = load_skill(skill_id)\n  1582→    if not skill:\n  1583→        return \"\"\n  1584→\n  1585→    # V2: Persona 注入（在专家身份之前）- 仅 lifecoach 支持\n  1586→    persona_prompt = _build_persona_prompt(skill_id, user_context)\n  1587→    if persona_prompt:\n  1588→        parts.append(persona_prompt)\n  1589→    else:\n  1590→        # v10: 直接加载 SKILL.md 全文（去掉 frontmatter）\n  1591→        skill_md_content = _load_skill_md_content(skill_id)\n  1592→        if skill_md_content:\n  1593→            parts.append(skill_md_content)\n  1594→        else:\n  1595→            # Fallback: 只加载专家身份\n  1596→            parts.append(f\"# {skill.name}\\n\\n{skill.expert_persona}\")\n  1597→\n  1598→    # V2: Voice Mode 注入\n  1599→    if user_context:\n  1600→        preferences = user_context.get(\"preferences\", {})\n  1601→        voice_mode = preferences.get(\"voice_mode\", \"warm\")\n  1602→        if voice_mode in VOICE_MODE_PROMPTS:\n  1603→            parts.append(VOICE_MODE_PROMPTS[voice_mode])\n  1604→\n  1605→    # 加载场景或规则\n  1606→    if scenario_id:\n  1607→        # v7: 优先尝试加载规则\n  1608→        if has_rules(skill_id):\n  1609→            rule = load_rule(skill_id, scenario_id)\n  1610→            if rule:\n  1611→                parts.append(f\"\\n---\\n\\n## 当前规则: {rule.name}\\n\")\n  1612→                # 添加规则完整内容\n  1613→                parts.append(rule.content)\n  1614→            else:\n  1615→                # 规则不存在，尝试加载场景（向后兼容）\n  1616→                scenario = load_scenario(skill_id, scenario_id)\n  1617→                if scenario:\n  1618→                    parts.append(f\"\\n---\\n\\n## 当前场景: {scenario.name}\\n\\n{scenario.description}\")\n  1619→                    if scenario.sop:\n  1620→                        sop_text = \"\\n## 服务流程 (SOP)\\n\\n\"\n  1621→                        for phase in scenario.sop:\n  1622→                            sop_text += f\"### Phase {phase['phase']}: {phase['name']}\\n{phase['content']}\\n\\n\"\n  1623→                        parts.append(sop_text)\n  1624→        else:\n  1625→            # 旧架构：加载场景\n  1626→            scenario = load_scenario(skill_id, scenario_id)\n  1627→            if scenario:\n  1628→                parts.append(f\"\\n---\\n\\n## 当前场景: {scenario.name}\\n\\n{scenario.description}\")\n  1629→                # SOP\n  1630→                if scenario.sop:\n  1631→                    sop_text = \"\\n## 服务流程 (SOP)\\n\\n\"\n  1632→                    for phase in scenario.sop:\n  1633→                        sop_text += f\"### Phase {phase['phase']}: {phase['name']}\\n{phase['content']}\\n\\n\"\n  1634→                    parts.append(sop_text)\n  1635→\n  1636→    # v10: 伦理边界已在 SKILL.md 全文中，无需重复注入\n  1637→\n  1638→    # 边界规则：从 core/rules/boundary.md 注入\n  1639→    boundary = load_boundary_rules_text()\n  1640→    if boundary:\n  1641→        parts.append(boundary)\n  1642→\n  1643→    # 用户上下文 - 自动处理所有字段 (v8.0 三层架构兼容)\n  1644→    if user_context:\n  1645→        ctx_text = \"\\n## 用户上下文\\n\"\n  1646→\n  1647→        # 特殊处理 birth_info\n  1648→        if user_context.get(\"birth_info\"):\n  1649→            birth_info = user_context['birth_info']\n  1650→            ctx_text += f\"\\n### 出生信息（已收集，无需再次询问）\\n\"\n  1651→            ctx_text += f\"{json.dumps(birth_info, ensure_ascii=False)}\\n\"\n  1652→            ctx_text += f\"\\n**重要**: 用户已提供出生信息，可以直接进行排盘和分析，无需调用 collect_bazi_info 工具。\\n\"\n  1653→\n  1654→        # 特殊处理 portrait\n  1655→        if user_context.get(\"portrait\"):\n  1656→            ctx_text += f\"\\n### 用户画像\\n{user_context['portrait']}\\n\"\n  1657→\n  1658→        # v8.0: 优先使用 vibe 结构\n  1659→        vibe = user_context.get(\"vibe\", {})\n  1660→        vibe_insight = vibe.get(\"insight\", {})\n  1661→        vibe_target = vibe.get(\"target\", {})\n  1662→\n  1663→        # VibeInsight - 用户画像（我是谁）\n  1664→        if vibe_insight:\n  1665→            ctx_text += f\"\\n### 用户画像 (VibeInsight)\\n\"\n  1666→            # 本质\n  1667→            essence = vibe_insight.get(\"essence\", {})\n  1668→            if essence.get(\"archetype\", {}).get(\"primary\"):\n  1669→                ctx_text += f\"**主要原型**: {essence['archetype']['primary']}\\n\"\n  1670→            if essence.get(\"traits\"):\n  1671→                traits = [t.get(\"trait\", str(t)) if isinstance(t, dict) else str(t) for t in essence[\"traits\"][:3]]\n  1672→                ctx_text += f\"**核心特质**: {', '.join(traits)}\\n\"\n  1673→            # 动态\n  1674→            dynamic = vibe_insight.get(\"dynamic\", {})\n  1675→            if dynamic.get(\"emotion\", {}).get(\"current\"):\n  1676→                ctx_text += f\"**当前情绪**: {dynamic['emotion']['current']}\\n\"\n  1677→            # 规律\n  1678→            pattern = vibe_insight.get(\"pattern\", {})\n  1679→            if pattern.get(\"insights\"):\n  1680→                ctx_text += f\"**洞察**: {pattern['insights'][0]}\\n\"\n  1681→\n  1682→        # VibeTarget - 用户目标（我要成为谁）\n  1683→        if vibe_target:\n  1684→            ctx_text += f\"\\n### 用户目标 (VibeTarget)\\n\"\n  1685→            # 北极星\n  1686→            north_star = vibe_target.get(\"north_star\", {})\n  1687→            if north_star.get(\"vision_scene\"):\n  1688→                vision = north_star[\"vision_scene\"]\n  1689→                if len(vision) > 100:\n  1690→                    vision = vision[:100] + \"...\"\n  1691→                ctx_text += f\"**愿景**: {vision}\\n\"\n  1692→            # 目标\n  1693→            goals = vibe_target.get(\"goals\", [])\n  1694→            if goals:\n  1695→                active_goals = [g for g in goals if g.get(\"status\") == \"in_progress\"][:2]\n  1696→                if active_goals:\n  1697→                    goals_text = ', '.join([g.get('title', '') for g in active_goals])\n  1698→                    ctx_text += f\"**当前目标**: {goals_text}\\n\"\n  1699→            # 聚焦\n  1700→            focus = vibe_target.get(\"focus\", {})\n  1701→            if focus.get(\"primary\"):\n  1702→                ctx_text += f\"**关注领域**: {focus['primary']}\\n\"\n  1703→\n  1704→        # v9.0: 已移除 extracted 和 life_context 兼容代码\n  1705→\n  1706→        parts.append(ctx_text)\n  1707→\n  1708→    return \"\\n\".join(parts)\n  1709→\n  1710→\n  1711→# ═══════════════════════════════════════════════════════════════════════════\n  1712→# 缓存管理\n  1713→# ═══════════════════════════════════════════════════════════════════════════\n  1714→\n  1715→def clear_cache():\n  1716→    \"\"\"清除所有缓存\"\"\"\n  1717→    load_skill.cache_clear()\n  1718→    load_skill_metadata.cache_clear()  # v7.4\n  1719→    load_scenario.cache_clear()\n  1720→    load_rule.cache_clear()\n  1721→    _load_skill_md_content.cache_clear()  # v10\n  1722→    clear_v9_cache()  # V9\n  1723→    logger.info(\"Skill cache cleared\")\n  1724→\n  1725→\n  1726→def reload_skill(skill_id: str) -> Optional[SkillConfig]:\n  1727→    \"\"\"重载单个 Skill\"\"\"\n  1728→    load_skill.cache_clear()\n  1729→    load_scenario.cache_clear()\n  1730→    load_rule.cache_clear()\n  1731→    _load_skill_md_content.cache_clear()  # v10\n  1732→    return load_skill(skill_id)\n  1733→\n  1734→\n  1735→def build_rule_prompt(skill_id: str, rule_id: str, user_context: Optional[Dict] = None) -> str:\n  1736→    \"\"\"构建包含规则的 System Prompt - v7 新增\n  1737→\n  1738→    Args:\n  1739→        skill_id: Skill ID\n  1740→        rule_id: Rule ID\n  1741→        user_context: 用户上下文\n  1742→\n  1743→    Returns:\n  1744→        完整的 system prompt，包含规则内容\n  1745→    \"\"\"\n  1746→    parts = []\n  1747→\n  1748→    # 加载 Skill\n  1749→    skill = load_skill(skill_id)\n  1750→    if not skill:\n  1751→        return \"\"\n  1752→\n  1753→    # 专家身份\n  1754→    parts.append(f\"# {skill.name}\\n\\n{skill.expert_persona}\")\n  1755→\n  1756→    # 加载规则\n  1757→    rule = load_rule(skill_id, rule_id)\n  1758→    if rule:\n  1759→        parts.append(f\"\\n---\\n\\n## 当前规则: {rule.name}\\n\")\n  1760→\n  1761→        # 添加规则完整内容\n  1762→        parts.append(rule.content)\n  1763→\n  1764→    # 伦理边界\n  1765→    if skill.ethics.get(\"forbidden\"):\n  1766→        ethics_text = \"\\n## 伦理边界\\n\\n### 绝对禁止\\n\"\n  1767→        for item in skill.ethics[\"forbidden\"]:\n  1768→            ethics_text += f\"- {item}\\n\"\n  1769→        parts.append(ethics_text)\n  1770→\n  1771→    # 用户上下文（复用原有逻辑）\n  1772→    if user_context:\n  1773→        ctx_text = \"\\n## 用户上下文\\n\"\n  1774→\n  1775→        if user_context.get(\"birth_info\"):\n  1776→            birth_info = user_context['birth_info']\n  1777→            ctx_text += f\"\\n### 出生信息（已收集，无需再次询问）\\n\"\n  1778→            ctx_text += f\"{json.dumps(birth_info, ensure_ascii=False)}\\n\"\n  1779→            ctx_text += f\"\\n**重要**: 用户已提供出生信息，可以直接进行排盘和分析，无需调用 collect_bazi_info 工具。\\n\"\n  1780→\n  1781→        if user_context.get(\"portrait\"):\n  1782→            ctx_text += f\"\\n### 用户画像\\n{user_context['portrait']}\\n\"\n  1783→\n  1784→        if user_context.get(\"extracted\"):\n  1785→            extracted = user_context['extracted']\n  1786→            ctx_text += f\"\\n### 用户信息 (从历史对话中抽取)\\n\"\n  1787→            if extracted.get(\"facts\"):\n  1788→                ctx_text += f\"**基本信息**: {json.dumps(extracted['facts'], ensure_ascii=False)}\\n\"\n  1789→            if extracted.get(\"concerns\"):\n  1790→                ctx_text += f\"**关注领域**: {', '.join(extracted['concerns'])}\\n\"\n  1791→            if extracted.get(\"goals\"):\n  1792→                ctx_text += f\"**当前目标**: {', '.join(extracted['goals'])}\\n\"\n  1793→            if extracted.get(\"pain_points\"):\n  1794→                ctx_text += f\"**面临困难**: {', '.join(extracted['pain_points'])}\\n\"\n  1795→\n  1796→        parts.append(ctx_text)\n  1797→\n  1798→    return \"\\n\".join(parts)\n  1799→\n  1800→\n  1801→# ═══════════════════════════════════════════════════════════════════════════\n  1802→# v7.5: 数据库优先的元数据加载（Async）\n  1803→# ═══════════════════════════════════════════════════════════════════════════\n  1804→\n  1805→async def load_skill_metadata_async(skill_id: str) -> Optional[SkillMetadata]:\n  1806→    \"\"\"\n  1807→    异步加载 Skill 元数据（数据库优先，SKILL.md 作为 fallback）- v7.5 新增\n  1808→\n  1809→    优先级：\n  1810→    1. skill_catalog 表（动态配置）\n  1811→    2. SKILL.md frontmatter（静态配置）\n  1812→\n  1813→    Args:\n  1814→        skill_id: Skill ID\n  1815→\n  1816→    Returns:\n  1817→        SkillMetadata 对象，或 None（如果不存在）\n  1818→    \"\"\"\n  1819→    try:\n  1820→        # 1. 尝试从数据库加载\n  1821→        from stores.skill_catalog_repo import SkillCatalogRepository\n  1822→\n  1823→        db_entry = await SkillCatalogRepository.get(skill_id)\n  1824→        if db_entry:\n  1825→            # 转换 SkillCatalogEntry -> SkillMetadata\n  1826→            return SkillMetadata(\n  1827→                id=db_entry.skill_id,\n  1828→                name=db_entry.name,\n  1829→                description=db_entry.description,\n  1830→                version=db_entry.version,\n  1831→                category=db_entry.category,\n  1832→                icon=db_entry.icon,\n  1833→                color=db_entry.color,\n  1834→                triggers=db_entry.triggers,\n  1835→                pricing=SkillPricing(\n  1836→                    type=db_entry.pricing.type,\n  1837→                    trial_messages=db_entry.pricing.trial_messages,\n  1838→                    credits_per_use=db_entry.pricing.credits_per_use,\n  1839→                ),\n  1840→                features=[\n  1841→                    SkillFeature(\n  1842→                        name=f.name,\n  1843→                        description=f.description,\n  1844→                        icon=f.icon,\n  1845→                        tier=f.tier,\n  1846→                    )\n  1847→                    for f in db_entry.features\n  1848→                ],\n  1849→                showcase=SkillShowcase(\n  1850→                    tagline=db_entry.showcase.tagline,\n  1851→                    highlights=db_entry.showcase.highlights,\n  1852→                    preview_image=db_entry.showcase.preview_image,\n  1853→                    demo_prompts=db_entry.showcase.demo_prompts,\n  1854→                ),\n  1855→                subscription=SkillSubscription(\n  1856→                    auto_subscribe=db_entry.subscription.auto_subscribe,\n  1857→                    can_unsubscribe=db_entry.subscription.can_unsubscribe,\n  1858→                    push_default=db_entry.subscription.push_default,\n  1859→                    min_subscription_days=db_entry.subscription.min_subscription_days,\n  1860→                ),\n  1861→            )\n  1862→    except Exception as e:\n  1863→        logger.warning(f\"Failed to load skill {skill_id} from database: {e}\")\n  1864→\n  1865→    # 2. Fallback 到 SKILL.md\n  1866→    return load_skill_metadata(skill_id)\n  1867→\n  1868→\n  1869→async def get_all_skill_metadata_async() -> List[SkillMetadata]:\n  1870→    \"\"\"\n  1871→    异步获取所有 Skill 元数据（数据库优先）- v7.5 新增\n  1872→\n  1873→    优先级：\n  1874→    1. skill_catalog 表（动态配置）\n  1875→    2. SKILL.md fallback（如果数据库为空或出错）\n  1876→\n  1877→    Returns:\n  1878→        所有 Skill 的 SkillMetadata 列表\n  1879→    \"\"\"\n  1880→    try:\n  1881→        # 1. 尝试从数据库加载\n  1882→        from stores.skill_catalog_repo import SkillCatalogRepository\n  1883→\n  1884→        catalog = await SkillCatalogRepository.get_all()\n  1885→        if catalog:\n  1886→            return [\n  1887→                SkillMetadata(\n  1888→                    id=entry.skill_id,\n  1889→                    name=entry.name,\n  1890→                    description=entry.description,\n  1891→                    version=entry.version,\n  1892→                    category=entry.category,\n  1893→                    icon=entry.icon,\n  1894→                    color=entry.color,\n  1895→                    triggers=entry.triggers,\n  1896→                    pricing=SkillPricing(\n  1897→                        type=entry.pricing.type,\n  1898→                        trial_messages=entry.pricing.trial_messages,\n  1899→                        credits_per_use=entry.pricing.credits_per_use,\n  1900→                    ),\n  1901→                    features=[\n  1902→                        SkillFeature(\n  1903→                            name=f.name,\n  1904→                            description=f.description,\n  1905→                            icon=f.icon,\n  1906→                            tier=f.tier,\n  1907→                        )\n  1908→                        for f in entry.features\n  1909→                    ],\n  1910→                    showcase=SkillShowcase(\n  1911→                        tagline=entry.showcase.tagline,\n  1912→                        highlights=entry.showcase.highlights,\n  1913→                        preview_image=entry.showcase.preview_image,\n  1914→                        demo_prompts=entry.showcase.demo_prompts,\n  1915→                    ),\n  1916→                    subscription=SkillSubscription(\n  1917→                        auto_subscribe=entry.subscription.auto_subscribe,\n  1918→                        can_unsubscribe=entry.subscription.can_unsubscribe,\n  1919→                        push_default=entry.subscription.push_default,\n  1920→                        min_subscription_days=entry.subscription.min_subscription_days,\n  1921→                    ),\n  1922→                )\n  1923→                for entry in catalog.values()\n  1924→            ]\n  1925→    except Exception as e:\n  1926→        logger.warning(f\"Failed to load skill catalog from database: {e}\")\n  1927→\n  1928→    # 2. Fallback 到 SKILL.md\n  1929→    return get_all_skill_metadata()\n  1930→\n  1931→\n  1932→async def get_skills_by_category_async(category: str) -> List[SkillMetadata]:\n  1933→    \"\"\"\n  1934→    异步按分类获取 Skill 列表（数据库优先）- v7.5 新增\n  1935→\n  1936→    Args:\n  1937→        category: core | default | professional\n  1938→\n  1939→    Returns:\n  1940→        该分类下所有 Skill 的 SkillMetadata 列表\n  1941→    \"\"\"\n  1942→    all_skills = await get_all_skill_metadata_async()\n  1943→    return [s for s in all_skills if s.category == category]\n  1944→\n  1945→\n  1946→async def get_featured_skills_async() -> List[SkillMetadata]:\n  1947→    \"\"\"\n  1948→    异步获取精选 Skill 列表（数据库优先）- v7.5 新增\n  1949→\n  1950→    Returns:\n  1951→        精选 Skill 列表，按 featured_position 排序\n  1952→    \"\"\"\n  1953→    try:\n  1954→        from stores.skill_catalog_repo import SkillCatalogRepository\n  1955→\n  1956→        featured_entries = await SkillCatalogRepository.get_featured()\n  1957→        return [\n  1958→            SkillMetadata(\n  1959→                id=entry.skill_id,\n  1960→                name=entry.name,\n  1961→                description=entry.description,\n  1962→                version=entry.version,\n  1963→                category=entry.category,\n  1964→                icon=entry.icon,\n  1965→                color=entry.color,\n  1966→                triggers=entry.triggers,\n  1967→                pricing=SkillPricing(\n  1968→                    type=entry.pricing.type,\n  1969→                    trial_messages=entry.pricing.trial_messages,\n  1970→                    credits_per_use=entry.pricing.credits_per_use,\n  1971→                ),\n  1972→                features=[\n  1973→                    SkillFeature(\n  1974→                        name=f.name,\n  1975→                        description=f.description,\n  1976→                        icon=f.icon,\n  1977→                        tier=f.tier,\n  1978→                    )\n  1979→                    for f in entry.features\n  1980→                ],\n  1981→                showcase=SkillShowcase(\n  1982→                    tagline=entry.showcase.tagline,\n  1983→                    highlights=entry.showcase.highlights,\n  1984→                    preview_image=entry.showcase.preview_image,\n  1985→                    demo_prompts=entry.showcase.demo_prompts,\n  1986→                ),\n  1987→                subscription=SkillSubscription(\n  1988→                    auto_subscribe=entry.subscription.auto_subscribe,\n  1989→                    can_unsubscribe=entry.subscription.can_unsubscribe,\n  1990→                    push_default=entry.subscription.push_default,\n  1991→                    min_subscription_days=entry.subscription.min_subscription_days,\n  1992→                ),\n  1993→            )\n  1994→            for entry in featured_entries\n  1995→        ]\n  1996→    except Exception as e:\n  1997→        logger.warning(f\"Failed to load featured skills from database: {e}\")\n  1998→        # Fallback: 返回 professional 分类的前 3 个\n  1999→        all_skills = get_all_skill_metadata()\n  2000→        professional = [s for s in all_skills if s.category == \"professional\"]\n  2001→        return professional[:3]\n  2002→\n  2003→\n  2004→async def get_skill_categories_summary_async() -> Dict[str, Dict]:\n  2005→    \"\"\"\n  2006→    异步获取分类统计（数据库优先）- v7.5 新增\n  2007→\n  2008→    Returns:\n  2009→        分类统计字典\n  2010→    \"\"\"\n  2011→    try:\n  2012→        from stores.skill_catalog_repo import get_skill_categories_summary\n  2013→        return await get_skill_categories_summary()\n  2014→    except Exception as e:\n  2015→        logger.warning(f\"Failed to get category summary from database: {e}\")\n  2016→        # Fallback\n  2017→        all_skills = get_all_skill_metadata()\n  2018→        return {\n  2019→            \"core\": {\n  2020→                \"name\": \"核心能力\",\n  2021→                \"description\": \"始终激活的基础能力\",\n  2022→                \"count\": len([s for s in all_skills if s.category == \"core\"])\n  2023→            },\n  2024→            \"default\": {\n  2025→                \"name\": \"基础功能\",\n  2026→                \"description\": \"默认激活，免费使用\",\n  2027→                \"count\": len([s for s in all_skills if s.category == \"default\"])\n  2028→            },\n  2029→            \"professional\": {\n  2030→                \"name\": \"专业技能\",\n  2031→                \"description\": \"需要订阅的高级功能\",\n  2032→                \"count\": len([s for s in all_skills if s.category == \"professional\"])\n  2033→            },\n  2034→        }\n  2035→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a85f5b09-2478-4090-ad81-ed63f5c6d294","timestamp":"2026-01-25T03:27:16.374Z","sourceToolAssistantUUID":"a5426cad-4604-4bbb-af60-9ecb268005e8"}
{"parentUuid":"a85f5b09-2478-4090-ad81-ed63f5c6d294","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01HBVL1DswZz4end6utSXSxs","toolUseID":"toolu_01HBVL1DswZz4end6utSXSxs","timestamp":"2026-01-25T03:27:16.383Z","uuid":"d6dc5121-d552-4c26-9d95-a87bce51f1ba"}
{"parentUuid":"46886d6a-8502-4d7d-9993-4e66e96087dc","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TRK1rhpMaTQwAPoBBvjoEz","type":"tool_result","content":"     1→\"\"\"\n     2→CoreAgent v10 + V9 渐进式架构（LLM-First）\n     3→\n     4→V9 架构特性（新增）：\n     5→- 多 Skill 并行激活：_active_skills: List[str]\n     6→- Core 工具始终可用\n     7→- 工具聚合去重\n     8→- activate_skills 支持激活多个 Skill\n     9→\n    10→v10 架构特性：\n    11→- Context Engineering: 文件/JSONB 持久化状态，断点续传\n    12→- 模块化: ContextManager, SessionManager, PromptBuilder, ToolExecutor\n    13→- 会话恢复: 自动检测未完成会话，支持断点续传\n    14→- 跨 Skill 共享: profile.extracted + identity\n    15→\n    16→LLM-First（V9.2）：\n    17→- Phase 1 仅暴露 activate_skills、ask、show\n    18→- 完全删除 routing.yaml 依赖\n    19→- 路由与提示均由 SKILL.md + tools.yaml + rules/*.md 驱动\n    20→\n    21→v8 架构特性（保留）：\n    22→- 分阶段上下文加载：Phase 1 (Skill 选择) / Phase 2 (Skill 执行)\n    23→- use_skill 同轮重载：激活 skill 后同一轮内重新构建上下文\n    24→\"\"\"\n    25→import json\n    26→import logging\n    27→import time\n    28→from typing import Optional, List, Dict, Any, AsyncGenerator\n    29→from dataclasses import dataclass\n    30→from enum import Enum\n    31→\n    32→from services.llm import LLMClient, get_llm_client\n    33→from services.llm.client import LLMMessage\n    34→from .case_index import get_case_index, CaseIndex\n    35→from .skill_loader import (\n    36→    load_skill, skill_requires_birth_info, skill_requires_compute,\n    37→    get_skill_compute_type, get_skill_rules,\n    38→)\n    39→from .tool_registry import ToolRegistry, ToolContext\n    40→# LLM-First: 不依赖 routing_config；工具描述直接由技能清单和注册表决定\n    41→def build_skill_tool_description() -> str:\n    42→    from .skill_loader import get_available_skills, load_skill\n    43→    lines = [\"激活专业技能来回答用户问题。\\n\\n## 可用技能\\n\"]\n    44→    for sid in [s for s in get_available_skills() if s != \"core\"]:\n    45→        skill = load_skill(sid)\n    46→        if skill:\n    47→            desc = skill.description\n    48→            if len(desc) > 50:\n    49→                desc = desc[:50] + \"...\"\n    50→            triggers = skill.triggers[:3] if skill.triggers else []\n    51→            t = \"、\".join(triggers)\n    52→            lines.append(f\"- **{sid}**: {desc}（{t}）\")\n    53→    lines.append(\"\\n## 参数说明\\n- `skill`: 必需，技能 ID\\n- `rule`: 可选，规则 ID（如该技能有细分流程）\")\n    54→    return \"\\n\".join(lines)\n    55→from .context_manager import get_context_manager, ContextManager, SessionContext\n    56→from .session_manager import get_session_manager, SessionManager, ActiveSession\n    57→from .prompt_builder import get_prompt_builder, PromptBuilder\n    58→from .tool_executor import get_tool_executor, ToolExecutor\n    59→\n    60→logger = logging.getLogger(__name__)\n    61→\n    62→\n    63→class AgentState(str, Enum):\n    64→    \"\"\"Agent 执行状态\"\"\"\n    65→    IDLE = \"idle\"\n    66→    THINKING = \"thinking\"\n    67→    TOOL_CALLING = \"tool_calling\"\n    68→    COMPLETED = \"completed\"\n    69→    ERROR = \"error\"\n    70→\n    71→\n    72→@dataclass\n    73→class AgentEvent:\n    74→    \"\"\"Agent 执行事件\"\"\"\n    75→    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase, session_resume\n    76→    data: Any = None\n    77→\n    78→\n    79→@dataclass\n    80→class AgentContext:\n    81→    \"\"\"Agent 执行上下文\n    82→\n    83→    v10 更新：\n    84→    - 新增 session_context 支持断点续传\n    85→    \"\"\"\n    86→    user_id: str\n    87→    user_tier: str = \"free\"\n    88→    profile: Optional[Dict[str, Any]] = None\n    89→    skill_data: Optional[Dict[str, Any]] = None\n    90→    history: Optional[List[Dict[str, str]]] = None\n    91→    skill: Optional[str] = None\n    92→    scenario: Optional[str] = None\n    93→    conversation_id: Optional[str] = None\n    94→    voice_mode: Optional[str] = \"warm\"\n    95→    protocol_prompt: Optional[str] = None\n    96→    session_context: Optional[SessionContext] = None  # v10: 会话上下文\n    97→\n    98→\n    99→def build_phase1_tools() -> List[Dict[str, Any]]:\n   100→    \"\"\"\n   101→    构建 Phase 1 路由工具集 - v10: 配置驱动\n   102→\n   103→    工具列表（LLM-First 精简）：\n   104→    1. activate_skills - 多技能激活（Core 原子工具）\n   105→    2. show - 统一展示（skill_list/recommendation/card）\n   106→    3. ask - 收集信息\n   107→    \"\"\"\n   108→    from .skill_loader import get_available_skills\n   109→\n   110→    available_skills = [s for s in get_available_skills() if s != \"core\"]\n   111→\n   112→    # 工具 1: activate_skills（多技能激活，LLM-First 推荐）\n   113→    activate_skills_tool = {\n   114→        \"type\": \"function\",\n   115→        \"function\": {\n   116→            \"name\": \"activate_skills\",\n   117→            \"description\": \"激活一个或多个技能。\",\n   118→            \"parameters\": {\n   119→                \"type\": \"object\",\n   120→                \"properties\": {\n   121→                    \"skills\": {\n   122→                        \"type\": \"array\",\n   123→                        \"items\": {\"type\": \"string\", \"enum\": available_skills},\n   124→                        \"description\": \"要激活的技能 ID 列表\"\n   125→                    },\n   126→                    \"rule\": {\"type\": \"string\", \"description\": \"可选规则 ID\"}\n   127→                },\n   128→                \"required\": [\"skills\"]\n   129→            }\n   130→        }\n   131→    }\n   132→\n   133→    # 工具 2: show（统一展示）\n   134→    show_tool = {\n   135→        \"type\": \"function\",\n   136→        \"function\": {\n   137→            \"name\": \"show\",\n   138→            \"description\": \"展示内容（skill_list / recommendation / card）\",\n   139→            \"parameters\": {\n   140→                \"type\": \"object\",\n   141→                \"properties\": {\n   142→                    \"type\": {\"type\": \"string\", \"enum\": [\"skill_list\", \"recommendation\", \"card\"]},\n   143→                    \"card_type\": {\"type\": \"string\"},\n   144→                    \"data\": {\"type\": \"object\"},\n   145→                },\n   146→                \"required\": [\"type\"]\n   147→            }\n   148→        }\n   149→    }\n   150→\n   151→    # 工具 3: ask（收集）\n   152→    ask_tool = {\n   153→        \"type\": \"function\",\n   154→        \"function\": {\n   155→            \"name\": \"ask\",\n   156→            \"description\": \"向用户提问或请求信息\",\n   157→            \"parameters\": {\n   158→                \"type\": \"object\",\n   159→                \"properties\": {\n   160→                    \"question\": {\"type\": \"string\"},\n   161→                    \"form_type\": {\"type\": \"string\", \"enum\": [\"text\", \"select\"]},\n   162→                },\n   163→                \"required\": [\"question\"]\n   164→            }\n   165→        }\n   166→    }\n   167→\n   168→    return [activate_skills_tool, show_tool, ask_tool]\n   169→\n   170→\n   171→# 缓存动态生成的工具定义\n   172→_PHASE1_TOOLS_CACHE: Optional[List[Dict[str, Any]]] = None\n   173→\n   174→\n   175→def get_phase1_tools() -> List[Dict[str, Any]]:\n   176→    \"\"\"获取 Phase 1 工具定义（带缓存）\"\"\"\n   177→    global _PHASE1_TOOLS_CACHE\n   178→    if _PHASE1_TOOLS_CACHE is None:\n   179→        _PHASE1_TOOLS_CACHE = build_phase1_tools()\n   180→    return _PHASE1_TOOLS_CACHE\n   181→\n   182→\n   183→class CoreAgent:\n   184→    \"\"\"\n   185→    CoreAgent v10 - Context Engineering 驱动\n   186→\n   187→    Features:\n   188→    - 会话恢复检查：自动检测未完成会话\n   189→    - 断点续传：从 checkpoint 恢复执行\n   190→    - 模块化设计：ContextManager, SessionManager, PromptBuilder, ToolExecutor\n   191→    - 分阶段上下文加载\n   192→    \"\"\"\n   193→\n   194→    def __init__(\n   195→        self,\n   196→        llm: Optional[LLMClient] = None,\n   197→        max_iterations: int = 10,\n   198→        case_index: Optional[CaseIndex] = None\n   199→    ):\n   200→        self.llm = llm or get_llm_client()\n   201→        self.max_iterations = max_iterations\n   202→        self.case_index = case_index or get_case_index()\n   203→        self.state = AgentState.IDLE\n   204→\n   205→        # v10: 新增模块\n   206→        self.context_manager: ContextManager = get_context_manager()\n   207→        self.session_manager: SessionManager = get_session_manager()\n   208→        self.prompt_builder: PromptBuilder = get_prompt_builder()\n   209→        self.tool_executor: ToolExecutor = get_tool_executor()\n   210→\n   211→        # 运行时状态 (V9: 支持多 Skill 激活)\n   212→        self._active_skills: List[str] = []  # V9: 多 Skill 列表\n   213→        self._active_skill: Optional[str] = None  # V9: 主 Skill（向后兼容）\n   214→        self._active_scenario: Optional[str] = None\n   215→        self._current_message: str = \"\"\n   216→        self._context: Optional[AgentContext] = None\n   217→        self._messages: Optional[List[LLMMessage]] = None\n   218→        self._session_context: Optional[SessionContext] = None\n   219→        self._perf_log: Dict[str, Any] = {}\n   220→\n   221→        # LLM-First: 技能切换节流与限制\n   222→        self._skill_switch_count: int = 0\n   223→        self._skill_switch_limit: int = 3\n   224→\n   225→    @property\n   226→    def usage(self) -> Dict[str, int]:\n   227→        \"\"\"获取 LLM 使用统计\"\"\"\n   228→        return self.llm.usage\n   229→\n   230→    async def run(\n   231→        self,\n   232→        message: str,\n   233→        context: AgentContext\n   234→    ) -> AsyncGenerator[AgentEvent, None]:\n   235→        \"\"\"执行 Agent 循环 - v10: Context Engineering 增强\"\"\"\n   236→        self.state = AgentState.IDLE\n   237→        self._current_message = message\n   238→        self._context = context\n   239→        self._perf_log = {\n   240→            \"iterations\": 0,\n   241→            \"llm_calls\": [],\n   242→            \"phase\": \"phase1\" if not context.skill else \"phase2\"\n   243→        }\n   244→\n   245→        # ═══════════════════════════════════════════════════════════════\n   246→        # v10 Phase 0: 会话恢复检查\n   247→        # ═══════════════════════════════════════════════════════════════\n   248→        active_session = await self.session_manager.get_active_session(context.user_id)\n   249→\n   250→        if active_session and active_session.is_active:\n   251→            # 检查是否应该恢复\n   252→            if self.session_manager.should_resume(message, active_session):\n   253→                # 恢复会话\n   254→                yield AgentEvent(type=\"session_resume\", data={\n   255→                    \"skill\": active_session.skill_id,\n   256→                    \"rule\": active_session.rule_id,\n   257→                    \"step\": active_session.checkpoint_step,\n   258→                    \"total\": active_session.checkpoint_total\n   259→                })\n   260→\n   261→                # 自动激活 skill (V9: 同时设置 _active_skills)\n   262→                self._active_skill = active_session.skill_id\n   263→                self._active_skills = [active_session.skill_id] if active_session.skill_id else []\n   264→                self._active_scenario = active_session.rule_id\n   265→\n   266→                # 加载会话上下文\n   267→                self._session_context = await self.context_manager.load_session_context(\n   268→                    context.user_id,\n   269→                    active_session.skill_id,\n   270→                    active_session.rule_id\n   271→                )\n   272→                context.session_context = self._session_context\n   273→\n   274→                # 动态加载 profile\n   275→                await self._reload_profile_for_skill(active_session.skill_id)\n   276→\n   277→                logger.info(f\"[CoreAgent] Session resumed: skill={active_session.skill_id}, step={active_session.checkpoint_step}\")\n   278→\n   279→            elif self.session_manager.should_ask_resume(message, active_session):\n   280→                # 提示用户是否继续\n   281→                resume_prompt = self.session_manager.build_resume_prompt(active_session)\n   282→                yield AgentEvent(type=\"session_prompt\", data={\n   283→                    \"prompt\": resume_prompt,\n   284→                    \"session\": active_session.to_dict()\n   285→                })\n   286→\n   287→        # ═══════════════════════════════════════════════════════════════\n   288→        # Phase 1/2: 正常执行流程\n   289→        # ═══════════════════════════════════════════════════════════════\n   290→\n   291→        # 使用前端指定的 skill/scenario，或从会话恢复 (V9: 同时设置 _active_skills)\n   292→        if context.skill:\n   293→            self._active_skill = context.skill\n   294→            self._active_skills = [context.skill] if context.skill else []\n   295→            self._active_scenario = context.scenario\n   296→        elif not self._active_skill and not self._active_skills:\n   297→            self._active_skill = None\n   298→            self._active_skills = []\n   299→            self._active_scenario = None\n   300→\n   301→        # 如果有 active skill 且没有加载 session context，现在加载\n   302→        if self._active_skill and not self._session_context:\n   303→            self._session_context = await self.context_manager.load_session_context(\n   304→                context.user_id,\n   305→                self._active_skill,\n   306→                self._active_scenario\n   307→            )\n   308→            context.session_context = self._session_context\n   309→\n   310→        # 发送 SOP 阶段事件\n   311→        if self._active_skill:\n   312→            sop_status = self._compute_sop_status(context)\n   313→            yield AgentEvent(type=\"sop_phase\", data={\n   314→                \"skill\": self._active_skill,\n   315→                \"scenario\": self._active_scenario,\n   316→                \"status\": sop_status,\n   317→                \"has_checkpoint\": self._session_context.has_checkpoint if self._session_context else False,\n   318→                \"message\": \"LLM 驱动模式\"\n   319→            })\n   320→\n   321→        # 构建初始消息\n   322→        t_prompt_start = time.time()\n   323→        messages = await self._build_initial_messages(message, context)\n   324→        self._messages = messages\n   325→        self._perf_log[\"prompt_build_ms\"] = int((time.time() - t_prompt_start) * 1000)\n   326→        self._perf_log[\"system_prompt_len\"] = len(messages[0].content) if messages else 0\n   327→        logger.info(f\"[PERF Agent] Prompt built: {self._perf_log['prompt_build_ms']}ms, len={self._perf_log['system_prompt_len']}\")\n   328→\n   329→        # 主循环\n   330→        for iteration in range(self.max_iterations):\n   331→            self.state = AgentState.THINKING\n   332→            yield AgentEvent(type=\"thinking\", data={\"iteration\": iteration})\n   333→            self._perf_log[\"iterations\"] = iteration + 1\n   334→\n   335→            tools = self._get_current_tools(context)\n   336→\n   337→            try:\n   338→                content_buffer = \"\"\n   339→                tool_calls = []\n   340→\n   341→                t_llm_start = time.time()\n   342→                first_token_time = None\n   343→\n   344→                async for chunk in self.llm.stream(\n   345→                    messages=messages,\n   346→                    tools=tools,\n   347→                    tool_choice=None,\n   348→                    user_tier=context.user_tier\n   349→                ):\n   350→                    if first_token_time is None:\n   351→                        first_token_time = time.time()\n   352→                        ttft = int((first_token_time - t_llm_start) * 1000)\n   353→                        logger.info(f\"[PERF Agent] LLM #{iteration+1} TTFT: {ttft}ms\")\n   354→\n   355→                    if chunk[\"type\"] == \"content\":\n   356→                        content_buffer += chunk[\"content\"]\n   357→                        yield AgentEvent(type=\"content\", data={\"content\": chunk[\"content\"]})\n   358→                    elif chunk[\"type\"] == \"tool_call\":\n   359→                        tool_calls.append(chunk)\n   360→\n   361→                llm_total = int((time.time() - t_llm_start) * 1000)\n   362→                self._perf_log[\"llm_calls\"].append({\n   363→                    \"iteration\": iteration + 1,\n   364→                    \"ttft_ms\": int((first_token_time - t_llm_start) * 1000) if first_token_time else 0,\n   365→                    \"total_ms\": llm_total,\n   366→                    \"has_tools\": len(tool_calls) > 0\n   367→                })\n   368→\n   369→                if tool_calls:\n   370→                    self.state = AgentState.TOOL_CALLING\n   371→\n   372→                    assistant_tool_calls = []\n   373→                    for tc in tool_calls:\n   374→                        assistant_tool_calls.append({\n   375→                            \"id\": tc[\"tool_call_id\"],\n   376→                            \"function\": {\n   377→                                \"name\": tc[\"tool_name\"],\n   378→                                \"arguments\": tc[\"tool_args\"]\n   379→                            }\n   380→                        })\n   381→                    messages.append(LLMMessage(\n   382→                        role=\"assistant\",\n   383→                        content=content_buffer or \"\",\n   384→                        tool_calls=assistant_tool_calls\n   385→                    ))\n   386→                    content_buffer = \"\"\n   387→\n   388→                    # 执行工具\n   389→                    t_tools_start = time.time()\n   390→                    tool_results = []\n   391→                    for tc in tool_calls:\n   392→                        tool_name = tc[\"tool_name\"]\n   393→                        tool_args = tc[\"tool_args\"]\n   394→                        tool_call_id = tc[\"tool_call_id\"]\n   395→\n   396→                        yield AgentEvent(type=\"tool_call\", data={\n   397→                            \"id\": tool_call_id,\n   398→                            \"name\": tool_name,\n   399→                            \"arguments\": tool_args\n   400→                        })\n   401→\n   402→                        t_tool_start = time.time()\n   403→\n   404→                        # 创建工具上下文\n   405→                        tool_context = ToolContext(\n   406→                            user_id=context.user_id,\n   407→                            user_tier=context.user_tier,\n   408→                            profile=context.profile or {},\n   409→                            skill_data=context.skill_data or {},\n   410→                            skill_id=self._active_skill,\n   411→                            scenario_id=self._active_scenario,\n   412→                            conversation_id=context.conversation_id\n   413→                        )\n   414→\n   415→                        # 节流：限制技能频繁切换\n   416→                        if tool_name == \"activate_skills\" and self._skill_switch_count >= self._skill_switch_limit:\n   417→                            warn_msg = f\"已达到技能切换上限（{self._skill_switch_limit} 次）。请先在当前技能内完成任务。\"\n   418→                            logger.info(\"[LLM-First] Skill switch throttled\")\n   419→                            yield AgentEvent(type=\"content\", data={\"content\": warn_msg})\n   420→                            continue\n   421→\n   422→                        # v10: 使用 ToolExecutor\n   423→                        result = await self.tool_executor.execute(\n   424→                            tool_name=tool_name,\n   425→                            tool_args=tool_args,\n   426→                            context=tool_context,\n   427→                            current_message=self._current_message,\n   428→                            reload_callback=lambda: self._handle_skill_activation(context)\n   429→                        )\n   430→\n   431→                        # 处理需要重载上下文的工具\n   432→                        if result.should_reload_context:\n   433→                            # V9: 从工具结果中提取激活的 skill/rule（支持多 Skill）\n   434→                            if isinstance(result.data, dict):\n   435→                                # V9: 支持 skills 列表\n   436→                                activated_skills = result.data.get(\"skills\", [])\n   437→                                activated_skill = result.data.get(\"skill\")\n   438→                                activated_rule = result.data.get(\"rule\")\n   439→\n   440→                                if activated_skills:\n   441→                                    self._active_skills = activated_skills\n   442→                                    self._active_skill = activated_skills[0] if activated_skills else None\n   443→                                    logger.info(f\"[CoreAgent V9] Skills activated: {activated_skills}, rule: {activated_rule}\")\n   444→                                elif activated_skill:\n   445→                                    self._active_skills = [activated_skill]\n   446→                                    self._active_skill = activated_skill\n   447→                                    logger.info(f\"[CoreAgent] Skill activated: {activated_skill}, rule: {activated_rule}\")\n   448→\n   449→                                if activated_rule:\n   450→                                    self._active_scenario = activated_rule\n   451→\n   452→                            # 统计技能切换\n   453→                            if tool_name == \"activate_skills\":\n   454→                                self._skill_switch_count += 1\n   455→                                self._perf_log[\"skill_switch_count\"] = self._skill_switch_count\n   456→\n   457→                            # 重新构建 System Prompt\n   458→                            new_system_prompt = await self._build_system_prompt(\n   459→                                self._current_message, context\n   460→                            )\n   461→                            self._messages[0] = LLMMessage(role=\"system\", content=new_system_prompt)\n   462→                            messages[0] = self._messages[0]\n   463→                            self._perf_log[\"phase\"] = \"phase2\"\n   464→                            self._perf_log[\"system_prompt_len\"] = len(new_system_prompt)\n   465→                            logger.info(f\"[CoreAgent] Phase 2 prompt rebuilt, len={len(new_system_prompt)}\")\n   466→\n   467→                        tool_exec_ms = int((time.time() - t_tool_start) * 1000)\n   468→                        logger.info(f\"[PERF Agent] Tool {tool_name}: {tool_exec_ms}ms\")\n   469→\n   470→                        tool_results.append({\n   471→                            \"tool_call_id\": tool_call_id,\n   472→                            \"result\": result.data\n   473→                        })\n   474→\n   475→                        yield AgentEvent(type=\"tool_result\", data={\n   476→                            \"id\": tool_call_id,\n   477→                            \"name\": tool_name,\n   478→                            \"result\": result.data\n   479→                        })\n   480→\n   481→                    tools_total = int((time.time() - t_tools_start) * 1000)\n   482→                    logger.info(f\"[PERF Agent] All tools: {tools_total}ms\")\n   483→\n   484→                    for tr in tool_results:\n   485→                        result_content = tr[\"result\"]\n   486→                        if isinstance(result_content, dict):\n   487→                            result_content = json.dumps(result_content, ensure_ascii=False)\n   488→                        messages.append(LLMMessage(\n   489→                            role=\"tool\",\n   490→                            content=str(result_content),\n   491→                            tool_call_id=tr[\"tool_call_id\"]\n   492→                        ))\n   493→                else:\n   494→                    self.state = AgentState.COMPLETED\n   495→                    logger.info(f\"[PERF Agent] Done: {self._perf_log}\")\n   496→                    yield AgentEvent(type=\"done\", data={\"content\": content_buffer})\n   497→                    return\n   498→\n   499→            except Exception as e:\n   500→                self.state = AgentState.ERROR\n   501→                logger.error(f\"Agent error: {e}\")\n   502→                yield AgentEvent(type=\"error\", data={\"error\": str(e)})\n   503→                return\n   504→\n   505→        self.state = AgentState.COMPLETED\n   506→        yield AgentEvent(type=\"done\", data={\"max_iterations_reached\": True})\n   507→\n   508→    async def _handle_skill_activation(self, context: AgentContext) -> None:\n   509→        \"\"\"处理 skill 激活后的上下文重载\"\"\"\n   510→        if self._context and self._context.user_id != \"guest\":\n   511→            try:\n   512→                from stores.profile_cache import get_cached_profile_with_skill\n   513→                from uuid import UUID\n   514→\n   515→                user_id = UUID(self._context.user_id)\n   516→                skill = self._active_skill\n   517→\n   518→                result = await get_cached_profile_with_skill(user_id, skill)\n   519→                self._context.profile = result.get(\"profile\", {})\n   520→                self._context.skill_data = result.get(\"skill_data\", {})\n   521→                context.profile = self._context.profile\n   522→                context.skill_data = self._context.skill_data\n   523→\n   524→                # 加载 session context\n   525→                if skill:\n   526→                    self._session_context = await self.context_manager.load_session_context(\n   527→                        self._context.user_id, skill, self._active_scenario\n   528→                    )\n   529→                    context.session_context = self._session_context\n   530→\n   531→                logger.info(f\"[CoreAgent] Profile reloaded for skill={skill}\")\n   532→            except Exception as e:\n   533→                logger.warning(f\"[CoreAgent] Failed to reload profile: {e}\")\n   534→\n   535→    async def _reload_profile_for_skill(self, skill_id: str) -> None:\n   536→        \"\"\"为指定 skill 重载 profile\"\"\"\n   537→        if not self._context or self._context.user_id == \"guest\":\n   538→            return\n   539→\n   540→        try:\n   541→            from stores.profile_cache import get_cached_profile_with_skill\n   542→            from uuid import UUID\n   543→\n   544→            user_id = UUID(self._context.user_id)\n   545→            result = await get_cached_profile_with_skill(user_id, skill_id)\n   546→            self._context.profile = result.get(\"profile\", {})\n   547→            self._context.skill_data = result.get(\"skill_data\", {})\n   548→\n   549→            logger.info(f\"[CoreAgent] Profile loaded for skill={skill_id}\")\n   550→        except Exception as e:\n   551→            logger.warning(f\"[CoreAgent] Failed to load profile: {e}\")\n   552→\n   553→    def _filter_valid_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   554→        \"\"\"过滤历史消息，确保 tool 消息配对完整\"\"\"\n   555→        if not history:\n   556→            return []\n   557→\n   558→        valid_tool_ids = set()\n   559→        for msg in history:\n   560→            if msg.get(\"role\") == \"assistant\" and msg.get(\"tool_calls\"):\n   561→                for tc in msg[\"tool_calls\"]:\n   562→                    tc_id = tc.get(\"id\")\n   563→                    if tc_id:\n   564→                        valid_tool_ids.add(tc_id)\n   565→\n   566→        filtered = []\n   567→        for msg in history:\n   568→            role = msg.get(\"role\", \"user\")\n   569→            if role == \"tool\":\n   570→                tool_call_id = msg.get(\"tool_call_id\")\n   571→                if tool_call_id and tool_call_id in valid_tool_ids:\n   572→                    filtered.append(msg)\n   573→                else:\n   574→                    logger.warning(f\"Skipping orphan tool message: {tool_call_id}\")\n   575→            else:\n   576→                filtered.append(msg)\n   577→\n   578→        return filtered\n   579→\n   580→    async def _build_initial_messages(\n   581→        self,\n   582→        message: str,\n   583→        context: AgentContext\n   584→    ) -> List[LLMMessage]:\n   585→        \"\"\"构建初始消息列表\"\"\"\n   586→        system_prompt = await self._build_system_prompt(message, context)\n   587→\n   588→        messages = [LLMMessage(role=\"system\", content=system_prompt)]\n   589→\n   590→        if context.history:\n   591→            filtered_history = self._filter_valid_history(context.history[-10:])\n   592→            for msg in filtered_history:\n   593→                messages.append(LLMMessage(\n   594→                    role=msg.get(\"role\", \"user\"),\n   595→                    content=msg.get(\"content\", \"\"),\n   596→                    tool_call_id=msg.get(\"tool_call_id\"),\n   597→                    tool_calls=msg.get(\"tool_calls\")\n   598→                ))\n   599→\n   600→        messages.append(LLMMessage(role=\"user\", content=message))\n   601→        return messages\n   602→\n   603→    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:\n   604→        \"\"\"构建 System Prompt - v10: 使用 PromptBuilder\"\"\"\n   605→        return await self.prompt_builder.build(\n   606→            skill_id=self._active_skill,\n   607→            rule_id=self._active_scenario,\n   608→            message=message,\n   609→            profile=context.profile,\n   610→            skill_data=context.skill_data,\n   611→            session_context=self._session_context,\n   612→            protocol_prompt=context.protocol_prompt\n   613→        )\n   614→\n   615→    def _compute_sop_status(self, context: AgentContext) -> Dict[str, Any]:\n   616→        \"\"\"计算 SOP 状态\"\"\"\n   617→        skill_id = self._active_skill\n   618→\n   619→        needs_birth = skill_requires_birth_info(skill_id) if skill_id else False\n   620→        identity = context.profile.get(\"identity\", {}) if context.profile else {}\n   621→        birth_info = identity.get(\"birth_info\", {})\n   622→        has_birth = bool(birth_info.get(\"birth_date\") or birth_info.get(\"date\"))\n   623→\n   624→        needs_compute = skill_requires_compute(skill_id) if skill_id else False\n   625→        compute_type = get_skill_compute_type(skill_id) if skill_id else None\n   626→        actual_compute_type = compute_type or skill_id\n   627→\n   628→        has_chart = False\n   629→        if context.skill_data and actual_compute_type:\n   630→            skill_data = context.skill_data.get(actual_compute_type, {})\n   631→            has_chart = bool(skill_data.get(\"chart\") or skill_data.get(\"cards\"))\n   632→\n   633→        # v10: 添加 checkpoint 信息\n   634→        checkpoint_info = {}\n   635→        if self._session_context and self._session_context.checkpoint:\n   636→            cp = self._session_context.checkpoint\n   637→            checkpoint_info = {\n   638→                \"step\": cp.step,\n   639→                \"total_steps\": cp.total_steps,\n   640→                \"has_data\": bool(cp.collected_data)\n   641→            }\n   642→\n   643→        return {\n   644→            \"skill_id\": skill_id,\n   645→            \"needs_birth_info\": needs_birth,\n   646→            \"has_birth_info\": has_birth,\n   647→            \"needs_compute\": needs_compute,\n   648→            \"has_chart_data\": has_chart,\n   649→            \"compute_type\": actual_compute_type,\n   650→            \"ready_for_analysis\": (not needs_birth or has_birth) and (not needs_compute or has_chart),\n   651→            \"checkpoint\": checkpoint_info\n   652→        }\n   653→\n   654→    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:\n   655→        \"\"\"获取当前可用工具 - V9: 支持多 Skill 工具聚合\"\"\"\n   656→        # Phase 1: 无激活 Skill，返回路由工具\n   657→        if not context.skill and not self._active_skill and not self._active_skills:\n   658→            return get_phase1_tools()\n   659→\n   660→        tools = []\n   661→        added_names = set()\n   662→\n   663→        # V9: Core 工具始终可用\n   664→        core_tools = ToolRegistry.get_tools_for_skill(\"core\")\n   665→        for t in core_tools:\n   666→            tool_name = t.get(\"function\", {}).get(\"name\", \"\")\n   667→            if tool_name and tool_name not in added_names:\n   668→                tools.append(t)\n   669→                added_names.add(tool_name)\n   670→\n   671→        # V9: 已激活 Skill 的工具（多 Skill 支持）\n   672→        active_skill_ids = self._active_skills if self._active_skills else []\n   673→        if not active_skill_ids and (self._active_skill or context.skill):\n   674→            active_skill_ids = [self._active_skill or context.skill]\n   675→\n   676→        for skill_id in active_skill_ids:\n   677→            if skill_id == \"core\":\n   678→                continue\n   679→            skill_tools = ToolRegistry.get_tools_for_skill(skill_id)\n   680→            for t in skill_tools:\n   681→                tool_name = t.get(\"function\", {}).get(\"name\", \"\")\n   682→                if tool_name and tool_name not in added_names:\n   683→                    tools.append(t)\n   684→                    added_names.add(tool_name)\n   685→\n   686→        # 如果没有工具，返回 Phase 1 工具\n   687→        if not tools:\n   688→            return get_phase1_tools()\n   689→\n   690→        # Phase 2: 添加 activate_skills 工具，支持动态切换 skill\n   691→        phase1_tools = get_phase1_tools()\n   692→        activate_tool = next((t for t in phase1_tools if t.get(\"function\", {}).get(\"name\") == \"activate_skills\"), None)\n   693→        if activate_tool:\n   694→            tool_name = activate_tool.get(\"function\", {}).get(\"name\", \"\")\n   695→            if tool_name not in added_names:\n   696→                tools.append(activate_tool)\n   697→\n   698→        return tools\n   699→\n   700→\n   701→def create_agent(\n   702→    llm: Optional[LLMClient] = None,\n   703→    max_iterations: int = 10\n   704→) -> CoreAgent:\n   705→    \"\"\"创建 CoreAgent 实例\"\"\"\n   706→    return CoreAgent(llm=llm, max_iterations=max_iterations)\n   707→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"81300fab-963d-41cb-8eba-597628bcf025","timestamp":"2026-01-25T03:27:17.415Z","sourceToolAssistantUUID":"46886d6a-8502-4d7d-9993-4e66e96087dc"}
{"parentUuid":"81300fab-963d-41cb-8eba-597628bcf025","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01TRK1rhpMaTQwAPoBBvjoEz","toolUseID":"toolu_01TRK1rhpMaTQwAPoBBvjoEz","timestamp":"2026-01-25T03:27:17.435Z","uuid":"643aca35-c0b9-46d6-aca2-52c663f606ce"}
{"parentUuid":"643aca35-c0b9-46d6-aca2-52c663f606ce","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0111RFZUqR2pvGsMjSUasguA","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我读取一些 Skill 定义文件来理解完整的路由机制："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4920,"cache_creation_input_tokens":53255,"cache_read_input_tokens":32027,"cache_creation":{"ephemeral_5m_input_tokens":53255,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPH1PXfwihcomadbDyF","type":"assistant","uuid":"b766071d-41d0-4b98-9ea1-d62a4f2b917e","timestamp":"2026-01-25T03:27:21.978Z"}
{"parentUuid":"b766071d-41d0-4b98-9ea1-d62a4f2b917e","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0111RFZUqR2pvGsMjSUasguA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GHA3xZoHzmBCTaoM9UmV7q","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/bazi/SKILL.md","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4920,"cache_creation_input_tokens":53255,"cache_read_input_tokens":32027,"cache_creation":{"ephemeral_5m_input_tokens":53255,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPH1PXfwihcomadbDyF","type":"assistant","uuid":"895cc6c9-d995-42bb-b4a1-e0a22d0fd671","timestamp":"2026-01-25T03:27:22.615Z"}
{"parentUuid":"895cc6c9-d995-42bb-b4a1-e0a22d0fd671","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0111RFZUqR2pvGsMjSUasguA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PgUiYqywZTUQM2rvxG21YT","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/core/SKILL.md","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4920,"cache_creation_input_tokens":53255,"cache_read_input_tokens":32027,"cache_creation":{"ephemeral_5m_input_tokens":53255,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPH1PXfwihcomadbDyF","type":"assistant","uuid":"9a09f824-644d-48f5-b03e-7e9cc6db5eea","timestamp":"2026-01-25T03:27:22.892Z"}
{"parentUuid":"9a09f824-644d-48f5-b03e-7e9cc6db5eea","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0111RFZUqR2pvGsMjSUasguA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018iSyNzNCN3NJy1yLHeHC2P","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/services/agent/tool_executor.py","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4920,"cache_creation_input_tokens":53255,"cache_read_input_tokens":32027,"cache_creation":{"ephemeral_5m_input_tokens":53255,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPH1PXfwihcomadbDyF","type":"assistant","uuid":"a930c6e6-1da3-4b5a-a2a1-12868e8407a3","timestamp":"2026-01-25T03:27:23.339Z"}
{"parentUuid":"895cc6c9-d995-42bb-b4a1-e0a22d0fd671","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GHA3xZoHzmBCTaoM9UmV7q","type":"tool_result","content":"     1→---\n     2→id: bazi\n     3→name: 八字命理\n     4→version: 4.0.0\n     5→description: |\n     6→  八字命理分析。融汇《滴天髓》《穷通宝鉴》《子平真诠》等经典的八字命理大师。\n     7→  工具：collect_bazi_info, calculate_bazi, show_bazi_chart, show_bazi_fortune, show_bazi_kline, show_skill_intro\n     8→triggers:\n     9→  - 八字\n    10→  - 命理\n    11→  - 生辰\n    12→  - 算命\n    13→  - 看命\n    14→  - 命盘\n    15→  - 排盘\n    16→category: astrology\n    17→requires_birth_info: true\n    18→requires_compute: true\n    19→compute_tool: calculate_bazi\n    20→collect_tool: collect_bazi_info\n    21→---\n    22→\n    23→# 八字命理 Skill\n    24→\n    25→## 专家身份\n    26→\n    27→我是融汇《滴天髓》《穷通宝鉴》《子平真诠》《东方代码启示录》四大经典的八字命理宗师。以用神为纲、调候为急、格局为本、十神生克为用，四法合参，洞察命运玄机。我不故弄玄虚，用现代语言解读古老智慧，帮助你理解自己的天赋、运势和人生方向。\n    28→\n    29→**知识来源优先级**：\n    30→1. 《滴天髓》《穷通宝鉴》《子平真诠》《东方代码启示录》（核心经典）\n    31→2. 实战验证案例\n    32→3. 大模型通用知识\n    33→\n    34→---\n    35→\n    36→## 核心能力索引\n    37→\n    38→| 能力 | 规则 | 典型问题 | 优先级 |\n    39→|-----|------|---------|-------|\n    40→| 基础解读 | basic-reading | 看命盘、算命、我的八字 | CRITICAL |\n    41→| 事业分析 | career | 适合什么工作、事业运势 | HIGH |\n    42→| 感情分析 | relationship | 婚姻、桃花、另一半 | HIGH |\n    43→| 财运分析 | wealth | 财运、投资、能发财吗 | MEDIUM |\n    44→| 运势分析 | fortune | 大运、流年、今年运势 | MEDIUM |\n    45→| 合婚配对 | compatibility | 合不合、八字配对 | LOW |\n    46→\n    47→**路由策略**：基于用户问题语义匹配最相关规则，无需精确触发词\n    48→\n    49→---\n    50→\n    51→## 工具快速参考\n    52→\n    53→| 用户意图 | 调用工具 | 说明 |\n    54→|---------|---------|------|\n    55→| 看命盘、排盘 | `show_bazi_chart` | 展示四柱、十神、五行 |\n    56→| 大运、流年 | `show_bazi_fortune` | 展示大运流年分析 |\n    57→| 运势趋势 | `show_bazi_kline` | 展示运势 K 线图 |\n    58→| 缺少出生信息 | `collect_bazi_info` | 收集生辰表单 |\n    59→| 需要参考知识 | `search_db` | 检索经典和案例 |\n    60→\n    61→**调用原则**：\n    62→1. 用户已有出生信息时，直接调用展示工具\n    63→2. 分析前先调用 `search_db` 检索相关知识\n    64→3. 核心洞察用 `show_insight` 展示（不超过 4 点）\n    65→\n    66→---\n    67→\n    68→## 知识检索策略\n    69→\n    70→**检索时机**：\n    71→- 用户首次提问时检索命局分析要点\n    72→- 涉及专业术语时检索定义和用法\n    73→- 需要案例支撑时检索类似命局\n    74→\n    75→**Query 构建**：\n    76→- 基础解读：\"{day_stem} 日主 性格 特质\"\n    77→- 事业分析：\"{dominant_gods} 职业方向 工作特点\"\n    78→- 感情分析：\"{spouse_star} 配偶 感情模式\"\n    79→- 运势分析：\"大运 {current_dayun} {day_stem} 十年运\"\n    80→\n    81→---\n    82→\n    83→## 服务原则\n    84→\n    85→1. **先收集后分析**：没有出生信息时先调用 `collect_bazi_info`\n    86→2. **先检索后回答**：重要分析前先 `search_db` 获取知识支撑\n    87→3. **可视化优先**：能用卡片展示的不用纯文字\n    88→4. **通俗易懂**：避免堆砌术语，用生活化语言\n    89→5. **积极引导**：困难是成长机会，避免宿命论\n    90→\n    91→---\n    92→\n    93→## 伦理边界\n    94→\n    95→### 绝对禁止\n    96→- 预测具体事件的确切日期\n    97→- 给出\"命中注定\"的定论\n    98→- 涉及健康诊断的具体预测\n    99→- 替用户做重大人生决定\n   100→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a06c415d-9df1-4c9c-ba82-2236c1feb99b","timestamp":"2026-01-25T03:27:23.447Z","sourceToolAssistantUUID":"895cc6c9-d995-42bb-b4a1-e0a22d0fd671"}
{"parentUuid":"9a09f824-644d-48f5-b03e-7e9cc6db5eea","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PgUiYqywZTUQM2rvxG21YT","type":"tool_result","content":"     1→---\n     2→id: core\n     3→name: Vibe\n     4→version: 9.1.0\n     5→description: |\n     6→  生命对话者。全程激活，提供对话能力和全局工具。\n     7→  工具：activate_skills, ask, save, read, search, show, remind\n     8→category: core\n     9→---\n    10→\n    11→# Vibe - 生命对话者\n    12→\n    13→## 人格\n    14→\n    15→温暖但不粘腻，智慧但不说教，好奇但不窥探，诚实但不伤害。\n    16→\n    17→> \"我不是来给你答案的，我是来陪你找到你自己的答案的。\"\n    18→\n    19→## 核心能力\n    20→\n    21→1. 倾听共情：先理解情绪，再处理事件\n    22→2. 模式觉察：发现用户自己没意识到的重复模式\n    23→3. 引导探索：用问题引导用户自己发现答案\n    24→4. 适度沉默：知道什么时候不说比说更好\n    25→\n    26→## 禁止\n    27→\n    28→- 不说\"你应该...\"、\"你必须...\"\n    29→- 不给未经请求的建议\n    30→- 不预测具体事件（如\"你下个月会遇到贵人\"）\n    31→- 不透露技术细节（模型名称等）\n    32→- 当被问\"你是什么模型\"时，回答\"我是 Vibe，你的生命对话者\"\n    33→\n    34→## 规则索引\n    35→\n    36→| 规则 | 文件 | 使用场景 |\n    37→|-----|------|---------|\n    38→| 危机处理 | `rules/crisis.md` | 用户表达强烈负面情绪时 |\n    39→| 对话技术 | `rules/dialog-principles.md` | 日常对话参考 |\n    40→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e2d46066-720e-4fa8-b4c2-f7d5fd6883ff","timestamp":"2026-01-25T03:27:23.447Z","sourceToolAssistantUUID":"9a09f824-644d-48f5-b03e-7e9cc6db5eea"}
{"parentUuid":"a930c6e6-1da3-4b5a-a2a1-12868e8407a3","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018iSyNzNCN3NJy1yLHeHC2P","type":"tool_result","content":"     1→\"\"\"\n     2→Tool Executor v10 - 工具执行器\n     3→\n     4→从 core.py 拆分出来的工具执行逻辑，支持：\n     5→- 统一工具执行\n     6→- 自动 checkpoint 保存\n     7→- Phase 1 路由工具处理\n     8→- 工具结果处理\n     9→\n    10→与 ContextManager 协作：\n    11→- 工具执行后自动保存 checkpoint\n    12→- 收集工具数据自动累积\n    13→\"\"\"\n    14→import json\n    15→import logging\n    16→from dataclasses import dataclass\n    17→from typing import Optional, Dict, Any, Callable, Awaitable\n    18→\n    19→from .tool_registry import ToolRegistry, ToolContext\n    20→from .skill_loader import load_skill, get_skill_rules, load_rule\n    21→\n    22→logger = logging.getLogger(__name__)\n    23→\n    24→\n    25→@dataclass\n    26→class ToolResult:\n    27→    \"\"\"工具执行结果\"\"\"\n    28→    data: Dict[str, Any]\n    29→    should_checkpoint: bool = False\n    30→    checkpoint_data: Optional[Dict[str, Any]] = None\n    31→    should_reload_context: bool = False  # 是否需要重新加载上下文\n    32→\n    33→\n    34→class ToolExecutor:\n    35→    \"\"\"\n    36→    工具执行器\n    37→\n    38→    职责：\n    39→    1. 执行工具调用\n    40→    2. 处理 Phase 1 路由工具\n    41→    3. 判断是否需要保存 checkpoint\n    42→    4. 返回执行结果\n    43→    \"\"\"\n    44→\n    45→    # 需要保存 checkpoint 的工具\n    46→    CHECKPOINT_TOOLS = {\n    47→        \"save_checkpoint\",\n    48→        \"write_state\",\n    49→        \"append_to_list\",\n    50→        \"save_skill_data\",\n    51→        \"request_info\",  # 收集工具\n    52→    }\n    53→\n    54→    # 收集型工具（返回的数据需要累积）\n    55→    COLLECT_TOOLS = {\n    56→        \"request_info\",\n    57→        \"ask_user_question\",\n    58→    }\n    59→\n    60→    def __init__(self):\n    61→        from .context_manager import get_context_manager\n    62→        self.context_manager = get_context_manager()\n    63→\n    64→    async def execute(\n    65→        self,\n    66→        tool_name: str,\n    67→        tool_args: str,\n    68→        context: ToolContext,\n    69→        current_message: str = \"\",\n    70→        reload_callback: Optional[Callable[[], Awaitable[None]]] = None\n    71→    ) -> ToolResult:\n    72→        \"\"\"\n    73→        执行工具调用\n    74→\n    75→        Args:\n    76→            tool_name: 工具名称\n    77→            tool_args: 工具参数（JSON 字符串）\n    78→            context: 工具上下文\n    79→            current_message: 当前用户消息（用于路由）\n    80→            reload_callback: 上下文重载回调（用于 activate_skill 后重新构建 prompt）\n    81→\n    82→        Returns:\n    83→            ToolResult 包含执行结果和 checkpoint 信息\n    84→        \"\"\"\n    85→        try:\n    86→            args = json.loads(tool_args) if tool_args else {}\n    87→        except json.JSONDecodeError:\n    88→            args = {}\n    89→\n    90→        # ═══════════════════════════════════════════════════════════════\n    91→        # Phase 1 路由工具\n    92→        # ═══════════════════════════════════════════════════════════════\n    93→\n    94→        # 移除 activate_skill：统一使用 activate_skills\n    95→\n    96→        # LLM-First: 不再提供平台级的 show_protocol_invitation/show_skill_intro/recommend_skills\n    97→        # 若某 Skill 自行实现了同名工具，走通用 ToolRegistry 执行路径\n    98→\n    99→        # 兼容旧的 use_skill\n   100→        if tool_name == \"use_skill\":\n   101→            # 兼容别名（仍接受）：映射为 activate_skills\n   102→            s = args.get(\"skill\")\n   103→            new_args = {\"skills\": [s] if s else [], \"rule\": args.get(\"scenario\")}\n   104→            return await self._handle_activate_skill(new_args, context, current_message, reload_callback)\n   105→\n   106→        # ═══════════════════════════════════════════════════════════════\n   107→        # Session 管理工具（v10 新增）\n   108→        # ═══════════════════════════════════════════════════════════════\n   109→\n   110→        if tool_name == \"save_checkpoint\":\n   111→            return await self._handle_save_checkpoint(args, context)\n   112→\n   113→        if tool_name == \"read_session_context\":\n   114→            return await self._handle_read_session_context(args, context)\n   115→\n   116→        if tool_name == \"add_finding\":\n   117→            return await self._handle_add_finding(args, context)\n   118→\n   119→        if tool_name == \"complete_session\":\n   120→            return await self._handle_complete_session(args, context)\n   121→\n   122→        # ═══════════════════════════════════════════════════════════════\n   123→        # 通用工具执行\n   124→        # ═══════════════════════════════════════════════════════════════\n   125→\n   126→        if ToolRegistry.has_handler(tool_name):\n   127→            result = await ToolRegistry.execute(tool_name, args, context)\n   128→\n   129→            # 判断是否需要保存 checkpoint\n   130→            should_checkpoint = tool_name in self.CHECKPOINT_TOOLS\n   131→            checkpoint_data = None\n   132→\n   133→            # LLM-First: 识别由 Core 原子工具返回的上下文重载标志\n   134→            should_reload = False\n   135→            if isinstance(result, dict):\n   136→                should_reload = bool(result.get(\"_should_reload_context\"))\n   137→            # 明确约定：activate_skills 一定触发重载\n   138→            if tool_name == \"activate_skills\":\n   139→                should_reload = True\n   140→\n   141→            if tool_name in self.COLLECT_TOOLS and result.get(\"status\") == \"success\":\n   142→                # 收集工具的数据需要累积\n   143→                checkpoint_data = {\n   144→                    \"tool\": tool_name,\n   145→                    \"data\": result\n   146→                }\n   147→\n   148→            return ToolResult(\n   149→                data=result,\n   150→                should_checkpoint=should_checkpoint,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c6dc8a00-93de-4324-b43f-5f0524f87d8f","timestamp":"2026-01-25T03:27:23.447Z","sourceToolAssistantUUID":"a930c6e6-1da3-4b5a-a2a1-12868e8407a3"}
{"parentUuid":"c6dc8a00-93de-4324-b43f-5f0524f87d8f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01GHA3xZoHzmBCTaoM9UmV7q","toolUseID":"toolu_01GHA3xZoHzmBCTaoM9UmV7q","timestamp":"2026-01-25T03:27:23.488Z","uuid":"9cefb7ec-f099-4048-9093-6befa08d6521"}
{"parentUuid":"9cefb7ec-f099-4048-9093-6befa08d6521","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01PgUiYqywZTUQM2rvxG21YT","toolUseID":"toolu_01PgUiYqywZTUQM2rvxG21YT","timestamp":"2026-01-25T03:27:23.488Z","uuid":"9d6f945b-c704-48f6-90f2-a8f816e150fb"}
{"parentUuid":"9d6f945b-c704-48f6-90f2-a8f816e150fb","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_018iSyNzNCN3NJy1yLHeHC2P","toolUseID":"toolu_018iSyNzNCN3NJy1yLHeHC2P","timestamp":"2026-01-25T03:27:23.488Z","uuid":"eab8be62-9329-41da-9adf-4484781c6ffb"}
{"parentUuid":"eab8be62-9329-41da-9adf-4484781c6ffb","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018L6pfFQKmd9dQeqjsAe9MZ","type":"message","role":"assistant","content":[{"type":"text","text":"让我继续读取更多关键文件来完整理解路由流程："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9892,"cache_read_input_tokens":85282,"cache_creation":{"ephemeral_5m_input_tokens":9892,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPHSyfarr567yhvLuQo","type":"assistant","uuid":"a3d5b700-9dd9-4ba2-9816-563667d319a5","timestamp":"2026-01-25T03:27:26.940Z"}
{"parentUuid":"a3d5b700-9dd9-4ba2-9816-563667d319a5","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018L6pfFQKmd9dQeqjsAe9MZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WSawwsBkRuMcFgcoPy76cQ","name":"Bash","input":{"command":"grep -r \"activate_skills\" /home/aiscend/work/vibelife/apps/api/skills/core/tools/ 2>/dev/null | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9892,"cache_read_input_tokens":85282,"cache_creation":{"ephemeral_5m_input_tokens":9892,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPHSyfarr567yhvLuQo","type":"assistant","uuid":"c16466a3-eb5a-440d-a7b4-3d97f35fb50f","timestamp":"2026-01-25T03:27:27.603Z"}
{"parentUuid":"c16466a3-eb5a-440d-a7b4-3d97f35fb50f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018L6pfFQKmd9dQeqjsAe9MZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DxfbLaHxnDkTYVAQcTQmR8","name":"Bash","input":{"command":"cat /home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml 2>/dev/null | head -60"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9892,"cache_read_input_tokens":85282,"cache_creation":{"ephemeral_5m_input_tokens":9892,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPHSyfarr567yhvLuQo","type":"assistant","uuid":"365e7b90-a51e-4981-aff8-aaeda3d0c37a","timestamp":"2026-01-25T03:27:27.892Z"}
{"parentUuid":"365e7b90-a51e-4981-aff8-aaeda3d0c37a","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018L6pfFQKmd9dQeqjsAe9MZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013MoapPCvzLGfz5AsXxy5Vw","name":"Bash","input":{"command":"ls -la /home/aiscend/work/vibelife/apps/api/skills/core/rules/ 2>/dev/null"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9892,"cache_read_input_tokens":85282,"cache_creation":{"ephemeral_5m_input_tokens":9892,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPHSyfarr567yhvLuQo","type":"assistant","uuid":"4051585b-f5b4-455b-b7c0-24f649b4170d","timestamp":"2026-01-25T03:27:28.209Z"}
{"parentUuid":"4051585b-f5b4-455b-b7c0-24f649b4170d","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013MoapPCvzLGfz5AsXxy5Vw","type":"tool_result","content":"总计 32\ndrwxrwxr-x 2 aiscend aiscend 4096 Jan 25 09:14 .\ndrwxrwxr-x 7 aiscend aiscend 4096 Jan 24 23:18 ..\n-rw-rw-r-- 1 aiscend aiscend 3614 Jan 19 21:17 birthday.md\n-rw-rw-r-- 1 aiscend aiscend  302 Jan 25 09:14 boundary.md\n-rw-rw-r-- 1 aiscend aiscend 1902 Jan 11 18:31 crisis.md\n-rw-rw-r-- 1 aiscend aiscend 3190 Jan 11 18:31 dialog-principles.md\n-rw-rw-r-- 1 aiscend aiscend 2717 Jan 19 21:17 monthly-report.md\n-rw-rw-r-- 1 aiscend aiscend 2192 Jan 19 21:16 weekly-summary.md","is_error":false}]},"uuid":"f5afe2cb-8e15-4814-a859-fe769df0f54d","timestamp":"2026-01-25T03:27:28.397Z","sourceToolAssistantUUID":"4051585b-f5b4-455b-b7c0-24f649b4170d"}
{"parentUuid":"365e7b90-a51e-4981-aff8-aaeda3d0c37a","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DxfbLaHxnDkTYVAQcTQmR8","type":"tool_result","content":"version: \"3.0\"\nskill_id: core\ndescription: V9 Core 全局工具 - 7 个原子工具\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 1. 路由工具\n# ═══════════════════════════════════════════════════════════════════════════\nrouting:\n  - name: activate_skills\n    description: |\n      激活一个或多个 Skill。\n\n      ## 何时调用\n      - 用户意图明确需要某个 Skill 时\n      - 用户说\"帮我算命\" → activate_skills([\"bazi\"])\n      - 用户说\"看职业运势\" → activate_skills([\"bazi\", \"career\"])\n      - 用户说\"看合盘\" → activate_skills([\"synastry\"])\n\n      ## 可用 Skills\n      - bazi: 八字命理（触发词：八字、命理、算命、排盘）\n      - zodiac: 西方占星（触发词：星座、星盘、占星、运势）\n      - tarot: 塔罗占卜（触发词：塔罗、抽牌、占卜）\n      - career: 职业规划（触发词：职业、工作、跳槽、创业）\n      - psych: 心理探索（触发词：心理、情绪、焦虑）\n      - mindfulness: 正念练习（触发词：冥想、正念、放松）\n      - lifecoach: 人生教练（触发词：目标、计划、教练）\n      - vibe_id: 四维人格（触发词：性格、人格、画像）\n      - jungastro: 荣格占星（触发词：荣格、心理占星）\n      - synastry: 关系合盘（触发词：合盘、关系、配对）\n    parameters:\n      - name: skills\n        type: array\n        required: true\n        description: 要激活的 Skill ID 列表\n      - name: rule\n        type: string\n        required: false\n        description: 可选的规则 ID，用于指定具体场景\n\n# ═══════════════════════════════════════════════════════════════════════════\n# 2. 收集工具\n# ═══════════════════════════════════════════════════════════════════════════\ncollect:\n  - name: ask\n    description: |\n      向用户提问或请求信息。合并了 request_info 和 ask_user_question。\n\n      ## 何时调用\n      - 需要收集出生信息时 → ask(question=\"...\", form_type=\"birth\")\n      - 需要用户选择时 → ask(question=\"...\", form_type=\"select\", options=[...])\n      - 需要文本输入时 → ask(question=\"...\", form_type=\"text\")\n      - 需要自定义表单时 → ask(question=\"...\", form_type=\"custom\", fields=[...])\n\n      ## form_type 说明\n      - birth: 出生信息表单（日期、时间、地点、性别）\n      - text: 文本输入框\n      - select: 选择器（需提供 options）\n      - custom: 自定义表单（需提供 fields）\n    card_type: collect_form\n    parameters:","is_error":false}]},"uuid":"cfefc17d-34a3-43fe-af5b-970c0c8647c5","timestamp":"2026-01-25T03:27:28.488Z","sourceToolAssistantUUID":"365e7b90-a51e-4981-aff8-aaeda3d0c37a"}
{"parentUuid":"c16466a3-eb5a-440d-a7b4-3d97f35fb50f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WSawwsBkRuMcFgcoPy76cQ","type":"tool_result","content":"/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml:  - name: activate_skills\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml:      - 用户说\"帮我算命\" → activate_skills([\"bazi\"])\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml:      - 用户说\"看职业运势\" → activate_skills([\"bazi\", \"career\"])\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml:      - 用户说\"看合盘\" → activate_skills([\"synastry\"])\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py:- activate_skills: 多 Skill 激活\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py:# 1. 路由工具 - activate_skills\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py:@tool_handler(\"activate_skills\")\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py:async def execute_activate_skills(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py:    logger.info(f\"[activate_skills] Activating: {skills}, rule: {rule}\")\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py:# 注意：文档与提示统一为 activate_skills；旧 activate_skill 仅用于历史对话回放。\n/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py:# 已移除 activate_skill 兼容转发；统一使用 activate_skills","is_error":false}]},"uuid":"cdbc6db6-88cf-4f2a-a974-2c247fa12e63","timestamp":"2026-01-25T03:27:28.491Z","sourceToolAssistantUUID":"c16466a3-eb5a-440d-a7b4-3d97f35fb50f"}
{"parentUuid":"cdbc6db6-88cf-4f2a-a974-2c247fa12e63","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018frNsMsnuhvUZh4igH4EUF","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我读取核心的 handlers.py 文件来看实际的路由执行逻辑："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1224,"cache_creation_input_tokens":1103,"cache_read_input_tokens":95174,"cache_creation":{"ephemeral_5m_input_tokens":1103,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPHpAsSwi2VaGWVQzXZ","type":"assistant","uuid":"624d95ec-4d9a-40e3-aaf6-6a5824cb252f","timestamp":"2026-01-25T03:27:31.353Z"}
{"parentUuid":"624d95ec-4d9a-40e3-aaf6-6a5824cb252f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018frNsMsnuhvUZh4igH4EUF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0191Uvzs15k6755b93KWnGe1","name":"Read","input":{"file_path":"/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1224,"cache_creation_input_tokens":1103,"cache_read_input_tokens":95174,"cache_creation":{"ephemeral_5m_input_tokens":1103,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPHpAsSwi2VaGWVQzXZ","type":"assistant","uuid":"e6407448-23ca-46ae-b673-d0f94dd59144","timestamp":"2026-01-25T03:27:31.799Z"}
{"parentUuid":"e6407448-23ca-46ae-b673-d0f94dd59144","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0191Uvzs15k6755b93KWnGe1","type":"tool_result","content":"     1→\"\"\"\n     2→Core Skill Tool Handlers - V9 原子工具执行器\n     3→\n     4→V9 架构：7 个原子工具，内部路由到原有实现\n     5→- activate_skills: 多 Skill 激活\n     6→- ask: 收集信息（合并 request_info + ask_user_question）\n     7→- save: 保存数据（合并 save_birth_info + write_state + save_skill_data）\n     8→- read: 读取数据（合并 read_state + read_user_data）\n     9→- search: 检索知识（从 search_db 简化）\n    10→- show: 展示内容（合并 show_card + show_all_skills + recommend_skill）\n    11→- remind: 管理提醒（合并 create/list/cancel_trigger）\n    12→\n    13→使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。\n    14→\"\"\"\n    15→import logging\n    16→from datetime import datetime, timezone\n    17→from typing import Dict, Any\n    18→\n    19→from services.agent.tool_registry import tool_handler, ToolContext\n    20→from services.agent.validators import validate_save_path, validate_show_args, validate_remind_args\n    21→from services.agent.schemas.cards import validate_card\n    22→\n    23→logger = logging.getLogger(__name__)\n    24→\n    25→\n    26→# ═══════════════════════════════════════════════════════════════════════════\n    27→# 1. 路由工具 - activate_skills\n    28→# ═══════════════════════════════════════════════════════════════════════════\n    29→\n    30→@tool_handler(\"activate_skills\")\n    31→async def execute_activate_skills(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    32→    \"\"\"\n    33→    激活一个或多个 Skill（V9 核心路由工具）\n    34→\n    35→    返回 should_reload_context=True 触发上下文重载\n    36→    \"\"\"\n    37→    skills = args.get(\"skills\", [])\n    38→    rule = args.get(\"rule\")\n    39→\n    40→    if not skills:\n    41→        return {\n    42→            \"status\": \"error\",\n    43→            \"error\": \"skills 参数不能为空\"\n    44→        }\n    45→\n    46→    # 取第一个作为主 Skill（V9 过渡期兼容）\n    47→    primary_skill = skills[0] if isinstance(skills, list) else skills\n    48→\n    49→    logger.info(f\"[activate_skills] Activating: {skills}, rule: {rule}\")\n    50→\n    51→    return {\n    52→        \"status\": \"success\",\n    53→        \"skill\": primary_skill,\n    54→        \"skills\": skills,\n    55→        \"rule\": rule,\n    56→        \"message\": f\"已激活 {', '.join(skills) if isinstance(skills, list) else skills}\",\n    57→        \"_should_reload_context\": True  # 标记需要重载上下文\n    58→    }\n    59→\n    60→\n    61→# ═══════════════════════════════════════════════════════════════════════════\n    62→# 2. 收集工具 - ask\n    63→# ═══════════════════════════════════════════════════════════════════════════\n    64→\n    65→@tool_handler(\"ask\")\n    66→async def execute_ask(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    67→    \"\"\"\n    68→    向用户提问或请求信息\n    69→\n    70→    根据 form_type 路由到不同表单：\n    71→    - birth: 出生信息表单\n    72→    - text: 文本输入框\n    73→    - select: 选择器\n    74→    - custom: 自定义表单\n    75→    \"\"\"\n    76→    question = args.get(\"question\", \"\")\n    77→    form_type = args.get(\"form_type\", \"text\")\n    78→    options = args.get(\"options\", [])\n    79→    fields = args.get(\"fields\", [])\n    80→\n    81→    # 根据 form_type 构建表单字段\n    82→    if form_type == \"birth\":\n    83→        form_fields = [\n    84→            {\"id\": \"birthDate\", \"label\": \"出生日期\", \"type\": \"date\", \"required\": True, \"placeholder\": \"\"},\n    85→            {\"id\": \"birthTime\", \"label\": \"出生时间\", \"type\": \"time\", \"required\": True, \"placeholder\": \"\"},\n    86→            {\"id\": \"birthPlace\", \"label\": \"出生地点\", \"type\": \"text\", \"required\": False, \"placeholder\": \"城市名\"},\n    87→            {\"id\": \"gender\", \"label\": \"性别\", \"type\": \"select\", \"required\": True, \"options\": [\n    88→                {\"value\": \"male\", \"label\": \"男\"},\n    89→                {\"value\": \"female\", \"label\": \"女\"},\n    90→            ]},\n    91→        ]\n    92→        return {\n    93→            \"status\": \"collecting\",\n    94→            \"cardType\": \"collect_form\",\n    95→            \"infoType\": \"birth\",\n    96→            \"question\": question,\n    97→            \"fields\": form_fields,\n    98→        }\n    99→\n   100→    elif form_type == \"select\":\n   101→        return {\n   102→            \"status\": \"asking\",\n   103→            \"cardType\": \"question_card\",\n   104→            \"question\": question,\n   105→            \"options\": options[:4] if options else [],\n   106→        }\n   107→\n   108→    elif form_type == \"custom\":\n   109→        return {\n   110→            \"status\": \"collecting\",\n   111→            \"cardType\": \"collect_form\",\n   112→            \"infoType\": \"custom\",\n   113→            \"question\": question,\n   114→            \"fields\": fields,\n   115→        }\n   116→\n   117→    else:  # text\n   118→        return {\n   119→            \"status\": \"collecting\",\n   120→            \"cardType\": \"collect_form\",\n   121→            \"infoType\": \"text\",\n   122→            \"question\": question,\n   123→            \"fields\": [\n   124→                {\"id\": \"text\", \"label\": \"回答\", \"type\": \"textarea\", \"required\": True, \"placeholder\": \"请输入...\"},\n   125→            ],\n   126→        }\n   127→\n   128→\n   129→# ═══════════════════════════════════════════════════════════════════════════\n   130→# 3. 保存工具 - save\n   131→# ═══════════════════════════════════════════════════════════════════════════\n   132→\n   133→@tool_handler(\"save\")\n   134→async def execute_save(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n   135→    \"\"\"\n   136→    保存数据到用户档案\n   137→\n   138→    根据 path 前缀路由到不同存储：\n   139→    - identity.birth_info: 出生信息\n   140→    - state.*: 运行时状态\n   141→    - skills.{skill_id}.*: Skill 专属数据\n   142→    - goals.*: 目标数据\n   143→    - triggers.*: 触发器数据\n   144→    \"\"\"\n   145→    from uuid import UUID\n   146→    from stores.unified_profile_repo import UnifiedProfileRepository, deep_merge\n   147→    from stores.profile_cache import invalidate_profile_cache\n   148→\n   149→    path = args.get(\"path\", \"\")\n   150→    data = args.get(\"data\")\n   151→    merge = args.get(\"merge\", True)\n   152→\n   153→    if not path:\n   154→        return {\"status\": \"error\", \"error\": \"path 参数不能为空\"}\n   155→    if not validate_save_path(path):\n   156→        return {\"status\": \"error\", \"error\": f\"非法保存路径: {path}\"}\n   157→\n   158→    if not context.user_id or context.user_id == \"guest\":\n   159→        return {\"status\": \"error\", \"error\": \"需要登录才能保存数据\"}\n   160→\n   161→    try:\n   162→        user_uuid = UUID(context.user_id) if isinstance(context.user_id, str) else context.user_id\n   163→        path_parts = path.split(\".\")\n   164→\n   165→        # 路由到不同存储\n   166→        if path.startswith(\"identity.birth_info\"):\n   167→            # 保存出生信息\n   168→            if data is None:\n   169→                return {\"status\": \"error\", \"error\": \"不能删除出生信息\"}\n   170→\n   171→            # 检查是否已有出生信息\n   172→            profile = context.profile or {}\n   173→            identity = profile.get(\"identity\", {})\n   174→            existing_birth = identity.get(\"birth_info\", {})\n   175→            if existing_birth.get(\"date\"):\n   176→                return {\n   177→                    \"status\": \"error\",\n   178→                    \"error\": \"用户已有出生信息，不能覆盖。如需修改，请使用设置页面。\",\n   179→                    \"existing_birth_info\": existing_birth,\n   180→                }\n   181→\n   182→            await UnifiedProfileRepository.update_birth_info(user_uuid, data)\n   183→            await invalidate_profile_cache(user_uuid)\n   184→\n   185→            return {\n   186→                \"status\": \"success\",\n   187→                \"message\": \"出生信息已保存\",\n   188→                \"path\": path,\n   189→            }\n   190→\n   191→        elif path.startswith(\"skills.\"):\n   192→            # 保存 Skill 数据\n   193→            # path: skills.{skill_id}.{section}\n   194→            if len(path_parts) < 2:\n   195→                return {\"status\": \"error\", \"error\": \"Skill path 格式错误，需要 skills.{skill_id}.*\"}\n   196→\n   197→            skill_id = path_parts[1]\n   198→            section = \".\".join(path_parts[2:]) if len(path_parts) > 2 else None\n   199→\n   200→            if data is None:\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c20c31a2-5a46-483e-8724-fef6efaceb0f","timestamp":"2026-01-25T03:27:31.932Z","sourceToolAssistantUUID":"e6407448-23ca-46ae-b673-d0f94dd59144"}
{"parentUuid":"c20c31a2-5a46-483e-8724-fef6efaceb0f","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_0191Uvzs15k6755b93KWnGe1","toolUseID":"toolu_0191Uvzs15k6755b93KWnGe1","timestamp":"2026-01-25T03:27:31.975Z","uuid":"d2149bb1-293b-42b6-917d-88ab141764ab"}
{"parentUuid":"d2149bb1-293b-42b6-917d-88ab141764ab","isSidechain":true,"userType":"external","cwd":"/home/aiscend/work/vibelife","sessionId":"80c7d6d7-00b7-445c-819f-7aa88a25876c","version":"2.1.19","gitBranch":"master","agentId":"a8b3668","slug":"scalable-honking-wozniak","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BQgrkWcE587dTYBAxYPcVF","type":"message","role":"assistant","content":[{"type":"text","text":"现在我有足够的信息。让我生成一份完整的分析报告。\n\n## VibeLife 项目 Agent/Skill 路由机制完整分析\n\n### 架构概览\n\nVibeLife 的路由机制采用 **LLM-First + V9 渐进式加载架构**，这是一个完全由 LLM 自主决策驱动的系统，而不是硬编码的规则引擎。整个流程分为两个阶段：\n\n**Phase 1（Skill 选择阶段）**：LLM 基于用户消息和可用技能清单，自主决策激活哪个/哪些 Skill。\n**Phase 2（Skill 执行阶段）**：在激活的 Skill 内执行具体操作。\n\n---\n\n## 核心文件结构\n\n```\n/home/aiscend/work/vibelife/apps/api/services/agent/\n├── core.py                    # CoreAgent v10 主循环（Phase 0/1/2 控制）\n├── skill_loader.py           # V9 渐进式加载（Phase 1 meta 加载，Phase 2 完整加载）\n├── prompt_builder.py         # System Prompt 构建（Phase 1 vs Phase 2 不同）\n├── tool_registry.py          # 工具注册表（动态加载 YAML + handlers）\n├── tool_executor.py          # 工具执行器（包含 activate_skills 路由逻辑）\n└── context_manager.py        # 会话上下文管理\n\n/home/aiscend/work/vibelife/apps/api/skills/\n├── core/\n│   ├── SKILL.md              # Core Skill 定义（全局工具宿主）\n│   └── tools/\n│       ├── tools.yaml        # activate_skills / ask / save 等 7 个原子工具\n│       └── handlers.py       # 工具执行器实现\n├── bazi/\n│   ├── SKILL.md              # 八字 Skill 定义（含触发词）\n│   └── tools/tools.yaml      # 八字专属工具（calculate_bazi 等）\n├── zodiac/                   # 西方占星\n├── career/                   # 职业规划\n├── lifecoach/                # 人生教练\n└── ... 其他 10+ 个 Skill\n```\n\n---\n\n## 完整路由流程（以\"我的生日是哪天\"为例）\n\n### 第 0 步：系统初始化\n\n```python\n# core.py - CoreAgent.__init__\nclass CoreAgent:\n    async def run(self, message: str, context: AgentContext):\n        # ═══════════════════════════════════════════════════════════════\n        # 初始化 v10 模块\n        # ═══════════════════════════════════════════════════════════════\n        self.context_manager = get_context_manager()      # 加载持久化会话\n        self.session_manager = get_session_manager()      # 恢复断点\n        self.prompt_builder = get_prompt_builder()        # 构建 Prompt\n        self.tool_executor = get_tool_executor()          # 执行工具\n        \n        # 初始状态：无激活 Skill\n        self._active_skills: List[str] = []\n        self._active_skill: Optional[str] = None\n```\n\n### 第 1 步：Phase 0 - 会话恢复检查\n\n```python\n# core.py - lines 246-286\nactive_session = await self.session_manager.get_active_session(user_id)\n\nif active_session and active_session.is_active:\n    if should_resume:\n        # 自动恢复上次中断的会话\n        self._active_skill = active_session.skill_id\n        self._active_skills = [active_session.skill_id]\n        context.session_context = await context_manager.load_session_context(...)\n    elif should_ask_resume:\n        # 询问用户是否继续\n        yield AgentEvent(type=\"session_prompt\", data={...})\n```\n\n### 第 2 步：Phase 1 - 构建初始 Prompt（无激活 Skill）\n\n**关键函数调用链**：\n```python\n# core.py - line 323\nmessages = await self._build_initial_messages(message, context)\n\n# ↓ 调用\n# prompt_builder.py - async def build()\nif not skill_id:  # Phase 1 路由模式\n    from .skill_loader import build_phase1_prompt\n    core_prompt = build_phase1_prompt()\n    # 注入个性化信息\n    core_prompt = self._inject_phase1_context(core_prompt, profile)\n```\n\n**skill_loader.py - build_phase1_prompt() 实现**（第 1181-1224 行）：\n\n```python\ndef build_phase1_prompt() -> str:\n    \"\"\"构建 Phase 1 System Prompt - V9 新增\n    \n    Phase 1 提供：\n    - Core Skill 全文（精简版）\n    - 其他 Skill 的 frontmatter 列表（id, name, description）\n    \n    LLM 基于此选择 Skill(s)。\n    \"\"\"\n    parts = []\n    \n    # 1. Core Skill 全文（始终激活，精简 5000 字符）\n    core = get_core_skill()\n    core_text = core.content[:5000] + \"\\n\\n…\"\n    parts.append(f\"# {core.meta.name}\\n\\n{core_text}\")\n    \n    # 2. 可用 Skill 列表（load_all_skill_metas 加载）\n    skill_metas = load_all_skill_metas()  # 仅加载 frontmatter\n    \n    for skill_id, meta in sorted(skill_metas.items()):\n        # 来自 SKILL.md frontmatter 的元数据\n        line = f\"- **{meta.name}** (`{skill_id}`): {meta.description}\"\n        if meta.tools_list:\n            # 工具列表内嵌在 description 中\n            tools_text = \", \".join(meta.tools_list[:6])\n            line += f\"（工具：{tools_text}）\"\n        parts.append(line)\n    \n    # 3. 能力边界规则（core/rules/boundary.md）\n    boundary = load_boundary_rules_text()\n    parts.append(boundary)\n    \n    # 4. Phase 1 约束\n    parts.append(\"## 约束\\n- 本轮只允许：activate_skills、ask、show\\n...\")\n    \n    return \"\\n\".join(parts)\n```\n\n**生成的 Phase 1 Prompt 示例**：\n\n```markdown\n# Vibe - 生命对话者\n\n[Core Skill 完整内容 ~5000 字符]\n\n---\n\n## 可用功能\n\n根据用户意图，可调用 activate_skills 激活一个或多个技能：\n\n- **八字命理** (`bazi`): 八字命理分析。融汇《滴天髓》《穷通宝鉴》《子平真诠》等经典...\n  （工具：collect_bazi_info, calculate_bazi, show_bazi_chart, show_bazi_fortune）\n\n- **西方占星** (`zodiac`): 西方占星星盘计算与解读...\n  （工具：collect_zodiac_info, calculate_zodiac, show_zodiac_chart）\n\n- **塔罗占卜** (`tarot`): 塔罗牌占卜与洞察...\n  （工具：draw_tarot_cards, show_tarot_reading）\n\n- ... [其他 10+ 个 Skill]\n\n---\n\n## 能力边界\n\n[core/rules/boundary.md 内容 - 表达危机处理、伦理边界等]\n\n---\n\n## 约束\n\n- 本轮只允许：activate_skills、ask、show\n- 禁止假设未激活 Skill 的工具存在\n- 禁止编造：不要假装知道用户的命盘/星座数据\n```\n\n### 第 3 步：Phase 1 - LLM 决策路由\n\n```python\n# core.py - lines 344-367\nasync for chunk in self.llm.stream(\n    messages=messages,\n    tools=get_phase1_tools(),  # 仅 3 个工具\n    tool_choice=None\n):\n    if chunk[\"type\"] == \"content\":\n        # LLM 直接输出内容（问候或澄清）\n        yield AgentEvent(type=\"content\", data={\"content\": chunk[\"content\"]})\n    elif chunk[\"type\"] == \"tool_call\":\n        # LLM 决定调用 activate_skills 工具\n        tool_calls.append(chunk)\n```\n\n**Phase 1 工具集**（core.py - lines 99-168）：\n\n```python\ndef build_phase1_tools() -> List[Dict[str, Any]]:\n    \"\"\"Phase 1 路由工具集 - 仅 3 个\"\"\"\n    \n    # 工具 1: activate_skills（多技能激活）\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"activate_skills\",\n            \"description\": \"激活一个或多个技能\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"skills\": {\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\", \"enum\": [\"bazi\", \"zodiac\", \"tarot\", ...]}\n                    },\n                    \"rule\": {\"type\": \"string\"}\n                },\n                \"required\": [\"skills\"]\n            }\n        }\n    }\n    \n    # 工具 2: show（展示）\n    # 工具 3: ask（提问）\n```\n\n**用户消息** ➜ **LLM 思考** ➜ **工具调用**：\n\n```\n用户: \"我的生日是哪天\"\n\nLLM Thinking:\n- 用户问\"我的生日是哪天\" = 查询个人信息\n- 这不是在问命理分析、占星、职业规划等\n- Core Skill 可以处理：ask/save/read 通用工具\n- 或需要激活某个 Skill 来存储/分析\n- 决策：调用 ask 收集用户的生日信息，或直接读取已保存的生日\n\nLLM Tool Call:\n{\n    \"tool_name\": \"ask\",\n    \"arguments\": {\n        \"question\": \"请告诉我你的生日是哪天？\",\n        \"form_type\": \"birth\"\n    }\n}\n```\n\n### 第 4 步：Phase 1 - 工具执行（ask）\n\n```python\n# tool_executor.py - execute()\nresult = await self.tool_executor.execute(\n    tool_name=\"ask\",\n    tool_args={\"question\": \"...\", \"form_type\": \"birth\"},\n    context=ToolContext(...)\n)\n\n# ↓ 路由到 core handlers\n# skills/core/tools/handlers.py - lines 65-126\n\n@tool_handler(\"ask\")\nasync def execute_ask(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"向用户提问或请求信息\"\"\"\n    form_type = args.get(\"form_type\", \"text\")\n    \n    if form_type == \"birth\":\n        form_fields = [\n            {\"id\": \"birthDate\", \"label\": \"出生日期\", \"type\": \"date\"},\n            {\"id\": \"birthTime\", \"label\": \"出生时间\", \"type\": \"time\"},\n            {\"id\": \"birthPlace\", \"label\": \"出生地点\", \"type\": \"text\"},\n            {\"id\": \"gender\", \"label\": \"性别\", \"type\": \"select\"},\n        ]\n        return {\n            \"status\": \"collecting\",\n            \"cardType\": \"collect_form\",\n            \"infoType\": \"birth\",\n            \"fields\": form_fields,\n        }\n```\n\n**返回给前端**：\n```json\n{\n    \"status\": \"collecting\",\n    \"cardType\": \"collect_form\",\n    \"infoType\": \"birth\",\n    \"question\": \"请告诉我你的生日是哪天？\",\n    \"fields\": [\n        {\"id\": \"birthDate\", \"label\": \"出生日期\", \"type\": \"date\", \"required\": true},\n        {\"id\": \"birthTime\", \"label\": \"出生时间\", \"type\": \"time\", \"required\": true},\n        {\"id\": \"birthPlace\", \"label\": \"出生地点\", \"type\": \"text\", \"required\": false},\n        {\"id\": \"gender\", \"label\": \"性别\", \"type\": \"select\", \"required\": true}\n    ]\n}\n```\n\n### 第 5 步：用户填写表单，进入 Phase 2\n\n用户提交生日表单后，下一轮消息进来：\n\n```python\nmessage = {\n    \"birth_date\": \"1990-01-15\",\n    \"birth_time\": \"10:30\",\n    \"birth_place\": \"北京\",\n    \"gender\": \"female\"\n}\n\n# core.py 检测：\n# 1. 用户已提交生日信息\n# 2. 如果用户后续说\"帮我看看八字\"，LLM 决策：激活 bazi Skill\n```\n\n### 第 6 步：Phase 2 - Skill 激活 (activate_skills)\n\n```\n用户（新消息）: \"帮我看看八字\"\n\nLLM Thinking（Phase 1）:\n- 用户说\"看八字\" = 触发 bazi Skill\n- 决策：调用 activate_skills([\"bazi\"])\n\nLLM Tool Call:\n{\n    \"tool_name\": \"activate_skills\",\n    \"arguments\": {\n        \"skills\": [\"bazi\"],\n        \"rule\": null\n    }\n}\n```\n\n**工具执行**：\n\n```python\n# tool_executor.py - _handle_activate_skill()\n# skills/core/tools/handlers.py - lines 30-58\n\n@tool_handler(\"activate_skills\")\nasync def execute_activate_skills(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:\n    \"\"\"激活一个或多个 Skill（V9 核心路由工具）\"\"\"\n    skills = args.get(\"skills\", [])  # [\"bazi\"]\n    rule = args.get(\"rule\")          # None\n    \n    primary_skill = skills[0]  # \"bazi\"\n    \n    logger.info(f\"[activate_skills] Activating: {skills}, rule: {rule}\")\n    \n    return {\n        \"status\": \"success\",\n        \"skill\": primary_skill,        # \"bazi\"\n        \"skills\": skills,              # [\"bazi\"]\n        \"rule\": rule,\n        \"message\": f\"已激活 {', '.join(skills)}\",\n        \"_should_reload_context\": True  # ← 关键标志！\n    }\n```\n\n### 第 7 步：Phase 2 - 上下文重载\n\n```python\n# core.py - lines 432-465\nif result.should_reload_context:\n    # 从工具结果中提取激活的 skill\n    activated_skills = result.data.get(\"skills\", [])  # [\"bazi\"]\n    activated_skill = result.data.get(\"skill\")        # \"bazi\"\n    activated_rule = result.data.get(\"rule\")          # None\n    \n    if activated_skills:\n        self._active_skills = activated_skills\n        self._active_skill = activated_skills[0]\n    \n    # 重新构建 System Prompt（Phase 2）\n    new_system_prompt = await self._build_system_prompt(\n        self._current_message,  # \"帮我看看八字\"\n        context\n    )\n    \n    # 更新消息历史\n    self._messages[0] = LLMMessage(role=\"system\", content=new_system_prompt)\n    messages[0] = self._messages[0]\n    \n    logger.info(f\"[CoreAgent] Phase 2 prompt rebuilt\")\n```\n\n### 第 8 步：Phase 2 - 构建新 Prompt\n\n```python\n# prompt_builder.py - async def build()\nasync def build(\n    self,\n    skill_id=\"bazi\",                    # ← 已激活！\n    rule_id=None,\n    message=\"帮我看看八字\",\n    profile={...},                      # 用户 Profile（包含生日）\n    skill_data={...},                   # 八字计算数据\n    ...\n) -> str:\n    \"\"\"构建 Phase 2 System Prompt - Skill 执行阶段\"\"\"\n    \n    # 基础 Skill Prompt（从 SKILL.md 加载）\n    user_ctx = dict(profile)\n    base_prompt = build_system_prompt(\"bazi\", None, user_ctx)\n    \n    # ↓ skill_loader.py - lines 1567-1708\n    # 1. 加载 SKILL.md（完整，不含 frontmatter）\n    skill_md_content = _load_skill_md_content(\"bazi\")\n    # 内容：专家身份 + 核心能力 + 服务原则 + 伦理边界 + 工具快速参考 等\n    \n    # 2. 加载 Profile 上下文（三层架构）\n    profile_context = self._build_profile_context(profile, skill_data, \"bazi\")\n    # Layer 1: Identity（基本信息）\n    # Layer 2: Skills（八字专属数据）\n    # Layer 3: Vibe（共享深度信息 - 原型、目标等）\n    \n    # 3. 加载 SOP 规则\n    sop_rules = self._build_sop_rules(\"bazi\", profile, skill_data)\n    # 检查：需要出生信息吗？用户已有吗？\n    # 检查：需要计算/排盘吗？已有命盘数据吗？\n    \n    # 4. 案例匹配\n    cases_text = await self._match_cases(\"bazi\", skill_data)\n```\n\n**生成的 Phase 2 Prompt 示例**：\n\n```markdown\n# 八字命理 Skill\n\n## 专家身份\n\n我是融汇《滴天髓》《穷通宝鉴》《子平真诠》等经典的八字命理宗师...\n\n## 核心能力索引\n\n| 能力 | 规则 | 典型问题 |\n|-----|------|---------|\n| 基础解读 | basic-reading | 看命盘、算命... |\n| 事业分析 | career | 适合什么工作... |\n...\n\n## 工具快速参考\n\n| 用户意图 | 调用工具 | 说明 |\n|---------|---------|------|\n| 看命盘、排盘 | show_bazi_chart | 展示四柱、十神、五行 |\n...\n\n---\n\n## 用户信息\n\n- 用户名：[用户昵称]\n- 出生日期：1990-01-15\n- 出生时间：10:30\n- 出生地点：北京\n- 性别：女\n\n---\n\n## Bazi 数据\n\n```json\n{\n    \"birth_date\": \"1990-01-15\",\n    \"birth_time\": \"10:30\",\n    \"birth_place\": \"北京\",\n    \"gender\": \"female\"\n}\n```\n\n---\n\n## 用户画像（VibeInsight）\n\n- 主要原型：[用户的心理原型]\n- 核心特质：[trait1, trait2, trait3]\n- 当前情绪：[emotion]\n\n---\n\n## 当前状态\n\n用户信息已完整，命盘已生成。你可以开始分析了。\n\n**分析流程**：\n1. 快速扫描命盘中的关键特征\n2. 根据用户问题聚焦分析\n3. 用 show_bazi_chart / show_bazi_fortune 展示分析结果\n\n---\n\n[core/rules/boundary.md - 能力边界]\n```\n\n### 第 9 步：Phase 2 - LLM 执行分析\n\n```python\n# core.py - lines 344-367（主循环继续）\nasync for chunk in self.llm.stream(\n    messages=messages,  # 更新了 System Prompt（Phase 2）\n    tools=self._get_current_tools(context),  # Phase 2 工具集\n    ...\n):\n    # LLM 现在看到了完整的八字信息和工具列表\n    # 决策：调用 calculate_bazi / show_bazi_chart 等\n```\n\n**Phase 2 工具集**（core.py - lines 654-698）：\n\n```python\ndef _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:\n    \"\"\"获取当前可用工具 - V9: 支持多 Skill 工具聚合\"\"\"\n    \n    tools = []\n    added_names = set()\n    \n    # V9: Core 工具始终可用\n    core_tools = ToolRegistry.get_tools_for_skill(\"core\")\n    for t in core_tools:\n        tools.append(t)\n        added_names.add(t[\"name\"])\n    \n    # V9: 已激活 Skill 的工具\n    for skill_id in [\"bazi\"]:  # self._active_skills\n        if skill_id == \"core\":\n            continue\n        skill_tools = ToolRegistry.get_tools_for_skill(skill_id)\n        for t in skill_tools:\n            if t[\"name\"] not in added_names:\n                tools.append(t)\n                added_names.add(t[\"name\"])\n    \n    # Phase 2: 仍可调用 activate_skills 动态切换 skill\n    activate_tool = ...\n    tools.append(activate_tool)\n    \n    return tools\n```\n\n**工具注册表动态加载**：\n\n```python\n# tool_registry.py - get_tools_for_skill(\"bazi\")\ndef get_tools_for_skill(cls, skill_id: str) -> List[Dict[str, Any]]:\n    \"\"\"获取 Skill 的所有工具 (OpenAI 格式)\"\"\"\n    cls.initialize()  # 首次调用时初始化\n    \n    tools = []\n    added_tool_names = set()\n    \n    # 1. 从 core/tools/tools.yaml 加载全局工具\n    all_global_tools = get_global_tools()  # activate_skills, ask, save, read, search, show, remind\n    \n    # 2. 从 bazi/tools/tools.yaml 加载八字工具\n    for name, tool in cls._tool_defs.items():\n        if getattr(tool, 'skill_id', None) == \"bazi\":\n            # collect_bazi_info, calculate_bazi, show_bazi_chart, \n            # show_bazi_fortune, show_bazi_kline, search_db\n            tools.append(tool.to_openai_format())\n    \n    return tools\n```\n\n---\n\n## 关键技术亮点\n\n### 1. **LLM-First 路由**\n- 不依赖 routing.yaml 硬编码规则\n- 完全由 LLM 通过自然语言理解做决策\n- trigger 词仅用于提示，不做强制匹配\n\n### 2. **V9 渐进式加载**\n```\n启动时:\n  load_all_skill_metas()  # 仅加载 frontmatter（~100 KB）\n  ↓ 快速\n\nPhase 1 执行时:\n  build_phase1_prompt()   # 展示 Core + 所有 Skill Meta\n  ↓ 轻量级\n\n激活 Skill 时:\n  load_skill_full(skill_id)  # 加载完整 SKILL.md + rules + tools\n  ↓ 按需加载\n```\n\n### 3. **工具动态注册**\n```\n工具定义（Single Source of Truth）:\n  skills/bazi/tools/tools.yaml\n  \n工具执行器:\n  skills/bazi/tools/handlers.py\n  \n自动发现 + 注册:\n  @tool_handler(\"calculate_bazi\")\n  async def execute_calculate_bazi(...) -> Dict:\n      ...\n  \n运行时加载:\n  UnifiedToolRegistry.initialize()  # 扫描所有 Skill，自动导入\n```\n\n### 4. **上下文工程（Context Engineering）**\n```\nProfile 三层架构:\n  Layer 1: Identity（name, birth_info）\n  Layer 2: Skills（当前 Skill 专属数据）\n  Layer 3: Vibe（深度信息 - 原型、目标）\n  \n每轮都注入:\n  - 用户基本信息\n  - 已有的命盘/占星数据\n  - 用户画像 + 目标\n  - 当前 SOP 状态\n```\n\n### 5. **自动会话恢复**\n```\nPhase 0: 检查是否有未完成会话\n  if active_session.is_active:\n    auto-resume OR ask-to-resume\n    \n断点续传:\n  checkpoint_step: 5/10\n  collected_data: {已收集的信息}\n  \nSOP 状态跟踪:\n  需要出生信息？已有？\n  需要排盘？已有命盘数据？\n```\n\n---\n\n## 触发词到 Skill 映射（来自 SKILL.md）\n\n| Skill | 触发词 | 是否需要出生信息 | 是否需要排盘 |\n|-------|-------|----------------|-----------|\n| bazi | 八字、命理、算命、排盘 | ✓ | ✓ |\n| zodiac | 星座、星盘、占星、运势 | ✓ | ✓ |\n| tarot | 塔罗、抽牌、占卜 | ✗ | ✗ |\n| career | 职业、工作、跳槽、创业 | ✗ | ✗ |\n| jungastro | 荣格、心理占星 | ✓ | ✓ compute_type:zodiac |\n| lifecoach | 目标、计划、教练 | ✗ | ✗ |\n| psych | 心理、情绪、焦虑 | ✗ | ✗ |\n| mindfulness | 冥想、正念、放松 | ✗ | ✗ |\n| vibe_id | 性格、人格、画像 | ✗ | ✗ |\n| synastry | 合盘、关系、配对 | ✓ (需 2 人) | ✓ |\n\n---\n\n## 当用户问\"我的生日是哪天\"时的完整流程\n\n```\n用户消息: \"我的生日是哪天\"\n    ↓\nCoreAgent.run() - Phase 0 (会话恢复检查)\n    → 无活动会话，继续\n    ↓\nPhase 1 - 构建 Prompt\n    → build_phase1_prompt()\n    → 加载 Core Skill + 所有 Skill Meta\n    → 注入用户画像 + 已订阅 Skills\n    ↓\nLLM 思考（Phase 1）\n    → \"用户问生日\" 不是命理/占星问题\n    → 需要调用 ask 工具收集信息\n    或 read 工具读取已保存信息\n    ↓\nLLM 决策: \"调用 ask 收集生日信息\"\n    ↓\nToolExecutor.execute(\"ask\", {...})\n    → skills/core/tools/handlers.py\n    → 返回 form_type=\"birth\" 的表单\n    ↓\n前端展示表单\n    → 用户填写日期/时间/地点\n    ↓\n用户提交: { birth_date: \"1990-01-15\", ... }\n    ↓\n如果后续消息 \"帮我算算八字\":\n    ↓\nLLM 决策: \"调用 activate_skills(['bazi'])\"\n    ↓\nToolExecutor.execute(\"activate_skills\", {\"skills\": [\"bazi\"]})\n    → return { \"_should_reload_context\": True }\n    ↓\nCoreAgent 重建 Phase 2 Prompt\n    → build_system_prompt(\"bazi\", None, user_context)\n    → 加载完整 bazi/SKILL.md\n    → 注入用户的生日信息 + 命盘数据\n    ↓\nLLM 执行（Phase 2）\n    → 看到完整的八字信息\n    → 调用 calculate_bazi / show_bazi_chart / show_bazi_fortune\n    ↓\n返回分析结果\n```\n\n---\n\n## 文件路径总结\n\n| 功能 | 文件路径 |\n|------|---------|\n| Agent 主循环 | `/home/aiscend/work/vibelife/apps/api/services/agent/core.py` |\n| Skill 加载器 | `/home/aiscend/work/vibelife/apps/api/services/agent/skill_loader.py` |\n| Prompt 构建 | `/home/aiscend/work/vibelife/apps/api/services/agent/prompt_builder.py` |\n| 工具注册表 | `/home/aiscend/work/vibelife/apps/api/services/agent/tool_registry.py` |\n| 工具执行器 | `/home/aiscend/work/vibelife/apps/api/services/agent/tool_executor.py` |\n| Core Skill | `/home/aiscend/work/vibelife/apps/api/skills/core/SKILL.md` |\n| Core 工具 | `/home/aiscend/work/vibelife/apps/api/skills/core/tools/tools.yaml` |\n| Core handlers | `/home/aiscend/work/vibelife/apps/api/skills/core/tools/handlers.py` |\n| 八字 Skill | `/home/aiscend/work/vibelife/apps/api/skills/bazi/SKILL.md` |\n| 八字工具 | `/home/aiscend/work/vibelife/apps/api/skills/bazi/tools/tools.yaml` |\n\n这就是 VibeLife 完整的 Agent/Skill 路由机制！🚀"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":4296,"cache_read_input_tokens":96277,"cache_creation":{"ephemeral_5m_input_tokens":4296,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXTPJ5NfwF7S9osiRg3EE","type":"assistant","uuid":"6eac5bb2-0f7b-4c3c-9e08-7aa66681857b","timestamp":"2026-01-25T03:28:41.277Z"}
