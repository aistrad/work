     1→"""
     2→Skill Subscription Repository - Data access layer for Skill subscriptions
     3→
     4→Handles:
     5→- Skill 订阅/取消订阅
     6→- 推送开关
     7→- 试用次数追踪
     8→- 使用记录
     9→"""
    10→from dataclasses import dataclass
    11→from datetime import datetime, date
    12→from typing import Optional, List, Dict, Any
    13→from uuid import UUID
    14→
    15→from .db import get_connection
    16→
    17→
    18→@dataclass
    19→class SkillSubscription:
    20→    """Skill 订阅数据类"""
    21→    skill_id: str
    22→    status: str  # subscribed | unsubscribed
    23→    push_enabled: bool
    24→    subscribed_at: Optional[datetime]
    25→    unsubscribed_at: Optional[datetime]
    26→    trial_messages_used: int
    27→
    28→    def to_dict(self) -> Dict[str, Any]:
    29→        return {
    30→            "skill_id": self.skill_id,
    31→            "status": self.status,
    32→            "push_enabled": self.push_enabled,
    33→            "subscribed_at": self.subscribed_at.isoformat() if self.subscribed_at else None,
    34→            "unsubscribed_at": self.unsubscribed_at.isoformat() if self.unsubscribed_at else None,
    35→            "trial_messages_used": self.trial_messages_used,
    36→        }
    37→
    38→
    39→class SkillSubscriptionRepository:
    40→    """Repository for Skill subscription operations"""
    41→
    42→    # ─────────────────────────────────────────────────────────────────
    43→    # 基础查询
    44→    # ─────────────────────────────────────────────────────────────────
    45→
    46→    @staticmethod
    47→    async def get(user_id: UUID, skill_id: str) -> Optional[SkillSubscription]:
    48→        """获取单个订阅"""
    49→        query = """
    50→            SELECT skill_id, status, push_enabled, subscribed_at, unsubscribed_at, trial_messages_used
    51→            FROM user_skill_subscriptions
    52→            WHERE user_id = $1 AND skill_id = $2
    53→        """
    54→        async with get_connection() as conn:
    55→            row = await conn.fetchrow(query, user_id, skill_id)
    56→            if row:
    57→                return SkillSubscription(
    58→                    skill_id=row["skill_id"],
    59→                    status=row["status"],
    60→                    push_enabled=row["push_enabled"],
    61→                    subscribed_at=row["subscribed_at"],
    62→                    unsubscribed_at=row["unsubscribed_at"],
    63→                    trial_messages_used=row["trial_messages_used"],
    64→                )
    65→        return None
    66→
    67→    @staticmethod
    68→    async def get_user_subscriptions(user_id: UUID) -> List[SkillSubscription]:
    69→        """获取用户所有订阅"""
    70→        query = """
    71→            SELECT skill_id, status, push_enabled, subscribed_at, unsubscribed_at, trial_messages_used
    72→            FROM user_skill_subscriptions
    73→            WHERE user_id = $1
    74→            ORDER BY subscribed_at DESC NULLS LAST
    75→        """
    76→        async with get_connection() as conn:
    77→            rows = await conn.fetch(query, user_id)
    78→            return [
    79→                SkillSubscription(
    80→                    skill_id=row["skill_id"],
    81→                    status=row["status"],
    82→                    push_enabled=row["push_enabled"],
    83→                    subscribed_at=row["subscribed_at"],
    84→                    unsubscribed_at=row["unsubscribed_at"],
    85→                    trial_messages_used=row["trial_messages_used"],
    86→                )
    87→                for row in rows
    88→            ]
    89→
    90→    @staticmethod
    91→    async def get_subscribed_skill_ids(user_id: UUID) -> List[str]:
    92→        """获取用户已订阅的 Skill ID 列表"""
    93→        query = """
    94→            SELECT skill_id
    95→            FROM user_skill_subscriptions
    96→            WHERE user_id = $1 AND status = 'subscribed'
    97→        """
    98→        async with get_connection() as conn:
    99→            rows = await conn.fetch(query, user_id)
   100→            return [row["skill_id"] for row in rows]
   101→
   102→    # ─────────────────────────────────────────────────────────────────
   103→    # 订阅管理
   104→    # ─────────────────────────────────────────────────────────────────
   105→
   106→    @staticmethod
   107→    async def subscribe(
   108→        user_id: UUID,
   109→        skill_id: str,
   110→        push_enabled: bool = True
   111→    ) -> SkillSubscription:
   112→        """订阅 Skill"""
   113→        query = """
   114→            INSERT INTO user_skill_subscriptions (user_id, skill_id, status, push_enabled, subscribed_at)
   115→            VALUES ($1, $2, 'subscribed', $3, now())
   116→            ON CONFLICT (user_id, skill_id)
   117→            DO UPDATE SET
   118→                status = 'subscribed',
   119→                push_enabled = $3,
   120→                subscribed_at = now(),
   121→                unsubscribed_at = NULL,
   122→                updated_at = now()
   123→            RETURNING skill_id, status, push_enabled, subscribed_at, unsubscribed_at, trial_messages_used
   124→        """
   125→        async with get_connection() as conn:
   126→            row = await conn.fetchrow(query, user_id, skill_id, push_enabled)
   127→            return SkillSubscription(
   128→                skill_id=row["skill_id"],
   129→                status=row["status"],
   130→                push_enabled=row["push_enabled"],
   131→                subscribed_at=row["subscribed_at"],
   132→                unsubscribed_at=row["unsubscribed_at"],
   133→                trial_messages_used=row["trial_messages_used"],
   134→            )
   135→
   136→    @staticmethod
   137→    async def unsubscribe(user_id: UUID, skill_id: str) -> SkillSubscription:
   138→        """取消订阅 Skill"""
   139→        query = """
   140→            UPDATE user_skill_subscriptions
   141→            SET status = 'unsubscribed', push_enabled = false, unsubscribed_at = now(), updated_at = now()
   142→            WHERE user_id = $1 AND skill_id = $2
   143→            RETURNING skill_id, status, push_enabled, subscribed_at, unsubscribed_at, trial_messages_used
   144→        """
   145→        async with get_connection() as conn:
   146→            row = await conn.fetchrow(query, user_id, skill_id)
   147→            if row:
   148→                return SkillSubscription(
   149→                    skill_id=row["skill_id"],
   150→                    status=row["status"],
   151→                    push_enabled=row["push_enabled"],
   152→                    subscribed_at=row["subscribed_at"],
   153→                    unsubscribed_at=row["unsubscribed_at"],
   154→                    trial_messages_used=row["trial_messages_used"],
   155→                )
   156→            # 如果不存在，返回一个默认的取消订阅状态
   157→            return SkillSubscription(
   158→                skill_id=skill_id,
   159→                status="unsubscribed",
   160→                push_enabled=False,
   161→                subscribed_at=None,
   162→                unsubscribed_at=datetime.utcnow(),
   163→                trial_messages_used=0,
   164→            )
   165→
   166→    # ─────────────────────────────────────────────────────────────────
   167→    # 推送控制
   168→    # ─────────────────────────────────────────────────────────────────
   169→
   170→    @staticmethod
   171→    async def update_push(
   172→        user_id: UUID,
   173→        skill_id: str,
   174→        enabled: bool
   175→    ) -> Optional[SkillSubscription]:
   176→        """更新推送状态"""
   177→        query = """
   178→            UPDATE user_skill_subscriptions
   179→            SET push_enabled = $3, updated_at = now()
   180→            WHERE user_id = $1 AND skill_id = $2
   181→            RETURNING skill_id, status, push_enabled, subscribed_at, unsubscribed_at, trial_messages_used
   182→        """
   183→        async with get_connection() as conn:
   184→            row = await conn.fetchrow(query, user_id, skill_id, enabled)
   185→            if row:
   186→                return SkillSubscription(
   187→                    skill_id=row["skill_id"],
   188→                    status=row["status"],
   189→                    push_enabled=row["push_enabled"],
   190→                    subscribed_at=row["subscribed_at"],
   191→                    unsubscribed_at=row["unsubscribed_at"],
   192→                    trial_messages_used=row["trial_messages_used"],
   193→                )
   194→            return None
   195→
   196→    @staticmethod
   197→    async def is_push_enabled(user_id: UUID, skill_id: str) -> bool:
   198→        """检查推送是否开启（用于 ProactiveEngine）"""
   199→        query = """
   200→            SELECT push_enabled
   201→            FROM user_skill_subscriptions
   202→            WHERE user_id = $1 AND skill_id = $2 AND status = 'subscribed'
   203→        """
   204→        async with get_connection() as conn:
   205→            row = await conn.fetchrow(query, user_id, skill_id)
   206→            return row["push_enabled"] if row else False
   207→
   208→    @staticmethod
   209→    async def get_users_with_push_enabled(skill_id: str) -> List[UUID]:
   210→        """获取某 Skill 开启推送的所有用户 ID（用于批量推送）"""
   211→        query = """
   212→            SELECT user_id
   213→            FROM user_skill_subscriptions
   214→            WHERE skill_id = $1 AND status = 'subscribed' AND push_enabled = true
   215→        """
   216→        async with get_connection() as conn:
   217→            rows = await conn.fetch(query, skill_id)
   218→            return [row["user_id"] for row in rows]
   219→
   220→    # ─────────────────────────────────────────────────────────────────
   221→    # 试用管理
   222→    # ─────────────────────────────────────────────────────────────────
   223→
   224→    @staticmethod
   225→    async def increment_trial_usage(user_id: UUID, skill_id: str) -> int:
   226→        """增加试用次数，返回新的使用次数"""
   227→        query = """
   228→            INSERT INTO user_skill_subscriptions (user_id, skill_id, trial_messages_used, status)
   229→            VALUES ($1, $2, 1, 'not_subscribed')
   230→            ON CONFLICT (user_id, skill_id)
   231→            DO UPDATE SET trial_messages_used = user_skill_subscriptions.trial_messages_used + 1, updated_at = now()
   232→            RETURNING trial_messages_used
   233→        """
   234→        async with get_connection() as conn:
   235→            row = await conn.fetchrow(query, user_id, skill_id)
   236→            return row["trial_messages_used"]
   237→
   238→    @staticmethod
   239→    async def get_trial_usage(user_id: UUID, skill_id: str) -> int:
   240→        """获取试用次数"""
   241→        query = """
   242→            SELECT trial_messages_used
   243→            FROM user_skill_subscriptions
   244→            WHERE user_id = $1 AND skill_id = $2
   245→        """
   246→        async with get_connection() as conn:
   247→            row = await conn.fetchrow(query, user_id, skill_id)
   248→            return row["trial_messages_used"] if row else 0
   249→
   250→    # ─────────────────────────────────────────────────────────────────
   251→    # 状态检查
   252→    # ─────────────────────────────────────────────────────────────────
   253→
   254→    @staticmethod
   255→    async def is_subscribed(user_id: UUID, skill_id: str) -> bool:
   256→        """检查是否已订阅"""
   257→        query = """
   258→            SELECT 1
   259→            FROM user_skill_subscriptions
   260→            WHERE user_id = $1 AND skill_id = $2 AND status = 'subscribed'
   261→        """
   262→        async with get_connection() as conn:
   263→            row = await conn.fetchrow(query, user_id, skill_id)
   264→            return row is not None
   265→
   266→    @staticmethod
   267→    async def can_use_skill(
   268→        user_id: UUID,
   269→        skill_id: str,
   270→        skill_category: str,
   271→        trial_limit: int = 3
   272→    ) -> tuple[bool, str]:
   273→        """
   274→        检查用户是否可以使用 Skill
   275→
   276→        Returns:
   277→            (can_use, reason)
   278→            - (True, "subscribed") - 已订阅
   279→            - (True, "default") - 默认 Skill
   280→            - (True, "core") - Core Skill
   281→            - (True, "trial") - 试用中
   282→            - (False, "trial_exhausted") - 试用次数用完
   283→            - (False, "not_subscribed") - 未订阅
   284→        """
   285→        # Core Skill 始终可用
   286→        if skill_category == "core":
   287→            return True, "core"
   288→
   289→        subscription = await SkillSubscriptionRepository.get(user_id, skill_id)
   290→
   291→        # Default Skill: 如果没有订阅记录或已订阅，则可用
   292→        if skill_category == "default":
   293→            if not subscription or subscription.status == "subscribed":
   294→                return True, "default"
   295→            return False, "unsubscribed"
   296→
   297→        # Professional Skill: 需要订阅或在试用期内
   298→        if subscription and subscription.status == "subscribed":
   299→            return True, "subscribed"
   300→
   301→        # 检查试用
   302→        trial_used = subscription.trial_messages_used if subscription else 0
   303→        if trial_used < trial_limit:
   304→            return True, "trial"
   305→
   306→        return False, "trial_exhausted"
   307→
   308→
   309→class SkillUsageRepository:
   310→    """Repository for Skill usage logging"""
   311→
   312→    @staticmethod
   313→    async def log_usage(
   314→        user_id: UUID,
   315→        skill_id: str,
   316→        action: str,
   317→        metadata: Optional[Dict[str, Any]] = None
   318→    ) -> None:
   319→        """记录 Skill 使用"""
   320→        query = """
   321→            INSERT INTO skill_usage_log (user_id, skill_id, action, metadata)
   322→            VALUES ($1, $2, $3, $4)
   323→        """
   324→        async with get_connection() as conn:
   325→            await conn.execute(
   326→                query,
   327→                user_id,
   328→                skill_id,
   329→                action,
   330→                metadata or {}
   331→            )
   332→
   333→    @staticmethod
   334→    async def get_user_skill_usage(
   335→        user_id: UUID,
   336→        skill_id: Optional[str] = None,
   337→        limit: int = 50
   338→    ) -> List[Dict[str, Any]]:
   339→        """获取用户 Skill 使用记录"""
   340→        if skill_id:
   341→            query = """
   342→                SELECT skill_id, action, metadata, created_at
   343→                FROM skill_usage_log
   344→                WHERE user_id = $1 AND skill_id = $2
   345→                ORDER BY created_at DESC
   346→                LIMIT $3
   347→            """
   348→            params = [user_id, skill_id, limit]
   349→        else:
   350→            query = """
   351→                SELECT skill_id, action, metadata, created_at
   352→                FROM skill_usage_log
   353→                WHERE user_id = $1
   354→                ORDER BY created_at DESC
   355→                LIMIT $2
   356→            """
   357→            params = [user_id, limit]
   358→
   359→        async with get_connection() as conn:
   360→            rows = await conn.fetch(query, *params)
   361→            return [dict(row) for row in rows]
   362→
   363→    @staticmethod
   364→    async def get_skill_usage_count(
   365→        user_id: UUID,
   366→        skill_id: str,
   367→        since: Optional[datetime] = None
   368→    ) -> int:
   369→        """获取 Skill 使用次数"""
   370→        if since:
   371→            query = """
   372→                SELECT COUNT(*)
   373→                FROM skill_usage_log
   374→                WHERE user_id = $1 AND skill_id = $2 AND created_at >= $3
   375→            """
   376→            params = [user_id, skill_id, since]
   377→        else:
   378→            query = """
   379→                SELECT COUNT(*)
   380→                FROM skill_usage_log
   381→                WHERE user_id = $1 AND skill_id = $2
   382→            """
   383→            params = [user_id, skill_id]
   384→
   385→        async with get_connection() as conn:
   386→            count = await conn.fetchval(query, *params)
   387→            return count or 0
   388→
   389→    @staticmethod
   390→    async def get_frequently_used_skills(
   391→        user_id: UUID,
   392→        limit: int = 5
   393→    ) -> List[Dict[str, Any]]:
   394→        """获取用户最常用的 Skill（用于推荐）"""
   395→        query = """
   396→            SELECT skill_id, COUNT(*) as usage_count, MAX(created_at) as last_used
   397→            FROM skill_usage_log
   398→            WHERE user_id = $1
   399→            GROUP BY skill_id
   400→            ORDER BY usage_count DESC, last_used DESC
   401→            LIMIT $2
   402→        """
   403→        async with get_connection() as conn:
   404→            rows = await conn.fetch(query, user_id, limit)
   405→            return [dict(row) for row in rows]
   406→
   407→
   408→class SkillRecommendationBlockRepository:
   409→    """Repository for Skill recommendation blocks"""
   410→
   411→    @staticmethod
   412→    async def block_skill(
   413→        user_id: UUID,
   414→        skill_id: str,
   415→        block_type: str = "permanent",
   416→        expires_at: Optional[datetime] = None
   417→    ) -> None:
   418→        """屏蔽 Skill 推荐"""
   419→        query = """
   420→            INSERT INTO skill_recommendation_blocks (user_id, skill_id, block_type, expires_at)
   421→            VALUES ($1, $2, $3, $4)
   422→            ON CONFLICT (user_id, skill_id)
   423→            DO UPDATE SET block_type = $3, expires_at = $4
   424→        """
   425→        async with get_connection() as conn:
   426→            await conn.execute(query, user_id, skill_id, block_type, expires_at)
   427→
   428→    @staticmethod
   429→    async def unblock_skill(user_id: UUID, skill_id: str) -> None:
   430→        """取消屏蔽 Skill 推荐"""
   431→        query = """
   432→            DELETE FROM skill_recommendation_blocks
   433→            WHERE user_id = $1 AND skill_id = $2
   434→        """
   435→        async with get_connection() as conn:
   436→            await conn.execute(query, user_id, skill_id)
   437→
   438→    @staticmethod
   439→    async def get_blocked_skills(user_id: UUID) -> List[str]:
   440→        """获取用户屏蔽的 Skill 列表"""
   441→        query = """
   442→            SELECT skill_id
   443→            FROM skill_recommendation_blocks
   444→            WHERE user_id = $1
   445→            AND (expires_at IS NULL OR expires_at > now())
   446→        """
   447→        async with get_connection() as conn:
   448→            rows = await conn.fetch(query, user_id)
   449→            return [row["skill_id"] for row in rows]
   450→
   451→    @staticmethod
   452→    async def is_blocked(user_id: UUID, skill_id: str) -> bool:
   453→        """检查 Skill 是否被屏蔽"""
   454→        query = """
   455→            SELECT 1
   456→            FROM skill_recommendation_blocks
   457→            WHERE user_id = $1 AND skill_id = $2
   458→            AND (expires_at IS NULL OR expires_at > now())
   459→        """
   460→        async with get_connection() as conn:
   461→            row = await conn.fetchrow(query, user_id, skill_id)
   462→            return row is not None
   463→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
