     1→"use client";
     2→
     3→/**
     4→ * SkillProvider - 提供当前 skill 上下文
     5→ *
     6→ * 功能：
     7→ * - 从 cookie 或 URL 参数中读取 skill
     8→ * - 支持子域名模式: bazi.vibelife.app -> skill=bazi
     9→ * - 集成 skillRegistry 提供完整 skill 配置
    10→ * - 注入主题 CSS 变量
    11→ * - 支持 Skill 切换过渡动画（双触发：AI Tool 调用 + 用户手动切换）
    12→ */
    13→
    14→import {
    15→  createContext,
    16→  useContext,
    17→  useState,
    18→  useEffect,
    19→  useMemo,
    20→  useCallback,
    21→  ReactNode,
    22→} from "react";
    23→import { type SkillType } from "@/components/core";
    24→import { skillRegistry, getSkillConfig, getSkillPanels, getSkillTools } from "@/skills/registry";
    25→import type { SkillId, SkillPlugin, PanelDefinition, ToolDefinition } from "@/skills/types";
    26→
    27→// ═══════════════════════════════════════════════════════════════════════════
    28→// Types
    29→// ═══════════════════════════════════════════════════════════════════════════
    30→
    31→interface SkillContextValue {
    32→  // Current skill state
    33→  skill: SkillType;
    34→  setSkill: (skill: SkillType, showTransition?: boolean) => void;
    35→
    36→  // Transition state
    37→  isTransitioning: boolean;
    38→  pendingSkill: SkillType | null;
    39→
    40→  // Skill configuration from registry
    41→  // 符合 V7 规范: server-serialization - 只传递必要的序列化数据
    42→  skillConfig: SkillPlugin | undefined;
    43→  panels: PanelDefinition[];
    44→  tools: ToolDefinition[];
    45→
    46→  // 注意: 移除了 registry 字段
    47→  // registry 包含函数和组件引用，不可序列化，会导致 RSC Payload 错误
    48→  // 使用 useSkillRegistry() hook 直接从模块获取
    49→}
    50→
    51→const SkillContext = createContext<SkillContextValue | null>(null);
    52→
    53→// ═══════════════════════════════════════════════════════════════════════════
    54→// Hooks
    55→// ═══════════════════════════════════════════════════════════════════════════
    56→
    57→export function useSkill() {
    58→  const context = useContext(SkillContext);
    59→  if (!context) {
    60→    throw new Error("useSkill must be used within SkillProvider");
    61→  }
    62→  return context;
    63→}
    64→
    65→// Convenience hooks
    66→export function useSkillConfig() {
    67→  const { skillConfig } = useSkill();
    68→  return skillConfig;
    69→}
    70→
    71→export function useSkillPanels() {
    72→  const { panels } = useSkill();
    73→  return panels;
    74→}
    75→
    76→export function useSkillTools() {
    77→  const { tools } = useSkill();
    78→  return tools;
    79→}
    80→
    81→export function useSkillRegistry() {
    82→  // 直接从模块导入，避免通过 context 传递不可序列化的对象
    83→  // 符合 V7 规范: server-serialization
    84→  return skillRegistry;
    85→}
    86→
    87→export function useCurrentSkill() {
    88→  const { skill } = useSkill();
    89→  return skill as SkillId;
    90→}
    91→
    92→export function useSkillTransition() {
    93→  const { isTransitioning, pendingSkill } = useSkill();
    94→  return { isTransitioning, pendingSkill };
    95→}
    96→
    97→// ═══════════════════════════════════════════════════════════════════════════
    98→// Helper Functions
    99→// ═══════════════════════════════════════════════════════════════════════════
   100→
   101→const VALID_SKILLS: SkillType[] = ["bazi", "zodiac", "mbti", "attach", "career"];
   102→const DEFAULT_SKILL: SkillType = "bazi";
   103→
   104→function getCookie(name: string): string | undefined {
   105→  if (typeof document === "undefined") return undefined;
   106→  const value = `; ${document.cookie}`;
   107→  const parts = value.split(`; ${name}=`);
   108→  if (parts.length === 2) return parts.pop()?.split(";").shift();
   109→  return undefined;
   110→}
   111→
   112→function getSkillFromHostname(): SkillType | null {
   113→  if (typeof window === "undefined") return null;
   114→
   115→  const hostname = window.location.hostname;
   116→  const parts = hostname.split(".");
   117→
   118→  if (parts.length >= 2) {
   119→    const subdomain = parts[0].toLowerCase() as SkillType;
   120→    if (VALID_SKILLS.includes(subdomain)) {
   121→      return subdomain;
   122→    }
   123→  }
   124→
   125→  return null;
   126→}
   127→
   128→function getInitialSkill(): SkillType {
   129→  // 1. 首先尝试从 hostname 获取
   130→  const hostnameSkill = getSkillFromHostname();
   131→  if (hostnameSkill) return hostnameSkill;
   132→
   133→  // 2. 然后尝试从 cookie 获取
   134→  const cookieSkill = getCookie("vibelife-skill") as SkillType | undefined;
   135→  if (cookieSkill && VALID_SKILLS.includes(cookieSkill)) {
   136→    return cookieSkill;
   137→  }
   138→
   139→  // 3. 默认
   140→  return DEFAULT_SKILL;
   141→}
   142→
   143→// ═══════════════════════════════════════════════════════════════════════════
   144→// Provider
   145→// ═══════════════════════════════════════════════════════════════════════════
   146→
   147→interface SkillProviderProps {
   148→  children: ReactNode;
   149→  /** 服务端传入的初始 skill（从 middleware headers 获取） */
   150→  initialSkill?: SkillType;
   151→}
   152→
   153→export function SkillProvider({ children, initialSkill }: SkillProviderProps) {
   154→  // 始终使用服务端传入的值，避免 hydration mismatch
   155→  // 符合 V7 规范: server-serialization - 信任服务端数据
   156→  const [skill, setSkillInternal] = useState<SkillType>(initialSkill || DEFAULT_SKILL);
   157→  const [isTransitioning, setIsTransitioning] = useState(false);
   158→  const [pendingSkill, setPendingSkill] = useState<SkillType | null>(null);
   159→
   160→  // 注意: 删除了原来的 useEffect 覆盖逻辑
   161→  // 原代码会在 hydration 后用客户端计算的值覆盖服务端值，导致 RSC Payload 错误
   162→  // 现在完全信任服务端通过 cookies() 传入的 initialSkill
   163→
   164→  // 切换 skill（支持过渡动画）
   165→  const setSkill = useCallback((newSkill: SkillType, showTransition = false) => {
   166→    if (newSkill === skill) return;
   167→
   168→    if (showTransition) {
   169→      // 开始过渡动画
   170→      setPendingSkill(newSkill);
   171→      setIsTransitioning(true);
   172→      // 动画中间点切换 skill（1s 后）
   173→      setTimeout(() => {
   174→        setSkillInternal(newSkill);
   175→        // 动画结束后清理状态（再 0.5s）
   176→        setTimeout(() => {
   177→          setIsTransitioning(false);
   178→          setPendingSkill(null);
   179→        }, 500);
   180→      }, 1000);
   181→    } else {
   182→      setSkillInternal(newSkill);
   183→    }
   184→  }, [skill]);
   185→
   186→  // Get skill configuration from registry
   187→  const skillConfig = useMemo(() => getSkillConfig(skill as SkillId), [skill]);
   188→  const panels = useMemo(() => getSkillPanels(skill as SkillId), [skill]);
   189→  const tools = useMemo(() => getSkillTools(skill as SkillId), [skill]);
   190→
   191→  // Inject theme CSS variables
   192→  useEffect(() => {
   193→    if (!skillConfig?.theme) return;
   194→
   195→    const root = document.documentElement;
   196→    const { primary, secondary, glow, gradient } = skillConfig.theme;
   197→
   198→    root.style.setProperty("--skill-primary", primary);
   199→    root.style.setProperty("--skill-secondary", secondary);
   200→    root.style.setProperty("--skill-glow", glow);
   201→    root.style.setProperty("--skill-gradient", gradient);
   202→
   203→    // Cleanup
   204→    return () => {
   205→      root.style.removeProperty("--skill-primary");
   206→      root.style.removeProperty("--skill-secondary");
   207→      root.style.removeProperty("--skill-glow");
   208→      root.style.removeProperty("--skill-gradient");
   209→    };
   210→  }, [skillConfig]);
   211→
   212→  const contextValue: SkillContextValue = useMemo(
   213→    () => ({
   214→      skill,
   215→      setSkill,
   216→      isTransitioning,
   217→      pendingSkill,
   218→      skillConfig,
   219→      panels,
   220→      tools,
   221→      // 注意: 移除了 registry，避免序列化不可序列化的对象
   222→      // 使用 useSkillRegistry() hook 直接获取
   223→    }),
   224→    [skill, setSkill, isTransitioning, pendingSkill, skillConfig, panels, tools]
   225→  );
   226→
   227→  return (
   228→    <SkillContext.Provider value={contextValue}>
   229→      {children}
   230→    </SkillContext.Provider>
   231→  );
   232→}
   233→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
