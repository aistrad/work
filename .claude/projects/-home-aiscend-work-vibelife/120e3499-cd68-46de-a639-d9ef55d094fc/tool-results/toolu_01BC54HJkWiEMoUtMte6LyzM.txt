     1→"""
     2→Subscription Repository - Data access layer for subscriptions
     3→"""
     4→from datetime import datetime
     5→from typing import Optional, List, Dict, Any
     6→from uuid import UUID
     7→
     8→from .db import get_connection
     9→
    10→
    11→class SubscriptionRepository:
    12→    """Repository for subscription operations"""
    13→
    14→    # ─────────────────────────────────────────────────────────────────
    15→    # Subscription Plans
    16→    # ─────────────────────────────────────────────────────────────────
    17→
    18→    @staticmethod
    19→    async def get_all_plans(active_only: bool = True) -> List[dict]:
    20→        """Get all subscription plans"""
    21→        async with get_connection() as conn:
    22→            if active_only:
    23→                rows = await conn.fetch(
    24→                    "SELECT * FROM subscription_plans WHERE is_active = true"
    25→                )
    26→            else:
    27→                rows = await conn.fetch("SELECT * FROM subscription_plans")
    28→            return [dict(row) for row in rows]
    29→
    30→    @staticmethod
    31→    async def get_plan(plan_id: str) -> Optional[dict]:
    32→        """Get plan by ID"""
    33→        async with get_connection() as conn:
    34→            row = await conn.fetchrow(
    35→                "SELECT * FROM subscription_plans WHERE id = $1",
    36→                plan_id
    37→            )
    38→            return dict(row) if row else None
    39→
    40→    @staticmethod
    41→    async def create_plan(
    42→        plan_id: str,
    43→        name: str,
    44→        plan_type: str,
    45→        skill_ids: Optional[List[str]] = None,
    46→        price_monthly: Optional[int] = None,
    47→        price_yearly: Optional[int] = None,
    48→        currency: str = "CNY",
    49→        features: Optional[Dict[str, Any]] = None
    50→    ) -> dict:
    51→        """Create a subscription plan"""
    52→        async with get_connection() as conn:
    53→            row = await conn.fetchrow(
    54→                """
    55→                INSERT INTO subscription_plans (
    56→                    id, name, plan_type, skill_ids,
    57→                    price_monthly, price_yearly, currency, features
    58→                )
    59→                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    60→                RETURNING *
    61→                """,
    62→                plan_id, name, plan_type, skill_ids,
    63→                price_monthly, price_yearly, currency, features
    64→            )
    65→            return dict(row)
    66→
    67→    # ─────────────────────────────────────────────────────────────────
    68→    # User Subscriptions
    69→    # ─────────────────────────────────────────────────────────────────
    70→
    71→    @staticmethod
    72→    async def create_subscription(
    73→        user_id: UUID,
    74→        plan_id: str,
    75→        source_skill: Optional[str] = None,
    76→        source_campaign: Optional[str] = None,
    77→        payment_provider: Optional[str] = None,
    78→        payment_subscription_id: Optional[str] = None,
    79→        current_period_end: Optional[datetime] = None
    80→    ) -> dict:
    81→        """Create user subscription"""
    82→        async with get_connection() as conn:
    83→            row = await conn.fetchrow(
    84→                """
    85→                INSERT INTO user_subscriptions (
    86→                    user_id, plan_id, source_skill, source_campaign,
    87→                    payment_provider, payment_subscription_id,
    88→                    current_period_end
    89→                )
    90→                VALUES ($1, $2, $3, $4, $5, $6, $7)
    91→                RETURNING *
    92→                """,
    93→                user_id, plan_id, source_skill, source_campaign,
    94→                payment_provider, payment_subscription_id,
    95→                current_period_end
    96→            )
    97→            return dict(row)
    98→
    99→    @staticmethod
   100→    async def get_user_subscription(user_id: UUID) -> Optional[dict]:
   101→        """Get user's active subscription"""
   102→        async with get_connection() as conn:
   103→            row = await conn.fetchrow(
   104→                """
   105→                SELECT us.*, sp.name as plan_name, sp.plan_type,
   106→                       sp.skill_ids, sp.features
   107→                FROM user_subscriptions us
   108→                JOIN subscription_plans sp ON us.plan_id = sp.id
   109→                WHERE us.user_id = $1 AND us.status = 'active'
   110→                ORDER BY us.started_at DESC
   111→                LIMIT 1
   112→                """,
   113→                user_id
   114→            )
   115→            return dict(row) if row else None
   116→
   117→    @staticmethod
   118→    async def get_subscription_history(
   119→        user_id: UUID,
   120→        limit: int = 10
   121→    ) -> List[dict]:
   122→        """Get user's subscription history"""
   123→        async with get_connection() as conn:
   124→            rows = await conn.fetch(
   125→                """
   126→                SELECT us.*, sp.name as plan_name
   127→                FROM user_subscriptions us
   128→                JOIN subscription_plans sp ON us.plan_id = sp.id
   129→                WHERE us.user_id = $1
   130→                ORDER BY us.started_at DESC
   131→                LIMIT $2
   132→                """,
   133→                user_id, limit
   134→            )
   135→            return [dict(row) for row in rows]
   136→
   137→    @staticmethod
   138→    async def update_subscription(
   139→        subscription_id: UUID,
   140→        status: Optional[str] = None,
   141→        current_period_end: Optional[datetime] = None,
   142→        cancelled_at: Optional[datetime] = None
   143→    ) -> Optional[dict]:
   144→        """Update subscription"""
   145→        updates = []
   146→        params = []
   147→        idx = 1
   148→
   149→        if status is not None:
   150→            updates.append(f"status = ${idx}")
   151→            params.append(status)
   152→            idx += 1
   153→
   154→        if current_period_end is not None:
   155→            updates.append(f"current_period_end = ${idx}")
   156→            params.append(current_period_end)
   157→            idx += 1
   158→
   159→        if cancelled_at is not None:
   160→            updates.append(f"cancelled_at = ${idx}")
   161→            params.append(cancelled_at)
   162→            idx += 1
   163→
   164→        if not updates:
   165→            return None
   166→
   167→        params.append(subscription_id)
   168→
   169→        async with get_connection() as conn:
   170→            row = await conn.fetchrow(
   171→                f"""
   172→                UPDATE user_subscriptions
   173→                SET {', '.join(updates)}
   174→                WHERE id = ${idx}
   175→                RETURNING *
   176→                """,
   177→                *params
   178→            )
   179→            return dict(row) if row else None
   180→
   181→    @staticmethod
   182→    async def cancel_subscription(subscription_id: UUID) -> Optional[dict]:
   183→        """Cancel subscription"""
   184→        return await SubscriptionRepository.update_subscription(
   185→            subscription_id,
   186→            status='cancelled',
   187→            cancelled_at=datetime.utcnow()
   188→        )
   189→
   190→    # ─────────────────────────────────────────────────────────────────
   191→    # Access Control
   192→    # ─────────────────────────────────────────────────────────────────
   193→
   194→    @staticmethod
   195→    async def has_skill_access(user_id: UUID, skill_id: str) -> bool:
   196→        """Check if user has access to a skill"""
   197→        sub = await SubscriptionRepository.get_user_subscription(user_id)
   198→
   199→        if not sub:
   200→            return False  # No active subscription
   201→
   202→        plan_type = sub.get('plan_type')
   203→        skill_ids = sub.get('skill_ids') or []
   204→
   205→        # vibelife_all has access to everything
   206→        if plan_type == 'vibelife_all':
   207→            return True
   208→
   209→        # Check if skill is in plan
   210→        return skill_id in skill_ids
   211→
   212→    @staticmethod
   213→    async def has_feature_access(
   214→        user_id: UUID,
   215→        feature: str
   216→    ) -> tuple[bool, Optional[str]]:
   217→        """
   218→        Check if user has access to a feature.
   219→        Returns (has_access, upgrade_plan_id)
   220→        """
   221→        sub = await SubscriptionRepository.get_user_subscription(user_id)
   222→
   223→        if not sub:
   224→            return False, 'vibelife_all'
   225→
   226→        features = sub.get('features') or {}
   227→
   228→        # Check feature access
   229→        if features.get(feature) or features.get('all_features'):
   230→            return True, None
   231→
   232→        return False, 'vibelife_all'
   233→
   234→    @staticmethod
   235→    async def get_subscription_status(user_id: UUID) -> dict:
   236→        """Get comprehensive subscription status"""
   237→        sub = await SubscriptionRepository.get_user_subscription(user_id)
   238→
   239→        if not sub:
   240→            return {
   241→                'is_premium': False,
   242→                'plan_id': 'free',
   243→                'plan_name': '免费版',
   244→                'skills_access': [],
   245→                'expires_at': None,
   246→                'features': {
   247→                    'daily_questions': 3,
   248→                    'basic_analysis': True
   249→                }
   250→            }
   251→
   252→        return {
   253→            'is_premium': True,
   254→            'plan_id': sub['plan_id'],
   255→            'plan_name': sub['plan_name'],
   256→            'skills_access': sub.get('skill_ids') or ['all'],
   257→            'expires_at': sub.get('current_period_end'),
   258→            'features': sub.get('features') or {}
   259→        }
   260→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
