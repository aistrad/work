     1→"""
     2→Profile Cache - In-memory caching for user profiles and skill data
     3→Reduces DB queries during chat sessions
     4→
     5→v9.0 更新：
     6→- 三层架构：identity, skills, vibe
     7→- 只从 skills 读取，已移除 skill_data 回退
     8→- 缓存 key 格式：{user_id}:{skill} 或 {user_id}:all
     9→"""
    10→import asyncio
    11→import logging
    12→from typing import Optional, Dict, Any, List
    13→from datetime import datetime, timedelta, timezone
    14→from uuid import UUID
    15→from dataclasses import dataclass, field
    16→
    17→logger = logging.getLogger(__name__)
    18→
    19→
    20→@dataclass
    21→class CacheEntry:
    22→    """缓存条目"""
    23→    data: Dict[str, Any]
    24→    expires_at: datetime
    25→    created_at: datetime = field(default_factory=datetime.utcnow)
    26→
    27→    @property
    28→    def is_expired(self) -> bool:
    29→        return datetime.now(timezone.utc) > self.expires_at
    30→
    31→
    32→class ProfileCache:
    33→    """
    34→    用户 Profile 缓存
    35→
    36→    缓存策略：
    37→    - TTL: 5 分钟（Profile 变化不频繁）
    38→    - 写入时更新缓存
    39→    - 支持手动失效
    40→
    41→    v2.0 更新：
    42→    - 支持自定义 key 格式（用于合并缓存）
    43→    - 支持按前缀失效（用于失效用户所有缓存）
    44→    """
    45→
    46→    DEFAULT_TTL = 300  # 5 分钟
    47→
    48→    def __init__(self):
    49→        self._cache: Dict[str, CacheEntry] = {}
    50→        self._lock = asyncio.Lock()
    51→        self._stats = {"hits": 0, "misses": 0}
    52→
    53→    async def get(self, user_id: UUID) -> Optional[Dict[str, Any]]:
    54→        """获取缓存的 Profile（兼容旧接口）"""
    55→        return await self.get_by_key(str(user_id))
    56→
    57→    async def get_by_key(self, key: str) -> Optional[Dict[str, Any]]:
    58→        """通过自定义 key 获取缓存"""
    59→        async with self._lock:
    60→            entry = self._cache.get(key)
    61→            if entry is None:
    62→                self._stats["misses"] += 1
    63→                return None
    64→            if entry.is_expired:
    65→                del self._cache[key]
    66→                self._stats["misses"] += 1
    67→                return None
    68→            self._stats["hits"] += 1
    69→            return entry.data
    70→
    71→    async def set(self, user_id: UUID, profile: Dict[str, Any], ttl: int = None) -> None:
    72→        """设置 Profile 缓存（兼容旧接口）"""
    73→        await self.set_by_key(str(user_id), profile, ttl)
    74→
    75→    async def set_by_key(self, key: str, data: Dict[str, Any], ttl: int = None) -> None:
    76→        """通过自定义 key 设置缓存"""
    77→        ttl = ttl or self.DEFAULT_TTL
    78→        async with self._lock:
    79→            self._cache[key] = CacheEntry(
    80→                data=data,
    81→                expires_at=datetime.now(timezone.utc) + timedelta(seconds=ttl)
    82→            )
    83→
    84→    async def invalidate(self, user_id: UUID) -> bool:
    85→        """使指定用户的缓存失效（兼容旧接口）"""
    86→        return await self.invalidate_by_key(str(user_id))
    87→
    88→    async def invalidate_by_key(self, key: str) -> bool:
    89→        """通过自定义 key 使缓存失效"""
    90→        async with self._lock:
    91→            if key in self._cache:
    92→                del self._cache[key]
    93→                return True
    94→            return False
    95→
    96→    async def invalidate_by_prefix(self, prefix: str) -> int:
    97→        """使所有以指定前缀开头的缓存失效"""
    98→        async with self._lock:
    99→            keys_to_delete = [k for k in self._cache.keys() if k.startswith(prefix)]
   100→            for key in keys_to_delete:
   101→                del self._cache[key]
   102→            return len(keys_to_delete)
   103→
   104→    async def clear(self) -> None:
   105→        """清空所有缓存"""
   106→        async with self._lock:
   107→            self._cache.clear()
   108→
   109→    def get_stats(self) -> Dict[str, Any]:
   110→        """获取缓存统计"""
   111→        total = self._stats["hits"] + self._stats["misses"]
   112→        hit_rate = self._stats["hits"] / total if total > 0 else 0
   113→        return {
   114→            **self._stats,
   115→            "hit_rate": f"{hit_rate:.2%}",
   116→            "cache_size": len(self._cache)
   117→        }
   118→
   119→
   120→# 全局缓存实例
   121→_profile_cache: Optional[ProfileCache] = None
   122→
   123→
   124→def get_profile_cache() -> ProfileCache:
   125→    """获取 Profile 缓存实例"""
   126→    global _profile_cache
   127→    if _profile_cache is None:
   128→        _profile_cache = ProfileCache()
   129→    return _profile_cache
   130→
   131→
   132→async def get_cached_profile(user_id: UUID) -> Optional[Dict[str, Any]]:
   133→    """
   134→    获取用户 Profile（带缓存）
   135→
   136→    v3.0: 从 unified_profiles 获取
   137→    """
   138→    cache = get_profile_cache()
   139→
   140→    # 尝试从缓存获取
   141→    profile = await cache.get(user_id)
   142→    if profile is not None:
   143→        return profile
   144→
   145→    # 缓存未命中，从 DB 获取
   146→    try:
   147→        from stores.unified_profile_repo import UnifiedProfileRepository
   148→        profile = await UnifiedProfileRepository.get_profile(user_id)
   149→
   150→        if profile:
   151→            await cache.set(user_id, profile)
   152→        return profile
   153→    except Exception as e:
   154→        logger.error(f"Failed to get profile for {user_id}: {e}")
   155→        return None
   156→
   157→
   158→async def invalidate_profile_cache(user_id: UUID) -> None:
   159→    """使用户 Profile 缓存失效（Profile 更新后调用）"""
   160→    cache = get_profile_cache()
   161→    await cache.invalidate(user_id)
   162→    # 同时失效所有 skill 相关缓存
   163→    await cache.invalidate_by_prefix(str(user_id))
   164→
   165→
   166→# ═══════════════════════════════════════════════════════════════════════════
   167→# v2.0: 合并缓存支持 (Profile + Skill Data)
   168→# v3.0: 从 unified_profiles 获取
   169→# v9.0: 只从 skills 读取
   170→# ═══════════════════════════════════════════════════════════════════════════
   171→
   172→async def get_cached_profile_with_skill(
   173→    user_id: UUID,
   174→    skill: str = None
   175→) -> Dict[str, Any]:
   176→    """
   177→    获取用户 Profile 和 Skill 数据（带缓存）
   178→
   179→    返回结构：
   180→    {
   181→        "profile": {...},        # Profile 数据（完整）
   182→        "skill_data": {...}      # Skill 数据（当前 skill 或全部）
   183→    }
   184→
   185→    v9.0: 只从 skills 读取，已移除 skill_data 回退
   186→
   187→    Args:
   188→        user_id: 用户 ID
   189→        skill: Skill 标识，如 'bazi', 'zodiac'。None 表示获取所有 skill 数据
   190→
   191→    Returns:
   192→        profile 和 skill_data
   193→    """
   194→    cache = get_profile_cache()
   195→    cache_key = f"{user_id}:{skill or 'all'}"
   196→
   197→    # 尝试从缓存获取
   198→    cached = await cache.get_by_key(cache_key)
   199→    if cached is not None:
   200→        return cached
   201→
   202→    # 缓存未命中，从 DB 获取
   203→    try:
   204→        from stores.unified_profile_repo import UnifiedProfileRepository
   205→        profile = await UnifiedProfileRepository.get_profile(user_id)
   206→
   207→        if profile:
   208→            # v9.0: 只从 skills 读取
   209→            skills_store = profile.get("skills", {})
   210→
   211→            if skill:
   212→                skill_data_dict = {skill: skills_store.get(skill, {})} if skills_store.get(skill) else {}
   213→            else:
   214→                skill_data_dict = skills_store
   215→
   216→            result = {
   217→                "profile": profile,
   218→                "skill_data": skill_data_dict
   219→            }
   220→        else:
   221→            result = {"profile": {}, "skill_data": {}}
   222→
   223→        await cache.set_by_key(cache_key, result)
   224→        return result
   225→    except Exception as e:
   226→        logger.error(f"Failed to get profile with skill for {user_id}: {e}")
   227→        return {"profile": {}, "skill_data": {}}
   228→
   229→
   230→async def invalidate_skill_cache(user_id: UUID, skill: str = None) -> None:
   231→    """
   232→    使 Skill 相关缓存失效
   233→
   234→    Args:
   235→        user_id: 用户 ID
   236→        skill: Skill 标识。None 表示失效所有 skill 缓存
   237→    """
   238→    cache = get_profile_cache()
   239→
   240→    if skill:
   241→        # 只失效特定 skill 的缓存
   242→        await cache.invalidate_by_key(f"{user_id}:{skill}")
   243→        # 也失效 all 缓存
   244→        await cache.invalidate_by_key(f"{user_id}:all")
   245→    else:
   246→        # 失效所有 skill 缓存
   247→        await cache.invalidate_by_prefix(str(user_id))
   248→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
