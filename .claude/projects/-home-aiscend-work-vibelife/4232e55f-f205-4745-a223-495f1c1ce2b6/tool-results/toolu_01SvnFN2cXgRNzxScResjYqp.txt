     1→"""
     2→User Repository - Data access layer for users
     3→"""
     4→import secrets
     5→import string
     6→from datetime import datetime
     7→from typing import Optional, List
     8→from uuid import UUID
     9→
    10→import bcrypt
    11→
    12→from .db import get_connection
    13→
    14→
    15→def generate_vibe_id() -> str:
    16→    """Generate unique Vibe ID (e.g., VB-A1B2C3D4)"""
    17→    chars = string.ascii_uppercase + string.digits
    18→    code = ''.join(secrets.choice(chars) for _ in range(8))
    19→    return f"VB-{code}"
    20→
    21→
    22→def hash_password(password: str) -> str:
    23→    """Hash password with bcrypt"""
    24→    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()
    25→
    26→
    27→def verify_password(password: str, hashed: str) -> bool:
    28→    """Verify password against hash"""
    29→    return bcrypt.checkpw(password.encode(), hashed.encode())
    30→
    31→
    32→class UserRepository:
    33→    """Repository for user operations"""
    34→
    35→    # ─────────────────────────────────────────────────────────────────
    36→    # User CRUD
    37→    # ─────────────────────────────────────────────────────────────────
    38→
    39→    @staticmethod
    40→    async def create(
    41→        display_name: Optional[str] = None,
    42→        birth_datetime: Optional[datetime] = None,
    43→        birth_location: Optional[str] = None,
    44→        gender: Optional[str] = None,
    45→        timezone: str = "Asia/Shanghai",
    46→        language: str = "zh-CN",
    47→    ) -> dict:
    48→        """Create a new user"""
    49→        vibe_id = generate_vibe_id()
    50→
    51→        async with get_connection() as conn:
    52→            row = await conn.fetchrow(
    53→                """
    54→                INSERT INTO vibe_users (
    55→                    vibe_id, display_name, birth_datetime,
    56→                    birth_location, gender, timezone, language
    57→                )
    58→                VALUES ($1, $2, $3, $4, $5, $6, $7)
    59→                RETURNING *
    60→                """,
    61→                vibe_id, display_name, birth_datetime,
    62→                birth_location, gender, timezone, language
    63→            )
    64→            return dict(row)
    65→
    66→    @staticmethod
    67→    async def get_by_id(user_id: UUID) -> Optional[dict]:
    68→        """Get user by ID"""
    69→        async with get_connection() as conn:
    70→            row = await conn.fetchrow(
    71→                "SELECT * FROM vibe_users WHERE id = $1",
    72→                user_id
    73→            )
    74→            return dict(row) if row else None
    75→
    76→    @staticmethod
    77→    async def get_by_vibe_id(vibe_id: str) -> Optional[dict]:
    78→        """Get user by Vibe ID"""
    79→        async with get_connection() as conn:
    80→            row = await conn.fetchrow(
    81→                "SELECT * FROM vibe_users WHERE vibe_id = $1",
    82→                vibe_id
    83→            )
    84→            return dict(row) if row else None
    85→
    86→    @staticmethod
    87→    async def update(user_id: UUID, **kwargs) -> Optional[dict]:
    88→        """Update user fields"""
    89→        if not kwargs:
    90→            return await UserRepository.get_by_id(user_id)
    91→
    92→        # Build SET clause
    93→        fields = []
    94→        values = []
    95→        idx = 1
    96→        for key, value in kwargs.items():
    97→            if value is not None:
    98→                fields.append(f"{key} = ${idx}")
    99→                values.append(value)
   100→                idx += 1
   101→
   102→        if not fields:
   103→            return await UserRepository.get_by_id(user_id)
   104→
   105→        values.append(user_id)
   106→        query = f"""
   107→            UPDATE vibe_users
   108→            SET {', '.join(fields)}, updated_at = NOW()
   109→            WHERE id = ${idx}
   110→            RETURNING *
   111→        """
   112→
   113→        async with get_connection() as conn:
   114→            row = await conn.fetchrow(query, *values)
   115→            return dict(row) if row else None
   116→
   117→    @staticmethod
   118→    async def delete(user_id: UUID) -> bool:
   119→        """Delete user"""
   120→        async with get_connection() as conn:
   121→            result = await conn.execute(
   122→                "DELETE FROM vibe_users WHERE id = $1",
   123→                user_id
   124→            )
   125→            return result == "DELETE 1"
   126→
   127→    # ─────────────────────────────────────────────────────────────────
   128→    # Authentication
   129→    # ─────────────────────────────────────────────────────────────────
   130→
   131→    @staticmethod
   132→    async def create_auth(
   133→        user_id: UUID,
   134→        auth_type: str,
   135→        auth_identifier: str,
   136→        auth_credential: Optional[str] = None,
   137→    ) -> dict:
   138→        """Create authentication method for user"""
   139→        # Hash password if it's email/phone auth
   140→        if auth_type in ('email', 'phone') and auth_credential:
   141→            auth_credential = hash_password(auth_credential)
   142→
   143→        async with get_connection() as conn:
   144→            row = await conn.fetchrow(
   145→                """
   146→                INSERT INTO vibe_user_auth (
   147→                    user_id, auth_type, auth_identifier, auth_credential
   148→                )
   149→                VALUES ($1, $2, $3, $4)
   150→                RETURNING *
   151→                """,
   152→                user_id, auth_type, auth_identifier, auth_credential
   153→            )
   154→            return dict(row)
   155→
   156→    @staticmethod
   157→    async def get_auth_by_identifier(
   158→        auth_type: str,
   159→        auth_identifier: str
   160→    ) -> Optional[dict]:
   161→        """Get auth by type and identifier"""
   162→        async with get_connection() as conn:
   163→            row = await conn.fetchrow(
   164→                """
   165→                SELECT ua.*, vu.*
   166→                FROM vibe_user_auth ua
   167→                JOIN vibe_users vu ON ua.user_id = vu.id
   168→                WHERE ua.auth_type = $1 AND ua.auth_identifier = $2
   169→                """,
   170→                auth_type, auth_identifier
   171→            )
   172→            return dict(row) if row else None
   173→
   174→    @staticmethod
   175→    async def verify_auth(
   176→        auth_type: str,
   177→        auth_identifier: str,
   178→        password: str
   179→    ) -> Optional[dict]:
   180→        """Verify authentication and return user"""
   181→        auth = await UserRepository.get_auth_by_identifier(auth_type, auth_identifier)
   182→        if not auth:
   183→            return None
   184→
   185→        # Verify password
   186→        if not verify_password(password, auth['auth_credential']):
   187→            return None
   188→
   189→        return await UserRepository.get_by_id(auth['user_id'])
   190→
   191→    @staticmethod
   192→    async def get_user_auths(user_id: UUID) -> List[dict]:
   193→        """Get all auth methods for user"""
   194→        async with get_connection() as conn:
   195→            rows = await conn.fetch(
   196→                "SELECT * FROM vibe_user_auth WHERE user_id = $1",
   197→                user_id
   198→            )
   199→            return [dict(row) for row in rows]
   200→
   201→    # ─────────────────────────────────────────────────────────────────
   202→    # Data Consent
   203→    # ─────────────────────────────────────────────────────────────────
   204→
   205→    @staticmethod
   206→    async def set_consent(
   207→        user_id: UUID,
   208→        source_skill: str,
   209→        target_skill: str,
   210→        data_type: str,
   211→        consent_granted: bool
   212→    ) -> dict:
   213→        """Set data sharing consent"""
   214→        async with get_connection() as conn:
   215→            row = await conn.fetchrow(
   216→                """
   217→                INSERT INTO vibe_data_consents (
   218→                    user_id, source_skill, target_skill, data_type,
   219→                    consent_granted, granted_at
   220→                )
   221→                VALUES ($1, $2, $3, $4, $5, $6)
   222→                ON CONFLICT (user_id, source_skill, target_skill, data_type)
   223→                DO UPDATE SET
   224→                    consent_granted = $5,
   225→                    granted_at = CASE WHEN $5 THEN NOW() ELSE granted_at END,
   226→                    revoked_at = CASE WHEN NOT $5 THEN NOW() ELSE NULL END
   227→                RETURNING *
   228→                """,
   229→                user_id, source_skill, target_skill, data_type,
   230→                consent_granted, datetime.utcnow() if consent_granted else None
   231→            )
   232→            return dict(row)
   233→
   234→    @staticmethod
   235→    async def get_consents(
   236→        user_id: UUID,
   237→        source_skill: Optional[str] = None
   238→    ) -> List[dict]:
   239→        """Get user's data consents"""
   240→        async with get_connection() as conn:
   241→            if source_skill:
   242→                rows = await conn.fetch(
   243→                    """
   244→                    SELECT * FROM vibe_data_consents
   245→                    WHERE user_id = $1 AND source_skill = $2
   246→                    """,
   247→                    user_id, source_skill
   248→                )
   249→            else:
   250→                rows = await conn.fetch(
   251→                    "SELECT * FROM vibe_data_consents WHERE user_id = $1",
   252→                    user_id
   253→                )
   254→            return [dict(row) for row in rows]
   255→
   256→    @staticmethod
   257→    async def check_consent(
   258→        user_id: UUID,
   259→        source_skill: str,
   260→        target_skill: str,
   261→        data_type: str
   262→    ) -> bool:
   263→        """Check if consent is granted"""
   264→        async with get_connection() as conn:
   265→            result = await conn.fetchval(
   266→                """
   267→                SELECT consent_granted FROM vibe_data_consents
   268→                WHERE user_id = $1 AND source_skill = $2
   269→                  AND target_skill = $3 AND data_type = $4
   270→                """,
   271→                user_id, source_skill, target_skill, data_type
   272→            )
   273→            return result is True
   274→
   275→    # ─────────────────────────────────────────────────────────────────
   276→    # Skill Profiles
   277→    # ─────────────────────────────────────────────────────────────────
   278→
   279→    @staticmethod
   280→    async def create_skill_profile(
   281→        user_id: UUID,
   282→        skill: str,
   283→        voice_mode: str = "warm",
   284→        profile_data: Optional[dict] = None
   285→    ) -> dict:
   286→        """Create or update skill profile with voice_mode and profile_data"""
   287→        import json
   288→        # Merge voice_mode into profile_data since table doesn't have voice_mode column
   289→        merged_data = profile_data or {}
   290→        merged_data['voice_mode'] = voice_mode
   291→
   292→        async with get_connection() as conn:
   293→            row = await conn.fetchrow(
   294→                """
   295→                INSERT INTO skill_profiles (
   296→                    user_id, skill_id, profile_data
   297→                )
   298→                VALUES ($1, $2, $3)
   299→                ON CONFLICT (user_id, skill_id)
   300→                DO UPDATE SET
   301→                    profile_data = skill_profiles.profile_data || $3,
   302→                    last_use_at = NOW()
   303→                RETURNING *
   304→                """,
   305→                user_id, skill, json.dumps(merged_data)
   306→            )
   307→            return dict(row) if row else {}
   308→
   309→    @staticmethod
   310→    async def get_skill_profile(
   311→        user_id: UUID,
   312→        skill: str
   313→    ) -> Optional[dict]:
   314→        """Get skill profile for user"""
   315→        async with get_connection() as conn:
   316→            row = await conn.fetchrow(
   317→                """
   318→                SELECT * FROM skill_profiles
   319→                WHERE user_id = $1 AND skill_id = $2
   320→                """,
   321→                user_id, skill
   322→            )
   323→            return dict(row) if row else None
   324→
   325→    @staticmethod
   326→    async def update_skill_voice_mode(
   327→        user_id: UUID,
   328→        skill: str,
   329→        voice_mode: str
   330→    ) -> Optional[dict]:
   331→        """Update voice_mode for a skill profile"""
   332→        import json
   333→        async with get_connection() as conn:
   334→            row = await conn.fetchrow(
   335→                """
   336→                UPDATE skill_profiles
   337→                SET profile_data = profile_data || $3, last_use_at = NOW()
   338→                WHERE user_id = $1 AND skill_id = $2
   339→                RETURNING *
   340→                """,
   341→                user_id, skill, json.dumps({'voice_mode': voice_mode})
   342→            )
   343→            return dict(row) if row else None
   344→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
