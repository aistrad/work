     1→"""
     2→OAuth Service - Google and Apple OAuth integration
     3→"""
     4→import os
     5→import httpx
     6→from typing import Optional
     7→from uuid import UUID
     8→
     9→from .jwt import JWTService
    10→from stores.user_repo import UserRepository
    11→
    12→
    13→class OAuthService:
    14→    """OAuth authentication service for Google and Apple"""
    15→
    16→    # OAuth configuration
    17→    GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID", "")
    18→    GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET", "")
    19→    APPLE_CLIENT_ID = os.getenv("APPLE_CLIENT_ID", "")
    20→    APPLE_TEAM_ID = os.getenv("APPLE_TEAM_ID", "")
    21→    APPLE_KEY_ID = os.getenv("APPLE_KEY_ID", "")
    22→
    23→    # ─────────────────────────────────────────────────────────────────
    24→    # Google OAuth
    25→    # ─────────────────────────────────────────────────────────────────
    26→
    27→    @classmethod
    28→    async def verify_google_token(cls, id_token: str) -> Optional[dict]:
    29→        """
    30→        Verify Google ID token and return user info.
    31→        """
    32→        try:
    33→            async with httpx.AsyncClient() as client:
    34→                response = await client.get(
    35→                    f"https://oauth2.googleapis.com/tokeninfo?id_token={id_token}"
    36→                )
    37→                if response.status_code != 200:
    38→                    return None
    39→
    40→                data = response.json()
    41→
    42→                # Verify audience matches our client ID
    43→                if data.get("aud") != cls.GOOGLE_CLIENT_ID:
    44→                    return None
    45→
    46→                return {
    47→                    "provider": "google",
    48→                    "provider_id": data.get("sub"),
    49→                    "email": data.get("email"),
    50→                    "email_verified": data.get("email_verified") == "true",
    51→                    "name": data.get("name"),
    52→                    "picture": data.get("picture")
    53→                }
    54→        except Exception:
    55→            return None
    56→
    57→    @classmethod
    58→    async def google_login(
    59→        cls,
    60→        id_token: str,
    61→        onboarding_data: Optional[dict] = None
    62→    ) -> Optional[dict]:
    63→        """
    64→        Login or register user with Google OAuth.
    65→        """
    66→        # Verify token
    67→        google_user = await cls.verify_google_token(id_token)
    68→        if not google_user:
    69→            return None
    70→
    71→        # Check if user exists with this Google ID
    72→        existing_auth = await UserRepository.get_auth_by_identifier(
    73→            "google", google_user["provider_id"]
    74→        )
    75→
    76→        if existing_auth:
    77→            # User exists, return tokens
    78→            user = await UserRepository.get_by_id(existing_auth["user_id"])
    79→            if not user:
    80→                return None
    81→        else:
    82→            # Check if email already registered
    83→            if google_user.get("email"):
    84→                email_auth = await UserRepository.get_auth_by_identifier(
    85→                    "email", google_user["email"]
    86→                )
    87→                if email_auth:
    88→                    # Link Google to existing account
    89→                    user = await UserRepository.get_by_id(email_auth["user_id"])
    90→                    await UserRepository.create_auth(
    91→                        user_id=user["id"],
    92→                        auth_type="google",
    93→                        auth_identifier=google_user["provider_id"],
    94→                        auth_credential=None
    95→                    )
    96→                else:
    97→                    # Create new user
    98→                    user = await UserRepository.create(
    99→                        display_name=google_user.get("name"),
   100→                        birth_datetime=onboarding_data.get("birth_datetime") if onboarding_data else None,
   101→                        birth_location=onboarding_data.get("birth_location") if onboarding_data else None,
   102→                        gender=onboarding_data.get("gender") if onboarding_data else None
   103→                    )
   104→
   105→                    # Create Google auth
   106→                    await UserRepository.create_auth(
   107→                        user_id=user["id"],
   108→                        auth_type="google",
   109→                        auth_identifier=google_user["provider_id"],
   110→                        auth_credential=None
   111→                    )
   112→
   113→                    # Create skill profile if onboarding data provided
   114→                    if onboarding_data and onboarding_data.get("skill"):
   115→                        await UserRepository.create_skill_profile(
   116→                            user_id=user["id"],
   117→                            skill=onboarding_data["skill"],
   118→                            voice_mode=onboarding_data.get("voice_mode", "warm"),
   119→                            profile_data={
   120→                                "interview_responses": onboarding_data.get("interview_responses", {}),
   121→                                "focus_areas": onboarding_data.get("focus_areas", [])
   122→                            }
   123→                        )
   124→            else:
   125→                return None
   126→
   127→        # Generate tokens
   128→        access_token = JWTService.create_access_token(
   129→            str(user["id"]), user["vibe_id"]
   130→        )
   131→        refresh_token = JWTService.create_refresh_token(
   132→            str(user["id"]), user["vibe_id"]
   133→        )
   134→
   135→        return {
   136→            "access_token": access_token,
   137→            "refresh_token": refresh_token,
   138→            "token_type": "bearer",
   139→            "expires_in": JWTService.get_token_expiry(),
   140→            "user": {
   141→                "user_id": str(user["id"]),
   142→                "vibe_id": user["vibe_id"],
   143→                "display_name": user.get("display_name")
   144→            }
   145→        }
   146→
   147→    # ─────────────────────────────────────────────────────────────────
   148→    # Apple OAuth
   149→    # ─────────────────────────────────────────────────────────────────
   150→
   151→    @classmethod
   152→    async def verify_apple_token(cls, id_token: str) -> Optional[dict]:
   153→        """
   154→        Verify Apple ID token and return user info.
   155→        """
   156→        try:
   157→            import jwt
   158→            from jwt import PyJWKClient
   159→
   160→            # Get Apple's public keys
   161→            jwks_client = PyJWKClient("https://appleid.apple.com/auth/keys")
   162→            signing_key = jwks_client.get_signing_key_from_jwt(id_token)
   163→
   164→            # Decode and verify token
   165→            data = jwt.decode(
   166→                id_token,
   167→                signing_key.key,
   168→                algorithms=["RS256"],
   169→                audience=cls.APPLE_CLIENT_ID,
   170→                issuer="https://appleid.apple.com"
   171→            )
   172→
   173→            return {
   174→                "provider": "apple",
   175→                "provider_id": data.get("sub"),
   176→                "email": data.get("email"),
   177→                "email_verified": data.get("email_verified", False),
   178→                "name": None  # Apple doesn't always provide name
   179→            }
   180→        except Exception:
   181→            return None
   182→
   183→    @classmethod
   184→    async def apple_login(
   185→        cls,
   186→        id_token: str,
   187→        user_name: Optional[str] = None,
   188→        onboarding_data: Optional[dict] = None
   189→    ) -> Optional[dict]:
   190→        """
   191→        Login or register user with Apple OAuth.
   192→        user_name is only provided on first login.
   193→        """
   194→        # Verify token
   195→        apple_user = await cls.verify_apple_token(id_token)
   196→        if not apple_user:
   197→            return None
   198→
   199→        # Check if user exists with this Apple ID
   200→        existing_auth = await UserRepository.get_auth_by_identifier(
   201→            "apple", apple_user["provider_id"]
   202→        )
   203→
   204→        if existing_auth:
   205→            # User exists, return tokens
   206→            user = await UserRepository.get_by_id(existing_auth["user_id"])
   207→            if not user:
   208→                return None
   209→        else:
   210→            # Check if email already registered
   211→            if apple_user.get("email"):
   212→                email_auth = await UserRepository.get_auth_by_identifier(
   213→                    "email", apple_user["email"]
   214→                )
   215→                if email_auth:
   216→                    # Link Apple to existing account
   217→                    user = await UserRepository.get_by_id(email_auth["user_id"])
   218→                    await UserRepository.create_auth(
   219→                        user_id=user["id"],
   220→                        auth_type="apple",
   221→                        auth_identifier=apple_user["provider_id"],
   222→                        auth_credential=None
   223→                    )
   224→                else:
   225→                    # Create new user
   226→                    user = await UserRepository.create(
   227→                        display_name=user_name or apple_user.get("email", "").split("@")[0],
   228→                        birth_datetime=onboarding_data.get("birth_datetime") if onboarding_data else None,
   229→                        birth_location=onboarding_data.get("birth_location") if onboarding_data else None,
   230→                        gender=onboarding_data.get("gender") if onboarding_data else None
   231→                    )
   232→
   233→                    # Create Apple auth
   234→                    await UserRepository.create_auth(
   235→                        user_id=user["id"],
   236→                        auth_type="apple",
   237→                        auth_identifier=apple_user["provider_id"],
   238→                        auth_credential=None
   239→                    )
   240→
   241→                    # Create skill profile if onboarding data provided
   242→                    if onboarding_data and onboarding_data.get("skill"):
   243→                        await UserRepository.create_skill_profile(
   244→                            user_id=user["id"],
   245→                            skill=onboarding_data["skill"],
   246→                            voice_mode=onboarding_data.get("voice_mode", "warm"),
   247→                            profile_data={
   248→                                "interview_responses": onboarding_data.get("interview_responses", {}),
   249→                                "focus_areas": onboarding_data.get("focus_areas", [])
   250→                            }
   251→                        )
   252→            else:
   253→                return None
   254→
   255→        # Generate tokens
   256→        access_token = JWTService.create_access_token(
   257→            str(user["id"]), user["vibe_id"]
   258→        )
   259→        refresh_token = JWTService.create_refresh_token(
   260→            str(user["id"]), user["vibe_id"]
   261→        )
   262→
   263→        return {
   264→            "access_token": access_token,
   265→            "refresh_token": refresh_token,
   266→            "token_type": "bearer",
   267→            "expires_in": JWTService.get_token_expiry(),
   268→            "user": {
   269→                "user_id": str(user["id"]),
   270→                "vibe_id": user["vibe_id"],
   271→                "display_name": user.get("display_name")
   272→            }
   273→        }
   274→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
