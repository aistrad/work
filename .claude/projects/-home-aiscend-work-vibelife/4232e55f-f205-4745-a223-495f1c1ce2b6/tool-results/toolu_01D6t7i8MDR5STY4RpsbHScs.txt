     1→"""
     2→Account Routes - 用户账户统一入口
     3→
     4→合并自:
     5→- routes/auth.py (认证)
     6→- routes/users.py (用户资料)
     7→- routes/identity.py (身份棱镜)
     8→- routes/guest.py (访客会话)
     9→
    10→端点:
    11→- /account/auth/* - 认证相关
    12→- /account/profile/* - 用户资料
    13→- /account/guest/* - 访客会话
    14→- /account/identity/* - 身份棱镜
    15→"""
    16→from typing import Optional, List
    17→from datetime import datetime
    18→from uuid import UUID
    19→
    20→from fastapi import APIRouter, HTTPException, status, Depends, Cookie, Response, Query
    21→from pydantic import BaseModel, EmailStr
    22→
    23→from services.identity import (
    24→    AuthService, SSOService, OAuthService, GuestSessionService,
    25→    PasswordResetService, get_current_user, get_optional_user, CurrentUser
    26→)
    27→from stores import UserRepository, SkillRepository, SubscriptionRepository
    28→
    29→router = APIRouter(prefix="/account", tags=["Account"])
    30→
    31→
    32→# ═══════════════════════════════════════════════════════════════════════════
    33→# Request/Response Models
    34→# ═══════════════════════════════════════════════════════════════════════════
    35→
    36→# --- Auth Models ---
    37→
    38→class OnboardingData(BaseModel):
    39→    """Onboarding data to associate with registration"""
    40→    birth_datetime: Optional[datetime] = None
    41→    birth_location: Optional[str] = None
    42→    gender: Optional[str] = None
    43→    voice_mode: Optional[str] = "warm"
    44→    skill: Optional[str] = "bazi"
    45→    interview_responses: Optional[dict] = None
    46→    focus_areas: Optional[List[str]] = None
    47→
    48→
    49→class RegisterRequest(BaseModel):
    50→    email: Optional[EmailStr] = None
    51→    phone: Optional[str] = None
    52→    password: str
    53→    display_name: Optional[str] = None
    54→    onboarding: Optional[OnboardingData] = None
    55→    session_id: Optional[str] = None
    56→
    57→
    58→class LoginRequest(BaseModel):
    59→    email: Optional[EmailStr] = None
    60→    phone: Optional[str] = None
    61→    password: str
    62→
    63→
    64→class RefreshRequest(BaseModel):
    65→    refresh_token: str
    66→
    67→
    68→class TokenResponse(BaseModel):
    69→    access_token: str
    70→    refresh_token: str
    71→    token_type: str = "bearer"
    72→    expires_in: int
    73→    user: dict
    74→
    75→
    76→class GoogleAuthRequest(BaseModel):
    77→    id_token: str
    78→    onboarding: Optional[OnboardingData] = None
    79→
    80→
    81→class AppleAuthRequest(BaseModel):
    82→    id_token: str
    83→    user_name: Optional[str] = None
    84→    onboarding: Optional[OnboardingData] = None
    85→
    86→
    87→class PasswordResetRequest(BaseModel):
    88→    email: Optional[EmailStr] = None
    89→    phone: Optional[str] = None
    90→
    91→
    92→class PasswordResetConfirmRequest(BaseModel):
    93→    token: str
    94→    new_password: str
    95→
    96→
    97→# --- Profile Models ---
    98→
    99→class ProfileUpdateRequest(BaseModel):
   100→    display_name: Optional[str] = None
   101→    avatar_url: Optional[str] = None
   102→    birth_datetime: Optional[datetime] = None
   103→    birth_location: Optional[str] = None
   104→    timezone: Optional[str] = None
   105→    language: Optional[str] = None
   106→
   107→
   108→class ProfileResponse(BaseModel):
   109→    user_id: str
   110→    vibe_id: str
   111→    display_name: Optional[str] = None
   112→    avatar_url: Optional[str] = None
   113→    birth_datetime: Optional[datetime] = None
   114→    birth_location: Optional[str] = None
   115→    timezone: str
   116→    language: str
   117→    created_at: datetime
   118→
   119→
   120→class UserResponse(BaseModel):
   121→    user_id: str
   122→    vibe_id: str
   123→    display_name: Optional[str] = None
   124→    avatar_url: Optional[str] = None
   125→
   126→
   127→# --- Guest Models ---
   128→
   129→class GuestSessionResponse(BaseModel):
   130→    session_id: str
   131→    birth_datetime: Optional[datetime] = None
   132→    birth_location: Optional[str] = None
   133→    gender: Optional[str] = None
   134→    voice_mode: Optional[str] = None
   135→    skill: Optional[str] = None
   136→    interview_responses: Optional[dict] = None
   137→    focus_areas: Optional[list] = None
   138→    expires_at: datetime
   139→
   140→
   141→class GuestOnboardingRequest(BaseModel):
   142→    birth_datetime: Optional[datetime] = None
   143→    birth_location: Optional[str] = None
   144→    gender: Optional[str] = None
   145→    voice_mode: Optional[str] = None
   146→    skill: Optional[str] = None
   147→    interview_responses: Optional[dict] = None
   148→    focus_areas: Optional[List[str]] = None
   149→
   150→
   151→# --- Identity Prism Models ---
   152→
   153→class PrismLayer(BaseModel):
   154→    title: str
   155→    content: str
   156→    evidence: Optional[str] = None
   157→
   158→
   159→class DimensionScore(BaseModel):
   160→    name: str
   161→    score: int
   162→    source: str
   163→
   164→
   165→class Memory(BaseModel):
   166→    content: str
   167→    date: str
   168→
   169→
   170→class PrismResponse(BaseModel):
   171→    core: PrismLayer
   172→    inner: PrismLayer
   173→    outer: PrismLayer
   174→    progress: int
   175→    dimensions: list[DimensionScore]
   176→    memories: list[Memory]
   177→
   178→
   179→# ═══════════════════════════════════════════════════════════════════════════
   180→# Auth Endpoints
   181→# ═══════════════════════════════════════════════════════════════════════════
   182→
   183→@router.post("/auth/register", response_model=TokenResponse)
   184→async def register(
   185→    request: RegisterRequest,
   186→    response: Response,
   187→    guest_session_id: Optional[str] = Cookie(None)
   188→):
   189→    """Register a new user with Vibe ID"""
   190→    try:
   191→        onboarding = request.onboarding
   192→
   193→        result = await AuthService.register(
   194→            email=request.email,
   195→            phone=request.phone,
   196→            password=request.password,
   197→            display_name=request.display_name,
   198→            birth_datetime=onboarding.birth_datetime if onboarding else None,
   199→            birth_location=onboarding.birth_location if onboarding else None,
   200→            gender=onboarding.gender if onboarding else None,
   201→            voice_mode=onboarding.voice_mode if onboarding else None,
   202→            skill=onboarding.skill if onboarding else None,
   203→            interview_responses=onboarding.interview_responses if onboarding else None,
   204→            focus_areas=onboarding.focus_areas if onboarding else None
   205→        )
   206→
   207→        # Link guest session if available
   208→        session_id = request.session_id or guest_session_id
   209→        if session_id:
   210→            await GuestSessionService.link_to_user(
   211→                session_id,
   212→                UUID(result["user"]["user_id"])
   213→            )
   214→            response.delete_cookie(key="guest_session_id")
   215→
   216→        return TokenResponse(**result)
   217→    except ValueError as e:
   218→        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   219→
   220→
   221→@router.post("/auth/login", response_model=TokenResponse)
   222→async def login(request: LoginRequest):
   223→    """Login with email/phone and password"""
   224→    try:
   225→        result = await AuthService.login(
   226→            email=request.email,
   227→            phone=request.phone,
   228→            password=request.password
   229→        )
   230→        return TokenResponse(**result)
   231→    except ValueError as e:
   232→        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(e))
   233→
   234→
   235→@router.post("/auth/refresh", response_model=TokenResponse)
   236→async def refresh_token(request: RefreshRequest):
   237→    """Refresh access token"""
   238→    try:
   239→        result = await AuthService.refresh_token(request.refresh_token)
   240→        return TokenResponse(**result)
   241→    except ValueError as e:
   242→        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(e))
   243→
   244→
   245→@router.post("/auth/logout")
   246→async def logout(current_user: CurrentUser = Depends(get_current_user)):
   247→    """Logout user"""
   248→    return {"message": "Logged out successfully"}
   249→
   250→
   251→@router.get("/auth/me", response_model=UserResponse)
   252→async def get_me(current_user: CurrentUser = Depends(get_current_user)):
   253→    """Get current authenticated user"""
   254→    return UserResponse(
   255→        user_id=str(current_user.user_id),
   256→        vibe_id=current_user.vibe_id,
   257→        display_name=current_user.display_name
   258→    )
   259→
   260→
   261→# --- OAuth ---
   262→
   263→@router.post("/auth/oauth/google", response_model=TokenResponse)
   264→async def google_auth(request: GoogleAuthRequest):
   265→    """Login or register with Google OAuth"""
   266→    onboarding_dict = None
   267→    if request.onboarding:
   268→        onboarding_dict = {
   269→            "birth_datetime": request.onboarding.birth_datetime,
   270→            "birth_location": request.onboarding.birth_location,
   271→            "gender": request.onboarding.gender,
   272→            "voice_mode": request.onboarding.voice_mode,
   273→            "skill": request.onboarding.skill,
   274→            "interview_responses": request.onboarding.interview_responses,
   275→            "focus_areas": request.onboarding.focus_areas
   276→        }
   277→
   278→    result = await OAuthService.google_login(
   279→        id_token=request.id_token,
   280→        onboarding_data=onboarding_dict
   281→    )
   282→
   283→    if not result:
   284→        raise HTTPException(
   285→            status_code=status.HTTP_401_UNAUTHORIZED,
   286→            detail="Invalid Google token or authentication failed"
   287→        )
   288→
   289→    return TokenResponse(**result)
   290→
   291→
   292→@router.post("/auth/oauth/apple", response_model=TokenResponse)
   293→async def apple_auth(request: AppleAuthRequest):
   294→    """Login or register with Apple OAuth"""
   295→    onboarding_dict = None
   296→    if request.onboarding:
   297→        onboarding_dict = {
   298→            "birth_datetime": request.onboarding.birth_datetime,
   299→            "birth_location": request.onboarding.birth_location,
   300→            "gender": request.onboarding.gender,
   301→            "voice_mode": request.onboarding.voice_mode,
   302→            "skill": request.onboarding.skill,
   303→            "interview_responses": request.onboarding.interview_responses,
   304→            "focus_areas": request.onboarding.focus_areas
   305→        }
   306→
   307→    result = await OAuthService.apple_login(
   308→        id_token=request.id_token,
   309→        user_name=request.user_name,
   310→        onboarding_data=onboarding_dict
   311→    )
   312→
   313→    if not result:
   314→        raise HTTPException(
   315→            status_code=status.HTTP_401_UNAUTHORIZED,
   316→            detail="Invalid Apple token or authentication failed"
   317→        )
   318→
   319→    return TokenResponse(**result)
   320→
   321→
   322→# --- Password Reset ---
   323→
   324→@router.post("/auth/password/reset-request")
   325→async def request_password_reset(request: PasswordResetRequest):
   326→    """Request a password reset"""
   327→    if not request.email and not request.phone:
   328→        raise HTTPException(
   329→            status_code=status.HTTP_400_BAD_REQUEST,
   330→            detail="Email or phone is required"
   331→        )
   332→
   333→    result = await PasswordResetService.request_reset(
   334→        email=request.email,
   335→        phone=request.phone
   336→    )
   337→
   338→    return {
   339→        "message": "If an account exists, a reset link has been sent",
   340→        "reset_url": result.get("reset_url") if result else None
   341→    }
   342→
   343→
   344→@router.post("/auth/password/reset")
   345→async def reset_password(request: PasswordResetConfirmRequest):
   346→    """Reset password using a valid token"""
   347→    if len(request.new_password) < 6:
   348→        raise HTTPException(
   349→            status_code=status.HTTP_400_BAD_REQUEST,
   350→            detail="Password must be at least 6 characters"
   351→        )
   352→
   353→    success = await PasswordResetService.reset_password(
   354→        token=request.token,
   355→        new_password=request.new_password
   356→    )
   357→
   358→    if not success:
   359→        raise HTTPException(
   360→            status_code=status.HTTP_400_BAD_REQUEST,
   361→            detail="Invalid or expired reset token"
   362→        )
   363→
   364→    return {"message": "Password reset successfully"}
   365→
   366→
   367→# ═══════════════════════════════════════════════════════════════════════════
   368→# Profile Endpoints
   369→# ═══════════════════════════════════════════════════════════════════════════
   370→
   371→@router.get("/profile", response_model=ProfileResponse)
   372→async def get_profile(current_user: CurrentUser = Depends(get_current_user)):
   373→    """Get current user's full profile"""
   374→    user = await UserRepository.get_by_id(current_user.user_id)
   375→    if not user:
   376→        raise HTTPException(status_code=404, detail="User not found")
   377→
   378→    return ProfileResponse(
   379→        user_id=str(user["id"]),
   380→        vibe_id=user["vibe_id"],
   381→        display_name=user.get("display_name"),
   382→        avatar_url=user.get("avatar_url"),
   383→        birth_datetime=user.get("birth_datetime"),
   384→        birth_location=user.get("birth_location"),
   385→        timezone=user.get("timezone", "Asia/Shanghai"),
   386→        language=user.get("language", "zh-CN"),
   387→        created_at=user["created_at"]
   388→    )
   389→
   390→
   391→@router.put("/profile", response_model=ProfileResponse)
   392→async def update_profile(
   393→    request: ProfileUpdateRequest,
   394→    current_user: CurrentUser = Depends(get_current_user)
   395→):
   396→    """Update current user's profile"""
   397→    update_data = request.model_dump(exclude_unset=True)
   398→
   399→    user = await UserRepository.update(current_user.user_id, **update_data)
   400→    if not user:
   401→        raise HTTPException(status_code=404, detail="User not found")
   402→
   403→    return ProfileResponse(
   404→        user_id=str(user["id"]),
   405→        vibe_id=user["vibe_id"],
   406→        display_name=user.get("display_name"),
   407→        avatar_url=user.get("avatar_url"),
   408→        birth_datetime=user.get("birth_datetime"),
   409→        birth_location=user.get("birth_location"),
   410→        timezone=user.get("timezone", "Asia/Shanghai"),
   411→        language=user.get("language", "zh-CN"),
   412→        created_at=user["created_at"]
   413→    )
   414→
   415→
   416→@router.get("/profile/export")
   417→async def export_data(current_user: CurrentUser = Depends(get_current_user)):
   418→    """Export all user data (GDPR compliance)"""
   419→    user = await UserRepository.get_by_id(current_user.user_id)
   420→    profiles = await SkillRepository.get_user_profiles(current_user.user_id)
   421→    consents = await UserRepository.get_consents(current_user.user_id)
   422→    subscription = await SubscriptionRepository.get_user_subscription(current_user.user_id)
   423→
   424→    return {
   425→        "user": {
   426→            "vibe_id": user["vibe_id"],
   427→            "display_name": user.get("display_name"),
   428→            "birth_datetime": str(user.get("birth_datetime")) if user.get("birth_datetime") else None,
   429→            "birth_location": user.get("birth_location"),
   430→            "timezone": user.get("timezone"),
   431→            "language": user.get("language"),
   432→            "created_at": str(user["created_at"])
   433→        },
   434→        "skill_profiles": [
   435→            {
   436→                "skill_id": p["skill_id"],
   437→                "profile_data": p["profile_data"],
   438→                "total_sessions": p["total_sessions"]
   439→            }
   440→            for p in profiles
   441→        ],
   442→        "consents": [
   443→            {
   444→                "source_skill": c["source_skill"],
   445→                "target_skill": c["target_skill"],
   446→                "data_type": c["data_type"],
   447→                "consent_granted": c["consent_granted"]
   448→            }
   449→            for c in consents
   450→        ],
   451→        "subscription": {
   452→            "plan_id": subscription["plan_id"] if subscription else "free",
   453→            "status": subscription["status"] if subscription else "none"
   454→        } if subscription else None,
   455→        "export_date": str(datetime.utcnow())
   456→    }
   457→
   458→
   459→# ═══════════════════════════════════════════════════════════════════════════
   460→# Guest Session Endpoints
   461→# ═══════════════════════════════════════════════════════════════════════════
   462→
   463→@router.post("/guest/session", response_model=GuestSessionResponse)
   464→async def create_guest_session(response: Response):
   465→    """Create a new guest session"""
   466→    session = await GuestSessionService.create_session()
   467→
   468→    response.set_cookie(
   469→        key="guest_session_id",
   470→        value=session["session_id"],
   471→        max_age=30 * 24 * 60 * 60,
   472→        httponly=True,
   473→        samesite="lax",
   474→        secure=True
   475→    )
   476→
   477→    return GuestSessionResponse(
   478→        session_id=session["session_id"],
   479→        expires_at=session["expires_at"]
   480→    )
   481→
   482→
   483→@router.get("/guest/session", response_model=GuestSessionResponse)
   484→async def get_guest_session(guest_session_id: Optional[str] = Cookie(None)):
   485→    """Get current guest session"""
   486→    if not guest_session_id:
   487→        raise HTTPException(status_code=404, detail="No guest session found")
   488→
   489→    session = await GuestSessionService.get_session(guest_session_id)
   490→    if not session:
   491→        raise HTTPException(status_code=404, detail="Guest session not found or expired")
   492→
   493→    return GuestSessionResponse(
   494→        session_id=session["session_id"],
   495→        birth_datetime=session.get("birth_datetime"),
   496→        birth_location=session.get("birth_location"),
   497→        gender=session.get("gender"),
   498→        voice_mode=session.get("voice_mode"),
   499→        skill=session.get("skill"),
   500→        interview_responses=session.get("interview_responses"),
   501→        focus_areas=session.get("focus_areas"),
   502→        expires_at=session["expires_at"]
   503→    )
   504→
   505→
   506→@router.put("/guest/session/onboarding", response_model=GuestSessionResponse)
   507→async def save_guest_onboarding(
   508→    data: GuestOnboardingRequest,
   509→    guest_session_id: Optional[str] = Cookie(None)
   510→):
   511→    """Save onboarding data to guest session"""
   512→    if not guest_session_id:
   513→        raise HTTPException(status_code=404, detail="No guest session found")
   514→
   515→    session = await GuestSessionService.save_onboarding_data(
   516→        session_id=guest_session_id,
   517→        birth_datetime=data.birth_datetime,
   518→        birth_location=data.birth_location,
   519→        gender=data.gender,
   520→        voice_mode=data.voice_mode,
   521→        skill=data.skill,
   522→        interview_responses=data.interview_responses,
   523→        focus_areas=data.focus_areas
   524→    )
   525→
   526→    if not session:
   527→        raise HTTPException(status_code=404, detail="Guest session not found or expired")
   528→
   529→    return GuestSessionResponse(
   530→        session_id=session["session_id"],
   531→        birth_datetime=session.get("birth_datetime"),
   532→        birth_location=session.get("birth_location"),
   533→        gender=session.get("gender"),
   534→        voice_mode=session.get("voice_mode"),
   535→        skill=session.get("skill"),
   536→        interview_responses=session.get("interview_responses"),
   537→        focus_areas=session.get("focus_areas"),
   538→        expires_at=session["expires_at"]
   539→    )
   540→
   541→
   542→@router.delete("/guest/session")
   543→async def delete_guest_session(
   544→    response: Response,
   545→    guest_session_id: Optional[str] = Cookie(None)
   546→):
   547→    """Delete guest session"""
   548→    response.delete_cookie(key="guest_session_id")
   549→    return {"message": "Guest session cleared"}
   550→
   551→
   552→# ═══════════════════════════════════════════════════════════════════════════
   553→# Identity Prism Endpoints
   554→# ═══════════════════════════════════════════════════════════════════════════
   555→
   556→@router.get("/identity/prism", response_model=PrismResponse)
   557→async def get_prism(
   558→    user_id: Optional[UUID] = Query(None),
   559→    current_user: Optional[CurrentUser] = Depends(get_optional_user)
   560→):
   561→    """Get user's Identity Prism data"""
   562→    import logging
   563→    logger = logging.getLogger(__name__)
   564→
   565→    target_user_id = user_id or (current_user.user_id if current_user else None)
   566→
   567→    # Default prism for guests
   568→    default_prism = PrismResponse(
   569→        core=PrismLayer(
   570→            title="核心驱动力",
   571→            content="追求稳定与安全感，同时渴望被理解和认可",
   572→            evidence="八字·星座"
   573→        ),
   574→        inner=PrismLayer(
   575→            title="内在渴望",
   576→            content="希望在事业上有所成就，同时保持内心的平静",
   577→            evidence="对话记录"
   578→        ),
   579→        outer=PrismLayer(
   580→            title="外在表现",
   581→            content="给人稳重可靠的印象，善于倾听和沟通",
   582→            evidence="八字·星座"
   583→        ),
   584→        progress=35,
   585→        dimensions=[
   586→            DimensionScore(name="八字命理", score=50, source="bazi"),
   587→            DimensionScore(name="星座能量", score=40, source="zodiac"),
   588→            DimensionScore(name="对话洞察", score=20, source="chat"),
   589→            DimensionScore(name="行为模式", score=10, source="behavior"),
   590→        ],
   591→        memories=[Memory(content="欢迎来到 VibeLife", date="刚刚")]
   592→    )
   593→
   594→    if not target_user_id:
   595→        return default_prism
   596→
   597→    try:
   598→        profiles = await SkillRepository.get_user_profiles(target_user_id)
   599→
   600→        bazi_score = 0
   601→        zodiac_score = 0
   602→        chat_score = 0
   603→
   604→        for profile in profiles:
   605→            skill = profile.get("skill_id", "")
   606→            sessions = profile.get("total_sessions", 0)
   607→            if skill == "bazi":
   608→                bazi_score = min(100, sessions * 20 + 50)
   609→            elif skill == "zodiac":
   610→                zodiac_score = min(100, sessions * 20 + 40)
   611→            elif skill == "chat":
   612→                chat_score = min(100, sessions * 5 + 10)
   613→
   614→        progress = int((bazi_score + zodiac_score + chat_score) / 4)
   615→
   616→        insights = await SkillRepository.get_user_insights(user_id=target_user_id, limit=5)
   617→
   618→        memories = [
   619→            Memory(
   620→                content=i.get("content", "")[:50] if i.get("content") else "新的洞察",
   621→                date=str(i.get("created_at", ""))[:10] if i.get("created_at") else "最近"
   622→            )
   623→            for i in insights
   624→        ] if insights else [Memory(content="继续探索，让我更了解你", date="刚刚")]
   625→
   626→        return PrismResponse(
   627→            core=PrismLayer(
   628→                title="核心驱动力",
   629→                content="追求稳定与安全感，同时渴望被理解和认可",
   630→                evidence="八字·星座"
   631→            ),
   632→            inner=PrismLayer(
   633→                title="内在渴望",
   634→                content="希望在事业上有所成就，同时保持内心的平静",
   635→                evidence="对话记录"
   636→            ),
   637→            outer=PrismLayer(
   638→                title="外在表现",
   639→                content="给人稳重可靠的印象，善于倾听和沟通",
   640→                evidence="八字·星座"
   641→            ),
   642→            progress=max(35, progress),
   643→            dimensions=[
   644→                DimensionScore(name="八字命理", score=max(50, bazi_score), source="bazi"),
   645→                DimensionScore(name="星座能量", score=max(40, zodiac_score), source="zodiac"),
   646→                DimensionScore(name="对话洞察", score=max(20, chat_score), source="chat"),
   647→                DimensionScore(name="行为模式", score=10, source="behavior"),
   648→            ],
   649→            memories=memories
   650→        )
   651→
   652→    except Exception as e:
   653→        logger.warning(f"Failed to get prism data: {e}")
   654→        return default_prism
   655→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
