     1→"""
     2→Authentication Service & Dependencies
     3→"""
     4→from typing import Optional
     5→from uuid import UUID
     6→
     7→from fastapi import Depends, HTTPException, status
     8→from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
     9→
    10→from .jwt import JWTService
    11→from stores.user_repo import UserRepository
    12→
    13→
    14→# ─────────────────────────────────────────────────────────────────
    15→# Security scheme
    16→# ─────────────────────────────────────────────────────────────────
    17→
    18→bearer_scheme = HTTPBearer(auto_error=False)
    19→
    20→
    21→# ─────────────────────────────────────────────────────────────────
    22→# Current User Data Class
    23→# ─────────────────────────────────────────────────────────────────
    24→
    25→class CurrentUser:
    26→    """Current authenticated user"""
    27→
    28→    def __init__(
    29→        self,
    30→        user_id: UUID,
    31→        vibe_id: str,
    32→        display_name: Optional[str] = None,
    33→        email: Optional[str] = None
    34→    ):
    35→        self.user_id = user_id
    36→        self.vibe_id = vibe_id
    37→        self.display_name = display_name
    38→        self.email = email
    39→
    40→    def __repr__(self):
    41→        return f"<CurrentUser {self.vibe_id}>"
    42→
    43→
    44→# ─────────────────────────────────────────────────────────────────
    45→# Auth Dependencies
    46→# ─────────────────────────────────────────────────────────────────
    47→
    48→async def get_current_user(
    49→    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme)
    50→) -> CurrentUser:
    51→    """
    52→    Get current authenticated user.
    53→    Raises 401 if not authenticated.
    54→    """
    55→    if not credentials:
    56→        raise HTTPException(
    57→            status_code=status.HTTP_401_UNAUTHORIZED,
    58→            detail="Not authenticated",
    59→            headers={"WWW-Authenticate": "Bearer"},
    60→        )
    61→
    62→    token = credentials.credentials
    63→    payload = JWTService.verify_access_token(token)
    64→
    65→    if not payload:
    66→        raise HTTPException(
    67→            status_code=status.HTTP_401_UNAUTHORIZED,
    68→            detail="Invalid or expired token",
    69→            headers={"WWW-Authenticate": "Bearer"},
    70→        )
    71→
    72→    user_id = payload.get("sub")
    73→    vibe_id = payload.get("vibe_id")
    74→
    75→    if not user_id or not vibe_id:
    76→        raise HTTPException(
    77→            status_code=status.HTTP_401_UNAUTHORIZED,
    78→            detail="Invalid token payload",
    79→            headers={"WWW-Authenticate": "Bearer"},
    80→        )
    81→
    82→    # Optionally verify user still exists
    83→    user = await UserRepository.get_by_id(UUID(user_id))
    84→    if not user or user.get("status") != "active":
    85→        raise HTTPException(
    86→            status_code=status.HTTP_401_UNAUTHORIZED,
    87→            detail="User not found or inactive",
    88→            headers={"WWW-Authenticate": "Bearer"},
    89→        )
    90→
    91→    return CurrentUser(
    92→        user_id=UUID(user_id),
    93→        vibe_id=vibe_id,
    94→        display_name=user.get("display_name")
    95→    )
    96→
    97→
    98→async def get_optional_user(
    99→    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme)
   100→) -> Optional[CurrentUser]:
   101→    """
   102→    Get current user if authenticated, None otherwise.
   103→    Does not raise error if not authenticated.
   104→    """
   105→    if not credentials:
   106→        return None
   107→
   108→    token = credentials.credentials
   109→    payload = JWTService.verify_access_token(token)
   110→
   111→    if not payload:
   112→        return None
   113→
   114→    user_id = payload.get("sub")
   115→    vibe_id = payload.get("vibe_id")
   116→
   117→    if not user_id or not vibe_id:
   118→        return None
   119→
   120→    return CurrentUser(
   121→        user_id=UUID(user_id),
   122→        vibe_id=vibe_id
   123→    )
   124→
   125→
   126→# ─────────────────────────────────────────────────────────────────
   127→# Auth Service Class
   128→# ─────────────────────────────────────────────────────────────────
   129→
   130→class AuthService:
   131→    """Authentication service"""
   132→
   133→    @staticmethod
   134→    async def register(
   135→        email: Optional[str] = None,
   136→        phone: Optional[str] = None,
   137→        password: str = None,
   138→        display_name: Optional[str] = None,
   139→        birth_datetime=None,
   140→        birth_location: Optional[str] = None,
   141→        gender: Optional[str] = None,
   142→        voice_mode: Optional[str] = None,
   143→        skill: Optional[str] = None,
   144→        interview_responses: Optional[dict] = None,
   145→        focus_areas: Optional[list] = None
   146→    ) -> dict:
   147→        """Register a new user with optional onboarding data"""
   148→        if not email and not phone:
   149→            raise ValueError("Email or phone is required")
   150→
   151→        if not password:
   152→            raise ValueError("Password is required")
   153→
   154→        # Check if identifier already exists
   155→        auth_type = "email" if email else "phone"
   156→        auth_identifier = email if email else phone
   157→
   158→        existing = await UserRepository.get_auth_by_identifier(auth_type, auth_identifier)
   159→        if existing:
   160→            raise ValueError(f"{auth_type.capitalize()} already registered")
   161→
   162→        # Create user with onboarding data
   163→        user = await UserRepository.create(
   164→            display_name=display_name or (email.split("@")[0] if email else phone[-4:]),
   165→            birth_datetime=birth_datetime,
   166→            birth_location=birth_location,
   167→            gender=gender
   168→        )
   169→
   170→        # Create auth
   171→        await UserRepository.create_auth(
   172→            user_id=user["id"],
   173→            auth_type=auth_type,
   174→            auth_identifier=auth_identifier,
   175→            auth_credential=password  # Will be hashed in repo
   176→        )
   177→
   178→        # Create skill profile with onboarding data if provided
   179→        if skill and (voice_mode or interview_responses or focus_areas):
   180→            await UserRepository.create_skill_profile(
   181→                user_id=user["id"],
   182→                skill=skill,
   183→                voice_mode=voice_mode or "warm",
   184→                profile_data={
   185→                    "interview_responses": interview_responses or {},
   186→                    "focus_areas": focus_areas or []
   187→                }
   188→            )
   189→
   190→        # Generate tokens
   191→        access_token = JWTService.create_access_token(
   192→            str(user["id"]), user["vibe_id"]
   193→        )
   194→        refresh_token = JWTService.create_refresh_token(
   195→            str(user["id"]), user["vibe_id"]
   196→        )
   197→
   198→        return {
   199→            "access_token": access_token,
   200→            "refresh_token": refresh_token,
   201→            "token_type": "bearer",
   202→            "expires_in": JWTService.get_token_expiry(),
   203→            "user": {
   204→                "user_id": str(user["id"]),
   205→                "vibe_id": user["vibe_id"],
   206→                "display_name": user["display_name"]
   207→            }
   208→        }
   209→
   210→    @staticmethod
   211→    async def login(
   212→        email: Optional[str] = None,
   213→        phone: Optional[str] = None,
   214→        password: str = None
   215→    ) -> dict:
   216→        """Login user"""
   217→        if not email and not phone:
   218→            raise ValueError("Email or phone is required")
   219→
   220→        auth_type = "email" if email else "phone"
   221→        auth_identifier = email if email else phone
   222→
   223→        # Verify credentials
   224→        user = await UserRepository.verify_auth(auth_type, auth_identifier, password)
   225→
   226→        if not user:
   227→            raise ValueError("Invalid credentials")
   228→
   229→        if user.get("status") != "active":
   230→            raise ValueError("Account is not active")
   231→
   232→        # Generate tokens
   233→        access_token = JWTService.create_access_token(
   234→            str(user["id"]), user["vibe_id"]
   235→        )
   236→        refresh_token = JWTService.create_refresh_token(
   237→            str(user["id"]), user["vibe_id"]
   238→        )
   239→
   240→        return {
   241→            "access_token": access_token,
   242→            "refresh_token": refresh_token,
   243→            "token_type": "bearer",
   244→            "expires_in": JWTService.get_token_expiry(),
   245→            "user": {
   246→                "user_id": str(user["id"]),
   247→                "vibe_id": user["vibe_id"],
   248→                "display_name": user["display_name"]
   249→            }
   250→        }
   251→
   252→    @staticmethod
   253→    async def refresh_token(refresh_token: str) -> dict:
   254→        """Refresh access token"""
   255→        payload = JWTService.verify_refresh_token(refresh_token)
   256→
   257→        if not payload:
   258→            raise ValueError("Invalid or expired refresh token")
   259→
   260→        user_id = payload.get("sub")
   261→        vibe_id = payload.get("vibe_id")
   262→
   263→        # Verify user
   264→        user = await UserRepository.get_by_id(UUID(user_id))
   265→        if not user or user.get("status") != "active":
   266→            raise ValueError("User not found or inactive")
   267→
   268→        # Generate new tokens
   269→        new_access_token = JWTService.create_access_token(user_id, vibe_id)
   270→        new_refresh_token = JWTService.create_refresh_token(user_id, vibe_id)
   271→
   272→        return {
   273→            "access_token": new_access_token,
   274→            "refresh_token": new_refresh_token,
   275→            "token_type": "bearer",
   276→            "expires_in": JWTService.get_token_expiry(),
   277→            "user": {
   278→                "user_id": str(user["id"]),
   279→                "vibe_id": user["vibe_id"],
   280→                "display_name": user["display_name"]
   281→            }
   282→        }
   283→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
