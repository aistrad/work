     1→"""
     2→Synastry Engine - 合盘计算引擎
     3→
     4→轻度融合架构：各 Skill 独立计算，最后 AI 综合解读
     5→
     6→支持的维度：
     7→- zodiac: 星座合盘
     8→- bazi: 八字合婚
     9→- jungastro: 荣格关系分析
    10→"""
    11→
    12→import logging
    13→from dataclasses import dataclass
    14→from datetime import datetime
    15→from typing import Dict, Any, List, Optional
    16→
    17→logger = logging.getLogger(__name__)
    18→
    19→
    20→@dataclass
    21→class SynastryDimensionResult:
    22→    """单个维度的合盘结果"""
    23→    skill_id: str
    24→    score: int
    25→    summary: str
    26→    data: dict
    27→
    28→
    29→@dataclass
    30→class SynastryResult:
    31→    """完整合盘结果"""
    32→    person1: dict
    33→    person2: dict
    34→    relationship_type: str
    35→    overall_score: int
    36→    dimensions: List[SynastryDimensionResult]
    37→    calculated_at: datetime
    38→
    39→
    40→class SynastryEngine:
    41→    """
    42→    合盘计算引擎
    43→
    44→    设计原则：
    45→    1. 各 Skill 独立计算，互不依赖
    46→    2. 综合评分取加权平均
    47→    3. AI 综合解读由 LLM 在对话中生成
    48→    """
    49→
    50→    async def calculate(
    51→        self,
    52→        user_profile: dict,
    53→        partner_birth_info: dict,
    54→        relationship_type: str,
    55→        subscribed_skills: List[str]
    56→    ) -> SynastryResult:
    57→        """
    58→        计算合盘
    59→
    60→        Args:
    61→            user_profile: 用户完整 Profile（包含 skills 数据）
    62→            partner_birth_info: 对方出生信息 {date, time, place, timezone}
    63→            relationship_type: 关系类型
    64→            subscribed_skills: 用户已订阅的 Skill 列表
    65→
    66→        Returns:
    67→            SynastryResult: 完整合盘结果
    68→        """
    69→        dimensions = []
    70→        total_score = 0
    71→        skill_count = 0
    72→
    73→        # 1. 星座合盘
    74→        if "zodiac" in subscribed_skills:
    75→            user_zodiac = user_profile.get("skills", {}).get("zodiac", {})
    76→            if user_zodiac.get("chart"):
    77→                try:
    78→                    result = await self._calc_zodiac_synastry(
    79→                        user_zodiac["chart"],
    80→                        partner_birth_info,
    81→                        relationship_type
    82→                    )
    83→                    dimensions.append(result)
    84→                    total_score += result.score
    85→                    skill_count += 1
    86→                except Exception as e:
    87→                    logger.error(f"星座合盘计算失败: {e}")
    88→
    89→        # 2. 八字合婚
    90→        if "bazi" in subscribed_skills:
    91→            user_bazi = user_profile.get("skills", {}).get("bazi", {})
    92→            if user_bazi.get("chart"):
    93→                try:
    94→                    result = await self._calc_bazi_synastry(
    95→                        user_bazi["chart"],
    96→                        partner_birth_info,
    97→                        relationship_type
    98→                    )
    99→                    dimensions.append(result)
   100→                    total_score += result.score
   101→                    skill_count += 1
   102→                except Exception as e:
   103→                    logger.error(f"八字合婚计算失败: {e}")
   104→
   105→        # 3. 荣格关系分析
   106→        if "jungastro" in subscribed_skills:
   107→            user_jungastro = user_profile.get("skills", {}).get("jungastro", {})
   108→            if user_jungastro:
   109→                try:
   110→                    result = await self._calc_jungastro_synastry(
   111→                        user_jungastro,
   112→                        partner_birth_info,
   113→                        relationship_type
   114→                    )
   115→                    dimensions.append(result)
   116→                    total_score += result.score
   117→                    skill_count += 1
   118→                except Exception as e:
   119→                    logger.error(f"荣格关系分析失败: {e}")
   120→
   121→        # 4. 计算综合评分
   122→        overall_score = round(total_score / skill_count) if skill_count > 0 else 50
   123→
   124→        return SynastryResult(
   125→            person1=self._extract_person_summary(user_profile),
   126→            person2={"name": "TA", "birth_info": partner_birth_info},
   127→            relationship_type=relationship_type,
   128→            overall_score=overall_score,
   129→            dimensions=dimensions,
   130→            calculated_at=datetime.utcnow()
   131→        )
   132→
   133→    async def _calc_zodiac_synastry(
   134→        self,
   135→        user_chart: dict,
   136→        partner_birth_info: dict,
   137→        relationship_type: str
   138→    ) -> SynastryDimensionResult:
   139→        """
   140→        计算星座合盘
   141→
   142→        TODO: 集成现有的 zodiac synastry 计算逻辑
   143→        """
   144→        # 暂时返回模拟数据，后续集成真实计算
   145→        from skills.zodiac.services.api import calculate_zodiac_chart
   146→
   147→        # 计算对方星盘
   148→        partner_chart = await calculate_zodiac_chart(partner_birth_info)
   149→
   150→        # 简化版合盘计算
   151→        user_sun = user_chart.get("sun_sign", "")
   152→        partner_sun = partner_chart.get("sun_sign", "") if partner_chart else ""
   153→
   154→        # 基于元素的简单兼容性计算
   155→        score = self._calc_element_compatibility(user_sun, partner_sun)
   156→
   157→        return SynastryDimensionResult(
   158→            skill_id="zodiac",
   159→            score=score,
   160→            summary=f"太阳{user_sun} × 太阳{partner_sun}",
   161→            data={
   162→                "person1": {
   163→                    "sunSign": user_chart.get("sun_sign"),
   164→                    "moonSign": user_chart.get("moon_sign"),
   165→                    "risingSign": user_chart.get("rising_sign"),
   166→                },
   167→                "person2": {
   168→                    "sunSign": partner_chart.get("sun_sign") if partner_chart else None,
   169→                    "moonSign": partner_chart.get("moon_sign") if partner_chart else None,
   170→                    "risingSign": partner_chart.get("rising_sign") if partner_chart else None,
   171→                },
   172→                "compatibility": {
   173→                    "overall": score,
   174→                    "emotional": score + 5 if score < 95 else 100,
   175→                    "communication": score - 5 if score > 5 else 0,
   176→                    "passion": score,
   177→                    "stability": score
   178→                }
   179→            }
   180→        )
   181→
   182→    async def _calc_bazi_synastry(
   183→        self,
   184→        user_chart: dict,
   185→        partner_birth_info: dict,
   186→        relationship_type: str
   187→    ) -> SynastryDimensionResult:
   188→        """
   189→        计算八字合婚
   190→
   191→        TODO: 集成真实的八字合婚算法
   192→        """
   193→        from skills.bazi.services.api import calculate_bazi_chart
   194→
   195→        # 计算对方八字
   196→        partner_chart = await calculate_bazi_chart(partner_birth_info)
   197→
   198→        # 获取日主
   199→        user_day_master = user_chart.get("day_master", {})
   200→        partner_day_master = partner_chart.get("day_master", {}) if partner_chart else {}
   201→
   202→        # 简化版日主关系计算
   203→        score = self._calc_day_master_compatibility(
   204→            user_day_master.get("stem", ""),
   205→            partner_day_master.get("stem", "")
   206→        )
   207→
   208→        return SynastryDimensionResult(
   209→            skill_id="bazi",
   210→            score=score,
   211→            summary=f"日主{user_day_master.get('stem', '?')} × {partner_day_master.get('stem', '?')}",
   212→            data={
   213→                "person1": {
   214→                    "dayMaster": user_day_master,
   215→                    "fourPillars": user_chart.get("four_pillars", {})
   216→                },
   217→                "person2": {
   218→                    "dayMaster": partner_day_master,
   219→                    "fourPillars": partner_chart.get("four_pillars", {}) if partner_chart else {}
   220→                },
   221→                "compatibility": {
   222→                    "overall": score,
   223→                    "dayMasterHarmony": score,
   224→                    "fiveElementBalance": score - 3 if score > 3 else 0,
   225→                    "tenGodInteraction": score + 3 if score < 97 else 100
   226→                }
   227→            }
   228→        )
   229→
   230→    async def _calc_jungastro_synastry(
   231→        self,
   232→        user_jungastro: dict,
   233→        partner_birth_info: dict,
   234→        relationship_type: str
   235→    ) -> SynastryDimensionResult:
   236→        """
   237→        计算荣格关系分析
   238→
   239→        基于用户的心理画像推导关系动力
   240→        """
   241→        # 从用户的荣格画像提取依附风格
   242→        attachment_style = user_jungastro.get("attachment_style", "secure")
   243→
   244→        # 根据关系类型调整分析重点
   245→        analysis_focus = self._get_jungastro_focus(relationship_type)
   246→
   247→        # 简化版计算
   248→        base_score = 70
   249→        if attachment_style == "secure":
   250→            base_score += 10
   251→        elif attachment_style == "anxious":
   252→            base_score -= 5
   253→        elif attachment_style == "avoidant":
   254→            base_score -= 5
   255→
   256→        return SynastryDimensionResult(
   257→            skill_id="jungastro",
   258→            score=base_score,
   259→            summary=f"依附风格: {self._get_attachment_label(attachment_style)}",
   260→            data={
   261→                "attachmentStyle": {
   262→                    "type": attachment_style,
   263→                    "description": self._get_attachment_description(attachment_style),
   264→                    "strengths": self._get_attachment_strengths(attachment_style),
   265→                    "challenges": self._get_attachment_challenges(attachment_style)
   266→                },
   267→                "relationshipPatterns": [],
   268→                "growthOpportunities": analysis_focus.get("growth_opportunities", [])
   269→            }
   270→        )
   271→
   272→    def _extract_person_summary(self, profile: dict) -> dict:
   273→        """提取用户摘要信息"""
   274→        return {
   275→            "name": profile.get("account", {}).get("display_name", "你"),
   276→            "birth_info": profile.get("identity", {}).get("birth_info", {})
   277→        }
   278→
   279→    def _calc_element_compatibility(self, sign1: str, sign2: str) -> int:
   280→        """基于星座元素计算兼容性"""
   281→        fire_signs = ["白羊座", "狮子座", "射手座", "Aries", "Leo", "Sagittarius"]
   282→        earth_signs = ["金牛座", "处女座", "摩羯座", "Taurus", "Virgo", "Capricorn"]
   283→        air_signs = ["双子座", "天秤座", "水瓶座", "Gemini", "Libra", "Aquarius"]
   284→        water_signs = ["巨蟹座", "天蝎座", "双鱼座", "Cancer", "Scorpio", "Pisces"]
   285→
   286→        def get_element(sign):
   287→            if sign in fire_signs:
   288→                return "fire"
   289→            elif sign in earth_signs:
   290→                return "earth"
   291→            elif sign in air_signs:
   292→                return "air"
   293→            elif sign in water_signs:
   294→                return "water"
   295→            return "unknown"
   296→
   297→        elem1 = get_element(sign1)
   298→        elem2 = get_element(sign2)
   299→
   300→        # 元素兼容性矩阵
   301→        compatibility = {
   302→            ("fire", "fire"): 85,
   303→            ("fire", "air"): 90,
   304→            ("fire", "earth"): 60,
   305→            ("fire", "water"): 50,
   306→            ("earth", "earth"): 80,
   307→            ("earth", "water"): 85,
   308→            ("earth", "air"): 55,
   309→            ("air", "air"): 75,
   310→            ("air", "water"): 60,
   311→            ("water", "water"): 90,
   312→        }
   313→
   314→        key = (elem1, elem2) if (elem1, elem2) in compatibility else (elem2, elem1)
   315→        return compatibility.get(key, 70)
   316→
   317→    def _calc_day_master_compatibility(self, stem1: str, stem2: str) -> int:
   318→        """计算日主兼容性"""
   319→        # 简化版：基于五行生克
   320→        element_map = {
   321→            "甲": "木", "乙": "木",
   322→            "丙": "火", "丁": "火",
   323→            "戊": "土", "己": "土",
   324→            "庚": "金", "辛": "金",
   325→            "壬": "水", "癸": "水"
   326→        }
   327→
   328→        elem1 = element_map.get(stem1, "")
   329→        elem2 = element_map.get(stem2, "")
   330→
   331→        if not elem1 or not elem2:
   332→            return 70
   333→
   334→        # 相生关系
   335→        generates = {
   336→            "木": "火", "火": "土", "土": "金", "金": "水", "水": "木"
   337→        }
   338→
   339→        if generates.get(elem1) == elem2 or generates.get(elem2) == elem1:
   340→            return 85  # 相生
   341→
   342→        # 相克关系
   343→        overcomes = {
   344→            "木": "土", "土": "水", "水": "火", "火": "金", "金": "木"
   345→        }
   346→
   347→        if overcomes.get(elem1) == elem2 or overcomes.get(elem2) == elem1:
   348→            return 55  # 相克
   349→
   350→        if elem1 == elem2:
   351→            return 75  # 比肩
   352→
   353→        return 70  # 其他
   354→
   355→    def _get_jungastro_focus(self, relationship_type: str) -> dict:
   356→        """获取荣格分析的关注重点"""
   357→        focuses = {
   358→            "romantic": {
   359→                "emphasis": ["passion", "emotional", "projection"],
   360→                "growth_opportunities": [
   361→                    "通过关系看见自己的阴影",
   362→                    "学习在亲密中保持自我",
   363→                    "共同成长的可能性"
   364→                ]
   365→            },
   366→            "parent_child": {
   367→                "emphasis": ["communication", "understanding", "growth"],
   368→                "growth_opportunities": [
   369→                    "理解彼此的心理需求",
   370→                    "找到有效的沟通方式",
   371→                    "支持彼此的个性化发展"
   372→                ]
   373→            },
   374→            "business": {
   375→                "emphasis": ["trust", "complementary", "decision"],
   376→                "growth_opportunities": [
   377→                    "利用互补的心理特质",
   378→                    "建立有效的决策模式",
   379→                    "在合作中相互学习"
   380→                ]
   381→            }
   382→        }
   383→        return focuses.get(relationship_type, focuses["romantic"])
   384→
   385→    def _get_attachment_label(self, style: str) -> str:
   386→        """获取依附风格标签"""
   387→        labels = {
   388→            "secure": "安全型",
   389→            "anxious": "焦虑型",
   390→            "avoidant": "回避型",
   391→            "disorganized": "混乱型"
   392→        }
   393→        return labels.get(style, style)
   394→
   395→    def _get_attachment_description(self, style: str) -> str:
   396→        """获取依附风格描述"""
   397→        descriptions = {
   398→            "secure": "你在关系中感到舒适，能够既依赖他人也让他人依赖你",
   399→            "anxious": "你渴望亲密关系，但有时会担心对方不够爱你",
   400→            "avoidant": "你重视独立，有时会在关系中保持一定距离",
   401→            "disorganized": "你对亲密关系有矛盾的感受"
   402→        }
   403→        return descriptions.get(style, "")
   404→
   405→    def _get_attachment_strengths(self, style: str) -> List[str]:
   406→        """获取依附风格优势"""
   407→        strengths = {
   408→            "secure": ["情绪稳定", "善于沟通", "信任他人"],
   409→            "anxious": ["深情投入", "敏感细腻", "重视关系"],
   410→            "avoidant": ["独立自主", "理性冷静", "不易受伤"],
   411→            "disorganized": ["适应力强", "深度敏感", "理解复杂性"]
   412→        }
   413→        return strengths.get(style, [])
   414→
   415→    def _get_attachment_challenges(self, style: str) -> List[str]:
   416→        """获取依附风格挑战"""
   417→        challenges = {
   418→            "secure": ["可能忽视关系中的问题"],
   419→            "anxious": ["容易过度担心", "需要更多安全感"],
   420→            "avoidant": ["亲密关系中可能退缩", "表达情感困难"],
   421→            "disorganized": ["关系模式不稳定", "需要更多自我了解"]
   422→        }
   423→        return challenges.get(style, [])
   424→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
