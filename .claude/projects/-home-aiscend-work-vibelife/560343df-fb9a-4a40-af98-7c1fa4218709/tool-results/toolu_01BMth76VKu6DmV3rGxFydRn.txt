     1→"""
     2→Global Tool Handlers - 全局工具执行器
     3→
     4→使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。
     5→"""
     6→import json
     7→import logging
     8→from datetime import datetime, timezone
     9→from typing import Dict, Any
    10→
    11→from .tool_registry import tool_handler, ToolContext
    12→from .skill_loader import get_skill_services
    13→
    14→logger = logging.getLogger(__name__)
    15→
    16→
    17→@tool_handler("search_db")
    18→async def execute_search_db(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    19→    """从数据库检索知识或案例"""
    20→    from services.knowledge.repository import get_knowledge_repository
    21→
    22→    table = args.get("table", "knowledge_chunks")
    23→    query = args.get("query", "")
    24→    filters = args.get("filters", {})
    25→    top_k = args.get("top_k", 5)
    26→
    27→    # 自动添加当前 skill_id 到 filters
    28→    if context.skill_id and "skill_id" not in filters:
    29→        filters["skill_id"] = context.skill_id
    30→
    31→    try:
    32→        repo = get_knowledge_repository()
    33→        results = await repo.search_db(
    34→            table=table,
    35→            query=query,
    36→            filters=filters,
    37→            top_k=top_k
    38→        )
    39→        return {
    40→            "status": "success",
    41→            "table": table,
    42→            "query": query,
    43→            "count": len(results),
    44→            "results": results
    45→        }
    46→    except Exception as e:
    47→        logger.error(f"search_db failed: {e}")
    48→        return {"status": "error", "error": str(e)}
    49→
    50→
    51→@tool_handler("ask_user_question")
    52→async def execute_ask_user_question(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    53→    """向用户提问"""
    54→    return {
    55→        "status": "question",
    56→        "question": args.get("question"),
    57→        "options": args.get("options", [])
    58→    }
    59→
    60→
    61→@tool_handler("show_service_menu")
    62→async def execute_show_service_menu(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    63→    """展示服务目录"""
    64→    services = args.get("services", [
    65→        {"id": "bazi", "name": "八字命理", "description": "八字排盘、运势分析", "icon": "compass"},
    66→        {"id": "zodiac", "name": "星座占星", "description": "星盘解读、行运分析", "icon": "star"},
    67→        {"id": "tarot", "name": "塔罗占卜", "description": "塔罗牌阵、问题指引", "icon": "cards"},
    68→        {"id": "career", "name": "职业规划", "description": "职业方向、发展建议", "icon": "briefcase"},
    69→    ])
    70→    return {
    71→        "status": "success",
    72→        "cardType": "service_menu",
    73→        "services": services,
    74→    }
    75→
    76→
    77→@tool_handler("show_skill_services")
    78→async def execute_show_skill_services(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    79→    """展示 Skill 服务目录"""
    80→    skill_id = args.get("skill_id") or context.skill_id or "bazi"
    81→
    82→    # 从 SKILL.md 动态获取服务列表
    83→    skill_services = get_skill_services(skill_id)
    84→    if skill_services:
    85→        return {
    86→            "status": "success",
    87→            "cardType": "skill_services",
    88→            "skillId": skill_id,
    89→            "skillName": skill_services.get("skill_name", skill_id),
    90→            "services": skill_services.get("services", {}),
    91→        }
    92→
    93→    # 回退到静态列表
    94→    static_services = {
    95→        "bazi": [
    96→            {"id": "bazi_chart", "name": "八字排盘", "description": "生成完整八字命盘", "tier": "entry"},
    97→            {"id": "bazi_fortune", "name": "运势分析", "description": "大运流年详解", "tier": "entry"},
    98→            {"id": "bazi_career", "name": "事业分析", "description": "职业方向与发展", "tier": "pro"},
    99→        ],
   100→        "zodiac": [
   101→            {"id": "zodiac_chart", "name": "星盘解读", "description": "本命星盘分析", "tier": "entry"},
   102→            {"id": "zodiac_transit", "name": "行运分析", "description": "当前行星影响", "tier": "entry"},
   103→        ],
   104→    }
   105→
   106→    return {
   107→        "status": "success",
   108→        "cardType": "skill_services",
   109→        "skillId": skill_id,
   110→        "services": static_services.get(skill_id, []),
   111→    }
   112→
   113→
   114→@tool_handler("recommend_service")
   115→async def execute_recommend_service(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   116→    """推荐升级服务"""
   117→    return {
   118→        "status": "success",
   119→        "cardType": "service_recommendation",
   120→        "scenarioId": args.get("scenario_id", ""),
   121→        "reason": args.get("reason", ""),
   122→        "highlights": args.get("highlights", []),
   123→    }
   124→
   125→
   126→@tool_handler("request_info")
   127→async def execute_request_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   128→    """向用户请求信息"""
   129→    info_type = args.get("info_type", "birth")
   130→
   131→    fields_map = {
   132→        "birth": [
   133→            {"id": "birthDate", "label": "出生日期", "type": "date", "placeholder": ""},
   134→            {"id": "birthTime", "label": "出生时间", "type": "time", "placeholder": ""},
   135→            {"id": "birthPlace", "label": "出生地点", "type": "text", "placeholder": "城市名"},
   136→            {"id": "gender", "label": "性别", "type": "select", "options": [
   137→                {"value": "male", "label": "男"},
   138→                {"value": "female", "label": "女"},
   139→            ]},
   140→        ],
   141→        "context": [
   142→            {"id": "situation", "label": "当前情况", "type": "text", "placeholder": "描述你目前面临的情况"},
   143→        ],
   144→        "goals": [
   145→            {"id": "goals", "label": "你的目标", "type": "text", "placeholder": "你想达成什么"},
   146→        ],
   147→        "concerns": [
   148→            {"id": "concerns", "label": "你的困惑", "type": "text", "placeholder": "最困扰你的是什么"},
   149→        ],
   150→    }
   151→
   152→    return {
   153→        "status": "collecting",
   154→        "cardType": "collect_form",
   155→        "infoType": info_type,
   156→        "question": args.get("question"),
   157→        "fields": fields_map.get(info_type, fields_map["birth"]),
   158→    }
   159→
   160→
   161→@tool_handler("show_insight")
   162→async def execute_show_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   163→    """展示洞察卡片"""
   164→    return {
   165→        "status": "success",
   166→        "cardType": "insight_card",
   167→        "insightType": args.get("insight_type", "general"),
   168→        "title": args.get("title", "关键洞察"),
   169→        "content": args.get("content", ""),
   170→    }
   171→
   172→
   173→@tool_handler("show_report")
   174→async def execute_show_report(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   175→    """展示报告"""
   176→    from uuid import UUID
   177→
   178→    report_id = args.get("report_id")
   179→    report_type = args.get("report_type", "lite")
   180→    user_id = context.user_id
   181→    skill = context.skill_id or "bazi"
   182→
   183→    # 尝试获取已有报告
   184→    if report_id:
   185→        try:
   186→            from stores import report_repo
   187→            report = await report_repo.get_report(report_id)
   188→            if report:
   189→                return _normalize_report(report.to_dict())
   190→        except Exception as e:
   191→            logger.error(f"Failed to get report {report_id}: {e}")
   192→
   193→    if user_id and user_id != "guest":
   194→        try:
   195→            from stores import report_repo
   196→            user_uuid = UUID(user_id) if isinstance(user_id, str) else user_id
   197→            reports = await report_repo.list_reports(user_uuid, skill=skill, limit=1)
   198→            if reports:
   199→                report = await report_repo.get_report(reports[0].id)
   200→                if report:
   201→                    return _normalize_report(report.to_dict())
   202→        except Exception as e:
   203→            logger.error(f"Failed to get user reports: {e}")
   204→
   205→    # 返回演示报告
   206→    return {
   207→        "status": "success",
   208→        "cardType": "report_card",
   209→        "id": "demo",
   210→        "title": f"{'星盘' if skill == 'zodiac' else '八字'}报告（演示）",
   211→        "createdAt": datetime.now().strftime("%Y-%m-%d"),
   212→        "prologue": "这是一个演示版报告卡片。完善个人信息后可生成真实报告。",
   213→        "isPaid": False,
   214→        "reportType": report_type,
   215→    }
   216→
   217→
   218→def _normalize_report(report: Dict[str, Any]) -> Dict[str, Any]:
   219→    """标准化报告字段名"""
   220→    return {
   221→        **report,
   222→        "status": "success",
   223→        "cardType": "report_card",
   224→        "createdAt": report.get("created_at") or report.get("createdAt"),
   225→        "isPaid": report.get("is_paid") if report.get("isPaid") is None else report.get("isPaid"),
   226→        "reportType": report.get("report_type") or report.get("reportType"),
   227→    }
   228→
   229→
   230→@tool_handler("show_relationship")
   231→async def execute_show_relationship(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   232→    """展示关系分析"""
   233→    partner_info = args.get("partner_info") or args.get("partnerInfo")
   234→    relationship_type = args.get("relationship_type") or args.get("relationshipType", "general")
   235→
   236→    # TODO: 接入真正的关系分析服务
   237→    return {
   238→        "status": "success",
   239→        "cardType": "relationship_card",
   240→        "score": 85,
   241→        "summary": "你们的关系有很好的互补性",
   242→        "strengths": ["沟通顺畅", "价值观相近"],
   243→        "challenges": ["需要更多耐心", "注意情绪表达"],
   244→        "advice": "多倾��对方的想法，用行动表达关心。",
   245→        "relationshipType": relationship_type,
   246→    }
   247→
   248→
   249→@tool_handler("recommend_skill")
   250→async def execute_recommend_skill(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   251→    """
   252→    推荐 Skill 给用户
   253→
   254→    当 LLM 判断用户可能对某个未订阅的 Skill 感兴趣时调用此工具。
   255→    前端收到此卡片后会显示推荐卡片，用户可以选择试用或了解更多。
   256→
   257→    Args:
   258→        skill_id: 推荐的 Skill ID
   259→        reason: 推荐原因（基于对话内容生成）
   260→        confidence: 推荐置信度 (high/medium/low)
   261→
   262→    Returns:
   263→        skill_recommendation 卡片数据
   264→    """
   265→    from .skill_loader import load_skill_metadata
   266→
   267→    skill_id = args.get("skill_id")
   268→    reason = args.get("reason", "")
   269→    confidence = args.get("confidence", "medium")
   270→
   271→    if not skill_id:
   272→        return {"status": "error", "error": "skill_id is required"}
   273→
   274→    # 加载 Skill 元数据
   275→    metadata = load_skill_metadata(skill_id)
   276→    if not metadata:
   277→        return {"status": "error", "error": f"Skill not found: {skill_id}"}
   278→
   279→    # 检查用户是否已订阅（如果已订阅则不推荐）
   280→    user_id = context.user_id
   281→    if user_id and user_id != "guest":
   282→        try:
   283→            from uuid import UUID
   284→            # v7.6: 使用 UnifiedProfileRepository
   285→            from stores.unified_profile_repo import UnifiedProfileRepository
   286→
   287→            user_uuid = UUID(user_id) if isinstance(user_id, str) else user_id
   288→            subscription = await UnifiedProfileRepository.get_skill_subscription(user_uuid, skill_id)
   289→
   290→            if subscription and subscription.status == "subscribed":
   291→                # 用户已订阅，不需要推荐
   292→                return {
   293→                    "status": "skip",
   294→                    "reason": "already_subscribed",
   295→                    "skill_id": skill_id,
   296→                }
   297→        except Exception as e:
   298→            logger.warning(f"Failed to check subscription for {skill_id}: {e}")
   299→
   300→    # 返回推荐卡片数据
   301→    return {
   302→        "status": "success",
   303→        "cardType": "skill_recommendation",
   304→        "skill_id": skill_id,
   305→        "skill": {
   306→            "id": metadata.id,
   307→            "name": metadata.name,
   308→            "description": metadata.description,
   309→            "icon": metadata.icon,
   310→            "color": metadata.color,
   311→            "tagline": metadata.showcase.tagline,
   312→            "trial_messages": metadata.pricing.trial_messages,
   313→        },
   314→        "reason": reason,
   315→        "confidence": confidence,
   316→    }
   317→
   318→
   319→# ============================================================================
   320→# 通用数据工具 - REFACTOR_PLAN.md Phase 1
   321→# ============================================================================
   322→
   323→@tool_handler("read_state")
   324→async def execute_read_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   325→    """
   326→    通用状态读取 - 自动使用当前 skill_id
   327→
   328→    按照 REFACTOR_PLAN.md 设计，所有 Skill 共享此工具。
   329→    LLM 不需要传 skill_id，从 context 自动获取。
   330→
   331→    Args:
   332→        sections: 可选，指定要读取的部分
   333→
   334→    示例：
   335→        read_state({})  # 读取全部
   336→        read_state({"sections": ["north_star", "goals"]})  # 只读取指定部分
   337→    """
   338→    from stores.unified_profile_repo import UnifiedProfileRepository
   339→    from uuid import UUID
   340→
   341→    skill_id = context.skill_id
   342→    if not skill_id:
   343→        return {
   344→            "status": "error",
   345→            "message": "No active skill"
   346→        }
   347→
   348→    sections = args.get("sections")
   349→
   350→    # 读取 skill 状态
   351→    user_uuid = UUID(context.user_id) if isinstance(context.user_id, str) else context.user_id
   352→    data = await UnifiedProfileRepository.get_skill_state(
   353→        user_uuid,
   354→        skill_id
   355→    )
   356→
   357→    if not data:
   358→        return {
   359→            "status": "empty",
   360→            "message": f"尚未建立 {skill_id} 数据",
   361→            "data": {}
   362→        }
   363→
   364→    # 过滤指定部分
   365→    if sections:
   366→        result = {k: v for k, v in data.items() if k in sections}
   367→    else:
   368→        result = data
   369→
   370→    return {
   371→        "status": "success",
   372→        "data": result,
   373→        "skill_id": skill_id
   374→    }
   375→
   376→
   377→@tool_handler("write_state")
   378→async def execute_write_state(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   379→    """
   380→    通用状态写入 - 自动使用当前 skill_id
   381→
   382→    支持深度合并，不会覆盖未指定的字段
   383→
   384→    Args:
   385→        section: 要写入的部分，如 "north_star" 或 "protocol"
   386→        data: 要写入的数据
   387→
   388→    示例:
   389→        write_state({
   390→            "section": "north_star",
   391→            "data": {"vision": "通过创作实现财务自由"}
   392→        })
   393→    """
   394→    from stores.unified_profile_repo import UnifiedProfileRepository
   395→    from uuid import UUID
   396→
   397→    skill_id = context.skill_id
   398→    if not skill_id:
   399→        return {
   400→            "status": "error",
   401→            "message": "No active skill"
   402→        }
   403→
   404→    section = args.get("section")
   405→    data = args.get("data")
   406→
   407→    if not section or not data:
   408→        return {
   409→            "status": "error",
   410→            "message": "Missing section or data"
   411→        }
   412→
   413→    # 写入状态
   414→    user_uuid = UUID(context.user_id) if isinstance(context.user_id, str) else context.user_id
   415→    await UnifiedProfileRepository.update_skill_state(
   416→        user_uuid,
   417→        skill_id,
   418→        section,
   419→        data
   420→    )
   421→
   422→    return {
   423→        "status": "success",
   424→        "message": f"已保存 {section}",
   425→        "skill_id": skill_id,
   426→        "section": section
   427→    }
   428→
   429→
   430→@tool_handler("append_to_list")
   431→async def execute_append_to_list(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   432→    """
   433→    向列表追加条目
   434→
   435→    用于日志、记录等场景。
   436→    自动添加 _created_at 时间戳。
   437→
   438→    Args:
   439→        path: 列表路径，如 "journal" 或 "progress.milestones"
   440→        entry: 要追加的条目
   441→        max_items: 列表最大长度（超出则删除最旧的），默认 100
   442→
   443→    示例:
   444→        append_to_list({
   445→            "path": "journal",
   446→            "entry": {"content": "今天完成了第一个目标"},
   447→            "max_items": 100
   448→        })
   449→    """
   450→    from stores.unified_profile_repo import UnifiedProfileRepository
   451→    from uuid import UUID
   452→
   453→    skill_id = context.skill_id
   454→    if not skill_id:
   455→        return {
   456→            "status": "error",
   457→            "message": "No active skill"
   458→        }
   459→
   460→    path = args.get("path")
   461→    entry = args.get("entry")
   462→    max_items = args.get("max_items", 100)
   463→
   464→    if not path or not entry:
   465→        return {
   466→            "status": "error",
   467→            "message": "Missing path or entry"
   468→        }
   469→
   470→    # 添加时间戳
   471→    if isinstance(entry, dict):
   472→        entry["_created_at"] = datetime.now(timezone.utc).isoformat()
   473→
   474→    # 追加到列表
   475→    user_uuid = UUID(context.user_id) if isinstance(context.user_id, str) else context.user_id
   476→    await UnifiedProfileRepository.append_to_skill_list(
   477→        user_uuid,
   478→        skill_id,
   479→        path,
   480→        entry,
   481→        max_items
   482→    )
   483→
   484→    return {
   485→        "status": "success",
   486→        "message": f"已添加到 {path}",
   487→        "skill_id": skill_id
   488→    }
   489→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
