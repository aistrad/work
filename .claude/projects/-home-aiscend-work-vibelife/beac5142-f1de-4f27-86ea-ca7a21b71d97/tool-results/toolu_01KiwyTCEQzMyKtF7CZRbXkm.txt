     1→"""
     2→Account Routes - 用户账户统一入口
     3→
     4→合并自:
     5→- routes/auth.py (认证)
     6→- routes/users.py (用户资料)
     7→- routes/identity.py (身份棱镜)
     8→- routes/guest.py (访客会话)
     9→
    10→端点:
    11→- /account/auth/* - 认证相关
    12→- /account/profile/* - 用户资料
    13→- /account/guest/* - 访客会话
    14→- /account/identity/* - 身份棱镜
    15→"""
    16→import os
    17→from typing import Optional, List
    18→from datetime import datetime, timezone
    19→from uuid import UUID
    20→
    21→from fastapi import APIRouter, HTTPException, status, Depends, Cookie, Response, Query
    22→from pydantic import BaseModel, EmailStr
    23→
    24→from services.identity import (
    25→    AuthService, SSOService, OAuthService, GuestSessionService,
    26→    WechatService, AccountDeletionService,
    27→    get_current_user, get_optional_user, CurrentUser
    28→)
    29→from stores import UserRepository, SkillRepository, SubscriptionRepository, UnifiedProfileRepository
    30→
    31→router = APIRouter(prefix="/account", tags=["Account"])
    32→
    33→
    34→# ═══════════════════════════════════════════════════════════════════════════
    35→# Request/Response Models
    36→# ═══════════════════════════════════════════════════════════════════════════
    37→
    38→# --- Auth Models ---
    39→
    40→class OnboardingData(BaseModel):
    41→    """Onboarding data to associate with registration"""
    42→    birth_datetime: Optional[datetime] = None
    43→    birth_location: Optional[str] = None
    44→    gender: Optional[str] = None
    45→    voice_mode: Optional[str] = "warm"
    46→    skill: Optional[str] = "bazi"
    47→    interview_responses: Optional[dict] = None
    48→    focus_areas: Optional[List[str]] = None
    49→
    50→
    51→class RefreshRequest(BaseModel):
    52→    refresh_token: str
    53→
    54→
    55→class TokenResponse(BaseModel):
    56→    access_token: str
    57→    refresh_token: str
    58→    token_type: str = "bearer"
    59→    expires_in: int
    60→    user: dict
    61→
    62→
    63→class GoogleAuthRequest(BaseModel):
    64→    id_token: str
    65→    onboarding: Optional[OnboardingData] = None
    66→
    67→
    68→class AppleAuthRequest(BaseModel):
    69→    id_token: str
    70→    user_name: Optional[str] = None
    71→    onboarding: Optional[OnboardingData] = None
    72→
    73→
    74→# --- WeChat OAuth Models ---
    75→
    76→class WechatQRCodeRequest(BaseModel):
    77→    redirect_uri: str
    78→
    79→
    80→class WechatQRCodeResponse(BaseModel):
    81→    scene_id: str
    82→    qrcode_url: str
    83→    expires_at: str
    84→
    85→
    86→class WechatCallbackRequest(BaseModel):
    87→    code: str
    88→    state: str
    89→    onboarding: Optional[OnboardingData] = None
    90→
    91→
    92→class WechatStatusResponse(BaseModel):
    93→    status: str  # pending | scanned | confirmed | expired
    94→    message: Optional[str] = None
    95→    access_token: Optional[str] = None
    96→    refresh_token: Optional[str] = None
    97→    token_type: Optional[str] = None
    98→    expires_in: Optional[int] = None
    99→    user: Optional[dict] = None
   100→
   101→
   102→# --- Account Deletion Models ---
   103→
   104→class DeletionStatusResponse(BaseModel):
   105→    status: str  # active | pending_deletion | deleted
   106→    deletion_requested_at: Optional[str] = None
   107→    deletion_scheduled_at: Optional[str] = None
   108→    grace_period_days: Optional[int] = None
   109→    can_cancel: bool = False
   110→    message: Optional[str] = None
   111→
   112→
   113→# --- Profile Models ---
   114→
   115→class ProfileUpdateRequest(BaseModel):
   116→    display_name: Optional[str] = None
   117→    avatar_url: Optional[str] = None
   118→    birth_datetime: Optional[datetime] = None
   119→    birth_location: Optional[str] = None
   120→    timezone: Optional[str] = None
   121→    language: Optional[str] = None
   122→
   123→
   124→class ProfileResponse(BaseModel):
   125→    user_id: str
   126→    vibe_id: str
   127→    display_name: Optional[str] = None
   128→    avatar_url: Optional[str] = None
   129→    birth_datetime: Optional[datetime] = None
   130→    birth_location: Optional[str] = None
   131→    timezone: str
   132→    language: str
   133→    created_at: datetime
   134→
   135→
   136→class UserResponse(BaseModel):
   137→    user_id: str
   138→    vibe_id: str
   139→    display_name: Optional[str] = None
   140→    avatar_url: Optional[str] = None
   141→    email: Optional[str] = None
   142→
   143→
   144→# --- Preferences Models ---
   145→
   146→class PreferencesResponse(BaseModel):
   147→    voice_mode: str = "warm"
   148→    language: str = "zh-CN"
   149→
   150→
   151→class PreferencesUpdateRequest(BaseModel):
   152→    voice_mode: Optional[str] = None
   153→    language: Optional[str] = None
   154→
   155→
   156→# --- Guest Models ---
   157→
   158→class GuestSessionResponse(BaseModel):
   159→    session_id: str
   160→    birth_datetime: Optional[datetime] = None
   161→    birth_location: Optional[str] = None
   162→    gender: Optional[str] = None
   163→    voice_mode: Optional[str] = None
   164→    skill: Optional[str] = None
   165→    interview_responses: Optional[dict] = None
   166→    focus_areas: Optional[list] = None
   167→    expires_at: datetime
   168→
   169→
   170→class GuestOnboardingRequest(BaseModel):
   171→    birth_datetime: Optional[datetime] = None
   172→    birth_location: Optional[str] = None
   173→    gender: Optional[str] = None
   174→    voice_mode: Optional[str] = None
   175→    skill: Optional[str] = None
   176→    interview_responses: Optional[dict] = None
   177→    focus_areas: Optional[List[str]] = None
   178→
   179→
   180→# --- Identity Prism Models ---
   181→
   182→class PrismLayer(BaseModel):
   183→    title: str
   184→    content: str
   185→    evidence: Optional[str] = None
   186→
   187→
   188→class DimensionScore(BaseModel):
   189→    name: str
   190→    score: int
   191→    source: str
   192→
   193→
   194→class Memory(BaseModel):
   195→    content: str
   196→    date: str
   197→
   198→
   199→class PrismResponse(BaseModel):
   200→    core: PrismLayer
   201→    inner: PrismLayer
   202→    outer: PrismLayer
   203→    progress: int
   204→    dimensions: list[DimensionScore]
   205→    memories: list[Memory]
   206→
   207→
   208→# ═══════════════════════════════════════════════════════════════════════════
   209→# Helper Functions
   210→# ═══════════════════════════════════════════════════════════════════════════
   211→
   212→def _build_onboarding_dict(onboarding: Optional[OnboardingData]) -> Optional[dict]:
   213→    """Convert OnboardingData to dict for service calls."""
   214→    if not onboarding:
   215→        return None
   216→    return {
   217→        "birth_datetime": onboarding.birth_datetime,
   218→        "birth_location": onboarding.birth_location,
   219→        "gender": onboarding.gender,
   220→        "voice_mode": onboarding.voice_mode,
   221→        "skill": onboarding.skill,
   222→        "interview_responses": onboarding.interview_responses,
   223→        "focus_areas": onboarding.focus_areas
   224→    }
   225→
   226→
   227→# ═══════════════════════════════════════════════════════════════════════════
   228→# Auth Endpoints
   229→# ═══════════════════════════════════════════════════════════════════════════
   230→
   231→@router.post("/auth/refresh", response_model=TokenResponse)
   232→async def refresh_token(request: RefreshRequest):
   233→    """Refresh access token"""
   234→    try:
   235→        result = await AuthService.refresh_token(request.refresh_token)
   236→        return TokenResponse(**result)
   237→    except ValueError as e:
   238→        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(e))
   239→
   240→
   241→@router.post("/auth/logout")
   242→async def logout(current_user: CurrentUser = Depends(get_current_user)):
   243→    """Logout user"""
   244→    return {"message": "Logged out successfully"}
   245→
   246→
   247→@router.get("/auth/me", response_model=UserResponse)
   248→async def get_me(current_user: CurrentUser = Depends(get_current_user)):
   249→    """Get current authenticated user"""
   250→    from stores.unified_profile_repo import UnifiedProfileRepository
   251→
   252→    # Get account info from unified_profiles (Week 3: migrate to unified_profiles)
   253→    account = await UnifiedProfileRepository.get_account_full(current_user.user_id)
   254→
   255→    # Get email from vibe_user_auth table
   256→    email = None
   257→    auth_record = await UserRepository.get_auth_by_user_id(current_user.user_id, "email")
   258→    if auth_record:
   259→        email = auth_record.get("auth_identifier")
   260→
   261→    return UserResponse(
   262→        user_id=str(current_user.user_id),
   263→        vibe_id=account.get("vibe_id") or current_user.vibe_id,
   264→        display_name=account.get("display_name") or current_user.display_name,
   265→        avatar_url=account.get("avatar_url"),
   266→        email=email
   267→    )
   268→
   269→
   270→# --- OAuth ---
   271→
   272→@router.post("/auth/oauth/google", response_model=TokenResponse)
   273→async def google_auth(request: GoogleAuthRequest):
   274→    """Login or register with Google OAuth"""
   275→    try:
   276→        result = await OAuthService.google_login(
   277→            id_token=request.id_token,
   278→            onboarding_data=_build_onboarding_dict(request.onboarding)
   279→        )
   280→        return TokenResponse(**result)
   281→    except ValueError as e:
   282→        error_msg = str(e)
   283→        if "already registered" in error_msg:
   284→            raise HTTPException(
   285→                status_code=status.HTTP_409_CONFLICT,
   286→                detail=error_msg
   287→            )
   288→        raise HTTPException(
   289→            status_code=status.HTTP_401_UNAUTHORIZED,
   290→            detail=error_msg or "Google authentication failed"
   291→        )
   292→
   293→
   294→@router.post("/auth/oauth/apple", response_model=TokenResponse)
   295→async def apple_auth(request: AppleAuthRequest):
   296→    """Login or register with Apple OAuth"""
   297→    try:
   298→        result = await OAuthService.apple_login(
   299→            id_token=request.id_token,
   300→            user_name=request.user_name,
   301→            onboarding_data=_build_onboarding_dict(request.onboarding)
   302→        )
   303→        return TokenResponse(**result)
   304→    except ValueError as e:
   305→        error_msg = str(e)
   306→        if "already registered" in error_msg:
   307→            raise HTTPException(
   308→                status_code=status.HTTP_409_CONFLICT,
   309→                detail=error_msg
   310→            )
   311→        raise HTTPException(
   312→            status_code=status.HTTP_401_UNAUTHORIZED,
   313→            detail=error_msg or "Apple authentication failed"
   314→        )
   315→
   316→
   317→# --- WeChat OAuth ---
   318→
   319→@router.post("/auth/oauth/wechat/qrcode", response_model=WechatQRCodeResponse)
   320→async def get_wechat_qrcode(request: WechatQRCodeRequest):
   321→    """Generate a WeChat QR code for login"""
   322→    try:
   323→        result = await WechatService.generate_qrcode(redirect_uri=request.redirect_uri)
   324→        return WechatQRCodeResponse(**result)
   325→    except ValueError as e:
   326→        raise HTTPException(
   327→            status_code=status.HTTP_400_BAD_REQUEST,
   328→            detail=str(e)
   329→        )
   330→
   331→
   332→@router.get("/auth/oauth/wechat/status/{scene_id}", response_model=WechatStatusResponse)
   333→async def poll_wechat_status(scene_id: str):
   334→    """Poll the status of a WeChat QR code login session"""
   335→    result = await WechatService.poll_status(scene_id)
   336→
   337→    response = WechatStatusResponse(
   338→        status=result["status"],
   339→        message=result.get("message")
   340→    )
   341→
   342→    # If confirmed, include tokens and user info
   343→    if result["status"] == "confirmed" and result.get("tokens"):
   344→        response.access_token = result["tokens"].get("access_token")
   345→        response.refresh_token = result["tokens"].get("refresh_token")
   346→        response.token_type = result["tokens"].get("token_type")
   347→        response.expires_in = result["tokens"].get("expires_in")
   348→        response.user = result.get("user")
   349→
   350→    return response
   351→
   352→
   353→@router.post("/auth/oauth/wechat/callback", response_model=TokenResponse)
   354→async def wechat_callback(request: WechatCallbackRequest):
   355→    """Handle WeChat OAuth callback after user authorizes"""
   356→    result = await WechatService.handle_callback(
   357→        code=request.code,
   358→        state=request.state,
   359→        onboarding_data=_build_onboarding_dict(request.onboarding)
   360→    )
   361→
   362→    if not result:
   363→        raise HTTPException(
   364→            status_code=status.HTTP_401_UNAUTHORIZED,
   365→            detail="WeChat authentication failed"
   366→        )
   367→
   368→    return TokenResponse(**result)
   369→
   370→
   371→# --- Dev Login (Development Only) ---
   372→
   373→class DevLoginRequest(BaseModel):
   374→    """Dev login request - only works in development mode"""
   375→    email: Optional[str] = None
   376→    vibe_id: Optional[str] = None
   377→
   378→
   379→@router.post("/auth/dev-login", response_model=TokenResponse)
   380→async def dev_login(request: DevLoginRequest):
   381→    """
   382→    Development-only login endpoint.
   383→    Allows login by email or vibe_id without OAuth.
   384→    Only available when VIBELIFE_ENV != 'production'.
   385→    """
   386→    import logging
   387→    logger = logging.getLogger(__name__)
   388→    logger.info(f"Dev login request: email={request.email}, vibe_id={request.vibe_id}")
   389→
   390→    # Security check: only allow in development
   391→    env = os.getenv("VIBELIFE_ENV", "development")
   392→    if env == "production":
   393→        raise HTTPException(
   394→            status_code=status.HTTP_403_FORBIDDEN,
   395→            detail="Dev login is not available in production"
   396→        )
   397→
   398→    # Find user by email or vibe_id
   399→    user = None
   400→    if request.email:
   401→        # Use auth table to find user by email (returns joined user data)
   402→        logger.info(f"Looking up user by email: {request.email}")
   403→        auth = await UserRepository.get_auth_by_identifier("email", request.email)
   404→        logger.info(f"Auth result: {auth}")
   405→        if auth:
   406→            # auth already contains user data from JOIN query
   407→            user = {
   408→                "id": auth["user_id"],
   409→                "vibe_id": auth["vibe_id"],
   410→                "display_name": auth.get("display_name"),
   411→                "avatar_url": auth.get("avatar_url"),
   412→            }
   413→    elif request.vibe_id:
   414→        user = await UserRepository.get_by_vibe_id(request.vibe_id)
   415→    else:
   416→        raise HTTPException(
   417→            status_code=status.HTTP_400_BAD_REQUEST,
   418→            detail="Either email or vibe_id is required"
   419→        )
   420→
   421→    if not user:
   422→        raise HTTPException(
   423→            status_code=status.HTTP_404_NOT_FOUND,
   424→            detail="User not found"
   425→        )
   426→
   427→    # Generate tokens
   428→    from services.identity import JWTService
   429→
   430→    access_token = JWTService.create_access_token(
   431→        user_id=str(user["id"]),
   432→        vibe_id=user["vibe_id"]
   433→    )
   434→    refresh_token = JWTService.create_refresh_token(
   435→        user_id=str(user["id"]),
   436→        vibe_id=user["vibe_id"]
   437→    )
   438→
   439→    return TokenResponse(
   440→        access_token=access_token,
   441→        refresh_token=refresh_token,
   442→        token_type="bearer",
   443→        expires_in=JWTService.get_token_expiry(),
   444→        user={
   445→            "user_id": str(user["id"]),
   446→            "vibe_id": user["vibe_id"],
   447→            "display_name": user.get("display_name"),
   448→            "avatar_url": user.get("avatar_url")
   449→        }
   450→    )
   451→
   452→
   453→# ═══════════════════════════════════════════════════════════════════════════
   454→# Profile Endpoints
   455→# ═══════════════════════════════════════════════════════════════════════════
   456→
   457→@router.get("/profile", response_model=ProfileResponse)
   458→async def get_profile(current_user: CurrentUser = Depends(get_current_user)):
   459→    """Get current user's full profile"""
   460→    from stores.unified_profile_repo import UnifiedProfileRepository
   461→
   462→    # Week 3: Read from unified_profiles instead of vibe_users
   463→    account = await UnifiedProfileRepository.get_account_full(current_user.user_id)
   464→    birth_info = await UnifiedProfileRepository.get_birth_info(current_user.user_id)
   465→
   466→    # Construct birth_datetime from birth_info
   467→    birth_datetime = None
   468→    if birth_info and birth_info.get("date"):
   469→        time_str = birth_info.get("time", "12:00:00")
   470→        birth_datetime_str = f"{birth_info['date']} {time_str}"
   471→        try:
   472→            from datetime import datetime
   473→            birth_datetime = datetime.fromisoformat(birth_datetime_str)
   474→        except:
   475→            pass
   476→
   477→    # created_at still from vibe_users (account-level immutable field)
   478→    user = await UserRepository.get_by_id(current_user.user_id)
   479→    if not user:
   480→        raise HTTPException(status_code=404, detail="User not found")
   481→
   482→    return ProfileResponse(
   483→        user_id=str(current_user.user_id),
   484→        vibe_id=account.get("vibe_id") or current_user.vibe_id,
   485→        display_name=account.get("display_name"),
   486→        avatar_url=account.get("avatar_url"),
   487→        birth_datetime=birth_datetime,
   488→        birth_location=birth_info.get("place") if birth_info else None,
   489→        timezone=account.get("timezone", "Asia/Shanghai"),
   490→        language=account.get("language", "zh-CN"),
   491→        created_at=user["created_at"]
   492→    )
   493→
   494→
   495→@router.put("/profile", response_model=ProfileResponse)
   496→async def update_profile(
   497→    request: ProfileUpdateRequest,
   498→    current_user: CurrentUser = Depends(get_current_user)
   499→):
   500→    """Update current user's profile"""
   501→    from stores.unified_profile_repo import UnifiedProfileRepository
   502→
   503→    update_data = request.model_dump(exclude_unset=True)
   504→
   505→    # Week 3: Split updates by data type
   506→    # 1. Account info (display_name, avatar_url)
   507→    if "display_name" in update_data or "avatar_url" in update_data:
   508→        await UnifiedProfileRepository.update_account_info(
   509→            current_user.user_id,
   510→            display_name=update_data.get("display_name"),
   511→            avatar_url=update_data.get("avatar_url")
   512→        )
   513→
   514→    # 2. Birth info (birth_datetime, birth_location + gender if provided)
   515→    if "birth_datetime" in update_data or "birth_location" in update_data:
   516→        birth_info = {}
   517→        if "birth_datetime" in update_data:
   518→            dt = update_data["birth_datetime"]
   519→            if dt:
   520→                birth_info["date"] = dt.date().isoformat()
   521→                birth_info["time"] = dt.time().isoformat()
   522→            else:
   523→                birth_info["date"] = None
   524→                birth_info["time"] = None
   525→
   526→        if "birth_location" in update_data:
   527→            birth_info["place"] = update_data["birth_location"]
   528→
   529→        if birth_info:
   530→            await UnifiedProfileRepository.update_birth_info(
   531→                current_user.user_id,
   532→                birth_info
   533→            )
   534→
   535→    # 3. Preferences (timezone, language)
   536→    if "timezone" in update_data or "language" in update_data:
   537→        prefs_update = {}
   538→        if "timezone" in update_data:
   539→            prefs_update["timezone"] = update_data["timezone"]
   540→        if "language" in update_data:
   541→            prefs_update["language"] = update_data["language"]
   542→
   543→        await UnifiedProfileRepository.update_preferences(
   544→            current_user.user_id,
   545→            prefs_update
   546→        )
   547→
   548→    # Return updated profile
   549→    return await get_profile(current_user)
   550→
   551→
   552→# --- Preferences Endpoints ---
   553→
   554→@router.get("/preferences", response_model=PreferencesResponse)
   555→async def get_preferences(current_user: CurrentUser = Depends(get_current_user)):
   556→    """Get current user's preferences (voice_mode, language, etc.)"""
   557→    preferences = await UnifiedProfileRepository.get_preferences(current_user.user_id)
   558→    return PreferencesResponse(
   559→        voice_mode=preferences.get("voice_mode", "warm"),
   560→        language=preferences.get("language", "zh-CN")
   561→    )
   562→
   563→
   564→@router.put("/preferences", response_model=PreferencesResponse)
   565→async def update_preferences(
   566→    request: PreferencesUpdateRequest,
   567→    current_user: CurrentUser = Depends(get_current_user)
   568→):
   569→    """Update current user's preferences"""
   570→    update_data = request.model_dump(exclude_unset=True)
   571→
   572→    if update_data:
   573→        await UnifiedProfileRepository.update_preferences(current_user.user_id, update_data)
   574→
   575→    # Return updated preferences
   576→    preferences = await UnifiedProfileRepository.get_preferences(current_user.user_id)
   577→    return PreferencesResponse(
   578→        voice_mode=preferences.get("voice_mode", "warm"),
   579→        language=preferences.get("language", "zh-CN")
   580→    )
   581→
   582→
   583→@router.get("/profile/export")
   584→async def export_data(current_user: CurrentUser = Depends(get_current_user)):
   585→    """Export all user data (GDPR compliance)"""
   586→    user = await UserRepository.get_by_id(current_user.user_id)
   587→    profiles = await SkillRepository.get_user_profiles(current_user.user_id)
   588→    consents = await UserRepository.get_consents(current_user.user_id)
   589→    subscription = await SubscriptionRepository.get_user_subscription(current_user.user_id)
   590→
   591→    return {
   592→        "user": {
   593→            "vibe_id": user["vibe_id"],
   594→            "display_name": user.get("display_name"),
   595→            "birth_datetime": str(user.get("birth_datetime")) if user.get("birth_datetime") else None,
   596→            "birth_location": user.get("birth_location"),
   597→            "timezone": user.get("timezone"),
   598→            "language": user.get("language"),
   599→            "created_at": str(user["created_at"])
   600→        },
   601→        "skill_profiles": [
   602→            {
   603→                "skill_id": p["skill_id"],
   604→                "profile_data": p["profile_data"],
   605→                "total_sessions": p["total_sessions"]
   606→            }
   607→            for p in profiles
   608→        ],
   609→        "consents": [
   610→            {
   611→                "source_skill": c["source_skill"],
   612→                "target_skill": c["target_skill"],
   613→                "data_type": c["data_type"],
   614→                "consent_granted": c["consent_granted"]
   615→            }
   616→            for c in consents
   617→        ],
   618→        "subscription": {
   619→            "plan_id": subscription["plan_id"] if subscription else "free",
   620→            "status": subscription["status"] if subscription else "none"
   621→        } if subscription else None,
   622→        "export_date": str(datetime.now(timezone.utc))
   623→    }
   624→
   625→
   626→# ═══════════════════════════════════════════════════════════════════════════
   627→# Account Deletion Endpoints
   628→# ═══════════════════════════════════════════════════════════════════════════
   629→
   630→@router.post("/auth/delete-account", response_model=DeletionStatusResponse)
   631→async def request_account_deletion(current_user: CurrentUser = Depends(get_current_user)):
   632→    """
   633→    Request account deletion.
   634→
   635→    Initiates a 30-day grace period before permanent deletion.
   636→    User can cancel during this period.
   637→    """
   638→    try:
   639→        result = await AccountDeletionService.request_deletion(current_user.user_id)
   640→        return DeletionStatusResponse(**result)
   641→    except ValueError as e:
   642→        raise HTTPException(
   643→            status_code=status.HTTP_400_BAD_REQUEST,
   644→            detail=str(e)
   645→        )
   646→
   647→
   648→@router.post("/auth/cancel-deletion", response_model=DeletionStatusResponse)
   649→async def cancel_account_deletion(current_user: CurrentUser = Depends(get_current_user)):
   650→    """
   651→    Cancel a pending account deletion request.
   652→
   653→    Only works during the 30-day grace period.
   654→    """
   655→    try:
   656→        result = await AccountDeletionService.cancel_deletion(current_user.user_id)
   657→        return DeletionStatusResponse(**result)
   658→    except ValueError as e:
   659→        raise HTTPException(
   660→            status_code=status.HTTP_400_BAD_REQUEST,
   661→            detail=str(e)
   662→        )
   663→
   664→
   665→@router.get("/auth/deletion-status", response_model=DeletionStatusResponse)
   666→async def get_deletion_status(current_user: CurrentUser = Depends(get_current_user)):
   667→    """
   668→    Get current account deletion status.
   669→
   670→    Returns whether deletion is pending and when it's scheduled.
   671→    """
   672→    try:
   673→        result = await AccountDeletionService.get_deletion_status(current_user.user_id)
   674→        return DeletionStatusResponse(**result)
   675→    except ValueError as e:
   676→        raise HTTPException(
   677→            status_code=status.HTTP_404_NOT_FOUND,
   678→            detail=str(e)
   679→        )
   680→
   681→
   682→# ═══════════════════════════════════════════════════════════════════════════
   683→# Guest Session Endpoints
   684→# ═══════════════════════════════════════════════════════════════════════════
   685→
   686→@router.post("/guest/session", response_model=GuestSessionResponse)
   687→async def create_guest_session(response: Response):
   688→    """Create a new guest session"""
   689→    session = await GuestSessionService.create_session()
   690→
   691→    response.set_cookie(
   692→        key="guest_session_id",
   693→        value=session["session_id"],
   694→        max_age=30 * 24 * 60 * 60,
   695→        httponly=True,
   696→        samesite="lax",
   697→        secure=True
   698→    )
   699→
   700→    return GuestSessionResponse(
   701→        session_id=session["session_id"],
   702→        expires_at=session["expires_at"]
   703→    )
   704→
   705→
   706→@router.get("/guest/session", response_model=GuestSessionResponse)
   707→async def get_guest_session(guest_session_id: Optional[str] = Cookie(None)):
   708→    """Get current guest session"""
   709→    if not guest_session_id:
   710→        raise HTTPException(status_code=404, detail="No guest session found")
   711→
   712→    session = await GuestSessionService.get_session(guest_session_id)
   713→    if not session:
   714→        raise HTTPException(status_code=404, detail="Guest session not found or expired")
   715→
   716→    return GuestSessionResponse(
   717→        session_id=session["session_id"],
   718→        birth_datetime=session.get("birth_datetime"),
   719→        birth_location=session.get("birth_location"),
   720→        gender=session.get("gender"),
   721→        voice_mode=session.get("voice_mode"),
   722→        skill=session.get("skill"),
   723→        interview_responses=session.get("interview_responses"),
   724→        focus_areas=session.get("focus_areas"),
   725→        expires_at=session["expires_at"]
   726→    )
   727→
   728→
   729→@router.put("/guest/session/onboarding", response_model=GuestSessionResponse)
   730→async def save_guest_onboarding(
   731→    data: GuestOnboardingRequest,
   732→    guest_session_id: Optional[str] = Cookie(None)
   733→):
   734→    """Save onboarding data to guest session"""
   735→    if not guest_session_id:
   736→        raise HTTPException(status_code=404, detail="No guest session found")
   737→
   738→    session = await GuestSessionService.save_onboarding_data(
   739→        session_id=guest_session_id,
   740→        birth_datetime=data.birth_datetime,
   741→        birth_location=data.birth_location,
   742→        gender=data.gender,
   743→        voice_mode=data.voice_mode,
   744→        skill=data.skill,
   745→        interview_responses=data.interview_responses,
   746→        focus_areas=data.focus_areas
   747→    )
   748→
   749→    if not session:
   750→        raise HTTPException(status_code=404, detail="Guest session not found or expired")
   751→
   752→    return GuestSessionResponse(
   753→        session_id=session["session_id"],
   754→        birth_datetime=session.get("birth_datetime"),
   755→        birth_location=session.get("birth_location"),
   756→        gender=session.get("gender"),
   757→        voice_mode=session.get("voice_mode"),
   758→        skill=session.get("skill"),
   759→        interview_responses=session.get("interview_responses"),
   760→        focus_areas=session.get("focus_areas"),
   761→        expires_at=session["expires_at"]
   762→    )
   763→
   764→
   765→@router.delete("/guest/session")
   766→async def delete_guest_session(
   767→    response: Response,
   768→    guest_session_id: Optional[str] = Cookie(None)
   769→):
   770→    """Delete guest session"""
   771→    response.delete_cookie(key="guest_session_id")
   772→    return {"message": "Guest session cleared"}
   773→
   774→
   775→# ═══════════════════════════════════════════════════════════════════════════
   776→# Identity Prism Endpoints
   777→# ═══════════════════════════════════════════════════════════════════════════
   778→
   779→@router.get("/identity/prism", response_model=PrismResponse)
   780→async def get_prism(
   781→    user_id: Optional[UUID] = Query(None),
   782→    current_user: Optional[CurrentUser] = Depends(get_optional_user)
   783→):
   784→    """Get user's Identity Prism data"""
   785→    import logging
   786→    logger = logging.getLogger(__name__)
   787→
   788→    target_user_id = user_id or (current_user.user_id if current_user else None)
   789→
   790→    # Default prism for guests
   791→    default_prism = PrismResponse(
   792→        core=PrismLayer(
   793→            title="核心驱动力",
   794→            content="追求稳定与安全感，同时渴望被理解和认可",
   795→            evidence="八字·星座"
   796→        ),
   797→        inner=PrismLayer(
   798→            title="内在渴望",
   799→            content="希望在事业上有所成就，同时保持内心的平静",
   800→            evidence="对话记录"
   801→        ),
   802→        outer=PrismLayer(
   803→            title="外在表现",
   804→            content="给人稳重可靠的印象，善于倾听和沟通",
   805→            evidence="八字·星座"
   806→        ),
   807→        progress=35,
   808→        dimensions=[
   809→            DimensionScore(name="八字命理", score=50, source="bazi"),
   810→            DimensionScore(name="星座能量", score=40, source="zodiac"),
   811→            DimensionScore(name="对话洞察", score=20, source="chat"),
   812→            DimensionScore(name="行为模式", score=10, source="behavior"),
   813→        ],
   814→        memories=[Memory(content="欢迎来到 VibeLife", date="刚刚")]
   815→    )
   816→
   817→    if not target_user_id:
   818→        return default_prism
   819→
   820→    try:
   821→        profiles = await SkillRepository.get_user_profiles(target_user_id)
   822→
   823→        bazi_score = 0
   824→        zodiac_score = 0
   825→        chat_score = 0
   826→
   827→        for profile in profiles:
   828→            skill = profile.get("skill_id", "")
   829→            sessions = profile.get("total_sessions", 0)
   830→            if skill == "bazi":
   831→                bazi_score = min(100, sessions * 20 + 50)
   832→            elif skill == "zodiac":
   833→                zodiac_score = min(100, sessions * 20 + 40)
   834→            elif skill == "chat":
   835→                chat_score = min(100, sessions * 5 + 10)
   836→
   837→        progress = int((bazi_score + zodiac_score + chat_score) / 4)
   838→
   839→        insights = await SkillRepository.get_user_insights(user_id=target_user_id, limit=5)
   840→
   841→        memories = [
   842→            Memory(
   843→                content=i.get("content", "")[:50] if i.get("content") else "新的洞察",
   844→                date=str(i.get("created_at", ""))[:10] if i.get("created_at") else "最近"
   845→            )
   846→            for i in insights
   847→        ] if insights else [Memory(content="继续探索，让我更了解你", date="刚刚")]
   848→
   849→        return PrismResponse(
   850→            core=PrismLayer(
   851→                title="核心驱动力",
   852→                content="追求稳定与安全感，同时渴望被理解和认可",
   853→                evidence="八字·星座"
   854→            ),
   855→            inner=PrismLayer(
   856→                title="内在渴望",
   857→                content="希望在事业上有所成就，同时保持内心的平静",
   858→                evidence="对话记录"
   859→            ),
   860→            outer=PrismLayer(
   861→                title="外在表现",
   862→                content="给人稳重可靠的印象，善于倾听和沟通",
   863→                evidence="八字·星座"
   864→            ),
   865→            progress=max(35, progress),
   866→            dimensions=[
   867→                DimensionScore(name="八字命理", score=max(50, bazi_score), source="bazi"),
   868→                DimensionScore(name="星座能量", score=max(40, zodiac_score), source="zodiac"),
   869→                DimensionScore(name="对话洞察", score=max(20, chat_score), source="chat"),
   870→                DimensionScore(name="行为模式", score=10, source="behavior"),
   871→            ],
   872→            memories=memories
   873→        )
   874→
   875→    except Exception as e:
   876→        logger.warning(f"Failed to get prism data: {e}")
   877→        return default_prism
   878→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
