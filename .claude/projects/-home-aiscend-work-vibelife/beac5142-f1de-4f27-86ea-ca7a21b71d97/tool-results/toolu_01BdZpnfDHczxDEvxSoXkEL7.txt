     1→/**
     2→ * Authentication Provider - v8.0 OAuth Only
     3→ * Based on: vibelife spec v3.0
     4→ *
     5→ * v8.0 Changes:
     6→ * - Removed password authentication methods
     7→ * - OAuth-only authentication (Google, Apple, WeChat)
     8→ * - Multi-tab sync support
     9→ * - JWT + localStorage based
    10→ */
    11→"use client";
    12→
    13→import React, {
    14→  createContext,
    15→  useContext,
    16→  useState,
    17→  useEffect,
    18→  useCallback,
    19→  useMemo,
    20→} from "react";
    21→import { useRouter } from "next/navigation";
    22→import {
    23→  getTokens,
    24→  clearTokens,
    25→  getMe,
    26→  logout as apiLogout,
    27→} from "@/lib/api";
    28→import {
    29→  getLocalStorageJSON,
    30→  setLocalStorageJSON,
    31→  invalidateStorageCache,
    32→} from "@/utils/storage";
    33→
    34→// ─────────────────────────────────────────────────────────────────
    35→// Types
    36→// ─────────────────────────────────────────────────────────────────
    37→
    38→export interface User {
    39→  user_id: string;
    40→  vibe_id: string;
    41→  display_name?: string;
    42→  email?: string;
    43→  phone?: string;
    44→}
    45→
    46→interface AuthState {
    47→  user: User | null;
    48→  isAuthenticated: boolean;
    49→  isLoading: boolean;
    50→}
    51→
    52→interface AuthActions {
    53→  logout: () => Promise<void>;
    54→  refreshUser: () => Promise<void>;
    55→}
    56→
    57→type AuthContextType = AuthState & AuthActions;
    58→
    59→// ─────────────────────────────────────────────────────────────────
    60→// Context
    61→// ─────────────────────────────────────────────────────────────────
    62→
    63→const AuthContext = createContext<AuthContextType | null>(null);
    64→
    65→// ─────────────────────────────────────────────────────────────────
    66→// Provider
    67→// ─────────────────────────────────────────────────────────────────
    68→
    69→interface AuthProviderProps {
    70→  children: React.ReactNode;
    71→}
    72→
    73→export function AuthProvider({ children }: AuthProviderProps) {
    74→  const router = useRouter();
    75→  const [state, setState] = useState<AuthState>({
    76→    user: null,
    77→    isAuthenticated: false,
    78→    isLoading: true,
    79→  });
    80→
    81→  // Initialize auth state from localStorage
    82→  const initAuth = useCallback(async () => {
    83→    const { accessToken } = getTokens();
    84→
    85→    if (!accessToken) {
    86→      setState({ user: null, isAuthenticated: false, isLoading: false });
    87→      return;
    88→    }
    89→
    90→    try {
    91→      // Use cached localStorage read for faster perceived load
    92→      const cachedUser = getLocalStorageJSON<User | null>("user", null);
    93→      if (cachedUser) {
    94→        // Show cached user immediately
    95→        setState({ user: cachedUser, isAuthenticated: true, isLoading: false });
    96→      }
    97→
    98→      // Then verify with backend (in background)
    99→      const userData = await getMe();
   100→      const user: User = {
   101→        user_id: userData.user_id,
   102→        vibe_id: userData.vibe_id,
   103→        display_name: userData.display_name,
   104→        email: userData.email,
   105→        phone: userData.phone,
   106→      };
   107→
   108→      // Update localStorage and state
   109→      setLocalStorageJSON("user", user);
   110→      setState({ user, isAuthenticated: true, isLoading: false });
   111→    } catch {
   112→      // Token invalid, clear everything
   113→      clearTokens();
   114→      invalidateStorageCache("user");
   115→      setState({ user: null, isAuthenticated: false, isLoading: false });
   116→    }
   117→  }, []);
   118→
   119→  // Initialize on mount
   120→  useEffect(() => {
   121→    initAuth();
   122→  }, [initAuth]);
   123→
   124→  // Listen for storage events (multi-tab sync)
   125→  useEffect(() => {
   126→    const handleStorageChange = (e: StorageEvent) => {
   127→      if (e.key === "access_token") {
   128→        if (!e.newValue) {
   129→          // Token was removed (logout in another tab)
   130→          setState({ user: null, isAuthenticated: false, isLoading: false });
   131→        } else if (e.newValue && !e.oldValue) {
   132→          // Token was added (login in another tab)
   133→          initAuth();
   134→        }
   135→      }
   136→
   137→      if (e.key === "user") {
   138→        if (e.newValue) {
   139→          try {
   140→            const user = JSON.parse(e.newValue) as User;
   141→            setState((prev) => ({ ...prev, user, isAuthenticated: true }));
   142→          } catch {
   143→            // Invalid JSON, ignore
   144→          }
   145→        }
   146→      }
   147→    };
   148→
   149→    window.addEventListener("storage", handleStorageChange);
   150→    return () => window.removeEventListener("storage", handleStorageChange);
   151→  }, [initAuth]);
   152→
   153→  // [P3] Listen for session expired events and redirect to login
   154→  useEffect(() => {
   155→    const handleSessionExpired = () => {
   156→      invalidateStorageCache("user");
   157→      setState({ user: null, isAuthenticated: false, isLoading: false });
   158→      router.push("/auth/login");
   159→    };
   160→
   161→    window.addEventListener("auth:session-expired", handleSessionExpired);
   162→    return () => window.removeEventListener("auth:session-expired", handleSessionExpired);
   163→  }, [router]);
   164→
   165→  // ─────────────────────────────────────────────────────────────────
   166→  // Actions
   167→  // ─────────────────────────────────────────────────────────────────
   168→
   169→  const logout = useCallback(async () => {
   170→    setState((prev) => ({ ...prev, isLoading: true }));
   171→
   172→    try {
   173→      await apiLogout();
   174→    } finally {
   175→      setState({ user: null, isAuthenticated: false, isLoading: false });
   176→    }
   177→  }, []);
   178→
   179→  const refreshUser = useCallback(async () => {
   180→    try {
   181→      const userData = await getMe();
   182→      const user: User = {
   183→        user_id: userData.user_id,
   184→        vibe_id: userData.vibe_id,
   185→        display_name: userData.display_name,
   186→        email: userData.email,
   187→        phone: userData.phone,
   188→      };
   189→
   190→      setLocalStorageJSON("user", user);
   191→      setState((prev) => ({ ...prev, user }));
   192→    } catch {
   193→      // Silently fail - user data refresh is not critical
   194→    }
   195→  }, []);
   196→
   197→  // ─────────────────────────────────────────────────────────────────
   198→  // Memoized value
   199→  // ─────────────────────────────────────────────────────────────────
   200→
   201→  const value = useMemo<AuthContextType>(
   202→    () => ({
   203→      ...state,
   204→      logout,
   205→      refreshUser,
   206→    }),
   207→    [state, logout, refreshUser]
   208→  );
   209→
   210→  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
   211→}
   212→
   213→// ─────────────────────────────────────────────────────────────────
   214→// Hooks
   215→// ─────────────────────────────────────────────────────────────────
   216→
   217→export function useAuth() {
   218→  const context = useContext(AuthContext);
   219→
   220→  if (!context) {
   221→    throw new Error("useAuth must be used within an AuthProvider");
   222→  }
   223→
   224→  return {
   225→    isSignedIn: context.isAuthenticated,
   226→    isLoaded: !context.isLoading,
   227→    userId: context.user?.user_id ?? null,
   228→    user: context.user,
   229→    logout: context.logout,
   230→    refreshUser: context.refreshUser,
   231→  };
   232→}
   233→
   234→export function useUser() {
   235→  const context = useContext(AuthContext);
   236→
   237→  if (!context) {
   238→    throw new Error("useUser must be used within an AuthProvider");
   239→  }
   240→
   241→  return {
   242→    user: context.user,
   243→    isLoaded: !context.isLoading,
   244→  };
   245→}
   246→
   247→// Clerk compatibility shims
   248→export function useClerk() {
   249→  const { logout } = useAuth();
   250→  return {
   251→    signOut: logout,
   252→  };
   253→}
   254→
   255→// Placeholder components for Clerk compatibility
   256→export function SignIn() {
   257→  return null;
   258→}
   259→
   260→export function SignUp() {
   261→  return null;
   262→}
   263→
   264→export function UserButton() {
   265→  return null;
   266→}
   267→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
