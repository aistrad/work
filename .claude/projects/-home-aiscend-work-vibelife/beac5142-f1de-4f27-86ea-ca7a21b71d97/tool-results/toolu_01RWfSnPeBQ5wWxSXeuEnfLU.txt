     1→/**
     2→ * VibeLife API Client
     3→ * All API calls go through Next.js API routes to avoid exposing backend URLs
     4→ */
     5→
     6→const API_BASE = "/api";
     7→
     8→// ─────────────────────────────────────────────────────────────────
     9→// Types
    10→// ─────────────────────────────────────────────────────────────────
    11→
    12→export interface TokenResponse {
    13→  access_token: string;
    14→  refresh_token: string;
    15→  token_type: string;
    16→  expires_in: number;
    17→  user: {
    18→    user_id: string;
    19→    vibe_id: string;
    20→    display_name?: string;
    21→  };
    22→}
    23→
    24→export interface ChatRequest {
    25→  message: string;
    26→  skill: string;           // Changed from skill_id to match backend
    27→  conversation_id?: string;
    28→  voice_mode?: string;     // Added voice mode support
    29→}
    30→
    31→export interface ChatResponse {
    32→  content: string;
    33→  conversation_id: string;
    34→  intent?: string;
    35→  tools_used?: string[];
    36→  knowledge_used: boolean;
    37→  insight?: {
    38→    id: string;
    39→    insight_type: string;
    40→    title: string;
    41→    content: string;
    42→  };
    43→  suggestions?: string[];
    44→}
    45→
    46→// ─────────────────────────────────────────────────────────────────
    47→// Token Management
    48→// ─────────────────────────────────────────────────────────────────
    49→
    50→let accessToken: string | null = null;
    51→let refreshToken: string | null = null;
    52→
    53→export function setTokens(access: string, refresh: string) {
    54→  accessToken = access;
    55→  refreshToken = refresh;
    56→  if (typeof window !== "undefined") {
    57→    localStorage.setItem("access_token", access);
    58→    localStorage.setItem("refresh_token", refresh);
    59→  }
    60→}
    61→
    62→export function getTokens() {
    63→  if (typeof window !== "undefined") {
    64→    accessToken = localStorage.getItem("access_token");
    65→    refreshToken = localStorage.getItem("refresh_token");
    66→  }
    67→  return { accessToken, refreshToken };
    68→}
    69→
    70→export function clearTokens() {
    71→  accessToken = null;
    72→  refreshToken = null;
    73→  if (typeof window !== "undefined") {
    74→    localStorage.removeItem("access_token");
    75→    localStorage.removeItem("refresh_token");
    76→    localStorage.removeItem("user");
    77→  }
    78→}
    79→
    80→// ─────────────────────────────────────────────────────────────────
    81→// API Helpers
    82→// ─────────────────────────────────────────────────────────────────
    83→
    84→async function fetchAPI(
    85→  endpoint: string,
    86→  options: RequestInit = {}
    87→): Promise<Response> {
    88→  const { accessToken } = getTokens();
    89→
    90→  const headers: Record<string, string> = {
    91→    "Content-Type": "application/json",
    92→    ...options.headers as Record<string, string>,
    93→  };
    94→
    95→  if (accessToken) {
    96→    headers["Authorization"] = `Bearer ${accessToken}`;
    97→  }
    98→
    99→  const response = await fetch(`${API_BASE}${endpoint}`, {
   100→    ...options,
   101→    headers,
   102→  });
   103→
   104→  // Handle 401 - try to refresh token
   105→  if (response.status === 401) {
   106→    const { refreshToken } = getTokens();
   107→    if (refreshToken) {
   108→      const refreshed = await refreshAccessToken();
   109→      if (refreshed) {
   110→        // IMPORTANT: Get fresh token after refresh
   111→        const { accessToken: newAccessToken } = getTokens();
   112→        const newHeaders = {
   113→          ...headers,
   114→          "Authorization": `Bearer ${newAccessToken}`,
   115→        };
   116→        return fetch(`${API_BASE}${endpoint}`, { ...options, headers: newHeaders });
   117→      }
   118→    }
   119→  }
   120→
   121→  return response;
   122→}
   123→
   124→async function refreshAccessToken(): Promise<boolean> {
   125→  try {
   126→    const { refreshToken: currentRefreshToken } = getTokens();
   127→    if (!currentRefreshToken) {
   128→      return false;
   129→    }
   130→
   131→    const response = await fetch("/api/auth/refresh", {
   132→      method: "POST",
   133→      headers: { "Content-Type": "application/json" },
   134→      body: JSON.stringify({ refresh_token: currentRefreshToken }),
   135→    });
   136→
   137→    if (response.ok) {
   138→      const data: TokenResponse = await response.json();
   139→      setTokens(data.access_token, data.refresh_token);
   140→      return true;
   141→    }
   142→  } catch (error) {
   143→    console.error("Token refresh failed:", error);
   144→  }
   145→
   146→  clearTokens();
   147→  // [P3] Dispatch event to notify that session has expired
   148→  if (typeof window !== "undefined") {
   149→    window.dispatchEvent(new CustomEvent("auth:session-expired"));
   150→  }
   151→  return false;
   152→}
   153→
   154→// ─────────────────────────────────────────────────────────────────
   155→// Auth API (OAuth only - no password authentication)
   156→// ─────────────────────────────────────────────────────────────────
   157→
   158→export async function logout(): Promise<void> {
   159→  try {
   160→    await fetchAPI("/auth/logout", { method: "POST" });
   161→  } finally {
   162→    clearTokens();
   163→  }
   164→}
   165→
   166→export async function getMe() {
   167→  const response = await fetchAPI("/auth/me");
   168→  if (!response.ok) throw new Error("Failed to get user");
   169→  return response.json();
   170→}
   171→
   172→// ─────────────────────────────────────────────────────────────────
   173→// Chat API
   174→// ─────────────────────────────────────────────────────────────────
   175→
   176→export async function sendMessage(request: ChatRequest): Promise<ChatResponse> {
   177→  const response = await fetchAPI("/chat/", {
   178→    method: "POST",
   179→    body: JSON.stringify(request),
   180→  });
   181→
   182→  if (!response.ok) {
   183→    const error = await response.json();
   184→    throw new Error(error.detail || "Chat failed");
   185→  }
   186→
   187→  return response.json();
   188→}
   189→
   190→export async function sendGuestMessage(
   191→  message: string,
   192→  skill: string
   193→): Promise<{ content: string; is_guest: boolean; suggestion: string }> {
   194→  const response = await fetch("/api/proxy?endpoint=/api/v1/chat/guest", {
   195→    method: "POST",
   196→    headers: { "Content-Type": "application/json" },
   197→    body: JSON.stringify({ message, skill }),
   198→  });
   199→
   200→  if (!response.ok) {
   201→    throw new Error("Chat failed");
   202→  }
   203→
   204→  return response.json();
   205→}
   206→
   207→export interface StreamChatResult {
   208→  conversation_id?: string;
   209→  skill?: string;
   210→  voice_mode?: string;
   211→}
   212→
   213→export async function streamChat(
   214→  request: ChatRequest,
   215→  onChunk: (chunk: string) => void,
   216→  onDone: (result: StreamChatResult) => void,
   217→  onError: (error: Error) => void
   218→): Promise<void> {
   219→  const { accessToken } = getTokens();
   220→
   221→  try {
   222→    const response = await fetch("/api/chat", {
   223→      method: "POST",
   224→      headers: {
   225→        "Content-Type": "application/json",
   226→        ...(accessToken && { Authorization: `Bearer ${accessToken}` }),
   227→      },
   228→      body: JSON.stringify(request),
   229→    });
   230→
   231→    if (!response.ok) {
   232→      const error = await response.json().catch(() => ({ detail: "Stream failed" }));
   233→      onError(new Error(error.detail || "Stream failed"));
   234→      return;
   235→    }
   236→
   237→    const reader = response.body?.getReader();
   238→    const decoder = new TextDecoder();
   239→
   240→    if (!reader) {
   241→      onError(new Error("No response body"));
   242→      return;
   243→    }
   244→
   245→    let buffer = "";
   246→
   247→    while (true) {
   248→      const { done, value } = await reader.read();
   249→      if (done) break;
   250→
   251→      buffer += decoder.decode(value, { stream: true });
   252→      const lines = buffer.split("\n");
   253→      buffer = lines.pop() || "";
   254→
   255→      for (const line of lines) {
   256→        if (line.startsWith("data: ")) {
   257→          const dataStr = line.slice(6).trim();
   258→          if (!dataStr) continue;
   259→
   260→          try {
   261→            const data = JSON.parse(dataStr);
   262→            if (data.type === "chunk") {
   263→              onChunk(data.content);
   264→            } else if (data.type === "done") {
   265→              onDone({
   266→                conversation_id: data.conversation_id,
   267→                skill: data.skill,
   268→                voice_mode: data.voice_mode,
   269→              });
   270→              return;
   271→            } else if (data.type === "error") {
   272→              onError(new Error(data.message));
   273→              return;
   274→            }
   275→          } catch {
   276→            // Skip malformed JSON
   277→          }
   278→        }
   279→      }
   280→    }
   281→
   282→    onDone({});
   283→  } catch (error) {
   284→    onError(error instanceof Error ? error : new Error(String(error)));
   285→  }
   286→}
   287→
   288→// ─────────────────────────────────────────────────────────────────
   289→// User API
   290→// ─────────────────────────────────────────────────────────────────
   291→
   292→export async function getProfile() {
   293→  const response = await fetchAPI("/users/me/profile");
   294→  if (!response.ok) throw new Error("Failed to get profile");
   295→  return response.json();
   296→}
   297→
   298→export async function updateProfile(data: Record<string, unknown>) {
   299→  const response = await fetchAPI("/users/me/profile", {
   300→    method: "PUT",
   301→    body: JSON.stringify(data),
   302→  });
   303→  if (!response.ok) throw new Error("Failed to update profile");
   304→  return response.json();
   305→}
   306→
   307→export async function getSubscriptionStatus() {
   308→  const response = await fetchAPI("/users/me/subscription");
   309→  if (!response.ok) throw new Error("Failed to get subscription");
   310→  return response.json();
   311→}
   312→
   313→// ─────────────────────────────────────────────────────────────────
   314→// Guest Tool API (Landing page direct tool invocation)
   315→// ─────────────────────────────────────────────────────────────────
   316→
   317→export interface GuestToolRequest {
   318→  skill: string;           // Changed from skill_id
   319→  tool: string;
   320→  birth_date: string;
   321→  birth_time?: string;
   322→  gender?: string;
   323→  birth_location?: string;
   324→}
   325→
   326→export interface GuestToolResponse {
   327→  success: boolean;
   328→  tool: string;
   329→  skill: string;           // Changed from skill_id
   330→  raw_result?: string;
   331→  chart_data?: Record<string, unknown>;
   332→  interpretation?: string;
   333→  is_guest: boolean;
   334→  suggestion?: string;
   335→  error?: string;
   336→}
   337→
   338→export async function invokeGuestTool(
   339→  request: GuestToolRequest
   340→): Promise<GuestToolResponse> {
   341→  const response = await fetch("/api/proxy?endpoint=/api/v1/chat/guest/tool", {
   342→    method: "POST",
   343→    headers: { "Content-Type": "application/json" },
   344→    body: JSON.stringify(request),
   345→  });
   346→
   347→  if (!response.ok) {
   348→    const error = await response.json().catch(() => ({ detail: "Tool invocation failed" }));
   349→    throw new Error(error.detail || "Tool invocation failed");
   350→  }
   351→
   352→  return response.json();
   353→}
   354→
   355→// ─────────────────────────────────────────────────────────────────
   356→// SSO API
   357→// ─────────────────────────────────────────────────────────────────
   358→
   359→export interface SSOGenerateResponse {
   360→  sso_token: string;
   361→  redirect_url: string;
   362→  expires_in: number;
   363→}
   364→
   365→export async function generateSSOToken(targetSite: string): Promise<SSOGenerateResponse> {
   366→  const response = await fetchAPI("/auth/sso/generate", {
   367→    method: "POST",
   368→    body: JSON.stringify({ target_site: targetSite }),
   369→  });
   370→
   371→  if (!response.ok) {
   372→    throw new Error("Failed to generate SSO token");
   373→  }
   374→
   375→  return response.json();
   376→}
   377→
   378→export async function exchangeSSOToken(
   379→  token: string,
   380→  site: string
   381→): Promise<TokenResponse> {
   382→  const response = await fetch("/api/auth/sso/callback", {
   383→    method: "POST",
   384→    headers: { "Content-Type": "application/json" },
   385→    body: JSON.stringify({ token, site }),
   386→  });
   387→
   388→  if (!response.ok) {
   389→    const error = await response.json().catch(() => ({ detail: "SSO exchange failed" }));
   390→    throw new Error(error.detail || "SSO exchange failed");
   391→  }
   392→
   393→  const data: TokenResponse = await response.json();
   394→  setTokens(data.access_token, data.refresh_token);
   395→
   396→  if (typeof window !== "undefined") {
   397→    localStorage.setItem("user", JSON.stringify(data.user));
   398→  }
   399→
   400→  return data;
   401→}
   402→
   403→/**
   404→ * Redirect to another VibeLife site with SSO
   405→ */
   406→export async function ssoRedirect(targetSite: string): Promise<void> {
   407→  const response = await generateSSOToken(targetSite);
   408→  if (response.redirect_url) {
   409→    window.location.href = response.redirect_url;
   410→  }
   411→}
   412→
   413→// ─────────────────────────────────────────────────────────────────
   414→// Guest Session API
   415→// ─────────────────────────────────────────────────────────────────
   416→
   417→export interface GuestSession {
   418→  session_id: string;
   419→  birth_datetime?: string;
   420→  birth_location?: string;
   421→  gender?: string;
   422→  voice_mode?: string;
   423→  skill?: string;
   424→  interview_responses?: Record<string, unknown>;
   425→  focus_areas?: string[];
   426→  expires_at: string;
   427→}
   428→
   429→export interface OnboardingData {
   430→  birth_datetime?: string;
   431→  birth_location?: string;
   432→  gender?: string;
   433→  voice_mode?: string;
   434→  skill?: string;
   435→  interview_responses?: Record<string, unknown>;
   436→  focus_areas?: string[];
   437→}
   438→
   439→export async function createGuestSession(): Promise<GuestSession> {
   440→  const response = await fetch("/api/guest/session", {
   441→    method: "POST",
   442→    headers: { "Content-Type": "application/json" },
   443→    credentials: "include",
   444→  });
   445→
   446→  if (!response.ok) {
   447→    throw new Error("Failed to create guest session");
   448→  }
   449→
   450→  return response.json();
   451→}
   452→
   453→export async function getGuestSession(): Promise<GuestSession | null> {
   454→  try {
   455→    const response = await fetch("/api/guest/session", {
   456→      credentials: "include",
   457→    });
   458→
   459→    if (!response.ok) {
   460→      return null;
   461→    }
   462→
   463→    return response.json();
   464→  } catch {
   465→    return null;
   466→  }
   467→}
   468→
   469→export async function saveOnboardingData(data: OnboardingData): Promise<GuestSession> {
   470→  const response = await fetch("/api/proxy?endpoint=/api/v1/guest/session/onboarding", {
   471→    method: "PUT",
   472→    headers: { "Content-Type": "application/json" },
   473→    credentials: "include",
   474→    body: JSON.stringify(data),
   475→  });
   476→
   477→  if (!response.ok) {
   478→    throw new Error("Failed to save onboarding data");
   479→  }
   480→
   481→  return response.json();
   482→}
   483→
   484→// ─────────────────────────────────────────────────────────────────
   485→// OAuth API
   486→// ─────────────────────────────────────────────────────────────────
   487→
   488→export async function googleAuth(
   489→  idToken: string,
   490→  onboarding?: OnboardingData
   491→): Promise<TokenResponse> {
   492→  const response = await fetch("/api/auth/oauth/google", {
   493→    method: "POST",
   494→    headers: { "Content-Type": "application/json" },
   495→    credentials: "include",
   496→    body: JSON.stringify({ id_token: idToken, onboarding }),
   497→  });
   498→
   499→  if (!response.ok) {
   500→    const error = await response.json().catch(() => ({ detail: "Google auth failed" }));
   501→    throw new Error(error.detail || "Google auth failed");
   502→  }
   503→
   504→  const data: TokenResponse = await response.json();
   505→  setTokens(data.access_token, data.refresh_token);
   506→
   507→  if (typeof window !== "undefined") {
   508→    localStorage.setItem("user", JSON.stringify(data.user));
   509→  }
   510→
   511→  return data;
   512→}
   513→
   514→export async function appleAuth(
   515→  idToken: string,
   516→  userName?: string,
   517→  onboarding?: OnboardingData
   518→): Promise<TokenResponse> {
   519→  const response = await fetch("/api/auth/oauth/apple", {
   520→    method: "POST",
   521→    headers: { "Content-Type": "application/json" },
   522→    credentials: "include",
   523→    body: JSON.stringify({ id_token: idToken, user_name: userName, onboarding }),
   524→  });
   525→
   526→  if (!response.ok) {
   527→    const error = await response.json().catch(() => ({ detail: "Apple auth failed" }));
   528→    throw new Error(error.detail || "Apple auth failed");
   529→  }
   530→
   531→  const data: TokenResponse = await response.json();
   532→  setTokens(data.access_token, data.refresh_token);
   533→
   534→  if (typeof window !== "undefined") {
   535→    localStorage.setItem("user", JSON.stringify(data.user));
   536→  }
   537→
   538→  return data;
   539→}
   540→
   541→// ─────────────────────────────────────────────────────────────────
   542→// WeChat OAuth API
   543→// ─────────────────────────────────────────────────────────────────
   544→
   545→export interface WechatQRCodeResponse {
   546→  scene_id: string;
   547→  qrcode_url: string;
   548→  expires_at: string;
   549→}
   550→
   551→export interface WechatStatusResponse {
   552→  status: "pending" | "scanned" | "confirmed" | "expired";
   553→  message?: string;
   554→  access_token?: string;
   555→  refresh_token?: string;
   556→  token_type?: string;
   557→  expires_in?: number;
   558→  user?: {
   559→    user_id: string;
   560→    vibe_id: string;
   561→    display_name?: string;
   562→  };
   563→}
   564→
   565→export async function getWechatQRCode(redirectUri: string): Promise<WechatQRCodeResponse> {
   566→  const response = await fetch("/api/auth/oauth/wechat/qrcode", {
   567→    method: "POST",
   568→    headers: { "Content-Type": "application/json" },
   569→    body: JSON.stringify({ redirect_uri: redirectUri }),
   570→  });
   571→
   572→  if (!response.ok) {
   573→    const error = await response.json().catch(() => ({ detail: "Failed to generate QR code" }));
   574→    throw new Error(error.detail || "Failed to generate QR code");
   575→  }
   576→
   577→  return response.json();
   578→}
   579→
   580→export async function pollWechatStatus(sceneId: string): Promise<WechatStatusResponse> {
   581→  const response = await fetch(`/api/auth/oauth/wechat/status/${sceneId}`);
   582→
   583→  if (!response.ok) {
   584→    const error = await response.json().catch(() => ({ detail: "Failed to poll status" }));
   585→    throw new Error(error.detail || "Failed to poll status");
   586→  }
   587→
   588→  const data: WechatStatusResponse = await response.json();
   589→
   590→  // If confirmed, store tokens
   591→  if (data.status === "confirmed" && data.access_token && data.refresh_token) {
   592→    setTokens(data.access_token, data.refresh_token);
   593→
   594→    if (typeof window !== "undefined" && data.user) {
   595→      localStorage.setItem("user", JSON.stringify(data.user));
   596→    }
   597→  }
   598→
   599→  return data;
   600→}
   601→
   602→// ─────────────────────────────────────────────────────────────────
   603→// Account Deletion API
   604→// ─────────────────────────────────────────────────────────────────
   605→
   606→export interface DeletionStatusResponse {
   607→  status: string;
   608→  deletion_requested_at?: string;
   609→  deletion_scheduled_at?: string;
   610→  grace_period_days?: number;
   611→  can_cancel: boolean;
   612→  message?: string;
   613→}
   614→
   615→export async function requestAccountDeletion(): Promise<DeletionStatusResponse> {
   616→  const response = await fetchAPI("/auth/delete-account", {
   617→    method: "POST",
   618→  });
   619→
   620→  if (!response.ok) {
   621→    const error = await response.json().catch(() => ({ detail: "Request failed" }));
   622→    throw new Error(error.detail || "Failed to request account deletion");
   623→  }
   624→
   625→  return response.json();
   626→}
   627→
   628→export async function cancelAccountDeletion(): Promise<DeletionStatusResponse> {
   629→  const response = await fetchAPI("/auth/cancel-deletion", {
   630→    method: "POST",
   631→  });
   632→
   633→  if (!response.ok) {
   634→    const error = await response.json().catch(() => ({ detail: "Request failed" }));
   635→    throw new Error(error.detail || "Failed to cancel deletion");
   636→  }
   637→
   638→  return response.json();
   639→}
   640→
   641→export async function getAccountDeletionStatus(): Promise<DeletionStatusResponse> {
   642→  const response = await fetchAPI("/auth/deletion-status");
   643→
   644→  if (!response.ok) {
   645→    const error = await response.json().catch(() => ({ detail: "Request failed" }));
   646→    throw new Error(error.detail || "Failed to get deletion status");
   647→  }
   648→
   649→  return response.json();
   650→}
   651→
   652→// ─────────────────────────────────────────────────────────────────
   653→// API Client (axios-like interface)
   654→// ─────────────────────────────────────────────────────────────────
   655→
   656→interface ApiClientResponse<T = unknown> {
   657→  data: T;
   658→  status: number;
   659→}
   660→
   661→interface ApiClientRequestConfig {
   662→  params?: Record<string, unknown>;
   663→  headers?: Record<string, string>;
   664→}
   665→
   666→function buildUrlWithParams(url: string, params?: Record<string, unknown>): string {
   667→  if (!params) return url;
   668→
   669→  const searchParams = new URLSearchParams();
   670→  for (const [key, value] of Object.entries(params)) {
   671→    if (value !== undefined && value !== null) {
   672→      searchParams.append(key, String(value));
   673→    }
   674→  }
   675→
   676→  const queryString = searchParams.toString();
   677→  if (!queryString) return url;
   678→
   679→  return url + (url.includes('?') ? '&' : '?') + queryString;
   680→}
   681→
   682→async function apiRequest<T>(
   683→  method: string,
   684→  url: string,
   685→  data?: unknown,
   686→  config?: ApiClientRequestConfig
   687→): Promise<ApiClientResponse<T>> {
   688→  const fullUrl = buildUrlWithParams(url, config?.params);
   689→
   690→  const response = await fetchAPI(fullUrl, {
   691→    method,
   692→    headers: config?.headers,
   693→    body: data ? JSON.stringify(data) : undefined,
   694→  });
   695→
   696→  const responseData = await response.json().catch(() => ({}));
   697→
   698→  if (!response.ok) {
   699→    const error = new Error((responseData as { detail?: string }).detail || 'Request failed') as Error & {
   700→      response: { status: number; data: unknown };
   701→    };
   702→    error.response = { status: response.status, data: responseData };
   703→    throw error;
   704→  }
   705→
   706→  return { data: responseData as T, status: response.status };
   707→}
   708→
   709→export const apiClient = {
   710→  get<T = unknown>(url: string, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
   711→    return apiRequest<T>('GET', url, undefined, config);
   712→  },
   713→
   714→  post<T = unknown>(url: string, data?: unknown, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
   715→    return apiRequest<T>('POST', url, data, config);
   716→  },
   717→
   718→  put<T = unknown>(url: string, data?: unknown, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
   719→    return apiRequest<T>('PUT', url, data, config);
   720→  },
   721→
   722→  patch<T = unknown>(url: string, data?: unknown, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
   723→    return apiRequest<T>('PATCH', url, data, config);
   724→  },
   725→
   726→  delete<T = unknown>(url: string, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
   727→    return apiRequest<T>('DELETE', url, undefined, config);
   728→  },
   729→};
   730→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
