     1→"""
     2→Message Repository - Database operations for chat messages
     3→Based on: vibelife spec v3.0 schema (001_v3_schema.sql)
     4→"""
     5→import json
     6→from typing import Optional, List, Dict, Any
     7→from uuid import UUID, uuid4
     8→from datetime import datetime
     9→import logging
    10→
    11→from .db import get_connection, fetchrow, fetch, execute
    12→
    13→logger = logging.getLogger(__name__)
    14→
    15→
    16→# ═══════════════════════════════════════════════════════════════════════════
    17→# Data Models
    18→# ═══════════════════════════════════════════════════════════════════════════
    19→
    20→class MessageRecord:
    21→    """Message database record"""
    22→
    23→    def __init__(
    24→        self,
    25→        id: UUID,
    26→        conversation_id: UUID,
    27→        role: str,
    28→        content: str,
    29→        metadata: Optional[Dict[str, Any]],
    30→        created_at: datetime
    31→    ):
    32→        self.id = id
    33→        self.conversation_id = conversation_id
    34→        self.role = role
    35→        self.content = content
    36→        self.metadata = metadata or {}
    37→        self.created_at = created_at
    38→
    39→    def to_dict(self) -> dict:
    40→        return {
    41→            "id": str(self.id),
    42→            "conversation_id": str(self.conversation_id),
    43→            "role": self.role,
    44→            "content": self.content,
    45→            "metadata": self.metadata,
    46→            "created_at": self.created_at.isoformat() if self.created_at else None,
    47→        }
    48→
    49→    def to_chat_format(self) -> dict:
    50→        """Convert to format used by LLM context builder"""
    51→        return {
    52→            "role": self.role,
    53→            "content": self.content,
    54→        }
    55→
    56→    @classmethod
    57→    def from_row(cls, row: dict) -> "MessageRecord":
    58→        metadata = row.get("metadata")
    59→        if isinstance(metadata, str):
    60→            metadata = json.loads(metadata)
    61→
    62→        return cls(
    63→            id=row["id"],
    64→            conversation_id=row["conversation_id"],
    65→            role=row["role"],
    66→            content=row["content"],
    67→            metadata=metadata,
    68→            created_at=row.get("created_at"),
    69→        )
    70→
    71→
    72→# ═══════════════════════════════════════════════════════════════════════════
    73→# Repository Functions
    74→# ═══════════════════════════════════════════════════════════════════════════
    75→
    76→async def create_message(
    77→    conversation_id: UUID,
    78→    role: str,
    79→    content: str,
    80→    metadata: Optional[Dict[str, Any]] = None
    81→) -> MessageRecord:
    82→    """
    83→    Create a new message.
    84→
    85→    Args:
    86→        conversation_id: Conversation ID
    87→        role: user | assistant | system
    88→        content: Message content
    89→        metadata: Optional metadata (tool calls, extracted info, etc.)
    90→
    91→    Returns:
    92→        Created MessageRecord
    93→    """
    94→    message_id = uuid4()
    95→
    96→    query = """
    97→        INSERT INTO messages (id, conversation_id, role, content, metadata)
    98→        VALUES ($1, $2, $3, $4, $5)
    99→        RETURNING *
   100→    """
   101→
   102→    metadata_json = json.dumps(metadata) if metadata else "{}"
   103→
   104→    try:
   105→        async with get_connection() as conn:
   106→            row = await conn.fetchrow(
   107→                query,
   108→                message_id,
   109→                conversation_id,
   110→                role,
   111→                content,
   112→                metadata_json
   113→            )
   114→            return MessageRecord.from_row(dict(row))
   115→    except Exception as e:
   116→        logger.error(f"Failed to create message: {e}")
   117→        raise
   118→
   119→
   120→async def get_message(message_id: UUID) -> Optional[MessageRecord]:
   121→    """Get a message by ID"""
   122→    query = "SELECT * FROM messages WHERE id = $1"
   123→
   124→    try:
   125→        row = await fetchrow(query, message_id)
   126→        if row:
   127→            return MessageRecord.from_row(dict(row))
   128→        return None
   129→    except Exception as e:
   130→        logger.error(f"Failed to get message: {e}")
   131→        raise
   132→
   133→
   134→async def list_messages(
   135→    conversation_id: UUID,
   136→    limit: int = 50,
   137→    offset: int = 0,
   138→    order: str = "asc"
   139→) -> List[MessageRecord]:
   140→    """
   141→    List messages in a conversation.
   142→
   143→    Args:
   144→        conversation_id: Conversation ID
   145→        limit: Max results
   146→        offset: Pagination offset
   147→        order: asc or desc by created_at
   148→
   149→    Returns:
   150→        List of MessageRecord
   151→    """
   152→    order_dir = "ASC" if order.lower() == "asc" else "DESC"
   153→
   154→    query = f"""
   155→        SELECT * FROM messages
   156→        WHERE conversation_id = $1
   157→        ORDER BY created_at {order_dir}
   158→        LIMIT $2 OFFSET $3
   159→    """
   160→
   161→    try:
   162→        rows = await fetch(query, conversation_id, limit, offset)
   163→        return [MessageRecord.from_row(dict(row)) for row in rows]
   164→    except Exception as e:
   165→        logger.error(f"Failed to list messages: {e}")
   166→        raise
   167→
   168→
   169→async def get_recent_messages(
   170→    conversation_id: UUID,
   171→    limit: int = 20
   172→) -> List[MessageRecord]:
   173→    """
   174→    Get recent messages for context building.
   175→    Returns messages in chronological order (oldest first).
   176→    """
   177→    # Get latest N messages, then reverse
   178→    query = """
   179→        SELECT * FROM (
   180→            SELECT * FROM messages
   181→            WHERE conversation_id = $1
   182→            ORDER BY created_at DESC
   183→            LIMIT $2
   184→        ) sub
   185→        ORDER BY created_at ASC
   186→    """
   187→
   188→    try:
   189→        rows = await fetch(query, conversation_id, limit)
   190→        return [MessageRecord.from_row(dict(row)) for row in rows]
   191→    except Exception as e:
   192→        logger.error(f"Failed to get recent messages: {e}")
   193→        raise
   194→
   195→
   196→async def get_messages_for_context(
   197→    conversation_id: UUID,
   198→    limit: int = 20
   199→) -> List[Dict[str, str]]:
   200→    """
   201→    Get messages formatted for LLM context.
   202→    Returns list of {role, content} dicts.
   203→    """
   204→    messages = await get_recent_messages(conversation_id, limit)
   205→    return [msg.to_chat_format() for msg in messages]
   206→
   207→
   208→async def count_messages(conversation_id: UUID) -> int:
   209→    """Count messages in a conversation"""
   210→    query = "SELECT COUNT(*) FROM messages WHERE conversation_id = $1"
   211→
   212→    try:
   213→        async with get_connection() as conn:
   214→            return await conn.fetchval(query, conversation_id)
   215→    except Exception as e:
   216→        logger.error(f"Failed to count messages: {e}")
   217→        raise
   218→
   219→
   220→async def delete_message(message_id: UUID) -> bool:
   221→    """Delete a single message"""
   222→    query = "DELETE FROM messages WHERE id = $1"
   223→
   224→    try:
   225→        result = await execute(query, message_id)
   226→        return "DELETE 1" in result
   227→    except Exception as e:
   228→        logger.error(f"Failed to delete message: {e}")
   229→        raise
   230→
   231→
   232→async def delete_conversation_messages(conversation_id: UUID) -> int:
   233→    """Delete all messages in a conversation"""
   234→    query = "DELETE FROM messages WHERE conversation_id = $1"
   235→
   236→    try:
   237→        result = await execute(query, conversation_id)
   238→        # Parse "DELETE N" to get count
   239→        if "DELETE" in result:
   240→            return int(result.split(" ")[1])
   241→        return 0
   242→    except Exception as e:
   243→        logger.error(f"Failed to delete conversation messages: {e}")
   244→        raise
   245→
   246→
   247→async def update_message_metadata(
   248→    message_id: UUID,
   249→    metadata: Dict[str, Any]
   250→) -> Optional[MessageRecord]:
   251→    """Update message metadata (merge with existing)"""
   252→    query = """
   253→        UPDATE messages
   254→        SET metadata = COALESCE(metadata, '{}'::jsonb) || $2::jsonb
   255→        WHERE id = $1
   256→        RETURNING *
   257→    """
   258→
   259→    try:
   260→        row = await fetchrow(query, message_id, json.dumps(metadata))
   261→        if row:
   262→            return MessageRecord.from_row(dict(row))
   263→        return None
   264→    except Exception as e:
   265→        logger.error(f"Failed to update message metadata: {e}")
   266→        raise
   267→
   268→
   269→async def search_messages(
   270→    user_id: UUID,
   271→    query_text: str,
   272→    limit: int = 20
   273→) -> List[MessageRecord]:
   274→    """
   275→    Search messages by content (full-text search).
   276→    Only searches within user's conversations.
   277→    """
   278→    query = """
   279→        SELECT m.* FROM messages m
   280→        JOIN conversations c ON m.conversation_id = c.id
   281→        WHERE c.user_id = $1
   282→        AND m.content ILIKE $2
   283→        ORDER BY m.created_at DESC
   284→        LIMIT $3
   285→    """
   286→
   287→    try:
   288→        rows = await fetch(query, user_id, f"%{query_text}%", limit)
   289→        return [MessageRecord.from_row(dict(row)) for row in rows]
   290→    except Exception as e:
   291→        logger.error(f"Failed to search messages: {e}")
   292→        raise
   293→
   294→
   295→# ═══════════════════════════════════════════════════════════════════════════
   296→# Goal-Anchored History (v10.1)
   297→# 借鉴 Planning-with-Files 的 Attention Manipulation 原则
   298→# 第一条消息（用户原始意图）永远保留在 context 中
   299→# ═══════════════════════════════════════════════════════════════════════════
   300→
   301→async def get_messages_anchored(
   302→    conversation_id: UUID,
   303→    limit: int = 14
   304→) -> List[Dict[str, str]]:
   305→    """
   306→    Goal-Anchored History：第一条消息 + 最近 N 条
   307→
   308→    解决问题：长对话（50+ 条）后，原始目标被挤出注意力窗口
   309→
   310→    原理（来自 Manus/PWF）：
   311→    - Context Window = RAM（易失、有限）
   312→    - 第一条消息 = 用户原始意图 = Goal
   313→    - 通过保留第一条消息实现 Attention Manipulation
   314→
   315→    Args:
   316→        conversation_id: 会话 ID
   317→        limit: 最近消息数量（默认 14，加第一条共 15 条）
   318→
   319→    Returns:
   320→        [第一条消息] + [最近 N 条消息]，按时间顺序排列
   321→    """
   322→    # 使用 UNION 合并第一条和最近 N 条，避免重复
   323→    query = """
   324→        WITH first_msg AS (
   325→            SELECT * FROM messages
   326→            WHERE conversation_id = $1
   327→            ORDER BY created_at ASC
   328→            LIMIT 1
   329→        ),
   330→        recent_msgs AS (
   331→            SELECT * FROM messages
   332→            WHERE conversation_id = $1
   333→            ORDER BY created_at DESC
   334→            LIMIT $2
   335→        ),
   336→        combined AS (
   337→            SELECT * FROM first_msg
   338→            UNION
   339→            SELECT * FROM recent_msgs
   340→        )
   341→        SELECT * FROM combined ORDER BY created_at ASC
   342→    """
   343→
   344→    try:
   345→        rows = await fetch(query, conversation_id, limit)
   346→        return [{"role": row["role"], "content": row["content"]} for row in rows]
   347→    except Exception as e:
   348→        logger.error(f"Failed to get anchored messages: {e}")
   349→        raise
   350→
   351→
   352→async def get_first_message(conversation_id: UUID) -> Optional[Dict[str, str]]:
   353→    """获取会话的第一条消息（用户原始意图）"""
   354→    query = """
   355→        SELECT role, content FROM messages
   356→        WHERE conversation_id = $1
   357→        ORDER BY created_at ASC
   358→        LIMIT 1
   359→    """
   360→
   361→    try:
   362→        row = await fetchrow(query, conversation_id)
   363→        if row:
   364→            return {"role": row["role"], "content": row["content"]}
   365→        return None
   366→    except Exception as e:
   367→        logger.error(f"Failed to get first message: {e}")
   368→        raise
   369→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
