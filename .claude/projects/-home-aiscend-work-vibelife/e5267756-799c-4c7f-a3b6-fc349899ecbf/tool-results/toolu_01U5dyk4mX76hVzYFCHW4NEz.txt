     1→"""
     2→Vibe 同步执行器 - v11
     3→
     4→配置驱动的 Skill → Vibe 同步
     5→
     6→职责：
     7→1. 加载 vibe_sync.yaml 配置
     8→2. 根据配置执行字段映射
     9→3. 处理特殊逻辑（archetype、traits transform）
    10→
    11→文档：docs/archive/v9/LLM_DRIVEN_ARCHITECTURE.md#15
    12→"""
    13→import yaml
    14→import logging
    15→from typing import Dict, Any, Optional, List
    16→from pathlib import Path
    17→from uuid import UUID
    18→from datetime import datetime, timezone
    19→
    20→logger = logging.getLogger(__name__)
    21→
    22→# 配置缓存
    23→_sync_config: Optional[Dict] = None
    24→
    25→
    26→def load_sync_config() -> Dict[str, Any]:
    27→    """加载 Vibe 同步配置（带缓存）"""
    28→    global _sync_config
    29→    if _sync_config is None:
    30→        config_path = Path(__file__).parent.parent.parent / "config" / "vibe_sync.yaml"
    31→        try:
    32→            with open(config_path, "r", encoding="utf-8") as f:
    33→                _sync_config = yaml.safe_load(f)
    34→                logger.info(f"[VibeSyncLoaded from {config_path}")
    35→        except Exception as e:
    36→            logger.error(f"[VibeSync] Failed to load config: {e}")
    37→            _sync_config = {}
    38→    return _sync_config
    39→
    40→
    41→def reload_sync_config() -> None:
    42→    """重新加载配置（清除缓存）"""
    43→    global _sync_config
    44→    _sync_config = None
    45→    load_sync_config()
    46→    logger.info("[VibeSync] Config reloaded")
    47→
    48→
    49→# ═══════════════════════════════════════════════════════════════
    50→# 工具函数
    51→# ═══════════════════════════════════════════════════════════════
    52→
    53→
    54→def get_nested_value(data: Dict, path: str) -> Any:
    55→    """
    56→    从嵌套字典中获取值，支持点号路径
    57→
    58→    Example:
    59→        get_nested_value({"a": {"b": 1}}, "a.b") → 1
    60→    """
    61→    if not data or not path:
    62→        return None
    63→
    64→    keys = path.split(".")
    65→    value = data
    66→    for key in keys:
    67→        if isinstance(value, dict):
    68→            value = value.get(key)
    69→        else:
    70→            return None
    71→    return value
    72→
    73→
    74→def set_nested_value(data: Dict, path: str, value: Any) -> None:
    75→    """
    76→    设置嵌套字典的值，支持点号路径
    77→
    78→    Example:
    79→        data = {}
    80→        set_nested_value(data, "a.b.c", 1)
    81→        → {"a": {"b": {"c": 1}}}
    82→    """
    83→    if not path:
    84→        return
    85→
    86→    keys = path.split(".")
    87→    current = data
    88→    for key in keys[:-1]:
    89→        current = current.setdefault(key, {})
    90→    current[keys[-1]] = value
    91→
    92→
    93→# ═══════════════════════════════════════════════════════════════
    94→# Transform 函数
    95→# ═══════════════════════════════════════════════════════════════
    96→
    97→
    98→def transform_element_to_archetype(element: str, config: Dict) -> Dict[str, Any]:
    99→    """五行元素 → 人格原型"""
   100→    if not element:
   101→        return {}
   102→
   103→    mapping = config.get("mapping", {})
   104→    element_lower = element.lower()
   105→
   106→    if element_lower in mapping:
   107→        arch = mapping[element_lower]
   108→        return {
   109→            "primary": arch.get("primary"),
   110→            "source": "bazi",
   111→            "element": element_lower,
   112→        }
   113→    return {}
   114→
   115→
   116→def transform_sign_to_archetype(sign: str, config: Dict) -> Dict[str, Any]:
   117→    """星座 → 人格原型"""
   118→    if not sign:
   119→        return {}
   120→
   121→    mapping = config.get("mapping", {})
   122→    sign_lower = sign.lower()
   123→
   124→    if sign_lower in mapping:
   125→        arch = mapping[sign_lower]
   126→        return {
   127→            "primary": arch.get("primary"),
   128→            "source": "zodiac",
   129→            "sign": sign_lower,
   130→        }
   131→    return {}
   132→
   133→
   134→def extract_bazi_traits(day_master: Dict, config: Dict) -> List[Dict[str, Any]]:
   135→    """从八字日主提取特质"""
   136→    if not day_master:
   137→        return []
   138→
   139→    element = day_master.get("element", "").lower()
   140→    mapping = config.get("mapping", {})
   141→    intensity = config.get("intensity", 0.8)
   142→
   143→    if element in mapping:
   144→        traits = mapping[element].get("traits", [])
   145→        return [
   146→            {"trait": t, "intensity": intensity, "source": "bazi"}
   147→            for t in traits
   148→        ]
   149→    return []
   150→
   151→
   152→def extract_zodiac_traits(sun_sign: str, config: Dict) -> List[Dict[str, Any]]:
   153→    """从星座提取特质"""
   154→    if not sun_sign:
   155→        return []
   156→
   157→    sign_lower = sun_sign.lower()
   158→    mapping = config.get("mapping", {})
   159→    intensity = config.get("intensity", 0.7)
   160→
   161→    if sign_lower in mapping:
   162→        traits = mapping[sign_lower].get("traits", [])[:2]  # 取前两个
   163→        return [
   164→            {"trait": t, "intensity": intensity, "source": "zodiac"}
   165→            for t in traits
   166→        ]
   167→    return []
   168→
   169→
   170→def extract_first_goal_id(rocks: List[Dict]) -> Optional[str]:
   171→    """从列表中提取第一个 goal_id"""
   172→    if not rocks or not isinstance(rocks, list):
   173→        return None
   174→    first = rocks[0] if rocks else {}
   175→    return first.get("goal_id")
   176→
   177→
   178→# ═══════════════════════════════════════════════════════════════
   179→# 主同步函数
   180→# ═══════════════════════════════════════════════════════════════
   181→
   182→
   183→async def sync_skill_to_vibe(
   184→    user_id: UUID,
   185→    skill_id: str,
   186→    skill_data: Dict[str, Any]
   187→) -> bool:
   188→    """
   189→    配置驱动的 Skill → Vibe 同步
   190→
   191→    Args:
   192→        user_id: 用户 ID
   193→        skill_id: Skill ID (bazi, zodiac, lifecoach, etc.)
   194→        skill_data: Skill 数据（刚保存的完整数据）
   195→
   196→    Returns:
   197→        bool: 是否执行了同步
   198→    """
   199→    config = load_sync_config()
   200→    if not config:
   201→        logger.warning("[VibeSync] No config loaded, skipping sync")
   202→        return False
   203→
   204→    synced = False
   205→
   206→    # 同步到 insight
   207→    insight_config = config.get("insight", {})
   208→    insight_updates = await _sync_to_insight(skill_id, skill_data, insight_config)
   209→    if insight_updates:
   210→        await _update_vibe_insight(user_id, insight_updates)
   211→        synced = True
   212→        logger.info(f"[VibeSync] Synced {skill_id} → vibe.insight for user {user_id}")
   213→
   214→    # 同步到 target
   215→    target_config = config.get("target", {})
   216→    target_updates = await _sync_to_target(skill_id, skill_data, target_config)
   217→    if target_updates:
   218→        await _update_vibe_target(user_id, target_updates)
   219→        synced = True
   220→        logger.info(f"[VibeSync] Synced {skill_id} → vibe.target for user {user_id}")
   221→
   222→    return synced
   223→
   224→
   225→async def _sync_to_insight(
   226→    skill_id: str,
   227→    skill_data: Dict,
   228→    insight_config: Dict
   229→) -> Dict[str, Any]:
   230→    """同步到 vibe.insight"""
   231→    updates = {}
   232→
   233→    # === Archetype 同步 ===
   234→    archetype_config = insight_config.get("essence", {}).get("archetype", {})
   235→    sources = archetype_config.get("sources", [])
   236→
   237→    for source in sources:
   238→        if source.get("skill") != skill_id:
   239→            continue
   240→
   241→        trigger_path = source.get("trigger")
   242→        trigger_value = get_nested_value(skill_data, trigger_path)
   243→        if not trigger_value:
   244→            continue
   245→
   246→        transform = source.get("transform")
   247→        if transform == "element_to_archetype":
   248→            # 从 day_master.element 获取元素
   249→            element = trigger_value.get("element") if isinstance(trigger_value, dict) else trigger_value
   250→            arch = transform_element_to_archetype(element, source)
   251→            if arch:
   252→                set_nested_value(updates, "essence.archetype", arch)
   253→                # 同时提取 traits
   254→                traits = extract_bazi_traits(trigger_value, source)
   255→                if traits:
   256→                    set_nested_value(updates, "essence.traits", traits)
   257→        elif transform == "sign_to_archetype":
   258→            arch = transform_sign_to_archetype(trigger_value, source)
   259→            if arch:
   260→                set_nested_value(updates, "essence.archetype", arch)
   261→                # 同时提取 traits
   262→                traits = extract_zodiac_traits(trigger_value, source)
   263→                if traits:
   264→                    existing_traits = get_nested_value(updates, "essence.traits") or []
   265→                    set_nested_value(updates, "essence.traits", existing_traits + traits)
   266→        elif transform == "direct":
   267→            path = source.get("path")
   268→            value = get_nested_value(skill_data, path)
   269→            if value:
   270→                set_nested_value(updates, "essence.archetype", value)
   271→
   272→    # === Chart Features 同步 ===
   273→    chart_features_config = insight_config.get("essence", {}).get("chart_features", {})
   274→    skill_chart_config = chart_features_config.get(skill_id, {})
   275→
   276→    if skill_chart_config:
   277→        trigger = skill_chart_config.get("trigger")
   278→        if get_nested_value(skill_data, trigger):
   279→            fields = skill_chart_config.get("fields", [])
   280→            for field in fields:
   281→                source_path = field.get("source")
   282→                dest_path = field.get("dest")
   283→                value = get_nested_value(skill_data, source_path)
   284→                if value is not None:
   285→                    set_nested_value(updates, f"essence.chart_features.{dest_path}", value)
   286→
   287→    return updates
   288→
   289→
   290→async def _sync_to_target(
   291→    skill_id: str,
   292→    skill_data: Dict,
   293→    target_config: Dict
   294→) -> Dict[str, Any]:
   295→    """同步到 vibe.target"""
   296→    updates = {}
   297→
   298→    for section, section_config in target_config.items():
   299→        if section_config.get("skill") != skill_id:
   300→            continue
   301→
   302→        trigger = section_config.get("trigger")
   303→        if not get_nested_value(skill_data, trigger):
   304→            continue
   305→
   306→        fields = section_config.get("fields", [])
   307→        for field in fields:
   308→            source_path = field.get("source")
   309→            dest_path = field.get("dest")
   310→            transform = field.get("transform", "direct")
   311→
   312→            value = get_nested_value(skill_data, source_path)
   313→            if value is None:
   314→                continue
   315→
   316→            # 应用 transform
   317→            if transform == "extract_first_goal_id":
   318→                value = extract_first_goal_id(value)
   319→            # direct: 不转换
   320→
   321→            if value is not None:
   322→                set_nested_value(updates, f"{section}.{dest_path}" if dest_path != section else section, value)
   323→
   324→    return updates
   325→
   326→
   327→async def _update_vibe_insight(user_id: UUID, updates: Dict) -> None:
   328→    """更新 vibe.insight（深度合并）"""
   329→    from stores.unified_profile_repo import UnifiedProfileRepository
   330→
   331→    current_insight = await UnifiedProfileRepository.get_vibe_insight(user_id)
   332→    current_insight = current_insight or {}
   333→
   334→    # 深度合并
   335→    merged = _deep_merge(current_insight, updates)
   336→    merged["updated_at"] = datetime.now(timezone.utc).isoformat()
   337→
   338→    await UnifiedProfileRepository.update_vibe_insight(user_id, merged)
   339→
   340→
   341→async def _update_vibe_target(user_id: UUID, updates: Dict) -> None:
   342→    """更新 vibe.target（深度合并）"""
   343→    from stores.unified_profile_repo import UnifiedProfileRepository
   344→
   345→    current_target = await UnifiedProfileRepository.get_vibe_target(user_id)
   346→    current_target = current_target or {}
   347→
   348→    # 深度合并
   349→    merged = _deep_merge(current_target, updates)
   350→    merged["updated_at"] = datetime.now(timezone.utc).isoformat()
   351→
   352→    await UnifiedProfileRepository.update_vibe_target(user_id, merged)
   353→
   354→
   355→def _deep_merge(base: Dict, update: Dict) -> Dict:
   356→    """深度合并两个字典"""
   357→    result = base.copy()
   358→    for key, value in update.items():
   359→        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
   360→            result[key] = _deep_merge(result[key], value)
   361→        else:
   362→            result[key] = value
   363→    return result
   364→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
