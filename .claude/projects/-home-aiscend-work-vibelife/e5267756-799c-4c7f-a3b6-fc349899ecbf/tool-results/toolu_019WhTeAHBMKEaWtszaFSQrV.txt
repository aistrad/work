     1→"""
     2→Profile Extractor Worker V8 - 从用户交互中抽取信息更新 Profile
     3→
     4→V8 架构升级：
     5→- 输出写入 vibe.insight (我是谁) + vibe.target (我要成为谁)
     6→- 废弃 extracted 字段
     7→- 保持 Cold Layer 写入 (vibe_profile_timeline + vibe_profile_insights)
     8→
     9→极简设计：
    10→- 单一抽取入口，替代 daily_extraction + portrait_service + insight_generator
    11→- 定时运行（每日），增量处理新消息
    12→"""
    13→import asyncio
    14→import json
    15→import logging
    16→import re
    17→from datetime import datetime, timedelta
    18→from typing import List, Dict, Any, Optional
    19→from uuid import UUID
    20→
    21→from stores.db import fetch, fetchrow
    22→from stores.unified_profile_repo import UnifiedProfileRepository
    23→from services.model_router.client import chat
    24→
    25→logger = logging.getLogger(__name__)
    26→
    27→# V8 抽取 Prompt - 输出到 vibe.insight + vibe.target
    28→EXTRACTION_PROMPT_V8 = """你是一个用户画像分析专家。分析对话记录，提取关键信息。
    29→
    30→## 输出格式 (JSON)
    31→
    32→{
    33→  "insight": {
    34→    "essence": {
    35→      "archetype": {"primary": "...", "secondary": "..."},
    36→      "traits": [{"trait": "...", "intensity": 0.8}],
    37→      "communication_style": "直接/温和/理性/感性",
    38→      "relationships": ["..."]
    39→    },
    40→    "dynamic": {
    41→      "emotion": {"current": "...", "trend": "stable/improving/declining"},
    42→      "energy": {"level": "low/medium/high"},
    43→      "challenges": ["..."]
    44→    },
    45→    "pattern": {
    46→      "interests": ["..."],
    47→      "behaviors": ["..."],
    48→      "insights": ["..."]
    49→    }
    50→  },
    51→  "target": {
    52→    "goals": [
    53→      {"title": "...", "category": "career/health/relationship/wealth/growth", "status": "in_progress"}
    54→    ],
    55→    "focus": {
    56→      "primary": "...",
    57→      "heat_map": {"career": 0.8, "health": 0.3, "relationship": 0.5}
    58→    }
    59→  },
    60→  "timeline_events": [
    61→    {"date": "2024-01", "event": "...", "type": "life_event"}
    62→  ]
    63→}
    64→
    65→## 抽取规则
    66→
    67→1. **archetype**: 用户核心身份原型（创造者/导师/英雄/照顾者/智者/探索者等）
    68→2. **traits**: 从对话中识别的稳定特质（最多5个，intensity范围0-1）
    69→3. **communication_style**: 对话风格偏好
    70→4. **relationships**: 提及的重要关系（家人、朋友、宠物等）
    71→5. **emotion/energy**: 最近对话中的情绪和能量状态
    72→6. **challenges**: 当前面临的困难或痛点
    73→7. **interests**: 反复提及的话题或领域
    74→8. **behaviors**: 观察到的行为模式
    75→9. **goals**: 明确表达的目标或愿望（需分类）
    76→10. **heat_map**: 各领域关注度（0-1，根据对话频率和深度判断）
    77→11. **timeline_events**: 重要人生节点（带日期）
    78→
    79→只返回从对话中明确提取到的信息，不要推测。空字段不要包含。
    80→如果完全没有新信息，返回空对象 {}"""
    81→
    82→
    83→async def get_active_users(days: int = 7) -> List[UUID]:
    84→    """获取最近活跃的用户"""
    85→    query = """
    86→        SELECT DISTINCT c.user_id FROM conversations c
    87→        WHERE c.user_id IS NOT NULL
    88→        AND c.updated_at > NOW() - INTERVAL '%s days'
    89→    """
    90→    rows = await fetch(query, days)
    91→    return [row["user_id"] for row in rows]
    92→
    93→
    94→async def get_user_messages_since(
    95→    user_id: UUID,
    96→    since: Optional[datetime] = None,
    97→    limit: int = 100
    98→) -> List[Dict[str, Any]]:
    99→    """获取用户自指定时间以来的消息"""
   100→    if since is None:
   101→        since = datetime.now() - timedelta(days=30)
   102→
   103→    query = """
   104→        SELECT m.role, m.content, m.created_at
   105→        FROM messages m
   106→        JOIN conversations c ON m.conversation_id = c.id
   107→        WHERE c.user_id = $1 AND m.created_at > $2
   108→        ORDER BY m.created_at ASC
   109→        LIMIT $3
   110→    """
   111→    rows = await fetch(query, user_id, since, limit)
   112→    return [dict(row) for row in rows]
   113→
   114→
   115→def merge_insight(current: Dict[str, Any], new: Dict[str, Any]) -> Dict[str, Any]:
   116→    """
   117→    合并 vibe.insight（我是谁）
   118→
   119→    合并策略:
   120→    - essence: 深度合并，新数据优先
   121→    - dynamic: 完全覆盖（状态型数据）
   122→    - pattern: 追加合并，保留最新
   123→    """
   124→    if not new:
   125→        return current
   126→
   127→    result = current.copy() if current else {}
   128→
   129→    # essence: 深度合并，新数据优先
   130→    if "essence" in new:
   131→        current_essence = result.get("essence", {})
   132→
   133→        # archetype: 直接覆盖
   134→        if "archetype" in new["essence"]:
   135→            current_essence["archetype"] = new["essence"]["archetype"]
   136→
   137→        # traits: 合并去重，保留最新 5 个（按 trait 名去重）
   138→        if "traits" in new["essence"]:
   139→            new_traits = new["essence"]["traits"]
   140→            current_traits = current_essence.get("traits", [])
   141→            # 新的在前，按 trait 去重
   142→            seen_traits = set()
   143→            merged_traits = []
   144→            for t in new_traits + current_traits:
   145→                trait_name = t.get("trait", "")
   146→                if trait_name and trait_name not in seen_traits:
   147→                    seen_traits.add(trait_name)
   148→                    merged_traits.append(t)
   149→            current_essence["traits"] = merged_traits[:5]
   150→
   151→        # communication_style: 直接覆盖
   152→        if "communication_style" in new["essence"]:
   153→            current_essence["communication_style"] = new["essence"]["communication_style"]
   154→
   155→        # relationships: 合并去重
   156→        if "relationships" in new["essence"]:
   157→            current_rels = current_essence.get("relationships", [])
   158→            combined = new["essence"]["relationships"] + current_rels
   159→            current_essence["relationships"] = list(dict.fromkeys(combined))[:10]
   160→
   161→        result["essence"] = current_essence
   162→
   163→    # dynamic: 完全覆盖（状态型数据，只保留最新）
   164→    if "dynamic" in new:
   165→        result["dynamic"] = new["dynamic"]
   166→
   167→    # pattern: 追加合并
   168→    if "pattern" in new:
   169→        current_pattern = result.get("pattern", {})
   170→
   171→        # interests, behaviors, insights: 追加去重
   172→        for field in ["interests", "behaviors", "insights"]:
   173→            if field in new["pattern"]:
   174→                current_list = current_pattern.get(field, [])
   175→                combined = new["pattern"][field] + current_list
   176→                current_pattern[field] = list(dict.fromkeys(combined))[:10]
   177→
   178→        result["pattern"] = current_pattern
   179→
   180→    return result
   181→
   182→
   183→def merge_target(current: Dict[str, Any], new: Dict[str, Any]) -> Dict[str, Any]:
   184→    """
   185→    合并 vibe.target（我要成为谁）
   186→
   187→    合并策略:
   188→    - goals: 合并，按 title 去重
   189→    - focus: 合并 heat_map，primary 覆盖
   190→    """
   191→    if not new:
   192→        return current
   193→
   194→    result = current.copy() if current else {}
   195→
   196→    # goals: 合并，按 title 去重
   197→    if "goals" in new and new["goals"]:
   198→        current_goals = result.get("goals", [])
   199→        existing_titles = {g.get("title", "") for g in current_goals}
   200→
   201→        for goal in new["goals"]:
   202→            title = goal.get("title", "")
   203→            if title and title not in existing_titles:
   204→                current_goals.append(goal)
   205→                existing_titles.add(title)
   206→
   207→        # 保留最新 10 个目标
   208→        result["goals"] = current_goals[:10]
   209→
   210→    # focus: 合并
   211→    if "focus" in new:
   212→        current_focus = result.get("focus", {})
   213→
   214→        # primary: 直接覆盖
   215→        if "primary" in new["focus"]:
   216→            current_focus["primary"] = new["focus"]["primary"]
   217→
   218→        # heat_map: 合并（新值覆盖旧值）
   219→        if "heat_map" in new["focus"]:
   220→            current_heat_map = current_focus.get("heat_map", {})
   221→            current_heat_map.update(new["focus"]["heat_map"])
   222→            current_focus["heat_map"] = current_heat_map
   223→
   224→        result["focus"] = current_focus
   225→
   226→    return result
   227→
   228→
   229→async def extract_user_profile(user_id: UUID) -> Dict[str, Any]:
   230→    """
   231→    为单个用户抽取 Profile (V8 架构)
   232→
   233→    输出写入:
   234→    - vibe.insight: 我是谁（essence + dynamic + pattern）
   235→    - vibe.target: 我要成为谁（goals + focus）
   236→    - Cold Layer: timeline_events + insights
   237→    """
   238→    logger.info(f"Extracting profile for user {user_id} (V8)")
   239→
   240→    # 1. 获取现有 vibe 数据
   241→    current_insight = await UnifiedProfileRepository.get_vibe_insight(user_id)
   242→    current_target = await UnifiedProfileRepository.get_vibe_target(user_id)
   243→
   244→    # 获取上次抽取时间
   245→    last_extracted_at = current_insight.get("updated_at") if current_insight else None
   246→
   247→    # 2. 确定抽取起始时间
   248→    if last_extracted_at:
   249→        try:
   250→            since = datetime.fromisoformat(last_extracted_at.replace("Z", "+00:00"))
   251→        except (ValueError, AttributeError):
   252→            since = datetime.now() - timedelta(days=7)
   253→    else:
   254→        since = datetime.now() - timedelta(days=30)  # 首次抽取，取最近 30 天
   255→
   256→    # 3. 获取新消息
   257→    messages = await get_user_messages_since(user_id, since, limit=100)
   258→
   259→    if not messages:
   260→        logger.info(f"No new messages for user {user_id}")
   261→        return {"insight": current_insight, "target": current_target}
   262→
   263→    # 4. 格式化消息
   264→    messages_text = "\n".join([
   265→        f"[{m['role']}] {m['content'][:300]}"
   266→        for m in messages
   267→        if m.get('content')
   268→    ])
   269→
   270→    if len(messages_text) < 50:
   271→        logger.info(f"Messages too short for user {user_id}")
   272→        return {"insight": current_insight, "target": current_target}
   273→
   274→    # 5. 构建 prompt (V8 结构)
   275→    current_context = {
   276→        "insight": current_insight,
   277→        "target": current_target
   278→    }
   279→    prompt = f"""## 当前已有信息
   280→{json.dumps(current_context, ensure_ascii=False, indent=2) if (current_insight or current_target) else "无"}
   281→
   282→## 新对话记录 (共 {len(messages)} 条)
   283→{messages_text[:6000]}
   284→
   285→请分析新对话，提取需要更新或新增的用户信息。只返回有变化的字段。"""
   286→
   287→    # 6. 调用 LLM 抽取
   288→    try:
   289→        response = await chat(
   290→            messages=[{"role": "user", "content": prompt}],
   291→            system=EXTRACTION_PROMPT_V8,
   292→            capability="analysis",
   293→            user_id=str(user_id),
   294→            temperature=0.3,
   295→        )
   296→
   297→        # 7. 解析响应
   298→        content = response.content if hasattr(response, 'content') else str(response)
   299→
   300→        # 提取 JSON
   301→        json_match = re.search(r'\{[\s\S]*\}', content)
   302→        if not json_match:
   303→            logger.warning(f"No JSON found in response for user {user_id}")
   304→            return {"insight": current_insight, "target": current_target}
   305→
   306→        new_data = json.loads(json_match.group())
   307→
   308→        # 8. 分别合并 insight 和 target
   309→        merged_insight = current_insight
   310→        merged_target = current_target
   311→
   312→        if "insight" in new_data:
   313→            merged_insight = merge_insight(current_insight, new_data["insight"])
   314→            await UnifiedProfileRepository.update_vibe_insight(user_id, merged_insight)
   315→            logger.info(f"Updated vibe.insight for user {user_id}")
   316→
   317→        if "target" in new_data:
   318→            merged_target = merge_target(current_target, new_data["target"])
   319→            await UnifiedProfileRepository.update_vibe_target(user_id, merged_target)
   320→            logger.info(f"Updated vibe.target for user {user_id}")
   321→
   322→        return {"insight": merged_insight, "target": merged_target}
   323→
   324→    except json.JSONDecodeError as e:
   325→        logger.error(f"JSON parse error for user {user_id}: {e}")
   326→        return {"insight": current_insight, "target": current_target}
   327→    except Exception as e:
   328→        logger.error(f"Extraction failed for user {user_id}: {e}")
   329→        return {"insight": current_insight, "target": current_target}
   330→
   331→
   332→async def run_profile_extraction(days: int = 7, batch_size: int = 10):
   333→    """
   334→    运行 Profile 抽取任务
   335→
   336→    Args:
   337→        days: 处理最近 N 天活跃的用户
   338→        batch_size: 每批处理的用户数
   339→    """
   340→    logger.info(f"Starting profile extraction task (days={days})")
   341→
   342→    # 获取活跃用户
   343→    active_users = await get_active_users(days=days)
   344→    logger.info(f"Found {len(active_users)} active users")
   345→
   346→    success_count = 0
   347→    error_count = 0
   348→
   349→    for i, user_id in enumerate(active_users):
   350→        try:
   351→            await extract_user_profile(user_id)
   352→            success_count += 1
   353→
   354→            # 限流：每处理 batch_size 个用户后暂停
   355→            if (i + 1) % batch_size == 0:
   356→                logger.info(f"Processed {i + 1}/{len(active_users)} users, pausing...")
   357→                await asyncio.sleep(2)
   358→
   359→        except Exception as e:
   360→            logger.error(f"Failed to extract for user {user_id}: {e}")
   361→            error_count += 1
   362→            continue
   363→
   364→    logger.info(f"Profile extraction completed: {success_count} success, {error_count} errors")
   365→
   366→
   367→async def main():
   368→    """命令行入口"""
   369→    import sys
   370→
   371→    # 简单参数解析
   372→    days = 7
   373→    if len(sys.argv) > 1:
   374→        try:
   375→            days = int(sys.argv[1])
   376→        except ValueError:
   377→            pass
   378→
   379→    await run_profile_extraction(days=days)
   380→
   381→
   382→if __name__ == "__main__":
   383→    # 配置日志
   384→    logging.basicConfig(
   385→        level=logging.INFO,
   386→        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
   387→    )
   388→
   389→    asyncio.run(main())
   390→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
