diff --git a/apps/api/services/agent/skill_loader.py b/apps/api/services/agent/skill_loader.py
index 9d22a7c..7c26d9e 100644
--- a/apps/api/services/agent/skill_loader.py
+++ b/apps/api/services/agent/skill_loader.py
@@ -1,7 +1,15 @@
 """
-SkillLoader v7 - 支持 Agentic + Rule 架构的 Skill 加载器
+SkillLoader v9 - 渐进式 Skill 加载器
 
-v7 架构：
+v9 架构（遵循 Claude Agent SDK 原则）：
+- Core Skill 全程激活，全文加载
+- 其他 Skill 渐进式加载：
+  - Phase 1: 只加载 frontmatter（SkillMeta）
+  - Phase 2: 按需加载完整内容（SkillFull）
+- 支持多 Skill 并行激活
+- LLM 自主编排，删除硬编码路由
+
+v7 架构（保留兼容）：
 - SKILL.md: 核心定义（专家身份、能力索引、伦理边界）
 - rules/*.md: 规则文件（分析要点、输出要求、常见问题）
 - scenarios/*.md: (旧架构兼容) MiniSkill 场景文件
@@ -196,6 +204,53 @@ class RuleConfig:
     common_questions: str  # 常见问题
 
 
+# ═══════════════════════════════════════════════════════════════════════════
+# V9: 渐进式加载数据结构
+# ═══════════════════════════════════════════════════════════════════════════
+
+@dataclass
+class SkillMeta:
+    """Skill 元数据摘要（Phase 1 展示）- V9 新增
+
+    只包含 frontmatter 信息，用于 Phase 1 路由。
+    description 内嵌工具列表，tools_list 为从 tools.yaml 抽取的机器可读清单。
+    """
+    id: str
+    name: str
+    description: str  # 内含工具列表，如 "星盘计算与解读。工具：calculate_zodiac, show_zodiac_chart"
+    triggers: List[str] = field(default_factory=list)
+    category: str = "professional"
+    tools_list: List[str] = field(default_factory=list)
+
+
+@dataclass
+class ToolDef:
+    """工具定义（用于 SkillFull）- V9 新增"""
+    name: str
+    description: str
+    parameters: Dict[str, Any] = field(default_factory=dict)
+    tool_type: str = "action"  # routing/collect/action/search/display/trigger
+
+
+@dataclass
+class SkillFull:
+    """Skill 完整内容（Phase 2 加载）- V9 新增
+
+    包含 SKILL.md 全文、工具定义、规则文件。
+    """
+    meta: SkillMeta
+    content: str  # SKILL.md 全文（不含 frontmatter）
+    tools: List[ToolDef] = field(default_factory=list)
+    rules: Dict[str, str] = field(default_factory=dict)  # rule_id -> content
+
+
+# V9: Core Skill 全局缓存
+_core_skill_cache: Optional[SkillFull] = None
+
+# V9: 所有 Skill Meta 缓存
+_skill_metas_cache: Optional[Dict[str, SkillMeta]] = None
+
+
 # ═══════════════════════════════════════════════════════════════════════════
 # 解析函数
 # ═══════════════════════════════════════════════════════════════════════════
@@ -751,6 +806,89 @@ def get_available_skills() -> List[str]:
             if p.is_dir() and (p / "SKILL.md").exists()]
 
 
+# ═══════════════════════════════════════════════════════════════════════════
+# Protocol/Rule 元信息（用于消除硬编码）
+# ═══════════════════════════════════════════════════════════════════════════
+
+@lru_cache(maxsize=32)
+def get_protocols_meta(skill_id: str) -> Dict[str, Dict[str, Any]]:
+    """扫描 rules 顶层 .md 作为“协议”，解析 frontmatter 返回 meta 映射。
+
+    返回: {protocol_id: {id, name, estimated_time?, total_steps?, order?, enabled?}}
+    仅扫描规则根目录，忽略子目录（如 companion/）。
+    """
+    rules_dir = SKILLS_DIR / skill_id / "rules"
+    metas: Dict[str, Dict[str, Any]] = {}
+    if not rules_dir.exists():
+        return metas
+
+    for md in rules_dir.glob("*.md"):
+        if md.stem.startswith("_"):
+            continue
+        try:
+            text = md.read_text(encoding="utf-8")
+            fm, _ = parse_frontmatter(text)
+            pid = fm.get("id", md.stem)
+            metas[pid] = {
+                "id": pid,
+                "name": fm.get("name", pid),
+                "estimated_time": fm.get("estimated_time"),
+                "total_steps": fm.get("total_steps"),
+                "order": fm.get("order", 0),
+                "enabled": fm.get("enabled", True),
+            }
+        except Exception:
+            # 忽略单个文件错误
+            continue
+    return metas
+
+
+@lru_cache(maxsize=32)
+def get_protocol_ids(skill_id: str) -> List[str]:
+    """返回启用的协议 ID 列表（按 order/name 排序）。"""
+    metas = get_protocols_meta(skill_id)
+    enabled = [m for m in metas.values() if m.get("enabled", True)]
+    enabled.sort(key=lambda m: (m.get("order", 0), m.get("name", m.get("id"))))
+    return [m["id"] for m in enabled]
+
+
+def get_rule_name(skill_id: str, rule_id: str) -> str:
+    """返回规则显示名（frontmatter.name），失败则回退 rule_id。"""
+    rc = load_rule(skill_id, rule_id)
+    return rc.name if rc else rule_id
+
+
+# ═══════════════════════════════════════════════════════════════════════════
+# Case Index 配置（用于提取特征字段，消除硬编码）
+# ═══════════════════════════════════════════════════════════════════════════
+
+@lru_cache(maxsize=64)
+def get_case_index_config(skill_id: str) -> Dict[str, Any]:
+    """从 SKILL.md frontmatter 读取 case_index 配置。
+
+    约定：
+    case_index:
+      nested_key: "chart"   # 可选
+      fields: ["daymaster", "strength", "pattern"]  # 必选
+    或简写：case_fields: ["..."]
+    """
+    skill_path = SKILLS_DIR / skill_id / "SKILL.md"
+    if not skill_path.exists():
+        return {}
+    try:
+        text = skill_path.read_text(encoding="utf-8")
+        fm, _ = parse_frontmatter(text)
+        cfg = fm.get("case_index") or {}
+        if not cfg and fm.get("case_fields"):
+            cfg = {"fields": fm.get("case_fields")}
+        # 规范化
+        nested_key = cfg.get("nested_key")
+        fields = cfg.get("fields") if isinstance(cfg.get("fields"), list) else []
+        return {"nested_key": nested_key, "fields": fields}
+    except Exception:
+        return {}
+
+
 def get_skill_scenarios(skill_id: str) -> List[str]:
     """获取 Skill 的所有场景
 
@@ -820,6 +958,535 @@ def get_skill_external_tools(skill_id: str) -> List[str]:
     return []
 
 
+# ═══════════════════════════════════════════════════════════════════════════
+# v10: 跨技能契约加载
+# ═══════════════════════════════════════════════════════════════════════════
+
+# 契约缓存
+_skill_contracts_cache: Optional[Dict[str, Any]] = None
+
+
+def load_skill_contract(skill_id: str) -> Optional[Any]:
+    """加载单个 Skill 的契约（exports + imports）
+
+    Args:
+        skill_id: Skill ID
+
+    Returns:
+        SkillContract 对象，如果不存在则返回 None
+    """
+    from .schemas.skill_contract import parse_skill_contract
+
+    skill_path = SKILLS_DIR / skill_id / "SKILL.md"
+    if not skill_path.exists():
+        return None
+
+    try:
+        text = skill_path.read_text(encoding='utf-8')
+        metadata, _ = parse_frontmatter(text)
+        return parse_skill_contract(skill_id, metadata)
+    except Exception as e:
+        logger.warning(f"Failed to load contract for {skill_id}: {e}")
+        return None
+
+
+def load_all_skill_contracts() -> Dict[str, Any]:
+    """加载所有 Skill 的契约
+
+    Returns:
+        {skill_id: SkillContract}
+    """
+    global _skill_contracts_cache
+
+    if _skill_contracts_cache is not None:
+        return _skill_contracts_cache
+
+    _skill_contracts_cache = {}
+
+    for skill_id in get_available_skills():
+        contract = load_skill_contract(skill_id)
+        if contract:
+            _skill_contracts_cache[skill_id] = contract
+
+    logger.info(f"[v10] Loaded {len(_skill_contracts_cache)} skill contracts")
+    return _skill_contracts_cache
+
+
+def get_skill_exports(skill_id: str) -> Optional[Any]:
+    """获取 Skill 的 exports 声明
+
+    Args:
+        skill_id: Skill ID
+
+    Returns:
+        SkillExports 对象，如果没有声明则返回 None
+    """
+    contract = load_skill_contract(skill_id)
+    return contract.exports if contract else None
+
+
+def get_skill_imports(skill_id: str) -> List[Any]:
+    """获取 Skill 的 imports 声明
+
+    Args:
+        skill_id: Skill ID
+
+    Returns:
+        SkillImport 列表
+    """
+    contract = load_skill_contract(skill_id)
+    return contract.imports if contract else []
+
+
+def get_imported_tool_names(skill_id: str) -> List[str]:
+    """获取 Skill 通过 imports 声明的所有工具名（扁平化）
+
+    Args:
+        skill_id: Skill ID
+
+    Returns:
+        工具名列表
+    """
+    contract = load_skill_contract(skill_id)
+    if not contract:
+        return []
+    return contract.get_all_imported_tool_names()
+
+
+def get_imported_tools_by_provider(skill_id: str) -> Dict[str, List[str]]:
+    """获取 Skill 从各 Provider 导入的工具
+
+    Args:
+        skill_id: Skill ID
+
+    Returns:
+        {provider_skill_id: [tool_name, ...]}
+    """
+    contract = load_skill_contract(skill_id)
+    if not contract:
+        return {}
+    return contract.get_imported_tools()
+
+
+def validate_all_contracts() -> Any:
+    """校验所有 Skill 契约
+
+    Returns:
+        ContractValidationResult
+    """
+    from .validators import validate_skill_contracts
+
+    contracts = load_all_skill_contracts()
+    return validate_skill_contracts(contracts)
+
+
+def clear_contracts_cache():
+    """清除契约缓存"""
+    global _skill_contracts_cache
+    _skill_contracts_cache = None
+    logger.info("[v10] Contracts cache cleared")
+
+
+# ═══════════════════════════════════════════════════════════════════════════
+# V9: 渐进式加载函数
+# ═══════════════════════════════════════════════════════════════════════════
+
+def get_core_skill() -> SkillFull:
+    """获取 Core Skill（全程可用，全文加载）- V9 新增
+
+    Core Skill 始终全文加载，不参与渐进式加载。
+    返回包含 SKILL.md 全文和工具定义的 SkillFull 对象。
+    """
+    global _core_skill_cache
+
+    if _core_skill_cache is not None:
+        return _core_skill_cache
+
+    skill_id = "core"
+    skill_path = SKILLS_DIR / skill_id / "SKILL.md"
+
+    if not skill_path.exists():
+        # 返回空的 Core Skill
+        _core_skill_cache = SkillFull(
+            meta=SkillMeta(id="core", name="Vibe", description="生命对话者"),
+            content="",
+            tools=[],
+            rules={}
+        )
+        return _core_skill_cache
+
+    text = skill_path.read_text(encoding='utf-8')
+    metadata, content = parse_frontmatter(text)
+
+    # 构建 SkillMeta
+    meta = SkillMeta(
+        id=metadata.get("id", skill_id),
+        name=metadata.get("name", "Vibe"),
+        description=metadata.get("description", ""),
+        triggers=metadata.get("triggers", []),
+        category=metadata.get("category", "core"),
+    )
+
+    # 加载工具定义
+    tools = _load_skill_tools(skill_id)
+
+    # 加载规则文件
+    rules = _load_skill_rules_content(skill_id)
+
+    _core_skill_cache = SkillFull(
+        meta=meta,
+        content=content,
+        tools=tools,
+        rules=rules,
+    )
+
+    logger.info(f"[V9] Core skill loaded: {len(content)} chars, {len(tools)} tools, {len(rules)} rules")
+    return _core_skill_cache
+
+
+def load_all_skill_metas() -> Dict[str, SkillMeta]:
+    """启动时加载所有非 Core Skill 的 frontmatter - V9 新增
+
+    只加载 frontmatter（SkillMeta），用于 Phase 1 路由。
+    description 内嵌工具列表，无需额外加载。
+    """
+    global _skill_metas_cache
+
+    if _skill_metas_cache is not None:
+        return _skill_metas_cache
+
+    _skill_metas_cache = {}
+
+    for skill_id in get_available_skills():
+        if skill_id == "core":
+            continue
+
+        skill_path = SKILLS_DIR / skill_id / "SKILL.md"
+        if not skill_path.exists():
+            continue
+
+        try:
+            text = skill_path.read_text(encoding='utf-8')
+            metadata, _ = parse_frontmatter(text)
+
+            # 从 description 中提取触发词（如果 frontmatter 中没有）
+            triggers = metadata.get("triggers", [])
+            if not triggers:
+                description = metadata.get("description", "")
+                trigger_match = re.search(r'触发词[：:]\s*([^。.]+)', description)
+                if trigger_match:
+                    trigger_str = trigger_match.group(1)
+                    triggers = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]
+
+            tools_list = _extract_tools_list(skill_id, metadata.get("description", ""))
+
+            _skill_metas_cache[skill_id] = SkillMeta(
+                id=metadata.get("id", skill_id),
+                name=metadata.get("name", skill_id),
+                description=metadata.get("description", ""),
+                triggers=triggers,
+                category=metadata.get("category", "professional"),
+                tools_list=tools_list,
+            )
+        except Exception as e:
+            logger.warning(f"[V9] Failed to load skill meta for {skill_id}: {e}")
+
+    logger.info(f"[V9] Loaded {len(_skill_metas_cache)} skill metas")
+    return _skill_metas_cache
+
+
+def load_skill_full(skill_id: str) -> Optional[SkillFull]:
+    """按需加载 Skill 完整内容 - V9 新增
+
+    Phase 2 时调用，加载 SKILL.md 全文、工具定义、规则文件。
+    """
+    if skill_id == "core":
+        return get_core_skill()
+
+    skill_path = SKILLS_DIR / skill_id / "SKILL.md"
+    if not skill_path.exists():
+        return None
+
+    try:
+        text = skill_path.read_text(encoding='utf-8')
+        metadata, content = parse_frontmatter(text)
+
+        # 从 description 中提取触发词
+        triggers = metadata.get("triggers", [])
+        if not triggers:
+            description = metadata.get("description", "")
+            trigger_match = re.search(r'触发词[：:]\s*([^。.]+)', description)
+            if trigger_match:
+                trigger_str = trigger_match.group(1)
+                triggers = [t.strip() for t in re.split(r'[、,，]', trigger_str) if t.strip()]
+
+        meta = SkillMeta(
+            id=metadata.get("id", skill_id),
+            name=metadata.get("name", skill_id),
+            description=metadata.get("description", ""),
+            triggers=triggers,
+            category=metadata.get("category", "professional"),
+        )
+
+        # 加载工具定义
+        tools = _load_skill_tools(skill_id)
+
+        # 加载规则文件
+        rules = _load_skill_rules_content(skill_id)
+
+        skill_full = SkillFull(
+            meta=meta,
+            content=content,
+            tools=tools,
+            rules=rules,
+        )
+
+        logger.info(f"[V9] Skill {skill_id} full loaded: {len(content)} chars, {len(tools)} tools, {len(rules)} rules")
+        return skill_full
+
+    except Exception as e:
+        logger.error(f"[V9] Failed to load skill full for {skill_id}: {e}")
+        return None
+
+
+def _load_skill_tools(skill_id: str) -> List[ToolDef]:
+    """加载 Skill 的工具定义 - V9 内部函数"""
+    tools_path = SKILLS_DIR / skill_id / "tools" / "tools.yaml"
+    if not tools_path.exists():
+        return []
+
+    try:
+        text = tools_path.read_text(encoding='utf-8')
+        data = yaml.safe_load(text) or {}
+
+        tools = []
+        # V9 格式：tools 列表
+        if "tools" in data:
+            for tool in data["tools"]:
+                tools.append(ToolDef(
+                    name=tool.get("name", ""),
+                    description=tool.get("description", ""),
+                    parameters={p.get("name", ""): p for p in tool.get("parameters", [])},
+                    tool_type=tool.get("type", "action"),
+                ))
+        else:
+            # V2 格式：按类别分组
+            for category in ["routing", "collect", "action", "search", "display", "trigger"]:
+                for tool in data.get(category, []):
+                    tools.append(ToolDef(
+                        name=tool.get("name", ""),
+                        description=tool.get("description", ""),
+                        parameters={p.get("name", ""): p for p in tool.get("parameters", [])},
+                        tool_type=category,
+                    ))
+
+        return tools
+    except Exception as e:
+        logger.warning(f"[V9] Failed to load tools for {skill_id}: {e}")
+        return []
+
+
+def _load_skill_rules_content(skill_id: str) -> Dict[str, str]:
+    """加载 Skill 的所有规则文件内容 - V9 内部函数"""
+    rules_dir = SKILLS_DIR / skill_id / "rules"
+    if not rules_dir.exists():
+        return {}
+
+    rules = {}
+    for md_file in rules_dir.rglob("*.md"):
+        if md_file.stem.startswith("_"):
+            continue
+
+        try:
+            relative_path = md_file.relative_to(rules_dir)
+            rule_id = str(relative_path.with_suffix("")).replace("\\", "/")
+            rules[rule_id] = md_file.read_text(encoding='utf-8')
+        except Exception as e:
+            logger.warning(f"[V9] Failed to load rule {md_file}: {e}")
+
+    return rules
+
+
+def build_phase1_prompt() -> str:
+    """构建 Phase 1 System Prompt - V9 新增
+
+    Phase 1 提供：
+    - Core Skill 全文（精简版）
+    - 其他 Skill 的 frontmatter 列表（id, name, description）
+
+    LLM 基于此选择 Skill(s)。
+    """
+    parts = []
+
+    # 1. Core Skill 全文（精简文本优先：若超过 5000 字符则截断）
+    core = get_core_skill()
+    core_text = core.content
+    if len(core_text) > 5000:
+        core_text = core_text[:5000] + "\n\n…"
+    parts.append(f"# {core.meta.name}\n\n{core_text}")
+
+    # 2. 可用 Skill 列表
+    skill_metas = load_all_skill_metas()
+    if skill_metas:
+        parts.append("\n---\n\n## 可用功能\n")
+        parts.append("根据用户意图，可调用 activate_skills 激活一个或多个技能：\n")
+
+        for skill_id, meta in sorted(skill_metas.items()):
+            desc = meta.description.strip().replace('\n', ' ')
+            if len(desc) > 120:
+                desc = desc[:120] + '…'
+            line = f"- **{meta.name}** (`{skill_id}`): {desc}"
+            if meta.tools_list:
+                tools_text = ", ".join(meta.tools_list[:6])
+                line += f"（工具：{tools_text}）"
+            parts.append(line)
+
+    # 3. 边界规则（来自 core/rules/boundary.md）
+    boundary = load_boundary_rules_text()
+    if boundary:
+        parts.append("\n---\n")
+        parts.append(boundary)
+
+    # 4. Phase 1 约束
+    parts.append("\n---\n## 约束\n- 本轮只允许：activate_skills、ask、show\n- 禁止假设未激活 Skill 的工具存在\n- 禁止编造：不要假装知道用户的命盘/星座数据\n")
+
+    return "\n".join(parts)
+
+
+def _extract_tools_list(skill_id: str, description: str) -> List[str]:
+    """提取工具名清单（优先 tools.yaml，其次从 description 正则解析）。"""
+    try:
+        import yaml  # 本地依赖
+        tools_yaml = SKILLS_DIR / skill_id / "tools" / "tools.yaml"
+        if tools_yaml.exists():
+            data = yaml.safe_load(tools_yaml.read_text(encoding='utf-8')) or {}
+            tools = []
+            # 兼容两种结构：顶层 tools: [] 或 按分组键 []
+            if isinstance(data.get("tools"), list):
+                for item in data["tools"]:
+                    if isinstance(item, dict) and item.get("name"):
+                        tools.append(item["name"])
+            # 遍历所有一级分组键
+            for k, v in data.items():
+                if k in {"version", "skill_id", "description", "phase1_tools"}:
+                    continue
+                if isinstance(v, list):
+                    for item in v:
+                        if isinstance(item, dict) and item.get("name"):
+                            tools.append(item["name"])
+            # 去重保持顺序
+            seen = set()
+            dedup = []
+            for t in tools:
+                if t not in seen:
+                    seen.add(t)
+                    dedup.append(t)
+            return dedup
+    except Exception as e:
+        logger.debug(f"[V9] extract tools_list failed for {skill_id}: {e}")
+
+    # 回退：从 description 提取
+    match = re.search(r'工具[：:]\s*([^\n。]+)', description or "")
+    if match:
+        return [t.strip() for t in re.split(r'[、,，]', match.group(1)) if t.strip()]
+    return []
+
+
+def load_boundary_rules_text() -> str:
+    """读取 Core 边界规则（core/rules/boundary.md）。找不到则返回空。"""
+    path = SKILLS_DIR / "core" / "rules" / "boundary.md"
+    try:
+        if path.exists():
+            return path.read_text(encoding='utf-8')
+    except Exception as e:
+        logger.debug(f"[V9] load boundary rules failed: {e}")
+    return ""
+
+
+def build_phase2_prompt(
+    active_skills: List[str],
+    user_context: Optional[Dict] = None,
+    active_rule: Optional[str] = None
+) -> str:
+    """构建 Phase 2 System Prompt - V9 新增
+
+    Phase 2 提供：
+    - Core Skill 全文（始终存在）
+    - 已激活 Skill 的完整 SKILL.md
+    - 相关 rules/*.md
+    - Profile + Skill Data
+
+    Args:
+        active_skills: 已激活的 Skill ID 列表
+        user_context: 用户上下文
+        active_rule: 当前激活的规则 ID
+
+    Returns:
+        完整的 System Prompt
+    """
+    parts = []
+
+    # 1. Core Skill 全文
+    core = get_core_skill()
+    parts.append(f"# {core.meta.name}\n\n{core.content}")
+
+    # 2. 已激活 Skill 的完整内容
+    for skill_id in active_skills:
+        if skill_id == "core":
+            continue
+
+        skill_full = load_skill_full(skill_id)
+        if skill_full:
+            parts.append(f"\n---\n\n# {skill_full.meta.name}\n\n{skill_full.content}")
+
+            # 如果有激活的规则，加载规则内容
+            if active_rule and active_rule in skill_full.rules:
+                rule_content = skill_full.rules[active_rule]
+                _, rule_body = parse_frontmatter(rule_content)
+                parts.append(f"\n## 当前规则\n{rule_body}")
+
+    # 3. 边界规则（来自 core/rules/boundary.md）
+    boundary = load_boundary_rules_text()
+    if boundary:
+        parts.append(boundary)
+
+    # 4. 用户上下文
+    if user_context:
+        ctx_text = "\n## 用户上下文\n"
+
+        # 出生信息
+        if user_context.get("birth_info"):
+            birth_info = user_context['birth_info']
+            ctx_text += f"\n### 出生信息（已收集）\n"
+            ctx_text += f"{json.dumps(birth_info, ensure_ascii=False)}\n"
+
+        # VibeInsight
+        vibe = user_context.get("vibe", {})
+        if vibe.get("insight"):
+            insight = vibe["insight"]
+            ctx_text += f"\n### 用户画像\n"
+            if insight.get("essence", {}).get("archetype", {}).get("primary"):
+                ctx_text += f"- 主要原型: {insight['essence']['archetype']['primary']}\n"
+
+        # VibeTarget
+        if vibe.get("target"):
+            target = vibe["target"]
+            if target.get("north_star", {}).get("vision_scene"):
+                ctx_text += f"\n### 愿景\n{target['north_star']['vision_scene'][:200]}\n"
+
+        parts.append(ctx_text)
+
+    return "\n".join(parts)
+
+
+def clear_v9_cache():
+    """清除 V9 缓存 - V9 新增"""
+    global _core_skill_cache, _skill_metas_cache
+    _core_skill_cache = None
+    _skill_metas_cache = None
+    logger.info("[V9] Cache cleared")
+
+
 # ═══════════════════════════════════════════════════════════════════════════
 # v7.1: SOP 配置查询函数
 # ═══════════════════════════════════════════════════════════════════════════
@@ -1097,22 +1764,10 @@ def build_system_prompt(
 
     # v10: 伦理边界已在 SKILL.md 全文中，无需重复注入
 
-    # v2.0: 边界规则配置化 - 从 routing.yaml 加载
-    from .routing_config import get_boundary_rules, inject_placeholders
-    boundary_rules = get_boundary_rules()
-    if boundary_rules.get("shared"):
-        # 注入占位符（如 {skill_id}）
-        boundary_shared = inject_placeholders(
-            boundary_rules["shared"],
-            {"skill_id": skill_id}
-        )
-        parts.append(boundary_shared)
-    if boundary_rules.get("phase2"):
-        boundary_phase2 = inject_placeholders(
-            boundary_rules["phase2"],
-            {"skill_id": skill_id}
-        )
-        parts.append(boundary_phase2)
+    # 边界规则：从 core/rules/boundary.md 注入
+    boundary = load_boundary_rules_text()
+    if boundary:
+        parts.append(boundary)
 
     # 用户上下文 - 自动处理所有字段 (v8.0 三层架构兼容)
     if user_context:
@@ -1193,6 +1848,8 @@ def clear_cache():
     load_scenario.cache_clear()
     load_rule.cache_clear()
     _load_skill_md_content.cache_clear()  # v10
+    clear_v9_cache()  # V9
+    clear_contracts_cache()  # v10: 契约缓存
     logger.info("Skill cache cleared")
 
 
diff --git a/apps/api/services/agent/tool_registry.py b/apps/api/services/agent/tool_registry.py
index 99a8fa9..b12c72e 100644
--- a/apps/api/services/agent/tool_registry.py
+++ b/apps/api/services/agent/tool_registry.py
@@ -1,5 +1,5 @@
 """
-Unified Tool Registry v6 - 统一工具注册表
+Unified Tool Registry v7 - 统一工具注册表
 
 解决工具注册的硬编码问题：
 1. 从 YAML 加载工具定义 (Single Source of Truth)
@@ -10,6 +10,12 @@ V6.1 更新：
 - 全局工具从 skills/core/tools/ 加载
 - 移除对 GLOBAL_TOOLS 硬编码的依赖
 
+V7.0 更新（跨技能契约）：
+- 支持 Provider/Consumer 双向契约
+- imports ⊆ exports 验证
+- 运行时访问控制（订阅/配额）
+- 审计日志
+
 新增工具只需修改 2 处：
 1. skills/{skill_id}/tools/tools.yaml - 工具定义
 2. skills/{skill_id}/tools/handlers.py - @tool_handler 执行器
@@ -32,6 +38,7 @@ from pathlib import Path
 from typing import Dict, Any, List, Optional, Callable, Awaitable, Union
 from dataclasses import dataclass, field
 from functools import wraps
+from datetime import datetime
 
 from .tool_schema import ToolDef, load_skill_tools, get_global_tools
 
@@ -160,30 +167,22 @@ class UnifiedToolRegistry:
         """获取 Skill 的所有工具 (OpenAI 格式)
 
         V6.2 更新：按需加载全局工具
-        V12 更新：支持 includes 从 routing.yaml 加载其他 Skill 的工具
+        V7.0 更新：支持 Provider/Consumer 契约（imports/exports）
 
         工具加载顺序：
         1. 全局工具（从 core skill 加载）
         2. 自身工具
-        3. includes 中声明的 Skill 的工具（v12）
-        4. external_tools 中声明的特定工具（v7.3 兼容）
+        3. imports 中声明的授权工具（v7.0 新增）
+        4. external_tools 中声明的特定工具（v7.3 兼容，将被废弃）
         """
         cls.initialize()
 
         tools = []
         added_tool_names = set()  # 避免重复添加
 
-        # 获取 Skill 声明需要的全局工具
-        # v12: 优先从 routing.yaml 读取，fallback 到 SKILL.md
-        try:
-            from .routing_config import get_skill_global_tools_from_routing
-            declared_global_tools = get_skill_global_tools_from_routing(skill_id)
-        except ImportError:
-            declared_global_tools = []
-
-        if not declared_global_tools:
-            from .skill_loader import get_skill_global_tools
-            declared_global_tools = get_skill_global_tools(skill_id)
+        # 获取 Skill 声明需要的全局工具（LLM-First：仅从 SKILL.md）
+        from .skill_loader import get_skill_global_tools
+        declared_global_tools = get_skill_global_tools(skill_id)
 
         # 全局工具（从 core skill 加载）
         all_global_tools = get_global_tools()
@@ -206,23 +205,37 @@ class UnifiedToolRegistry:
                         tools.append(tool.to_openai_format())
                         added_tool_names.add(name)
 
-        # v12: includes - 从 routing.yaml 读取需要包含的 Skill 工具
-        try:
-            from .routing_config import get_skill_includes
-            includes = get_skill_includes(skill_id)
-            for inc_skill_id in includes:
-                for name, tool in cls._tool_defs.items():
-                    if getattr(tool, 'skill_id', None) == inc_skill_id:
-                        if name not in added_tool_names:
-                            tools.append(tool.to_openai_format())
-                            added_tool_names.add(name)
-        except ImportError:
-            pass
-
-        # v7.3: 外部工具（从其他 skill 导入）- 兼容旧配置
+        # v7.0: imports 授权工具（Provider/Consumer 契约）
+        from .skill_loader import get_imported_tools_by_provider, get_skill_exports
+        imported_tools = get_imported_tools_by_provider(skill_id)
+
+        for provider_id, tool_names in imported_tools.items():
+            # 获取 Provider 的 exports（用于校验）
+            provider_exports = get_skill_exports(provider_id)
+
+            for tool_name in tool_names:
+                # 如果 Provider 有 exports，校验工具是否被导出
+                if provider_exports and not provider_exports.has_tool(tool_name):
+                    logger.warning(
+                        f"[Contract] {skill_id} imports {tool_name} from {provider_id}, "
+                        f"but it's not in {provider_id}.exports.tools"
+                    )
+                    continue  # 跳过未导出的工具
+
+                # 添加工具
+                if tool_name in cls._tool_defs and tool_name not in added_tool_names:
+                    tools.append(cls._tool_defs[tool_name].to_openai_format())
+                    added_tool_names.add(tool_name)
+                    logger.debug(f"[Contract] {skill_id} imported {tool_name} from {provider_id}")
+
+        # v7.3: 外部工具（从其他 skill 导入）- 兼容旧配置（将被废弃）
         from .skill_loader import get_skill_external_tools
         external_tool_names = get_skill_external_tools(skill_id)
         if external_tool_names:
+            logger.warning(
+                f"[Deprecated] {skill_id} uses external_tools, "
+                f"please migrate to imports syntax"
+            )
             for name, tool in cls._tool_defs.items():
                 if name in external_tool_names:
                     if name not in added_tool_names:
@@ -256,13 +269,36 @@ class UnifiedToolRegistry:
         args: Dict[str, Any],
         context: ToolContext
     ) -> Dict[str, Any]:
-        """执行工具"""
+        """执行工具
+
+        V7.0 更新：跨技能访问控制
+        - 检查 imports 授权
+        - 订阅检查
+        - 配额检查
+        - 审计日志
+        """
         cls.initialize()
 
         if tool_name not in cls._handlers:
             logger.warning(f"No handler for tool: {tool_name}")
             return {"error": f"Tool handler not found: {tool_name}"}
 
+        # V7.0: 跨技能访问控制
+        tool_def = cls._tool_defs.get(tool_name)
+        provider_skill_id = getattr(tool_def, 'skill_id', None) if tool_def else None
+        consumer_skill_id = context.skill_id
+
+        # 如果是跨技能调用，进行访问控制
+        if provider_skill_id and consumer_skill_id and provider_skill_id != consumer_skill_id:
+            access_result = await cls._check_cross_skill_access(
+                consumer_skill_id=consumer_skill_id,
+                provider_skill_id=provider_skill_id,
+                tool_name=tool_name,
+                user_id=context.user_id,
+            )
+            if not access_result.get("allowed"):
+                return access_result
+
         handler = cls._handlers[tool_name]
 
         try:
@@ -270,11 +306,133 @@ class UnifiedToolRegistry:
             result = handler(args, context)
             if asyncio.iscoroutine(result):
                 result = await result
+
+            # V7.0: 审计日志（跨技能调用）
+            if provider_skill_id and consumer_skill_id and provider_skill_id != consumer_skill_id:
+                cls._log_cross_skill_call(
+                    consumer_skill_id=consumer_skill_id,
+                    provider_skill_id=provider_skill_id,
+                    tool_name=tool_name,
+                    user_id=context.user_id,
+                    success=True,
+                )
+
             return result
         except Exception as e:
             logger.error(f"Tool execution failed: {tool_name}, error: {e}")
+
+            # V7.0: 审计日志（失败）
+            if provider_skill_id and consumer_skill_id and provider_skill_id != consumer_skill_id:
+                cls._log_cross_skill_call(
+                    consumer_skill_id=consumer_skill_id,
+                    provider_skill_id=provider_skill_id,
+                    tool_name=tool_name,
+                    user_id=context.user_id,
+                    success=False,
+                    error=str(e),
+                )
+
             return {"error": str(e)}
 
+    @classmethod
+    async def _check_cross_skill_access(
+        cls,
+        consumer_skill_id: str,
+        provider_skill_id: str,
+        tool_name: str,
+        user_id: str,
+    ) -> Dict[str, Any]:
+        """检查跨技能工具访问权限
+
+        Returns:
+            {"allowed": True} 或 {"allowed": False, "error": "...", ...}
+        """
+        from .skill_loader import load_skill_contract, get_skill_exports
+
+        # 1. 获取契约
+        consumer_contract = load_skill_contract(consumer_skill_id)
+        provider_contract = load_skill_contract(provider_skill_id)
+
+        if not consumer_contract:
+            return {"allowed": True}  # 没有契约，允许（兼容期）
+
+        # 2. 检查 imports 声明
+        from .validators import validate_cross_skill_tool_access
+
+        if provider_contract:
+            allowed, error_msg = validate_cross_skill_tool_access(
+                consumer_skill_id=consumer_skill_id,
+                provider_skill_id=provider_skill_id,
+                tool_name=tool_name,
+                consumer_contract=consumer_contract,
+                provider_contract=provider_contract,
+            )
+            if not allowed:
+                logger.warning(f"[Contract] Access denied: {error_msg}")
+                return {
+                    "allowed": False,
+                    "error": "tool_not_imported",
+                    "message": error_msg,
+                }
+
+        # 3. 订阅检查
+        provider_exports = get_skill_exports(provider_skill_id)
+        if provider_exports:
+            # 检查是否需要订阅
+            if provider_exports.access.requires_subscription:
+                if not provider_exports.is_free_tool(tool_name):
+                    # TODO: 实际检查用户订阅状态
+                    # has_subscription = await check_user_subscription(user_id, provider_skill_id)
+                    # if not has_subscription:
+                    #     return {
+                    #         "allowed": False,
+                    #         "error": "subscription_required",
+                    #         "skill_id": provider_skill_id,
+                    #         "action": "show_subscribe_card",
+                    #     }
+                    pass
+
+            # 4. 配额检查
+            rate_limit = provider_exports.get_rate_limit(tool_name)
+            if rate_limit and rate_limit != "unlimited":
+                # TODO: 实际检查配额
+                # if is_rate_limited(user_id, tool_name, rate_limit):
+                #     return {
+                #         "allowed": False,
+                #         "error": "rate_limited",
+                #         "retry_after": get_retry_after(...),
+                #     }
+                pass
+
+        return {"allowed": True}
+
+    @classmethod
+    def _log_cross_skill_call(
+        cls,
+        consumer_skill_id: str,
+        provider_skill_id: str,
+        tool_name: str,
+        user_id: str,
+        success: bool,
+        error: Optional[str] = None,
+    ):
+        """记录跨技能调用审计日志"""
+        log_data = {
+            "type": "cross_skill_call",
+            "consumer": consumer_skill_id,
+            "provider": provider_skill_id,
+            "tool": tool_name,
+            "user_id": user_id,
+            "success": success,
+        }
+        if error:
+            log_data["error"] = error
+
+        if success:
+            logger.info(f"[Audit] {consumer_skill_id} -> {provider_skill_id}.{tool_name} (user={user_id})")
+        else:
+            logger.warning(f"[Audit] FAILED: {consumer_skill_id} -> {provider_skill_id}.{tool_name} (user={user_id}): {error}")
+
     @classmethod
     def get_schema(cls, skill_id: Optional[str] = None) -> Dict[str, Any]:
         """获取工具 Schema (用于前端)
@@ -291,27 +449,20 @@ class UnifiedToolRegistry:
             from .skill_loader import get_skill_external_tools
             external_tool_names = set(get_skill_external_tools(skill_id))
 
-        # v12: 获取 includes 中的 Skill ID
+        # LLM-First: 不再支持 includes（移除 routing.yaml 聚合）
         includes_skill_ids = set()
-        if skill_id:
-            try:
-                from .routing_config import get_skill_includes
-                includes_skill_ids = set(get_skill_includes(skill_id))
-            except ImportError:
-                pass
 
         tools = []
         for name, tool in cls._tool_defs.items():
             tool_skill_id = getattr(tool, 'skill_id', None)
 
             if skill_id:
-                # 包含条件: 自身工具 OR 全局工具 OR 外部工具 OR includes 的 Skill 工具
+                # 包含条件: 自身工具 OR 全局工具 OR 外部工具
                 is_own_tool = tool_skill_id == skill_id
                 is_global = name in global_tool_names
                 is_external = name in external_tool_names
-                is_included = tool_skill_id in includes_skill_ids
 
-                if not (is_own_tool or is_global or is_external or is_included):
+                if not (is_own_tool or is_global or is_external):
                     continue
 
             tools.append({
diff --git a/apps/api/skills/jungastro/SKILL.md b/apps/api/skills/jungastro/SKILL.md
index 6752dc4..34c6e71 100644
--- a/apps/api/skills/jungastro/SKILL.md
+++ b/apps/api/skills/jungastro/SKILL.md
@@ -1,11 +1,35 @@
 ---
 id: jungastro
 name: 荣格心理占星
-version: 2.0.0
-description: 基于 Carl Jung 分析心理学框架，将占星作为心理自我认知工具
+version: 3.0.0
+description: |
+  荣格心理占星。基于 Carl Jung 分析心理学框架，将占星作为心理自我认知工具。
+  工具：collect_birth_info, show_psychological_portrait, show_shadow_analysis, show_individuation_path, show_psychological_functions, show_relationship_dynamics, show_skill_intro
+triggers:
+  - 荣格
+  - 心理占星
+  - 阴影整合
+  - 个体化
+  - 心理画像
 category: self-awareness
-# SOP/工具/数据依赖配置已迁移到 routing.yaml (v12)
-# skill_data: [bazi, zodiac], includes: [zodiac]
+requires_birth_info: true
+requires_compute: true
+compute_type: zodiac
+compute_tool: calculate_zodiac
+collect_tool: collect_birth_info
+requires_skill_data:
+  - bazi
+  - zodiac
+
+# ══════════════════════════════════════════════════════════════
+# 从其他 Skill 引用的能力（Consumer 契约）
+# ══════════════════════════════════════════════════════════════
+imports:
+  - from: zodiac
+    tools:
+      - calculate_zodiac
+      - get_chart_snapshot
+    min_version: "1.0"
 ---
 
 # 荣格心理占星 Skill
diff --git a/apps/api/skills/zodiac/SKILL.md b/apps/api/skills/zodiac/SKILL.md
index 441a7fa..3bb3db7 100644
--- a/apps/api/skills/zodiac/SKILL.md
+++ b/apps/api/skills/zodiac/SKILL.md
@@ -1,10 +1,101 @@
 ---
 id: zodiac
 name: 西方占星
-version: 2.0.0
-description: 融汇 Robert Hand、Sue Tompkins、Howard Sasportas 等大师智慧的心理占星分析
+version: 3.0.0
+description: |
+  星盘计算与解读。融汇 Robert Hand、Sue Tompkins 等大师智慧的心理占星分析。
+  工具：collect_zodiac_info, calculate_zodiac, show_zodiac_chart, show_zodiac_transit, show_zodiac_synastry, show_skill_intro
+triggers:
+  - 星座
+  - 星盘
+  - 占星
+  - 上升
+  - 月亮星座
+  - 太阳星座
 category: astrology
-# SOP/工具配置已迁移到 routing.yaml (v12)
+requires_birth_info: true
+requires_compute: true
+compute_tool: calculate_zodiac
+collect_tool: collect_zodiac_info
+
+# ══════════════════════════════════════════════════════════════
+# 对外导出能力（Provider 契约）
+# ══════════════════════════════════════════════════════════════
+exports:
+  api_version: "1.0"
+  tools:
+    - name: calculate_zodiac
+      description: 计算星盘，使用 Swiss Ephemeris 进行精确天文计算
+      input_schema:
+        type: object
+        required: []
+        properties:
+          birth_date:
+            type: string
+            format: date
+            description: 出生日期 (YYYY-MM-DD)，不提供时从 profile 读取
+          birth_time:
+            type: string
+            pattern: "^\\d{2}:\\d{2}$"
+            description: 出生时间 (HH:MM)
+          birth_place:
+            type: string
+            description: 出生地点
+      output_schema:
+        type: object
+        properties:
+          chart:
+            type: object
+            description: 完整星盘数据
+          sun_sign:
+            type: string
+            description: 太阳星座
+          moon_sign:
+            type: string
+            description: 月亮星座
+          rising_sign:
+            type: string
+            description: 上升星座
+          planets:
+            type: array
+            description: 行星位置列表
+          houses:
+            type: array
+            description: 宫位列表
+          aspects:
+            type: array
+            description: 相位列表
+
+    - name: get_chart_snapshot
+      description: 获取星盘快照（只读，用于跨技能数据共享）
+      input_schema:
+        type: object
+        properties:
+          include_aspects:
+            type: boolean
+            default: false
+            description: 是否包含相位数据
+      output_schema:
+        type: object
+        properties:
+          sun_sign:
+            type: string
+          moon_sign:
+            type: string
+          rising_sign:
+            type: string
+          planets:
+            type: array
+            description: 行星位置简要列表
+
+  access:
+    requires_subscription: false
+    free_tools:
+      - calculate_zodiac
+      - get_chart_snapshot
+    rate_limit:
+      calculate_zodiac: "100/day"
+      get_chart_snapshot: unlimited
 ---
 
 # 西方占星 Skill