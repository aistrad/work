     1→"""
     2→路由配置加载器 - Single Source of Truth
     3→
     4→从 skills/core/config/routing.yaml 加载所有路由相关配置，
     5→避免在代码中重复定义元数据。
     6→"""
     7→import os
     8→import yaml
     9→import logging
    10→from typing import Dict, Any, List, Optional
    11→from functools import lru_cache
    12→
    13→logger = logging.getLogger(__name__)
    14→
    15→# 配置文件路径
    16→CONFIG_PATH = os.path.join(
    17→    os.path.dirname(__file__),
    18→    "../../skills/core/config/routing.yaml"
    19→)
    20→
    21→
    22→@lru_cache(maxsize=1)
    23→def load_routing_config() -> Dict[str, Any]:
    24→    """加载路由配置（带缓存）"""
    25→    try:
    26→        with open(CONFIG_PATH, "r", encoding="utf-8") as f:
    27→            config = yaml.safe_load(f)
    28→            logger.info(f"[RoutingConfig] Loaded from {CONFIG_PATH}")
    29→            return config or {}
    30→    except Exception as e:
    31→        logger.error(f"[RoutingConfig] Failed to load config: {e}")
    32→        return {}
    33→
    34→
    35→def get_phase1_prompt() -> str:
    36→    """获取 Phase 1 System Prompt"""
    37→    config = load_routing_config()
    38→    return config.get("phase1_prompt", "")
    39→
    40→
    41→def get_protocol_meta(protocol_id: str) -> Optional[Dict[str, Any]]:
    42→    """获取协议元数据"""
    43→    config = load_routing_config()
    44→    protocols = config.get("protocols", {})
    45→    return protocols.get(protocol_id)
    46→
    47→
    48→def get_all_protocols() -> Dict[str, Dict[str, Any]]:
    49→    """获取所有协议元数据"""
    50→    config = load_routing_config()
    51→    return config.get("protocols", {})
    52→
    53→
    54→def get_skill_routing_config(skill_id: str) -> Optional[Dict[str, Any]]:
    55→    """获取 Skill 路由配置"""
    56→    config = load_routing_config()
    57→    skills = config.get("skills", {})
    58→    return skills.get(skill_id)
    59→
    60→
    61→def get_all_skill_routing() -> Dict[str, Dict[str, Any]]:
    62→    """获取所有 Skill 路由配置"""
    63→    config = load_routing_config()
    64→    return config.get("skills", {})
    65→
    66→
    67→# ═══════════════════════════════════════════════════════════════
    68→# v12: 统一配置框架查询函数
    69→# ═══════════════════════════════════════════════════════════════
    70→
    71→def get_skill_data_deps(skill_id: str) -> List[str]:
    72→    """
    73→    获取需要加载的 skill_data 列表 (v12)
    74→
    75→    根据 routing.yaml 中的 skill_data 配置返回需要加载的数据。
    76→    始终包含自身，然后添加配置中声明的依赖。
    77→
    78→    Args:
    79→        skill_id: Skill 标识
    80→
    81→    Returns:
    82→        需要加载数据的 Skill ID 列表，始终包含自身
    83→
    84→    示例:
    85→        get_skill_data_deps("jungastro") → ["jungastro", "bazi", "zodiac"]
    86→        get_skill_data_deps("bazi") → ["bazi"]
    87→    """
    88→    config = get_skill_routing_config(skill_id)
    89→    if not config:
    90→        return [skill_id]
    91→
    92→    deps = config.get("skill_data", [])
    93→
    94→    # 始终包含自身
    95→    if skill_id not in deps:
    96→        deps = [skill_id] + deps
    97→
    98→    return deps
    99→
   100→
   101→def get_skill_includes(skill_id: str) -> List[str]:
   102→    """
   103→    获取需要加载工具的 Skill 列表 (v12)
   104→
   105→    根据 routing.yaml 中的 includes 配置返回需要加载工具的 Skill 列表。
   106→    不包含自身（自身工具由 ToolRegistry 默认加载）。
   107→
   108→    Args:
   109→        skill_id: Skill 标识
   110→
   111→    Returns:
   112→        需要加载工具的 Skill ID 列表
   113→
   114→    示例:
   115→        get_skill_includes("jungastro") → ["zodiac"]
   116→        get_skill_includes("synastry") → ["bazi", "zodiac"]
   117→        get_skill_includes("bazi") → []
   118→    """
   119→    config = get_skill_routing_config(skill_id)
   120→    if not config:
   121→        return []
   122→
   123→    return config.get("includes", [])
   124→
   125→
   126→def get_skill_global_tools_from_routing(skill_id: str) -> List[str]:
   127→    """
   128→    获取 Skill 声明需要的全局工具列表 (v12)
   129→
   130→    从 routing.yaml 读取 global_tools 配置。
   131→
   132→    Args:
   133→        skill_id: Skill 标识
   134→
   135→    Returns:
   136→        需要的全局工具名称列表
   137→    """
   138→    config = get_skill_routing_config(skill_id)
   139→    if not config:
   140→        return []
   141→
   142→    return config.get("global_tools", [])
   143→
   144→
   145→def get_sop_template(template_name: str) -> str:
   146→    """获取 SOP 规则模板"""
   147→    config = load_routing_config()
   148→    templates = config.get("sop_templates", {})
   149→    return templates.get(template_name, "")
   150→
   151→
   152→def get_welcome_config() -> Dict[str, Any]:
   153→    """获取欢迎消息配置"""
   154→    config = load_routing_config()
   155→    return config.get("welcome", {})
   156→
   157→
   158→def get_boundary_rules() -> Dict[str, str]:
   159→    """获取边界规则配置 (v2.0)"""
   160→    config = load_routing_config()
   161→    return config.get("boundary_rules", {})
   162→
   163→
   164→def inject_placeholders(template: str, context: Optional[Dict[str, Any]] = None) -> str:
   165→    """
   166→    注入占位符到模板中 (v2.0)
   167→
   168→    支持的占位符：
   169→    - {boundary_rules_shared}: 通用边界规则
   170→    - {boundary_rules_phase2}: Phase 2 专属边界规则
   171→    - {skill_id}: Skill ID (从 context 获取)
   172→    - 其他 context 中的键值对
   173→
   174→    Args:
   175→        template: 包含占位符的模板字符串
   176→        context: 上下文字典，用于替换占位符
   177→
   178→    Returns:
   179→        替换后的字符串
   180→    """
   181→    if not template:
   182→        return template
   183→
   184→    # 获取边界规则
   185→    boundary_rules = get_boundary_rules()
   186→
   187→    # 准备替换映射
   188→    replacements = {
   189→        "boundary_rules_shared": boundary_rules.get("shared", ""),
   190→        "boundary_rules_phase2": boundary_rules.get("phase2", ""),
   191→    }
   192→
   193→    # 合并 context
   194→    if context:
   195→        replacements.update(context)
   196→
   197→    # 执行替换
   198→    result = template
   199→    for key, value in replacements.items():
   200→        placeholder = "{" + key + "}"
   201→        if placeholder in result:
   202→            result = result.replace(placeholder, str(value) if value else "")
   203→
   204→    return result
   205→
   206→
   207→def build_protocol_tool_description() -> str:
   208→    """
   209→    构建 show_protocol_invitation 工具的描述
   210→    从配置文件动态生成，避免硬编码
   211→    """
   212→    protocols = get_all_protocols()
   213→    if not protocols:
   214→        return "展示协议邀请卡片"
   215→
   216→    lines = ["展示协议邀请卡片，引导用户进入结构化协议流程。\n"]
   217→    lines.append("## 可用协议\n")
   218→    lines.append("| protocol_id | 名称 | 适用场景 | 时长 |")
   219→    lines.append("|-------------|------|---------|------|")
   220→
   221→    for pid, meta in protocols.items():
   222→        name = meta.get("name", pid)
   223→        desc = meta.get("description", "")[:20] + "..."
   224→        time = meta.get("estimated_time", "10分钟")
   225→        lines.append(f"| {pid} | {name} | {desc} | {time} |")
   226→
   227→    lines.append("\n## 触发词映射\n")
   228→    for pid, meta in protocols.items():
   229→        triggers = meta.get("triggers", [])
   230→        if triggers:
   231→            lines.append(f"- {pid}: {', '.join(triggers[:3])}")
   232→
   233→    lines.append("\n## 重要")
   234→    lines.append("匹配到协议关键词时，必须调用此工具！")
   235→
   236→    return "\n".join(lines)
   237→
   238→
   239→def build_skill_tool_description() -> str:
   240→    """
   241→    构建 activate_skill 工具的描述 - v10.1: 包含 rule 选择指引
   242→    从配置文件动态生成
   243→    """
   244→    from .skill_loader import load_skill, get_available_skills, get_skill_rules, load_rule
   245→
   246→    available_skills = [s for s in get_available_skills() if s != "core"]
   247→    skill_routing = get_all_skill_routing()
   248→
   249→    lines = ["激活专业技能来回答用户问题。\n"]
   250→    lines.append("## 可用技能\n")
   251→
   252→    for skill_id in available_skills:
   253→        skill = load_skill(skill_id)
   254→        routing = skill_routing.get(skill_id, {})
   255→
   256→        if skill:
   257→            desc = routing.get("short_desc") or skill.description
   258→            if len(desc) > 50:
   259→                desc = desc[:50] + "..."
   260→            triggers = routing.get("triggers", skill.triggers or [])[:3]
   261→            trigger_text = "、".join(triggers) if triggers else ""
   262→            lines.append(f"- **{skill_id}**: {desc}（{trigger_text}）")
   263→
   264→            # v10.1: 列出可选 rules
   265→            rules = get_skill_rules(skill_id)
   266→            if rules and len(rules) > 0:
   267→                lines.append(f"  可选规则（rule 参数）：")
   268→                for rule_id in rules[:3]:  # 最多显示 3 个
   269→                    rule = load_rule(skill_id, rule_id)
   270→                    if rule:
   271→                        rule_name = getattr(rule, 'name', rule_id)
   272→                        tags = getattr(rule, 'tags', [])
   273→                        tags_text = "、".join(tags[:2]) if tags else ""
   274→                        lines.append(f"    - `{rule_id}`: {rule_name}（{tags_text}）")
   275→
   276→    lines.append("\n## 参数说明")
   277→    lines.append("- `skill`: 必需，技能 ID")
   278→    lines.append("- `rule`: 可选，规则 ID。用户意图明确匹配某规则时传入")
   279→
   280→    lines.append("\n## rule 参数使用指南")
   281→    lines.append("- 用户说'做人生重置' → `activate_skill(skill='lifecoach', rule='dankoe')`")
   282→    lines.append("- 用户说'算命'（无明确 rule）→ `activate_skill(skill='bazi')`")
   283→    lines.append("- 用户说'七个习惯' → `activate_skill(skill='lifecoach', rule='covey')`")
   284→
   285→    lines.append("\n## 何时调用")
   286→    lines.append("- 用户明确需要某个专业领域的帮助")
   287→    lines.append("- 用户提到了技能相关的关键词")
   288→
   289→    return "\n".join(lines)
   290→
   291→
   292→def reload_config():
   293→    """重新加载配置（清除缓存）"""
   294→    load_routing_config.cache_clear()
   295→    logger.info("[RoutingConfig] Cache cleared, will reload on next access")
   296→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
