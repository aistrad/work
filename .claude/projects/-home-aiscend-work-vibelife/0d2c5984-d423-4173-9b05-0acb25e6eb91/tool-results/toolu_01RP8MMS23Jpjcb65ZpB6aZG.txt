     1→"""
     2→Unified Tool Registry v6 - 统一工具注册表
     3→
     4→解决工具注册的硬编码问题：
     5→1. 从 YAML 加载工具定义 (Single Source of Truth)
     6→2. 使用 @tool_handler 装饰器动态注册执行器
     7→3. 消除 if-elif 分发，使用注册表查找
     8→
     9→V6.1 更新：
    10→- 全局工具从 skills/core/tools/ 加载
    11→- 移除对 GLOBAL_TOOLS 硬编码的依赖
    12→
    13→新增工具只需修改 2 处：
    14→1. skills/{skill_id}/tools/tools.yaml - 工具定义
    15→2. skills/{skill_id}/tools/handlers.py - @tool_handler 执行器
    16→
    17→用法：
    18→    from services.agent.tool_registry import tool_handler, ToolRegistry
    19→
    20→    @tool_handler("show_bazi_chart")
    21→    async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:
    22→        return {"chart": ...}
    23→
    24→    # CoreAgent 中使用
    25→    tools = ToolRegistry.get_tools_for_skill("bazi")
    26→    result = await ToolRegistry.execute("show_bazi_chart", args, context)
    27→"""
    28→import logging
    29→import importlib
    30→import asyncio
    31→from pathlib import Path
    32→from typing import Dict, Any, List, Optional, Callable, Awaitable, Union
    33→from dataclasses import dataclass, field
    34→from functools import wraps
    35→
    36→from .tool_schema import ToolDef, load_skill_tools, get_global_tools
    37→
    38→logger = logging.getLogger(__name__)
    39→
    40→SKILLS_DIR = Path(__file__).parent.parent.parent / "skills"
    41→
    42→
    43→@dataclass
    44→class ToolContext:
    45→    """工具执行上下文"""
    46→    user_id: str
    47→    user_tier: str = "free"
    48→    profile: Dict[str, Any] = field(default_factory=dict)
    49→    skill_data: Dict[str, Any] = field(default_factory=dict)
    50→    skill_id: Optional[str] = None
    51→    scenario_id: Optional[str] = None
    52→    conversation_id: Optional[str] = None
    53→
    54→
    55→# 工具执行器类型: 同步或异步函数
    56→ToolHandler = Callable[[Dict[str, Any], ToolContext], Union[Dict[str, Any], Awaitable[Dict[str, Any]]]]
    57→
    58→
    59→class UnifiedToolRegistry:
    60→    """
    61→    统一工具注册表
    62→
    63→    - 工具定义从 YAML 加载
    64→    - 执行器通过 @tool_handler 装饰器注册
    65→    - 支持全局工具和 Skill 专属工具
    66→    """
    67→
    68→    # 工具定义缓存: {tool_name: ToolDef}
    69→    _tool_defs: Dict[str, ToolDef] = {}
    70→
    71→    # 工具执行器: {tool_name: handler_function}
    72→    _handlers: Dict[str, ToolHandler] = {}
    73→
    74→    # 已加载的 Skill
    75→    _loaded_skills: set = set()
    76→
    77→    # 是否已初始化
    78→    _initialized: bool = False
    79→
    80→    @classmethod
    81→    def initialize(cls):
    82→        """初始化注册表，加载全局工具"""
    83→        if cls._initialized:
    84→            return
    85→
    86→        # 从 core skill 加载全局工具定义
    87→        global_tools = get_global_tools()
    88→        for tool in global_tools:
    89→            tool.is_global = True
    90→            cls._tool_defs[tool.name] = tool
    91→
    92→        # 加载 core skill 的 handlers
    93→        cls._load_handlers_module("core")
    94→
    95→        # 自动发现并加载所有 Skill 的工具
    96→        cls._auto_discover_skills()
    97→
    98→        cls._initialized = True
    99→        logger.info(f"ToolRegistry initialized: {len(cls._tool_defs)} tools, {len(cls._handlers)} handlers")
   100→
   101→    @classmethod
   102→    def _auto_discover_skills(cls):
   103→        """自动发现并加载所有 Skill"""
   104→        if not SKILLS_DIR.exists():
   105→            logger.warning(f"Skills directory not found: {SKILLS_DIR}")
   106→            return
   107→
   108→        for skill_dir in SKILLS_DIR.iterdir():
   109→            if skill_dir.is_dir() and skill_dir.name != "__pycache__":
   110→                skill_id = skill_dir.name
   111→                cls.load_skill(skill_id)
   112→
   113→    @classmethod
   114→    def load_skill(cls, skill_id: str):
   115→        """加载 Skill 的工具定义和执行器"""
   116→        if skill_id in cls._loaded_skills:
   117→            return
   118→
   119→        # 1. 从 YAML 加载工具定义
   120→        tools = load_skill_tools(skill_id)
   121→        for tool in tools:
   122→            tool.skill_id = skill_id  # 标记所属 Skill
   123→            cls._tool_defs[tool.name] = tool
   124→
   125→        # 2. 尝试加载执行器模块
   126→        cls._load_handlers_module(skill_id)
   127→
   128→        cls._loaded_skills.add(skill_id)
   129→        logger.debug(f"Loaded skill '{skill_id}': {len(tools)} tools")
   130→
   131→    @classmethod
   132→    def _load_handlers_module(cls, skill_id: str):
   133→        """加载 Skill 的 handlers 模块"""
   134→        handlers_path = SKILLS_DIR / skill_id / "tools" / "handlers.py"
   135→        if not handlers_path.exists():
   136→            logger.debug(f"No handlers module for skill '{skill_id}'")
   137→            return
   138→
   139→        try:
   140→            module_name = f"skills.{skill_id}.tools.handlers"
   141→            importlib.import_module(module_name)
   142→            logger.debug(f"Loaded handlers module: {module_name}")
   143→        except ImportError as e:
   144→            logger.warning(f"Failed to import handlers for '{skill_id}': {e}")
   145→
   146→    @classmethod
   147→    def register_handler(cls, tool_name: str, handler: ToolHandler):
   148→        """注册工具执行器"""
   149→        cls._handlers[tool_name] = handler
   150→        logger.debug(f"Registered handler: {tool_name}")
   151→
   152→    @classmethod
   153→    def get_tool_def(cls, tool_name: str) -> Optional[ToolDef]:
   154→        """获取工具定义"""
   155→        cls.initialize()
   156→        return cls._tool_defs.get(tool_name)
   157→
   158→    @classmethod
   159→    def get_tools_for_skill(cls, skill_id: str) -> List[Dict[str, Any]]:
   160→        """获取 Skill 的所有工具 (OpenAI 格式)
   161→
   162→        V6.2 更新：按需加载全局工具
   163→        V12 更新：支持 includes 从 routing.yaml 加载其他 Skill 的工具
   164→
   165→        工具加载顺序：
   166→        1. 全局工具（从 core skill 加载）
   167→        2. 自身工具
   168→        3. includes 中声明的 Skill 的工具（v12）
   169→        4. external_tools 中声明的特定工具（v7.3 兼容）
   170→        """
   171→        cls.initialize()
   172→
   173→        tools = []
   174→        added_tool_names = set()  # 避免重复添加
   175→
   176→        # 获取 Skill 声明需要的全局工具
   177→        # v12: 优先从 routing.yaml 读取，fallback 到 SKILL.md
   178→        try:
   179→            from .routing_config import get_skill_global_tools_from_routing
   180→            declared_global_tools = get_skill_global_tools_from_routing(skill_id)
   181→        except ImportError:
   182→            declared_global_tools = []
   183→
   184→        if not declared_global_tools:
   185→            from .skill_loader import get_skill_global_tools
   186→            declared_global_tools = get_skill_global_tools(skill_id)
   187→
   188→        # 全局工具（从 core skill 加载）
   189→        all_global_tools = get_global_tools()
   190→        for tool in all_global_tools:
   191→            # 如果声明了 global_tools，只加载声明的；否则加载全部
   192→            if declared_global_tools:
   193→                if tool.name in declared_global_tools:
   194→                    tools.append(tool.to_openai_format())
   195→                    added_tool_names.add(tool.name)
   196→            else:
   197→                # 向后兼容：没有声明则加载全部
   198→                tools.append(tool.to_openai_format())
   199→                added_tool_names.add(tool.name)
   200→
   201→        # Skill 专属工具（跳过 core，因为已经加载了）
   202→        if skill_id != "core":
   203→            for name, tool in cls._tool_defs.items():
   204→                if getattr(tool, 'skill_id', None) == skill_id:
   205→                    if name not in added_tool_names:
   206→                        tools.append(tool.to_openai_format())
   207→                        added_tool_names.add(name)
   208→
   209→        # v12: includes - 从 routing.yaml 读取需要包含的 Skill 工具
   210→        try:
   211→            from .routing_config import get_skill_includes
   212→            includes = get_skill_includes(skill_id)
   213→            for inc_skill_id in includes:
   214→                for name, tool in cls._tool_defs.items():
   215→                    if getattr(tool, 'skill_id', None) == inc_skill_id:
   216→                        if name not in added_tool_names:
   217→                            tools.append(tool.to_openai_format())
   218→                            added_tool_names.add(name)
   219→        except ImportError:
   220→            pass
   221→
   222→        # v7.3: 外部工具（从其他 skill 导入）- 兼容旧配置
   223→        from .skill_loader import get_skill_external_tools
   224→        external_tool_names = get_skill_external_tools(skill_id)
   225→        if external_tool_names:
   226→            for name, tool in cls._tool_defs.items():
   227→                if name in external_tool_names:
   228→                    if name not in added_tool_names:
   229→                        tools.append(tool.to_openai_format())
   230→                        added_tool_names.add(name)
   231→
   232→        return tools
   233→
   234→    @classmethod
   235→    def get_all_tools(cls) -> List[Dict[str, Any]]:
   236→        """获取所有已注册的工具 (OpenAI 格式)"""
   237→        cls.initialize()
   238→        return [tool.to_openai_format() for tool in cls._tool_defs.values()]
   239→
   240→    @classmethod
   241→    def get_card_type(cls, tool_name: str) -> Optional[str]:
   242→        """获取工具对应的卡片类型"""
   243→        tool = cls.get_tool_def(tool_name)
   244→        return tool.card_type if tool else None
   245→
   246→    @classmethod
   247→    def has_handler(cls, tool_name: str) -> bool:
   248→        """检查是否有注册的执行器"""
   249→        cls.initialize()
   250→        return tool_name in cls._handlers
   251→
   252→    @classmethod
   253→    async def execute(
   254→        cls,
   255→        tool_name: str,
   256→        args: Dict[str, Any],
   257→        context: ToolContext
   258→    ) -> Dict[str, Any]:
   259→        """执行工具"""
   260→        cls.initialize()
   261→
   262→        if tool_name not in cls._handlers:
   263→            logger.warning(f"No handler for tool: {tool_name}")
   264→            return {"error": f"Tool handler not found: {tool_name}"}
   265→
   266→        handler = cls._handlers[tool_name]
   267→
   268→        try:
   269→            # 支持同步和异步处理器
   270→            result = handler(args, context)
   271→            if asyncio.iscoroutine(result):
   272→                result = await result
   273→            return result
   274→        except Exception as e:
   275→            logger.error(f"Tool execution failed: {tool_name}, error: {e}")
   276→            return {"error": str(e)}
   277→
   278→    @classmethod
   279→    def get_schema(cls, skill_id: Optional[str] = None) -> Dict[str, Any]:
   280→        """获取工具 Schema (用于前端)
   281→
   282→        V12 更新：支持 includes 从 routing.yaml
   283→        """
   284→        cls.initialize()
   285→
   286→        global_tool_names = {t.name for t in get_global_tools()}
   287→
   288→        # v7.3: 获取外部工具名
   289→        external_tool_names = set()
   290→        if skill_id:
   291→            from .skill_loader import get_skill_external_tools
   292→            external_tool_names = set(get_skill_external_tools(skill_id))
   293→
   294→        # v12: 获取 includes 中的 Skill ID
   295→        includes_skill_ids = set()
   296→        if skill_id:
   297→            try:
   298→                from .routing_config import get_skill_includes
   299→                includes_skill_ids = set(get_skill_includes(skill_id))
   300→            except ImportError:
   301→                pass
   302→
   303→        tools = []
   304→        for name, tool in cls._tool_defs.items():
   305→            tool_skill_id = getattr(tool, 'skill_id', None)
   306→
   307→            if skill_id:
   308→                # 包含条件: 自身工具 OR 全局工具 OR 外部工具 OR includes 的 Skill 工具
   309→                is_own_tool = tool_skill_id == skill_id
   310→                is_global = name in global_tool_names
   311→                is_external = name in external_tool_names
   312→                is_included = tool_skill_id in includes_skill_ids
   313→
   314→                if not (is_own_tool or is_global or is_external or is_included):
   315→                    continue
   316→
   317→            tools.append({
   318→                "name": tool.name,
   319→                "description": tool.description,
   320→                "tool_type": tool.tool_type,
   321→                "card_type": tool.card_type,
   322→                "fallback_type": tool.fallback_type,  # V7.1: 降级类型
   323→                "card_props": tool.card_props,  # 新增: 表单配置等
   324→                "parameters": [
   325→                    {
   326→                        "name": p.name,
   327→                        "type": p.type,
   328→                        "required": p.required,
   329→                        "description": p.description,
   330→                        "enum": p.enum,
   331→                        "default": p.default,
   332→                    }
   333→                    for p in tool.parameters
   334→                ],
   335→                "when_to_call": tool.when_to_call,
   336→            })
   337→
   338→        return {
   339→            "version": "12.0",
   340→            "skill_id": skill_id,
   341→            "tools": tools,
   342→        }
   343→
   344→    @classmethod
   345→    def clear(cls):
   346→        """清除所有注册 (用于测试)"""
   347→        cls._tool_defs.clear()
   348→        cls._handlers.clear()
   349→        cls._loaded_skills.clear()
   350→        cls._initialized = False
   351→
   352→
   353→def tool_handler(tool_name: str):
   354→    """
   355→    工具执行器装饰器
   356→
   357→    用法:
   358→        @tool_handler("show_bazi_chart")
   359→        async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:
   360→            return {"chart": ...}
   361→    """
   362→    def decorator(func: ToolHandler) -> ToolHandler:
   363→        @wraps(func)
   364→        async def wrapper(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   365→            result = func(args, context)
   366→            if asyncio.iscoroutine(result):
   367→                return await result
   368→            return result
   369→
   370→        # 注册到 Registry
   371→        UnifiedToolRegistry.register_handler(tool_name, wrapper)
   372→        return wrapper
   373→
   374→    return decorator
   375→
   376→
   377→# 便捷别名
   378→ToolRegistry = UnifiedToolRegistry
   379→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
