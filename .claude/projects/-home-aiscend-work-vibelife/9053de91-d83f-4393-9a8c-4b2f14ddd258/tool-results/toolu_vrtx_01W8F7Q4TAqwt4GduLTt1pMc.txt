     1→# CoreAgent 重构方案
     2→
     3→> 日期: 2026-01-20
     4→> 状态: Draft
     5→> 范围: 协议流、工具设计、Profile 结构
     6→
     7→---
     8→
     9→## 1. 背景
    10→
    11→当前架构存在以下问题：
    12→
    13→| 问题 | 现状 | 影响 |
    14→|-----|------|-----|
    15→| Skill 专用工具 | `read_lifecoach_state` / `write_lifecoach_state` | 每个 Skill 需要重复实现 |
    16→| 数据存储分散 | `skill_data` + `life_context._paths` | 区分不清晰，查询复杂 |
    17→| 协议逻辑位置 | 计划放在 CoreAgent | CoreAgent 职责过重 |
    18→
    19→---
    20→
    21→## 2. 重构目标
    22→
    23→1. **工具通用化**：一套工具，所有 Skill 复用
    24→2. **数据结构简化**：统一到 `profile.skills.{skill_id}`
    25→3. **协议逻辑分层**：路由层处理协议，CoreAgent 保持通用
    26→
    27→---
    28→
    29→## 3. Profile 结构重构
    30→
    31→### 3.1 现状
    32→
    33→```
    34→profile
    35→├── account
    36→├── birth_info
    37→├── preferences
    38→├── state
    39→│
    40→├── skill_data              # 计算结果
    41→│   ├── bazi: {chart: ...}
    42→│   └── zodiac: {chart: ...}
    43→│
    44→├── life_context            # 用户输入的生活数据
    45→│   └── _paths
    46→│       └── lifecoach: {
    47→│           content: {...},
    48→│           version: 1,
    49→│           updated_at: "..."
    50→│       }
    51→│
    52→└── extracted
    53→```
    54→
    55→**问题**：
    56→- `skill_data` vs `life_context` 区分不清晰
    57→- `_paths` 虚拟文件系统过度设计
    58→- lifecoach 数据路径过深：`life_context._paths.lifecoach.content`
    59→
    60→### 3.2 目标结构
    61→
    62→```
    63→profile
    64→├── account                 # 账户信息
    65→│   ├── vibe_id
    66→│   ├── display_name
    67→│   ├── tier
    68→│   └── status
    69→│
    70→├── birth_info              # 出生信息
    71→│   ├── date
    72→│   ├── time
    73→│   ├── place
    74→│   └── timezone
    75→│
    76→├── preferences             # 用户偏好
    77→│   ├── voice_mode
    78→│   ├── language
    79→│   ├── timezone
    80→│   ├── subscribed_skills
    81→│   ├── push_settings
    82→│   └── blocked_skills
    83→│
    84→├── state                   # 当前状态
    85→│   ├── focus: ["career", "health"]
    86→│   └── updated_at
    87→│
    88→├── skills                  # 统一存储所有 Skill 数据
    89→│   ├── bazi
    90→│   │   ├── chart: {...}           # 计算结果
    91→│   │   ├── insights: [...]        # AI 洞察
    92→│   │   └── _meta: {updated_at}
    93→│   │
    94→│   ├── zodiac
    95→│   │   ├── chart: {...}
    96→│   │   └── _meta: {updated_at}
    97→│   │
    98→│   ├── lifecoach
    99→│   │   ├── system: {...}          # 方法论选择
   100→│   │   ├── north_star: {...}      # 愿景/反愿景
   101→│   │   ├── goals: {...}           # 目标
   102→│   │   ├── current: {...}         # 当前焦点
   103→│   │   ├── progress: {...}        # 进度
   104→│   │   ├── journal: [...]         # 日志
   105→│   │   ├── protocol: {...}        # 协议状态（新增）
   106→│   │   └── _meta: {updated_at}
   107→│   │
   108→│   └── career
   109→│       ├── resume: {...}
   110→│       ├── goals: {...}
   111→│       └── _meta: {updated_at}
   112→│
   113→└── extracted               # AI 抽取的跨 Skill 信息
   114→    ├── facts: [...]
   115→    ├── concerns: [...]
   116→    ├── goals: [...]
   117→    └── patterns: [...]
   118→```
   119→
   120→### 3.3 变化总结
   121→
   122→| 现状 | 目标 | 说明 |
   123→|-----|------|-----|
   124→| `skill_data.bazi` | `skills.bazi` | 重命名 |
   125→| `life_context._paths.lifecoach.content` | `skills.lifecoach` | 扁平化 |
   126→| 分散存储 | 统一到 `skills` | 简化查询 |
   127→
   128→---
   129→
   130→## 4. 工具设计重构
   131→
   132→### 4.1 现状
   133→
   134→```yaml
   135→# lifecoach 专用
   136→- read_lifecoach_state
   137→- write_lifecoach_state
   138→- add_journal_entry
   139→- update_progress
   140→
   141→# 如果 career 也需要存储数据...
   142→- read_career_state    # 需要新增
   143→- write_career_state   # 需要新增
   144→```
   145→
   146→**问题**：每个 Skill 需要重复实现读写工具
   147→
   148→### 4.2 目标：通用工具
   149→
   150→```yaml
   151→# 通用数据工具（所有 Skill 共享）
   152→- name: read_state
   153→  description: 读取当前 Skill 的用户状态
   154→  type: data
   155→  parameters:
   156→    - name: sections
   157→      type: array
   158→      description: 要读取的部分（不传则读取全部）
   159→
   160→- name: write_state
   161→  description: 写入当前 Skill 的用户状态（深度合并）
   162→  type: data
   163→  parameters:
   164→    - name: section
   165→      type: string
   166→      required: true
   167→      description: 要写入的部分
   168→    - name: data
   169→      type: object
   170→      required: true
   171→      description: 要写入的数据
   172→
   173→- name: append_to_list
   174→  description: 向列表追加条目（如日志、记录）
   175→  type: data
   176→  parameters:
   177→    - name: path
   178→      type: string
   179→      required: true
   180→      description: 列表路径，如 "journal" 或 "progress.milestones"
   181→    - name: entry
   182→      type: object
   183→      required: true
   184→      description: 要追加的条目
   185→    - name: max_items
   186→      type: integer
   187→      default: 100
   188→      description: 列表最大长度（超出则删除最旧的）
   189→```
   190→
   191→### 4.3 实现
   192→
   193→```python
   194→# services/agent/global_handlers.py
   195→
   196→from services.agent.tool_registry import tool_handler, ToolContext
   197→from stores.unified_profile_repo import UnifiedProfileRepository
   198→
   199→
   200→@tool_handler("read_state")
   201→async def read_state(args: Dict, context: ToolContext) -> Dict:
   202→    """
   203→    通用状态读取 - 自动使用当前 skill_id
   204→
   205→    LLM 不需要传 skill_id，从 context 自动获取
   206→    """
   207→    skill_id = context.skill_id
   208→    if not skill_id:
   209→        return {"status": "error", "message": "No active skill"}
   210→
   211→    sections = args.get("sections")
   212→
   213→    data = await UnifiedProfileRepository.get_skill_state(
   214→        context.user_id,
   215→        skill_id
   216→    )
   217→
   218→    if not data:
   219→        return {
   220→            "status": "empty",
   221→            "message": f"尚未建立 {skill_id} 数据",
   222→            "data": {}
   223→        }
   224→
   225→    if sections:
   226→        result = {k: v for k, v in data.items() if k in sections}
   227→    else:
   228→        result = data
   229→
   230→    return {
   231→        "status": "success",
   232→        "data": result,
   233→        "skill_id": skill_id
   234→    }
   235→
   236→
   237→@tool_handler("write_state")
   238→async def write_state(args: Dict, context: ToolContext) -> Dict:
   239→    """
   240→    通用状态写入 - 自动使用当前 skill_id
   241→
   242→    支持深度合并，不会覆盖未指定的字段
   243→    """
   244→    skill_id = context.skill_id
   245→    if not skill_id:
   246→        return {"status": "error", "message": "No active skill"}
   247→
   248→    section = args.get("section")
   249→    data = args.get("data")
   250→
   251→    if not section or not data:
   252→        return {"status": "error", "message": "Missing section or data"}
   253→
   254→    await UnifiedProfileRepository.update_skill_state(
   255→        context.user_id,
   256→        skill_id,
   257→        section,
   258→        data
   259→    )
   260→
   261→    return {
   262→        "status": "success",
   263→        "message": f"已保存 {section}",
   264→        "skill_id": skill_id
   265→    }
   266→
   267→
   268→@tool_handler("append_to_list")
   269→async def append_to_list(args: Dict, context: ToolContext) -> Dict:
   270→    """
   271→    向列表追加条目
   272→
   273→    用于日志、记录等场景
   274→    """
   275→    skill_id = context.skill_id
   276→    if not skill_id:
   277→        return {"status": "error", "message": "No active skill"}
   278→
   279→    path = args.get("path")
   280→    entry = args.get("entry")
   281→    max_items = args.get("max_items", 100)
   282→
   283→    if not path or not entry:
   284→        return {"status": "error", "message": "Missing path or entry"}
   285→
   286→    # 添加时间戳
   287→    entry["_created_at"] = datetime.utcnow().isoformat()
   288→
   289→    await UnifiedProfileRepository.append_to_skill_list(
   290→        context.user_id,
   291→        skill_id,
   292→        path,
   293→        entry,
   294→        max_items
   295→    )
   296→
   297→    return {
   298→        "status": "success",
   299→        "message": f"已添加到 {path}",
   300→        "skill_id": skill_id
   301→    }
   302→```
   303→
   304→### 4.4 Repository 扩展
   305→
   306→```python
   307→# stores/unified_profile_repo.py
   308→
   309→class UnifiedProfileRepository:
   310→
   311→    @staticmethod
   312→    async def get_skill_state(user_id: UUID, skill_id: str) -> Dict:
   313→        """获取 Skill 状态"""
   314→        profile = await UnifiedProfileRepository.get_profile(user_id)
   315→        if not profile:
   316→            return {}
   317→        return profile.get("skills", {}).get(skill_id, {})
   318→
   319→    @staticmethod
   320→    async def update_skill_state(
   321→        user_id: UUID,
   322→        skill_id: str,
   323→        section: str,
   324→        data: Dict
   325→    ) -> None:
   326→        """
   327→        更新 Skill 状态（深度合并）
   328→
   329→        使用 jsonb_set + || 实现深度合并
   330→        """
   331→        exists = await fetchval(
   332→            "SELECT 1 FROM unified_profiles WHERE user_id = $1",
   333→            user_id
   334→        )
   335→
   336→        if exists:
   337→            # 使用 || 操作符进行深度合并
   338→            await execute(
   339→                """UPDATE unified_profiles
   340→                   SET profile = jsonb_set(
   341→                       jsonb_set(
   342→                           jsonb_set(
   343→                               COALESCE(profile, '{}'::jsonb),
   344→                               '{skills}',
   345→                               COALESCE(profile -> 'skills', '{}'::jsonb)
   346→                           ),
   347→                           ARRAY['skills', $2],
   348→                           COALESCE(profile -> 'skills' -> $2, '{}'::jsonb)
   349→                       ),
   350→                       ARRAY['skills', $2, $3],
   351→                       COALESCE(profile -> 'skills' -> $2 -> $3, '{}'::jsonb) || $4::jsonb
   352→                   ),
   353→                   updated_at = NOW()
   354→                   WHERE user_id = $1""",
   355→                user_id, skill_id, section, json.dumps(data, ensure_ascii=False, default=str)
   356→            )
   357→        else:
   358→            await UnifiedProfileRepository.create_profile(
   359→                user_id,
   360→                {"skills": {skill_id: {section: data}}}
   361→            )
   362→
   363→        await UnifiedProfileRepository._invalidate_cache(user_id, skill_id)
   364→
   365→    @staticmethod
   366→    async def append_to_skill_list(
   367→        user_id: UUID,
   368→        skill_id: str,
   369→        path: str,
   370→        entry: Dict,
   371→        max_items: int = 100
   372→    ) -> None:
   373→        """
   374→        向 Skill 数据中的列表追加条目
   375→
   376→        Args:
   377→            path: 列表路径，如 "journal" 或 "progress.milestones"
   378→        """
   379→        # 获取当前数据
   380→        skill_data = await UnifiedProfileRepository.get_skill_state(user_id, skill_id)
   381→
   382→        # 解析路径
   383→        parts = path.split(".")
   384→        current = skill_data
   385→        for part in parts[:-1]:
   386→            current = current.setdefault(part, {})
   387→
   388→        # 获取或创建列表
   389→        list_key = parts[-1]
   390→        current_list = current.get(list_key, [])
   391→        if not isinstance(current_list, list):
   392→            current_list = []
   393→
   394→        # 追加并限制长度
   395→        current_list = [entry] + current_list[:max_items - 1]
   396→        current[list_key] = current_list
   397→
   398→        # 写回
   399→        await UnifiedProfileRepository.update_skill_state(
   400→            user_id, skill_id, parts[0],
   401→            skill_data.get(parts[0], {}) if len(parts) > 1 else {list_key: current_list}
   402→        )
   403→```
   404→
   405→---
   406→
   407→## 5. 协议流设计
   408→
   409→### 5.1 设计决策
   410→
   411→| 问题 | 决策 | 理由 |
   412→|-----|------|-----|
   413→| 协议触发机制 | 后端工具调用 (`show_protocol_invitation`) | 只有后端知道用户是否适合该协议 |
   414→| 进度数据来源 | SSE 自定义事件 (`protocol_progress`) | 实时更新，不污染消息流 |
   415→| 协议中断恢复 | 自动继续 + 友好提示 | 用户体验最佳 |
   416→| 协议完成过渡 | 无缝过渡，数据永久保存 | 协议结果可复用 |
   417→
   418→### 5.2 架构分层
   419→
   420→```
   421→┌─────────────────────────────────────────────────────────────┐
   422→│  chat_v5.py (路由层)                                        │
   423→│  ├── 检测协议状态                                           │
   424→│  ├── 构建 protocol_prompt                                   │
   425→│  ├── 发送 protocol_progress SSE 事件                        │
   426→│  └── 检测步骤完成，更新协议状态                              │
   427→└─────────────────────────────────────────────────────────────┘
   428→                            │
   429→                            ▼
   430→┌─────────────────────────────────────────────────────────────┐
   431→│  CoreAgent (执行层)                                         │
   432→│  ├── 接收 context.protocol_prompt                           │
   433→│  ├── 执行 LLM 对话                                          │
   434→│  └── 返回 AgentEvent 流                                     │
   435→└─────────────────────────────────────────────────────────────┘
   436→```
   437→
   438→**原则**：CoreAgent 不感知协议逻辑，只负责执行
   439→
   440→### 5.3 协议状态存储
   441→
   442→```json
   443→// profile.skills.lifecoach.protocol
   444→{
   445→  "id": "dankoe",
   446→  "step": 2,
   447→  "total_steps": 6,
   448→  "started_at": "2026-01-20T10:00:00Z",
   449→  "data": {
   450→    "step_1": { "pain_points": ["工作没意义"] },
   451→    "step_2": { "anti_vision_scene": "..." }
   452→  },
   453→  "completed": false
   454→}
   455→```
   456→
   457→### 5.4 SSE 事件扩展
   458→
   459→```python
   460→# services/agent/stream_adapter.py
   461→
   462→class AISDKv6Adapter(BaseStreamAdapter):
   463→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]):
   464→        # ... 现有逻辑 ...
   465→
   466→        async for event in events:
   467→            # ... 现有事件处理 ...
   468→
   469→            elif event.type == "protocol_progress":
   470→                # 协议进度更新
   471→                yield self._format({
   472→                    "type": "data",
   473→                    "data": ["protocol_progress", {
   474→                        "protocol_id": event.data.get("protocol_id"),
   475→                        "step": event.data.get("step"),
   476→                        "total_steps": event.data.get("total_steps"),
   477→                        "phase": event.data.get("phase"),
   478→                        "progress": event.data.get("progress"),
   479→                        "step_name": event.data.get("step_name"),
   480→                    }]
   481→                })
   482→
   483→            elif event.type == "protocol_completed":
   484→                yield self._format({
   485→                    "type": "data",
   486→                    "data": ["protocol_completed", {
   487→                        "protocol_id": event.data.get("protocol_id"),
   488→                        "summary": event.data.get("summary"),
   489→                    }]
   490→                })
   491→```
   492→
   493→### 5.5 协议工具
   494→
   495→```yaml
   496→# 协议专用工具（lifecoach）
   497→- name: show_protocol_invitation
   498→  description: 向用户推荐开始一个协议
   499→  type: display
   500→  parameters:
   501→    - name: protocol_id
   502→      type: string
   503→      required: true
   504→    - name: title
   505→      type: string
   506→      required: true
   507→    - name: description
   508→      type: string
   509→      required: true
   510→    - name: estimated_time
   511→      type: string
   512→    - name: actions
   513→      type: array
   514→      required: true
   515→      description: "[{label: '开始重置', value: 'start'}, {label: '稍后再说', value: 'later'}]"
   516→
   517→- name: advance_protocol_step
   518→  description: 完成当前协议步骤，保存数据并进入下一步
   519→  type: data
   520→  parameters:
   521→    - name: step_data
   522→      type: object
   523→      required: true
   524→      description: 当前步骤收集的数据
   525→    - name: step_summary
   526→      type: string
   527→      description: 对用户回答的简短总结
   528→
   529→- name: cancel_protocol
   530→  description: 取消当前协议
   531→  type: data
   532→  parameters:
   533→    - name: reason
   534→      type: string
   535→      description: 取消原因
   536→```
   537→
   538→---
   539→
   540→## 6. 迁移计划
   541→
   542→### Phase 1: 添加通用工具（无破坏性）
   543→
   544→```
   545→1. 添加 read_state / write_state / append_to_list 到 global_handlers.py
   546→2. 添加 get_skill_state / update_skill_state 到 unified_profile_repo.py
   547→3. 在 core skill 的 tools.yaml 中注册通用工具
   548→4. lifecoach 专用工具暂时保留（兼容）
   549→```
   550→
   551→### Phase 2: 数据迁移
   552→
   553→```sql
   554→-- 将 skill_data 迁移到 skills
   555→UPDATE unified_profiles
   556→SET profile = jsonb_set(
   557→    profile,
   558→    '{skills}',
   559→    COALESCE(profile -> 'skill_data', '{}'::jsonb)
   560→)
   561→WHERE profile -> 'skill_data' IS NOT NULL;
   562→
   563→-- 将 life_context._paths.lifecoach 迁移到 skills.lifecoach
   564→UPDATE unified_profiles
   565→SET profile = jsonb_set(
   566→    profile,
   567→    '{skills, lifecoach}',
   568→    COALESCE(
   569→        profile -> 'skills' -> 'lifecoach',
   570→        '{}'::jsonb
   571→    ) || COALESCE(
   572→        profile -> 'life_context' -> '_paths' -> 'lifecoach' -> 'content',
   573→        '{}'::jsonb
   574→    )
   575→)
   576→WHERE profile -> 'life_context' -> '_paths' -> 'lifecoach' IS NOT NULL;
   577→```
   578→
   579→### Phase 3: 清理
   580→
   581→```
   582→1. 删除 read_lifecoach_state / write_lifecoach_state
   583→2. 删除 life_context 相关代码
   584→3. 删除 skill_data 相关代码（改用 skills）
   585→4. 更新所有引用
   586→```
   587→
   588→---
   589→
   590→## 7. 未解决问题
   591→
   592→1. **协议超时处理**：用户离开1小时后回来，是否需要重新确认？
   593→2. **多协议支持**：如果用户同时在进行多个协议（如 dankoe + covey），如何处理？
   594→3. **协议数据导出**：完成后的数据如何展示？是否需要生成报告？
   595→4. **前端 AI SDK 版本**：需要确认 AI SDK 4.x 如何处理自定义 data 事件
   596→
   597→---
   598→
   599→## 8. 参考
   600→
   601→- [PROTOCOL_DESIGN.md](./PROTOCOL_DESIGN.md) - 协议流详细设计
   602→- [SKILL_DATA_ARCHITECTURE.md](./SKILL_DATA_ARCHITECTURE.md) - Skill 数据架构
   603→- [dankoe.yaml](/apps/api/skills/lifecoach/protocols/dankoe.yaml) - Dan Koe 协议配置
   604→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
