     1→/**
     2→ * useVibeChat - AI SDK 4.x useChat wrapper for VibeLife
     3→ *
     4→ * v6.0 简化版:
     5→ * - 移除 Protocol 状态管理（改为 LLM 自己管理）
     6→ * - 添加 scenario 参数支持
     7→ *
     8→ * v7.0 新增:
     9→ * - 支持从后端加载历史消息
    10→ * - conversation_id 切换时自动加载历史
    11→ *
    12→ * Provides streaming chat with OpenAI-compatible backend
    13→ * Uses standard OpenAI SSE format from Python CoreAgent
    14→ */
    15→
    16→'use client';
    17→
    18→import { useChat, Message } from 'ai/react';
    19→import { useCallback, useMemo, useEffect, useRef } from 'react';
    20→import { getAccessToken } from '@/utils/storage';
    21→import { useConversationDetail } from './useConversations';
    22→
    23→export type SkillId = 'bazi' | 'zodiac' | 'mbti' | 'tarot' | 'attach' | 'career' | 'lifecoach';
    24→export type VoiceMode = 'warm' | 'sarcastic' | 'wise';
    25→
    26→export interface UseVibeChatOptions {
    27→  /**
    28→   * Skill ID - 可选
    29→   * - 传入时：后端直接使用该 skill，不走 LLM 路由
    30→   * - 不传时：后端 CoreAgent 通过 LLM 自动识别用户意图并路由到合适的 skill
    31→   */
    32→  skillId?: SkillId;
    33→  /**
    34→   * Scenario/Rule ID - 可选
    35→   * - 传入时：后端直接加载对应的 Rule 文件
    36→   * - 不传时：后端根据 tags 匹配或使用默认 scenario
    37→   */
    38→  scenario?: string;
    39→  voiceMode?: VoiceMode;
    40→  conversationId?: string;
    41→  onConversationStart?: (id: string) => void;
    42→  onError?: (error: Error) => void;
    43→  onFinish?: (message: Message) => void;
    44→}
    45→
    46→export function useVibeChat({
    47→  skillId,
    48→  scenario,
    49→  voiceMode = 'warm',
    50→  conversationId,
    51→  onConversationStart,
    52→  onError,
    53→  onFinish,
    54→}: UseVibeChatOptions) {
    55→  // Track previous conversation_id to detect changes
    56→  const prevConversationIdRef = useRef<string | undefined>(conversationId);
    57→
    58→  // Get auth token - getAccessToken() uses cached Map lookup (O(1)), safe to call on each render
    59→  // This ensures token changes (login/logout) are reflected immediately
    60→  const accessToken = getAccessToken();
    61→
    62→  // Load conversation history when conversation_id is provided
    63→  const { conversation: conversationDetail } = useConversationDetail(conversationId || null);
    64→
    65→  // Memoize headers to prevent unnecessary re-renders (Vercel rule: rerender-usememo-expensive)
    66→  const headers = useMemo(
    67→    () => (accessToken ? { Authorization: `Bearer ${accessToken}` } : undefined),
    68→    [accessToken]
    69→  );
    70→
    71→  // Memoize body to prevent unnecessary re-renders
    72→  // 当 skillId 为 undefined 时，不传 skill 字段，让后端 LLM 自动路由
    73→  const body = useMemo(
    74→    () => ({
    75→      ...(skillId && { skill: skillId }),
    76→      ...(scenario && { scenario }),
    77→      voice_mode: voiceMode,
    78→      conversation_id: conversationId,
    79→    }),
    80→    [skillId, scenario, voiceMode, conversationId]
    81→  );
    82→
    83→  // AI SDK 4.x useChat hook
    84→  const chat = useChat({
    85→    api: '/api/v1/chat/v5/stream',
    86→    // 使用默认 data 协议，支持 toolInvocations (0:, 9:, a: 格式) 和自定义数据 (2:[key, value])
    87→    headers,
    88→    body,
    89→    onFinish: (message) => {
    90→      onFinish?.(message);
    91→    },
    92→    onError: (error) => {
    93→      console.error('Chat error:', error);
    94→      onError?.(error);
    95→    },
    96→  });
    97→
    98→  // Load history messages when conversation_id changes
    99→  useEffect(() => {
   100→    // Only load when conversation_id changes
   101→    if (conversationId !== prevConversationIdRef.current) {
   102→      prevConversationIdRef.current = conversationId;
   103→
   104→      if (conversationId && conversationDetail?.messages) {
   105→        // Convert backend messages to AI SDK format
   106→        const historyMessages: Message[] = conversationDetail.messages.map((msg) => ({
   107→          id: msg.id,
   108→          role: msg.role as 'user' | 'assistant',
   109→          content: msg.content,
   110→          createdAt: new Date(msg.created_at),
   111→        }));
   112→        chat.setMessages(historyMessages);
   113→      } else if (!conversationId) {
   114→        // New chat - clear messages
   115→        chat.setMessages([]);
   116→      }
   117→    }
   118→  }, [conversationId, conversationDetail, chat]);
   119→
   120→  // Wrapper for sending messages
   121→  const sendVibeMessage = useCallback(
   122→    async (content: string) => {
   123→      return chat.append({
   124→        role: 'user',
   125→        content,
   126→      });
   127→    },
   128→    [chat]
   129→  );
   130→
   131→  // Clear messages and send (for quick prompts)
   132→  const sendQuickPrompt = useCallback(
   133→    async (content: string) => {
   134→      chat.setMessages([]);
   135→      return sendVibeMessage(content);
   136→    },
   137→    [chat, sendVibeMessage]
   138→  );
   139→
   140→  // Tool approval (placeholder for AI SDK 4.x compatibility)
   141→  // In AI SDK 4.x, tool results are handled server-side
   142→  const approveToolCall = useCallback(
   143→    (toolCallId: string, approved: boolean) => {
   144→      console.log(`Tool ${toolCallId} ${approved ? 'approved' : 'rejected'}`);
   145→      // AI SDK 4.x handles tool execution server-side
   146→    },
   147→    []
   148→  );
   149→
   150→  return {
   151→    // Core state
   152→    messages: chat.messages,
   153→    isLoading: chat.isLoading,
   154→    error: chat.error,
   155→
   156→    // Actions
   157→    sendMessage: sendVibeMessage,
   158→    sendQuickPrompt,
   159→    stop: chat.stop,
   160→    reload: chat.reload,
   161→    approveToolCall,
   162→
   163→    // For advanced use
   164→    setMessages: chat.setMessages,
   165→    append: chat.append,
   166→    input: chat.input,
   167→    setInput: chat.setInput,
   168→    handleInputChange: chat.handleInputChange,
   169→    handleSubmit: chat.handleSubmit,
   170→
   171→    // Metadata
   172→    conversationId,
   173→    skillId,
   174→    scenario,
   175→    voiceMode,
   176→  };
   177→}
   178→
   179→export default useVibeChat;
   180→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
