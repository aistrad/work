     1→"""
     2→Stream Adapter - 将 CoreAgent 内部事件转换为前端协议格式
     3→
     4→设计原则：
     5→- CoreAgent 输出统一的内部事件格式（AgentEvent）
     6→- StreamAdapter 负责转换为特定前端协议
     7→- 未来换前端方案只需写新的 Adapter，不改 CoreAgent
     8→
     9→支持的协议：
    10→- AI SDK Data Stream Protocol (Vercel)
    11→- 可扩展支持其他协议
    12→"""
    13→import json
    14→from typing import AsyncGenerator, Dict, Any
    15→from uuid import uuid4
    16→from dataclasses import dataclass
    17→
    18→from .core import AgentEvent
    19→
    20→
    21→@dataclass
    22→class StreamConfig:
    23→    """流配置"""
    24→    protocol: str = "ai-sdk-6"  # ai-sdk-6, sse-legacy, custom
    25→    include_step_events: bool = True
    26→
    27→
    28→class BaseStreamAdapter:
    29→    """基础流适配器"""
    30→
    31→    def __init__(self, config: StreamConfig = None):
    32→        self.config = config or StreamConfig()
    33→
    34→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:
    35→        """将内部事件转换为协议格式"""
    36→        raise NotImplementedError
    37→
    38→
    39→class AISDKv6Adapter(BaseStreamAdapter):
    40→    """
    41→    AI SDK Data Stream Protocol 适配器
    42→
    43→    协议格式：
    44→    - data: {"type":"start","messageId":"..."}\n\n
    45→    - data: {"type":"text-delta","id":"...","delta":"..."}\n\n
    46→    - data: {"type":"finish"}\n\n
    47→    - data: [DONE]\n\n
    48→
    49→    参考: https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol
    50→    """
    51→
    52→    def __init__(self, config: StreamConfig = None):
    53→        super().__init__(config)
    54→        self.message_id = f"msg_{uuid4().hex[:24]}"
    55→        self.text_id = f"text_{uuid4().hex[:12]}"
    56→        self._text_started = False
    57→
    58→    def _format(self, data: Dict[str, Any] | str) -> Dict[str, str]:
    59→        """格式化为 SSE 事件 (sse-starlette 格式)"""
    60→        if isinstance(data, str):
    61→            return {"data": data}
    62→        return {"data": json.dumps(data, ensure_ascii=False)}
    63→
    64→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[Dict[str, str], None]:
    65→        """将 AgentEvent 转换为 AI SDK 格式 (sse-starlette dict 格式)"""
    66→
    67→        # 1. 消息开始
    68→        yield self._format({"type": "start", "messageId": self.message_id})
    69→
    70→        # 2. 步骤开始
    71→        if self.config.include_step_events:
    72→            yield self._format({"type": "start-step"})
    73→
    74→        async for event in events:
    75→            if event.type == "thinking":
    76→                # thinking 事件不输出到前端
    77→                pass
    78→
    79→            elif event.type == "content":
    80→                # 文本增量
    81→                if not self._text_started:
    82→                    yield self._format({"type": "text-start", "id": self.text_id})
    83→                    self._text_started = True
    84→
    85→                content = event.data.get("content", "")
    86→                if content:
    87→                    yield self._format({
    88→                        "type": "text-delta",
    89→                        "id": self.text_id,
    90→                        "delta": content
    91→                    })
    92→
    93→            elif event.type == "tool_call":
    94→                # 结束之前的文本块
    95→                if self._text_started:
    96→                    yield self._format({"type": "text-end", "id": self.text_id})
    97→                    self._text_started = False
    98→                    # 为下一个文本块生成新 ID
    99→                    self.text_id = f"text_{uuid4().hex[:12]}"
   100→
   101→                # 工具调用
   102→                tool_call_id = event.data.get("id")
   103→                tool_name = event.data.get("name")
   104→                args_str = event.data.get("arguments", "{}")
   105→
   106→                try:
   107→                    args = json.loads(args_str) if isinstance(args_str, str) else args_str
   108→                except json.JSONDecodeError:
   109→                    args = {}
   110→
   111→                yield self._format({
   112→                    "type": "tool-input-start",
   113→                    "toolCallId": tool_call_id,
   114→                    "toolName": tool_name
   115→                })
   116→                yield self._format({
   117→                    "type": "tool-input-available",
   118→                    "toolCallId": tool_call_id,
   119→                    "toolName": tool_name,
   120→                    "input": args
   121→                })
   122→
   123→            elif event.type == "tool_result":
   124→                # 工具结果
   125→                yield self._format({
   126→                    "type": "tool-output-available",
   127→                    "toolCallId": event.data.get("id"),
   128→                    "output": event.data.get("result")
   129→                })
   130→
   131→            elif event.type == "error":
   132→                # 错误
   133→                yield self._format({
   134→                    "type": "error",
   135→                    "errorText": str(event.data.get("error", "Unknown error"))
   136→                })
   137→
   138→            elif event.type == "done":
   139→                # 完成信号在循环结束后统一处理
   140→                pass
   141→
   142→        # 3. 结束文本块（如果还有）
   143→        if self._text_started:
   144→            yield self._format({"type": "text-end", "id": self.text_id})
   145→
   146→        # 4. 步骤结束
   147→        if self.config.include_step_events:
   148→            yield self._format({"type": "finish-step"})
   149→
   150→        # 5. 消息结束
   151→        yield self._format({"type": "finish"})
   152→
   153→        # 6. 流终止
   154→        yield self._format("[DONE]")
   155→
   156→
   157→class LegacySSEAdapter(BaseStreamAdapter):
   158→    """
   159→    AI SDK 4.x Data Stream Protocol 适配器
   160→
   161→    格式 (参考 https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol):
   162→    - 0:"text"                                    - Text Part
   163→    - 9:{toolCallId, toolName, args}              - Tool Call Part
   164→    - a:{toolCallId, result}                      - Tool Result Part
   165→    - e:{finishReason, usage, isContinued}        - Finish Step Part
   166→    - d:{finishReason, usage}                     - Finish Message Part
   167→    """
   168→
   169→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:
   170→        async for event in events:
   171→            if event.type == "content":
   172→                content = event.data.get("content", "")
   173→                if content:
   174→                    yield f'0:{json.dumps(content, ensure_ascii=False)}\n'
   175→
   176→            elif event.type == "tool_call":
   177→                tool_call_id = event.data.get("id")
   178→                tool_name = event.data.get("name")
   179→                args_str = event.data.get("arguments", "{}")
   180→                try:
   181→                    args = json.loads(args_str) if isinstance(args_str, str) else args_str
   182→                except json.JSONDecodeError:
   183→                    args = {}
   184→
   185→                yield f'9:{json.dumps({"toolCallId": tool_call_id, "toolName": tool_name, "args": args}, ensure_ascii=False)}\n'
   186→
   187→            elif event.type == "tool_result":
   188→                yield f'a:{json.dumps({"toolCallId": event.data.get("id"), "result": event.data.get("result")}, ensure_ascii=False)}\n'
   189→
   190→            elif event.type == "error":
   191→                yield f'3:{json.dumps(str(event.data.get("error", "Unknown error")))}\n'
   192→
   193→        # Finish Step Part (必需，让 AI SDK 正确解析 parts)
   194→        yield f'e:{json.dumps({"finishReason": "stop", "usage": {"promptTokens": 0, "completionTokens": 0}, "isContinued": False})}\n'
   195→        # Finish Message Part
   196→        yield f'd:{json.dumps({"finishReason": "stop", "usage": {"promptTokens": 0, "completionTokens": 0}})}\n'
   197→
   198→
   199→class OpenAIAdapter(BaseStreamAdapter):
   200→    """
   201→    OpenAI 兼容格式适配器
   202→
   203→    输出标准 OpenAI Chat Completions SSE 格式，兼容 AI SDK 4.x useChat
   204→
   205→    格式：
   206→    data: {"id":"chatcmpl-xxx","choices":[{"delta":{"content":"..."}}]}
   207→    data: {"id":"chatcmpl-xxx","choices":[{"delta":{"tool_calls":[...]}}]}
   208→    data: [DONE]
   209→    """
   210→
   211→    def __init__(self, config: StreamConfig = None):
   212→        super().__init__(config)
   213→        self.completion_id = f"chatcmpl-{uuid4().hex[:24]}"
   214→        self._tool_call_index = 0
   215→
   216→    def _format(self, data: Dict[str, Any] | str) -> Dict[str, str]:
   217→        """格式化为 SSE 事件"""
   218→        if isinstance(data, str):
   219→            return {"data": data}
   220→        return {"data": json.dumps(data, ensure_ascii=False)}
   221→
   222→    def _make_chunk(self, delta: Dict[str, Any], finish_reason: str = None) -> Dict[str, Any]:
   223→        """构建 OpenAI 格式的 chunk"""
   224→        return {
   225→            "id": self.completion_id,
   226→            "object": "chat.completion.chunk",
   227→            "created": int(__import__("time").time()),
   228→            "model": "vibelife-agent",
   229→            "choices": [{
   230→                "index": 0,
   231→                "delta": delta,
   232→                "finish_reason": finish_reason
   233→            }]
   234→        }
   235→
   236→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[Dict[str, str], None]:
   237→        """将 AgentEvent 转换为 OpenAI 兼容格式"""
   238→
   239→        # 发送 role 标识
   240→        yield self._format(self._make_chunk({"role": "assistant"}))
   241→
   242→        async for event in events:
   243→            if event.type == "thinking":
   244→                # thinking 事件不输出
   245→                pass
   246→
   247→            elif event.type == "content":
   248→                content = event.data.get("content", "")
   249→                if content:
   250→                    yield self._format(self._make_chunk({"content": content}))
   251→
   252→            elif event.type == "tool_call":
   253→                tool_call_id = event.data.get("id")
   254→                tool_name = event.data.get("name")
   255→                args_str = event.data.get("arguments", "{}")
   256→
   257→                # OpenAI tool_calls 格式
   258→                tool_call = {
   259→                    "index": self._tool_call_index,
   260→                    "id": tool_call_id,
   261→                    "type": "function",
   262→                    "function": {
   263→                        "name": tool_name,
   264→                        "arguments": args_str if isinstance(args_str, str) else json.dumps(args_str)
   265→                    }
   266→                }
   267→                yield self._format(self._make_chunk({"tool_calls": [tool_call]}))
   268→                self._tool_call_index += 1
   269→
   270→            elif event.type == "tool_result":
   271→                # OpenAI 格式中，tool_result 通常不在流中返回
   272→                # 但我们可以作为特殊内容发送，让前端知道工具执行完成
   273→                result = event.data.get("result", {})
   274→                # 将工具结果作为特殊格式发送（前端可以解析）
   275→                yield self._format({
   276→                    "id": self.completion_id,
   277→                    "object": "chat.completion.chunk",
   278→                    "choices": [{
   279→                        "index": 0,
   280→                        "delta": {},
   281→                        "finish_reason": None
   282→                    }],
   283→                    "tool_result": {
   284→                        "tool_call_id": event.data.get("id"),
   285→                        "result": result
   286→                    }
   287→                })
   288→
   289→            elif event.type == "error":
   290→                # 错误作为内容发送
   291→                error_msg = str(event.data.get("error", "Unknown error"))
   292→                yield self._format(self._make_chunk({"content": f"\n\n❌ Error: {error_msg}"}))
   293→
   294→        # 发送完成信号
   295→        yield self._format(self._make_chunk({}, finish_reason="stop"))
   296→        yield self._format("[DONE]")
   297→
   298→
   299→class TextStreamAdapter(BaseStreamAdapter):
   300→    """
   301→    纯文本流适配器 (AI SDK streamProtocol: 'text')
   302→
   303→    只输出纯文本内容，不包含任何格式化。
   304→    适用于 AI SDK 4.x/6.x 的 streamProtocol: 'text' 模式。
   305→    """
   306→
   307→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:
   308→        """将 AgentEvent 转换为纯文本流"""
   309→        async for event in events:
   310→            if event.type == "content":
   311→                content = event.data.get("content", "")
   312→                if content:
   313→                    yield content
   314→
   315→            elif event.type == "error":
   316→                error_msg = str(event.data.get("error", "Unknown error"))
   317→                yield f"\n\n❌ Error: {error_msg}"
   318→
   319→
   320→class SimpleToolAdapter(BaseStreamAdapter):
   321→    """
   322→    简单工具标记适配器
   323→
   324→    在文本流中嵌入 [[TOOL:toolName:jsonData]] 标记，
   325→    前端解析后渲染对应的工具卡片。
   326→
   327→    格式：
   328→    - 0:"text" - 普通文本
   329→    - 0:"[[TOOL:show_bazi_chart:{...}]]" - 工具结果标记
   330→    - d:{finishReason} - 结束
   331→
   332→    内部工具过滤：
   333→    - use_skill, search_db 等内部工具不发送给前端
   334→    - 错误信息友好化处理
   335→    """
   336→
   337→    # 内部工具列表 - 不发送给前端
   338→    INTERNAL_TOOLS = {
   339→        "use_skill",       # 技能路由（兼容）
   340→        # activate_skill 已移除；仅保留 activate_skills
   341→        "activate_skills", # 新：多技能激活（路由型，不对用户展示）
   342→        "search_db",       # 数据库搜索
   343→        "get_context",     # 获取上下文
   344→        "update_memory",   # 更新记忆
   345→        "log_event",       # 日志事件
   346→    }
   347→
   348→    # 错误信息友好化映射
   349→    ERROR_MESSAGES = {
   350→        "quota": "今日对话次数已用完，升级会员可获得更多次数",
   351→        "timeout": "服务响应超时，请稍后重试",
   352→        "network": "网络连接不稳定，请稍后重试",
   353→        "rate_limit": "请求过于频繁，请稍后重试",
   354→        "auth": "登录已过期，请重新登录",
   355→        "permission": "暂无权限访问此功能",
   356→        "not_found": "未找到相关信息",
   357→        "invalid": "输入信息有误，请检查后重试",
   358→    }
   359→
   360→    def _get_friendly_error(self, error: str) -> str:
   361→        """将技术错误转换为用户友好的消息"""
   362→        error_lower = error.lower()
   363→        for key, message in self.ERROR_MESSAGES.items():
   364→            if key in error_lower:
   365→                return message
   366→        # 默认友好消息
   367→        return "抱歉，遇到了一些问题，请稍后重试"
   368→
   369→    async def adapt(self, events: AsyncGenerator[AgentEvent, None]) -> AsyncGenerator[str, None]:
   370→        async for event in events:
   371→            if event.type == "content":
   372→                content = event.data.get("content", "")
   373→                if content:
   374→                    yield f'0:{json.dumps(content, ensure_ascii=False)}\n'
   375→
   376→            elif event.type == "tool_result":
   377→                tool_name = event.data.get("name", "unknown")
   378→
   379→                # 过滤内部工具，不发送给前端
   380→                if tool_name in self.INTERNAL_TOOLS:
   381→                    continue
   382→
   383→                # 检查工具结果是否包含错误
   384→                result = event.data.get("result", {})
   385→                if isinstance(result, dict) and result.get("error"):
   386→                    # 工具执行出错，不发送原始错误给前端
   387→                    # Agent 会根据错误生成友好的文本回复
   388→                    continue
   389→
   390→                # 将工具结果嵌入文本流作为特殊标记
   391→                marker = f'[[TOOL:{tool_name}:{json.dumps(result, ensure_ascii=False)}]]'
   392→                yield f'0:{json.dumps(marker, ensure_ascii=False)}\n'
   393→
   394→            elif event.type == "error":
   395→                # 错误信息友好化
   396→                raw_error = str(event.data.get("error", "Unknown error"))
   397→                friendly_error = self._get_friendly_error(raw_error)
   398→                yield f'3:{json.dumps(friendly_error)}\n'
   399→
   400→            elif event.type == "protocol_progress":
   401→                # 协议进度更新 - 使用 AI SDK Data Stream Protocol data part (2:[key, value])
   402→                yield f'2:{json.dumps(["protocol_progress", event.data], ensure_ascii=False)}\n'
   403→
   404→            elif event.type == "protocol_completed":
   405→                # 协议完成 - 使用 AI SDK Data Stream Protocol data part (2:[key, value])
   406→                yield f'2:{json.dumps(["protocol_completed", event.data], ensure_ascii=False)}\n'
   407→
   408→        # Finish Message Part
   409→        yield f'd:{json.dumps({"finishReason": "stop", "usage": {"promptTokens": 0, "completionTokens": 0}})}\n'
   410→
   411→
   412→def get_adapter(protocol: str = "openai") -> BaseStreamAdapter:
   413→    """获取适配器实例"""
   414→    adapters = {
   415→        "openai": OpenAIAdapter,
   416→        "text": TextStreamAdapter,
   417→        "ai-sdk-6": AISDKv6Adapter,
   418→        "legacy": LegacySSEAdapter,
   419→        "simple": SimpleToolAdapter,
   420→    }
   421→    adapter_class = adapters.get(protocol, OpenAIAdapter)
   422→    return adapter_class()
   423→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
