     1→"use client";
     2→
     3→import { Suspense, useMemo } from "react";
     4→import { cn } from "@/lib/utils";
     5→import { ExpertAvatar, type SkillType } from "@/components/core";
     6→import { skillRegistry } from "@/skills/registry";
     7→import { CardRegistry } from "@/skills/CardRegistry";
     8→import { useToolSchema } from "@/hooks/useToolSchema";
     9→import { MarkdownRenderer } from "./MarkdownRenderer";
    10→import { ToolCardErrorBoundary } from "./ToolCardErrorBoundary";
    11→import type { SkillId, ToolExecuteContext } from "@/skills/types";
    12→
    13→// ═══════════════════════════════════════════════════════════════════════════
    14→// ChatMessage - v7.1 Linear 风格设计系统
    15→// 克制、精致、流畅
    16→// ═══════════════════════════════════════════════════════════════════════════
    17→
    18→// 内容段类型
    19→interface TextSegment {
    20→  type: 'text';
    21→  content: string;
    22→}
    23→
    24→interface ToolSegment {
    25→  type: 'tool';
    26→  name: string;
    27→  data: unknown;
    28→}
    29→
    30→type ContentSegment = TextSegment | ToolSegment;
    31→
    32→// 解析内容，提取 [[TOOL:...]] 标记
    33→function parseContent(content: string): ContentSegment[] {
    34→  const regex = /\[\[TOOL:(\w+):([\s\S]*?)\]\]/g;
    35→  const segments: ContentSegment[] = [];
    36→  let lastIndex = 0;
    37→
    38→  const matches = Array.from(content.matchAll(regex));
    39→  for (const match of matches) {
    40→    // 前面的文本
    41→    if (match.index !== undefined && match.index > lastIndex) {
    42→      const text = content.slice(lastIndex, match.index).trim();
    43→      if (text) {
    44→        segments.push({ type: 'text', content: text });
    45→      }
    46→    }
    47→    // tool 块
    48→    try {
    49→      segments.push({
    50→        type: 'tool',
    51→        name: match[1],
    52→        data: JSON.parse(match[2])
    53→      });
    54→    } catch {
    55→      // JSON 解析失败，作为文本处理
    56→      segments.push({ type: 'text', content: match[0] });
    57→    }
    58→    lastIndex = (match.index ?? 0) + match[0].length;
    59→  }
    60→
    61→  // 剩余文本
    62→  if (lastIndex < content.length) {
    63→    const text = content.slice(lastIndex).trim();
    64→    if (text) {
    65→      segments.push({ type: 'text', content: text });
    66→    }
    67→  }
    68→
    69→  return segments;
    70→}
    71→
    72→export interface ChatMessageProps {
    73→  role: "user" | "assistant";
    74→  content: string;
    75→  timestamp?: string;
    76→  isStreaming?: boolean;
    77→  showAvatar?: boolean;
    78→  skill?: SkillType;
    79→  /**
    80→   * 表单提交回调 - 用于处理工具卡片中的表单提交
    81→   */
    82→  onSendMessage?: (message: string) => void;
    83→}
    84→
    85→export function ChatMessage({
    86→  role,
    87→  content,
    88→  timestamp,
    89→  isStreaming,
    90→  showAvatar = true,
    91→  skill = "bazi",
    92→  onSendMessage,
    93→}: ChatMessageProps) {
    94→  const isUser = role === "user";
    95→
    96→  // 解析内容，提取工具标记
    97→  const segments = useMemo(() => {
    98→    if (isUser || !content) return [];
    99→    return parseContent(content);
   100→  }, [content, isUser]);
   101→
   102→  // 判断是否有工具卡片
   103→  const hasToolCards = segments.some(s => s.type === 'tool');
   104→
   105→  return (
   106→    <article
   107→      className={cn(
   108→        // content-visibility 优化长列表 (Vercel rule: rendering-content-visibility)
   109→        "chat-message-item",
   110→        // CSS 动画替代 Framer Motion (Vercel rule: rerender-animation-library)
   111→        "animate-slide-in-up",
   112→        "flex w-full mb-4 gap-3",
   113→        isUser ? "flex-row-reverse" : "flex-row"
   114→      )}
   115→      role={isUser ? "note" : "article"}
   116→      aria-label={isUser ? "您发送的消息" : "AI 助手的回复"}
   117→    >
   118→      {/* Avatar */}
   119→      {showAvatar && !isUser && (
   120→        <ExpertAvatar skill={skill as any} size="md" />
   121→      )}
   122→
   123→      {/* Message content area */}
   124→      <div className={cn("flex-1 max-w-[85%]", isUser && "flex flex-col items-end")}>
   125→        {isUser ? (
   126→          // 用户消息：深色气泡
   127→          <div className="chat-bubble-user">
   128→            <p className="whitespace-pre-wrap leading-relaxed text-sm">{content}</p>
   129→            {timestamp && <p className="chat-timestamp opacity-70 mt-1">{timestamp}</p>}
   130→          </div>
   131→        ) : (
   132→          // AI 消息：解析并渲染文本+工具卡片
   133→          <>
   134→            {segments.map((segment, index) => {
   135→              if (segment.type === 'text') {
   136→                return (
   137→                  <div key={index} className="chat-bubble-assistant">
   138→                    <MarkdownRenderer
   139→                      content={segment.content}
   140→                      isStreaming={isStreaming && index === segments.length - 1}
   141→                    />
   142→                    {/* Streaming indicator - Linear 风格 */}
   143→                    {isStreaming && index === segments.length - 1 && !hasToolCards && (
   144→                      <StreamingDots />
   145→                    )}
   146→                  </div>
   147→                );
   148→              } else {
   149→                return (
   150→                  <ToolCardRenderer
   151→                    key={index}
   152→                    name={segment.name}
   153→                    data={segment.data}
   154→                    skill={skill as SkillId}
   155→                    onSendMessage={onSendMessage}
   156→                  />
   157→                );
   158→              }
   159→            })}
   160→            {/* 如果没有任何段落但有内容，显示原始内容 */}
   161→            {segments.length === 0 && content && (
   162→              <div className="chat-bubble-assistant">
   163→                <MarkdownRenderer content={content} isStreaming={isStreaming} />
   164→                {isStreaming && <StreamingDots />}
   165→              </div>
   166→            )}
   167→            {timestamp && <p className="chat-timestamp mt-1">{timestamp}</p>}
   168→          </>
   169→        )}
   170→      </div>
   171→
   172→      {/* User avatar placeholder for alignment */}
   173→      {showAvatar && isUser && (
   174→        <div className="flex-shrink-0 w-8 h-8" />
   175→      )}
   176→    </article>
   177→  );
   178→}
   179→
   180→// ═══════════════════════════════════════════════════════════════════════════
   181→// StreamingDots - Linear 风格流式加载指示器
   182→// ═══════════════════════════════════════════════════════════════════════════
   183→
   184→function StreamingDots() {
   185→  return (
   186→    <span className="streaming-dots ml-1">
   187→      <span />
   188→      <span />
   189→      <span />
   190→    </span>
   191→  );
   192→}
   193→
   194→// ═══════════════════════════════════════════════════════════════════════════
   195→// ToolCardRenderer - 渲染工具卡片
   196→// ═══════════════════════════════════════════════════════════════════════════
   197→
   198→interface ToolCardRendererProps {
   199→  name: string;
   200→  data: unknown;
   201→  skill: SkillId;
   202→  onSendMessage?: (message: string) => void;
   203→}
   204→
   205→// 内部工具列表 - 静默忽略，不渲染任何内容
   206→const INTERNAL_TOOLS = new Set([
   207→  "use_skill",
   208→  "search_db",
   209→  "get_context",
   210→  "update_memory",
   211→  "log_event",
   212→  "activate_skill",
   213→]);
   214→
   215→function ToolCardRenderer({ name, data, skill, onSendMessage }: ToolCardRendererProps) {
   216→  const { getCardType, getCardProps } = useToolSchema({ skillId: skill });
   217→
   218→  // 0. 内部工具静默忽略
   219→  if (INTERNAL_TOOLS.has(name)) {
   220→    return null;
   221→  }
   222→
   223→  // 1. 优先使用后端返回的 cardType
   224→  const toolData = data as Record<string, unknown> | null;
   225→  const cardType = toolData?.cardType as string | undefined
   226→    || toolData?.card_type as string | undefined
   227→    || getCardType(name);
   228→
   229→  // 2. 如果有 cardType，使用 CardRegistry 渲染
   230→  if (cardType && CardRegistry.has(cardType)) {
   231→    const cardProps = getCardProps(name);
   232→
   233→    // 为表单卡片提供提交回调
   234→    const handleFormSubmit = (formData: Record<string, any>) => {
   235→      if (onSendMessage) {
   236→        // 将表单数据格式化为消息
   237→        const message = Object.entries(formData)
   238→          .map(([key, value]) => `${key}: ${value}`)
   239→          .join('\n');
   240→        onSendMessage(message);
   241→      }
   242→    };
   243→
   244→    // 统一的 onAction 处理器（用于 ShowCard 的 form、select 等）
   245→    const handleAction = (action: string, payload?: any) => {
   246→      if (action === 'submit' && onSendMessage) {
   247→        // form 提交
   248→        const message = Object.entries(payload)
   249→          .map(([key, value]) => `${key}: ${value}`)
   250→          .join('\n');
   251→        onSendMessage(message);
   252→      } else if (action === 'select' && onSendMessage) {
   253→        // select 选择
   254→        onSendMessage(String(payload));
   255→      }
   256→      // 其他 action 可以在这里添加
   257→    };
   258→
   259→    // 处理 QuestionCard 的回答提交
   260→    const handleQuestionSubmit = (answer: string) => {
   261→      if (onSendMessage) {
   262→        onSendMessage(answer);
   263→      }
   264→    };
   265→
   266→    // 适配不同卡片类型的 props 格式
   267→    const adaptedProps = cardType === 'collect_form' ? {
   268→      // CollectFormCard 专用 props
   269→      formFields: toolData?.fields || [],
   270→      title: toolData?.title,
   271→      description: toolData?.description,
   272→      allowTextInput: toolData?.allowTextInput,
   273→      textInputPlaceholder: toolData?.textInputPlaceholder,
   274→      onSubmit: handleFormSubmit,
   275→    } : cardType === 'question_card' ? {
   276→      // QuestionCard 专用 props
   277→      data: toolData,
   278→      onSubmit: handleQuestionSubmit,  // 直接传递字符串回答
   279→    } : cardType === 'skill_recommendation' ? {
   280→      // SkillRecommendationCard 专用 props
   281→      data: toolData,
   282→      onSendMessage,  // 传递消息发送回调
   283→    } : {
   284→      // 通用卡片 props（包括 form、select 等）
   285→      data: toolData,
   286→      cardProps,
   287→      onAction: handleAction,  // ShowCard 使用 onAction
   288→      onSubmit: handleFormSubmit,  // 向后兼容
   289→      ...toolData  // 传递所有后端数据
   290→    };
   291→
   292→    return (
   293→      <ToolCardErrorBoundary toolName={name}>
   294→        <Suspense fallback={<ToolLoadingFallback />}>
   295→          <div className="mt-3">
   296→            {CardRegistry.render(cardType, adaptedProps)}
   297→          </div>
   298→        </Suspense>
   299→      </ToolCardErrorBoundary>
   300→    );
   301→  }
   302→
   303→  // 3. 回退：从 skillRegistry 获取工具定义
   304→  const toolDef = skillRegistry.getTool(name);
   305→  if (toolDef?.render) {
   306→    const context: ToolExecuteContext = { skillId: skill };
   307→    return (
   308→      <ToolCardErrorBoundary toolName={name}>
   309→        <Suspense fallback={<ToolLoadingFallback />}>
   310→          <div className="mt-3">
   311→            {toolDef.render(toolData, context)}
   312→          </div>
   313→        </Suspense>
   314→      </ToolCardErrorBoundary>
   315→    );
   316→  }
   317→
   318→  // 4. Fallback: 静默忽略未知工具（不暴露技术细节）
   319→  // 仅在开发环境输出警告
   320→  if (process.env.NODE_ENV === "development") {
   321→    console.warn(`[ToolCardRenderer] Unknown tool: ${name}`, data);
   322→  }
   323→  return null;
   324→}
   325→
   326→// ═══════════════════════════════════════════════════════════════════════════
   327→// ToolLoadingFallback - Shimmer 加载骨架
   328→// ═══════════════════════════════════════════════════════════════════════════
   329→
   330→function ToolLoadingFallback() {
   331→  return (
   332→    <div className="mt-3 rounded-lg p-4 bg-bg-secondary border border-subtle">
   333→      <div className="skeleton h-4 w-1/3 mb-3 rounded" />
   334→      <div className="skeleton h-20 w-full rounded" />
   335→    </div>
   336→  );
   337→}
   338→
   339→function getToolDisplayName(toolName: string): string {
   340→  const displayNames: Record<string, string> = {
   341→    show_bazi_chart: "展示命盘",
   342→    show_bazi_kline: "展示人生K线",
   343→    show_bazi_fortune: "展示大运流年",
   344→    show_zodiac_chart: "展示星盘",
   345→    show_transit: "展示天象推运",
   346→    show_synastry: "展示合盘分析",
   347→    show_report: "展示报告",
   348→    show_relationship: "关系分析",
   349→    show_insight: "展示洞察",
   350→    request_info: "收集信息",
   351→    show_vibe_id: "展示 VibeID",
   352→    vibe_id: "VibeID 分析",
   353→    vibe_id_radar: "原型分布图",
   354→  };
   355→  return displayNames[toolName] || toolName;
   356→}
   357→
   358→// ═══════════════════════════════════════════════════════════════════════════
   359→// SystemMessage - 系统消息
   360→// ═══════════════════════════════════════════════════════════════════════════
   361→
   362→interface SystemMessageProps {
   363→  content: string;
   364→  className?: string;
   365→}
   366→
   367→export function SystemMessage({ content, className }: SystemMessageProps) {
   368→  return (
   369→    <div className={cn("flex justify-center my-4", className)}>
   370→      <span className="px-3 py-1.5 text-xs text-text-tertiary bg-bg-secondary rounded-full">
   371→        {content}
   372→      </span>
   373→    </div>
   374→  );
   375→}
   376→
   377→// ═══════════════════════════════════════════════════════════════════════════
   378→// TypingIndicator - AI 思考指示器
   379→// ═══════════════════════════════════════════════════════════════════════════
   380→
   381→interface TypingIndicatorProps {
   382→  className?: string;
   383→  skill?: SkillType;
   384→}
   385→
   386→export function TypingIndicator({ className, skill = "bazi" }: TypingIndicatorProps) {
   387→  return (
   388→    <div
   389→      className={cn("flex items-center gap-3 mb-4 animate-slide-in-up", className)}
   390→    >
   391→      <ExpertAvatar skill={skill as any} size="md" />
   392→      <div className="chat-bubble-assistant py-3">
   393→        <div className="streaming-dots">
   394→          <span />
   395→          <span />
   396→          <span />
   397→        </div>
   398→      </div>
   399→    </div>
   400→  );
   401→}
   402→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
