     1→"""
     2→Unified Tool Registry v6 - 统一工具注册表
     3→
     4→解决工具注册的硬编码问题：
     5→1. 从 YAML 加载工具定义 (Single Source of Truth)
     6→2. 使用 @tool_handler 装饰器动态注册执行器
     7→3. 消除 if-elif 分发，使用注册表查找
     8→
     9→V6.1 更新：
    10→- 全局工具从 skills/core/tools/ 加载
    11→- 移除对 GLOBAL_TOOLS 硬编码的依赖
    12→
    13→新增工具只需修改 2 处：
    14→1. skills/{skill_id}/tools/tools.yaml - 工具定义
    15→2. skills/{skill_id}/tools/handlers.py - @tool_handler 执行器
    16→
    17→用法：
    18→    from services.agent.tool_registry import tool_handler, ToolRegistry
    19→
    20→    @tool_handler("show_bazi_chart")
    21→    async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:
    22→        return {"chart": ...}
    23→
    24→    # CoreAgent 中使用
    25→    tools = ToolRegistry.get_tools_for_skill("bazi")
    26→    result = await ToolRegistry.execute("show_bazi_chart", args, context)
    27→"""
    28→import logging
    29→import importlib
    30→import asyncio
    31→from pathlib import Path
    32→from typing import Dict, Any, List, Optional, Callable, Awaitable, Union
    33→from dataclasses import dataclass, field
    34→from functools import wraps
    35→
    36→from .tool_schema import ToolDef, load_skill_tools, get_global_tools
    37→
    38→logger = logging.getLogger(__name__)
    39→
    40→SKILLS_DIR = Path(__file__).parent.parent.parent / "skills"
    41→
    42→
    43→@dataclass
    44→class ToolContext:
    45→    """工具执行上下文"""
    46→    user_id: str
    47→    user_tier: str = "free"
    48→    profile: Dict[str, Any] = field(default_factory=dict)
    49→    skill_data: Dict[str, Any] = field(default_factory=dict)
    50→    skill_id: Optional[str] = None
    51→    scenario_id: Optional[str] = None
    52→    conversation_id: Optional[str] = None
    53→
    54→
    55→# 工具执行器类型: 同步或异步函数
    56→ToolHandler = Callable[[Dict[str, Any], ToolContext], Union[Dict[str, Any], Awaitable[Dict[str, Any]]]]
    57→
    58→
    59→class UnifiedToolRegistry:
    60→    """
    61→    统一工具注册表
    62→
    63→    - 工具定义从 YAML 加载
    64→    - 执行器通过 @tool_handler 装饰器注册
    65→    - 支持全局工具和 Skill 专属工具
    66→    """
    67→
    68→    # 工具定义缓存: {tool_name: ToolDef}
    69→    _tool_defs: Dict[str, ToolDef] = {}
    70→
    71→    # 工具执行器: {tool_name: handler_function}
    72→    _handlers: Dict[str, ToolHandler] = {}
    73→
    74→    # 已加载的 Skill
    75→    _loaded_skills: set = set()
    76→
    77→    # 是否已初始化
    78→    _initialized: bool = False
    79→
    80→    @classmethod
    81→    def initialize(cls):
    82→        """初始化注册表，加载全局工具"""
    83→        if cls._initialized:
    84→            return
    85→
    86→        # 从 core skill 加载全局工具定义
    87→        global_tools = get_global_tools()
    88→        for tool in global_tools:
    89→            tool.is_global = True
    90→            cls._tool_defs[tool.name] = tool
    91→
    92→        # 加载 core skill 的 handlers
    93→        cls._load_handlers_module("core")
    94→
    95→        # 自动发现并加载所有 Skill 的工具
    96→        cls._auto_discover_skills()
    97→
    98→        cls._initialized = True
    99→        logger.info(f"ToolRegistry initialized: {len(cls._tool_defs)} tools, {len(cls._handlers)} handlers")
   100→
   101→    @classmethod
   102→    def _auto_discover_skills(cls):
   103→        """自动发现并加载所有 Skill"""
   104→        if not SKILLS_DIR.exists():
   105→            logger.warning(f"Skills directory not found: {SKILLS_DIR}")
   106→            return
   107→
   108→        for skill_dir in SKILLS_DIR.iterdir():
   109→            if skill_dir.is_dir() and skill_dir.name != "__pycache__":
   110→                skill_id = skill_dir.name
   111→                cls.load_skill(skill_id)
   112→
   113→    @classmethod
   114→    def load_skill(cls, skill_id: str):
   115→        """加载 Skill 的工具定义和执行器"""
   116→        if skill_id in cls._loaded_skills:
   117→            return
   118→
   119→        # 1. 从 YAML 加载工具定义
   120→        tools = load_skill_tools(skill_id)
   121→        for tool in tools:
   122→            tool.skill_id = skill_id  # 标记所属 Skill
   123→            cls._tool_defs[tool.name] = tool
   124→
   125→        # 2. 尝试加载执行器模块
   126→        cls._load_handlers_module(skill_id)
   127→
   128→        cls._loaded_skills.add(skill_id)
   129→        logger.debug(f"Loaded skill '{skill_id}': {len(tools)} tools")
   130→
   131→    @classmethod
   132→    def _load_handlers_module(cls, skill_id: str):
   133→        """加载 Skill 的 handlers 模块"""
   134→        handlers_path = SKILLS_DIR / skill_id / "tools" / "handlers.py"
   135→        if not handlers_path.exists():
   136→            logger.debug(f"No handlers module for skill '{skill_id}'")
   137→            return
   138→
   139→        try:
   140→            module_name = f"skills.{skill_id}.tools.handlers"
   141→            importlib.import_module(module_name)
   142→            logger.debug(f"Loaded handlers module: {module_name}")
   143→        except ImportError as e:
   144→            logger.warning(f"Failed to import handlers for '{skill_id}': {e}")
   145→
   146→    @classmethod
   147→    def register_handler(cls, tool_name: str, handler: ToolHandler):
   148→        """注册工具执行器"""
   149→        cls._handlers[tool_name] = handler
   150→        logger.debug(f"Registered handler: {tool_name}")
   151→
   152→    @classmethod
   153→    def get_tool_def(cls, tool_name: str) -> Optional[ToolDef]:
   154→        """获取工具定义"""
   155→        cls.initialize()
   156→        return cls._tool_defs.get(tool_name)
   157→
   158→    @classmethod
   159→    def get_tools_for_skill(cls, skill_id: str) -> List[Dict[str, Any]]:
   160→        """获取 Skill 的所有工具 (OpenAI 格式)
   161→
   162→        V6.2 更新：按需加载全局工具
   163→        - 如果 SKILL.md 中声明了 global_tools，只加载声明的全局工具
   164→        - 如果没有声明，加载所有全局工具（向后兼容）
   165→        """
   166→        cls.initialize()
   167→
   168→        tools = []
   169→
   170→        # 获取 Skill 声明需要的全局工具
   171→        from .skill_loader import get_skill_global_tools
   172→        declared_global_tools = get_skill_global_tools(skill_id)
   173→
   174→        # 全局工具（从 core skill 加载）
   175→        all_global_tools = get_global_tools()
   176→        for tool in all_global_tools:
   177→            # 如果声明了 global_tools，只加载声明的；否则加载全部
   178→            if declared_global_tools:
   179→                if tool.name in declared_global_tools:
   180→                    tools.append(tool.to_openai_format())
   181→            else:
   182→                # 向后兼容：没有声明则加载全部
   183→                tools.append(tool.to_openai_format())
   184→
   185→        # Skill 专属工具（跳过 core，因为已经加载了）
   186→        if skill_id != "core":
   187→            for name, tool in cls._tool_defs.items():
   188→                if getattr(tool, 'skill_id', None) == skill_id:
   189→                    tools.append(tool.to_openai_format())
   190→
   191→        # v7.3: 外部工具（从其他 skill 导入）
   192→        from .skill_loader import get_skill_external_tools
   193→        external_tool_names = get_skill_external_tools(skill_id)
   194→        if external_tool_names:
   195→            for name, tool in cls._tool_defs.items():
   196→                if name in external_tool_names:
   197→                    tools.append(tool.to_openai_format())
   198→
   199→        return tools
   200→
   201→    @classmethod
   202→    def get_all_tools(cls) -> List[Dict[str, Any]]:
   203→        """获取所有已注册的工具 (OpenAI 格式)"""
   204→        cls.initialize()
   205→        return [tool.to_openai_format() for tool in cls._tool_defs.values()]
   206→
   207→    @classmethod
   208→    def get_card_type(cls, tool_name: str) -> Optional[str]:
   209→        """获取工具对应的卡片类型"""
   210→        tool = cls.get_tool_def(tool_name)
   211→        return tool.card_type if tool else None
   212→
   213→    @classmethod
   214→    def has_handler(cls, tool_name: str) -> bool:
   215→        """检查是否有注册的执行器"""
   216→        cls.initialize()
   217→        return tool_name in cls._handlers
   218→
   219→    @classmethod
   220→    async def execute(
   221→        cls,
   222→        tool_name: str,
   223→        args: Dict[str, Any],
   224→        context: ToolContext
   225→    ) -> Dict[str, Any]:
   226→        """执行工具"""
   227→        cls.initialize()
   228→
   229→        if tool_name not in cls._handlers:
   230→            logger.warning(f"No handler for tool: {tool_name}")
   231→            return {"error": f"Tool handler not found: {tool_name}"}
   232→
   233→        handler = cls._handlers[tool_name]
   234→
   235→        try:
   236→            # 支持同步和异步处理器
   237→            result = handler(args, context)
   238→            if asyncio.iscoroutine(result):
   239→                result = await result
   240→            return result
   241→        except Exception as e:
   242→            logger.error(f"Tool execution failed: {tool_name}, error: {e}")
   243→            return {"error": str(e)}
   244→
   245→    @classmethod
   246→    def get_schema(cls, skill_id: Optional[str] = None) -> Dict[str, Any]:
   247→        """获取工具 Schema (用于前端)"""
   248→        cls.initialize()
   249→
   250→        global_tool_names = {t.name for t in get_global_tools()}
   251→
   252→        # v7.3: 获取外部工具名
   253→        external_tool_names = set()
   254→        if skill_id:
   255→            from .skill_loader import get_skill_external_tools
   256→            external_tool_names = set(get_skill_external_tools(skill_id))
   257→
   258→        tools = []
   259→        for name, tool in cls._tool_defs.items():
   260→            if skill_id and getattr(tool, 'skill_id', None) != skill_id:
   261→                if name not in global_tool_names and name not in external_tool_names:
   262→                    continue
   263→
   264→            tools.append({
   265→                "name": tool.name,
   266→                "description": tool.description,
   267→                "tool_type": tool.tool_type,
   268→                "card_type": tool.card_type,
   269→                "fallback_type": tool.fallback_type,  # V7.1: 降级类型
   270→                "card_props": tool.card_props,  # 新增: 表单配置等
   271→                "parameters": [
   272→                    {
   273→                        "name": p.name,
   274→                        "type": p.type,
   275→                        "required": p.required,
   276→                        "description": p.description,
   277→                        "enum": p.enum,
   278→                        "default": p.default,
   279→                    }
   280→                    for p in tool.parameters
   281→                ],
   282→                "when_to_call": tool.when_to_call,
   283→            })
   284→
   285→        return {
   286→            "version": "7.1",
   287→            "skill_id": skill_id,
   288→            "tools": tools,
   289→        }
   290→
   291→    @classmethod
   292→    def clear(cls):
   293→        """清除所有注册 (用于测试)"""
   294→        cls._tool_defs.clear()
   295→        cls._handlers.clear()
   296→        cls._loaded_skills.clear()
   297→        cls._initialized = False
   298→
   299→
   300→def tool_handler(tool_name: str):
   301→    """
   302→    工具执行器装饰器
   303→
   304→    用法:
   305→        @tool_handler("show_bazi_chart")
   306→        async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:
   307→            return {"chart": ...}
   308→    """
   309→    def decorator(func: ToolHandler) -> ToolHandler:
   310→        @wraps(func)
   311→        async def wrapper(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
   312→            result = func(args, context)
   313→            if asyncio.iscoroutine(result):
   314→                return await result
   315→            return result
   316→
   317→        # 注册到 Registry
   318→        UnifiedToolRegistry.register_handler(tool_name, wrapper)
   319→        return wrapper
   320→
   321→    return decorator
   322→
   323→
   324→# 便捷别名
   325→ToolRegistry = UnifiedToolRegistry
   326→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
