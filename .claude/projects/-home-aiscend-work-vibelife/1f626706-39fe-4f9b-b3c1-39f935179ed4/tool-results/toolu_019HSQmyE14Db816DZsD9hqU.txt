     1→import { NextResponse } from "next/server";
     2→import type { NextRequest } from "next/server";
     3→
     4→/**
     5→ * Middleware - 子域名路由 + Skill 检测
     6→ *
     7→ * 路由规则:
     8→ * - vibelife.app (无子域名) -> 品牌首页 (www 路由组)
     9→ * - bazi.vibelife.app -> /bazi/* 路由组
    10→ * - zodiac.vibelife.app -> /zodiac/* 路由组
    11→ *
    12→ * URL 重写示例:
    13→ * - bazi.vibelife.app/ -> /bazi
    14→ * - bazi.vibelife.app/chat -> /bazi/chat
    15→ * - zodiac.vibelife.app/chat -> /zodiac/chat
    16→ *
    17→ * 本地开发:
    18→ * - localhost:3000 -> 默认显示品牌首页
    19→ * - localhost:3000/bazi -> bazi 路由
    20→ * - localhost:3000/zodiac -> zodiac 路由
    21→ */
    22→
    23→// 支持的 skill 类型
    24→const VALID_SKILLS = ["bazi", "zodiac", "mbti", "attach", "career"] as const;
    25→type ValidSkill = (typeof VALID_SKILLS)[number];
    26→
    27→// 当前已启用的 skills (有对应路由组)
    28→const ENABLED_SKILLS: ValidSkill[] = ["bazi", "zodiac"];
    29→
    30→// 默认 skill
    31→const DEFAULT_SKILL: ValidSkill = "bazi";
    32→
    33→// 共享路由（不需要 skill 前缀）
    34→const SHARED_ROUTES = ["/auth", "/payment", "/checkout", "/interview"];
    35→
    36→// 检查是否是共享路由
    37→function isSharedRoute(pathname: string): boolean {
    38→  return SHARED_ROUTES.some((route) => pathname.startsWith(route));
    39→}
    40→
    41→// 检查路径是否已经包含 skill 前缀
    42→function hasSkillPrefix(pathname: string): boolean {
    43→  const firstSegment = pathname.split("/")[1];
    44→  return VALID_SKILLS.includes(firstSegment as ValidSkill);
    45→}
    46→
    47→export default function middleware(request: NextRequest) {
    48→  const url = request.nextUrl.clone();
    49→  const hostname = request.headers.get("host") || "";
    50→  const pathname = url.pathname;
    51→
    52→  // 提取子域名
    53→  let detectedSkill: ValidSkill | null = null;
    54→  const parts = hostname.split(".");
    55→
    56→  // 检测子域名
    57→  // 格式: {skill}.vibelife.app 或 {skill}.localhost:xxxx
    58→  if (parts.length >= 2) {
    59→    const subdomain = parts[0].toLowerCase();
    60→    if (ENABLED_SKILLS.includes(subdomain as ValidSkill)) {
    61→      detectedSkill = subdomain as ValidSkill;
    62→    }
    63→  }
    64→
    65→  // 确定最终使用的 skill
    66→  let skill: ValidSkill;
    67→  let shouldRewrite = false;
    68→
    69→  if (detectedSkill) {
    70→    // 有子域名，使用子域名对应的 skill
    71→    skill = detectedSkill;
    72→
    73→    // 如果路径不是共享路由且没有 skill 前缀，需要重写
    74→    if (!isSharedRoute(pathname) && !hasSkillPrefix(pathname)) {
    75→      shouldRewrite = true;
    76→    }
    77→  } else {
    78→    // 无子域名
    79→    // 检查路径是否已有 skill 前缀
    80→    const firstSegment = pathname.split("/")[1];
    81→    if (ENABLED_SKILLS.includes(firstSegment as ValidSkill)) {
    82→      skill = firstSegment as ValidSkill;
    83→    } else {
    84→      skill = DEFAULT_SKILL;
    85→    }
    86→  }
    87→
    88→  // 设置 skill 到请求头
    89→  const requestHeaders = new Headers(request.headers);
    90→  requestHeaders.set("x-vibelife-skill", skill);
    91→
    92→  // 处理 URL 重写（仅当有子域名时）
    93→  if (shouldRewrite && detectedSkill) {
    94→    // 重写路径：添加 skill 前缀
    95→    // / -> /bazi
    96→    // /chat -> /bazi/chat
    97→    const newPathname = pathname === "/" ? `/${detectedSkill}` : `/${detectedSkill}${pathname}`;
    98→    url.pathname = newPathname;
    99→
   100→    const response = NextResponse.rewrite(url, {
   101→      request: { headers: requestHeaders },
   102→    });
   103→
   104→    // 设置 cookie
   105→    response.cookies.set("vibelife-skill", skill, {
   106→      path: "/",
   107→      sameSite: "lax",
   108→      secure: process.env.NODE_ENV === "production",
   109→      maxAge: 60 * 60 * 24 * 365,
   110→    });
   111→
   112→    return response;
   113→  }
   114→
   115→  // 普通请求（无重写）
   116→  const response = NextResponse.next({
   117→    request: { headers: requestHeaders },
   118→  });
   119→
   120→  // 设置 cookie
   121→  response.cookies.set("vibelife-skill", skill, {
   122→    path: "/",
   123→    sameSite: "lax",
   124→    secure: process.env.NODE_ENV === "production",
   125→    maxAge: 60 * 60 * 24 * 365,
   126→  });
   127→
   128→  return response;
   129→}
   130→
   131→export const config = {
   132→  matcher: [
   133→    /*
   134→     * Match all request paths except:
   135→     * - _next/static (static files)
   136→     * - _next/image (image optimization files)
   137→     * - favicon.ico (favicon file)
   138→     * - public folder files
   139→     * - api routes
   140→     */
   141→    "/((?!_next/static|_next/image|favicon.ico|.*\\..*|api).*)",
   142→  ],
   143→};
   144→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
