     1â†’"""
     2â†’Interview Service - Core interview logic
     3â†’Based on: vibelife spec v3.0, section 4.2
     4â†’
     5â†’Trigger Conditions:
     6â†’- User requests report generation
     7â†’- User info is incomplete (Profile score < threshold)
     8â†’- First-time user
     9â†’
    10â†’Required Questions (2-3):
    11â†’1. Current concerns/pain points
    12â†’2. Life status (career, relationship, etc.)
    13â†’3. Expectations and goals
    14â†’"""
    15â†’import json
    16â†’from typing import Optional, List, Dict, Any, Tuple
    17â†’from uuid import UUID, uuid4
    18â†’from datetime import datetime
    19â†’from dataclasses import dataclass, field, asdict
    20â†’from enum import Enum
    21â†’import logging
    22â†’
    23â†’from services.vibe_engine.llm import get_llm_service, create_user_message, LLMService
    24â†’from stores.db import get_connection
    25â†’
    26â†’logger = logging.getLogger(__name__)
    27â†’
    28â†’
    29â†’class InterviewState(str, Enum):
    30â†’    """Interview session states"""
    31â†’    NOT_STARTED = "not_started"
    32â†’    IN_PROGRESS = "in_progress"
    33â†’    COMPLETED = "completed"
    34â†’    SKIPPED = "skipped"
    35â†’
    36â†’
    37â†’@dataclass
    38â†’class InterviewQuestion:
    39â†’    """A single interview question"""
    40â†’    id: str
    41â†’    question_text: str
    42â†’    question_type: str  # core | followup | optional
    43â†’    answer: Optional[str] = None
    44â†’    extracted_info: Optional[Dict[str, Any]] = None
    45â†’    answered_at: Optional[datetime] = None
    46â†’
    47â†’
    48â†’@dataclass
    49â†’class InterviewSession:
    50â†’    """Complete interview session"""
    51â†’    id: UUID
    52â†’    user_id: Optional[UUID]
    53â†’    skill: str  # bazi | zodiac
    54â†’    state: InterviewState
    55â†’    questions: List[InterviewQuestion]
    56â†’    current_question_idx: int
    57â†’    created_at: datetime
    58â†’    completed_at: Optional[datetime] = None
    59â†’
    60â†’    def to_dict(self) -> dict:
    61â†’        return {
    62â†’            "id": str(self.id),
    63â†’            "user_id": str(self.user_id) if self.user_id else None,
    64â†’            "skill": self.skill,
    65â†’            "state": self.state.value,
    66â†’            "questions": [
    67â†’                {
    68â†’                    "id": q.id,
    69â†’                    "question_text": q.question_text,
    70â†’                    "question_type": q.question_type,
    71â†’                    "answer": q.answer,
    72â†’                    "extracted_info": q.extracted_info,
    73â†’                    "answered_at": q.answered_at.isoformat() if q.answered_at else None,
    74â†’                }
    75â†’                for q in self.questions
    76â†’            ],
    77â†’            "current_question_idx": self.current_question_idx,
    78â†’            "created_at": self.created_at.isoformat(),
    79â†’            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
    80â†’        }
    81â†’
    82â†’
    83â†’@dataclass
    84â†’class InterviewResult:
    85â†’    """Final interview extraction result"""
    86â†’    success: bool
    87â†’    extracted_profile: Dict[str, Any]
    88â†’    summary: str
    89â†’    questions_answered: int
    90â†’    total_questions: int
    91â†’
    92â†’
    93â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    94â†’# Core Questions (æŒ‰ spec 4.2)
    95â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    96â†’
    97â†’CORE_QUESTIONS = [
    98â†’    {
    99â†’        "id": "q1_concerns",
   100â†’        "question_text": "ä½ çŽ°åœ¨æœ€æƒ³è§£å†³çš„é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿæˆ–è€…ï¼Œæœ€å›°æ‰°ä½ çš„æ˜¯ä»€ä¹ˆï¼Ÿ",
   101â†’        "question_type": "core",
   102â†’        "extract_fields": ["current_concerns", "pain_points"],
   103â†’    },
   104â†’    {
   105â†’        "id": "q2_life_status",
   106â†’        "question_text": "ç®€å•è¯´è¯´ä½ çŽ°åœ¨çš„çŠ¶æ€ï¼Ÿå·¥ä½œã€æ„Ÿæƒ…ã€è¿˜æ˜¯å…¶ä»–æ–¹é¢ï¼Ÿ",
   107â†’        "question_type": "core",
   108â†’        "extract_fields": ["career_status", "relationship_status", "life_stage"],
   109â†’    },
   110â†’    {
   111â†’        "id": "q3_expectations",
   112â†’        "question_text": "ä½ å¸Œæœ›ä»Žè¿™æ¬¡åˆ†æžä¸­èŽ·å¾—ä»€ä¹ˆï¼Ÿ",
   113â†’        "question_type": "core",
   114â†’        "extract_fields": ["expectations", "goals"],
   115â†’    },
   116â†’]
   117â†’
   118â†’INTERVIEW_INTRO = """ðŸŒŸ åœ¨ç”Ÿæˆä½ çš„ä¸“å±žæŠ¥å‘Šä¹‹å‰...
   119â†’
   120â†’æˆ‘æƒ³æ›´äº†è§£ä½ ä¸€ç‚¹ã€‚è¿™æ ·æˆ‘æ‰èƒ½ç»™ä½ çœŸæ­£æœ‰ç”¨çš„åˆ†æžï¼Œè€Œä¸æ˜¯æ³›æ³›è€Œè°ˆã€‚
   121â†’
   122â†’å‡†å¤‡å¥½äº†å—ï¼Ÿåªéœ€è¦å›žç­” 2-3 ä¸ªé—®é¢˜ã€‚"""
   123â†’
   124â†’INTERVIEW_SKIP_WARNING = """è·³è¿‡è®¿è°ˆåŽï¼ŒæŠ¥å‘Šå¯èƒ½ä¸å¤Ÿç²¾å‡†ï¼Œåªèƒ½åŸºäºŽåŸºç¡€ä¿¡æ¯è¿›è¡Œåˆ†æžã€‚
   125â†’
   126â†’ç¡®å®šè¦è·³è¿‡å—ï¼Ÿ"""
   127â†’
   128â†’
   129â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   130â†’# Answer Extraction Prompt
   131â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   132â†’
   133â†’EXTRACT_ANSWER_PROMPT = """ä»Žç”¨æˆ·å›žç­”ä¸­æŠ½å–ç»“æž„åŒ–ä¿¡æ¯ã€‚
   134â†’
   135â†’é—®é¢˜: {question}
   136â†’ç”¨æˆ·å›žç­”: {answer}
   137â†’
   138â†’è¯·æå–ä»¥ä¸‹å­—æ®µï¼ˆå¦‚æžœèƒ½ä»Žå›žç­”ä¸­èŽ·å–ï¼‰ï¼š
   139â†’{extract_fields}
   140â†’
   141â†’## è¾“å‡ºæ ¼å¼ï¼ˆåªè¾“å‡º JSONï¼‰
   142â†’{{
   143â†’  "life_context": {{
   144â†’    "career": {{
   145â†’      "status": "employed | unemployed | student | freelance | null",
   146â†’      "industry": "è¡Œä¸š | null",
   147â†’      "concerns": ["å…³æ³¨ç‚¹1", "å…³æ³¨ç‚¹2"]
   148â†’    }},
   149â†’    "relationship": {{
   150â†’      "status": "single | in_relationship | married | divorced | null",
   151â†’      "concerns": ["å…³æ³¨ç‚¹1"]
   152â†’    }},
   153â†’    "current_focus": ["å½“å‰å…³æ³¨é¢†åŸŸ"],
   154â†’    "life_stage": "æè¿° | null"
   155â†’  }},
   156â†’  "ai_insights": {{
   157â†’    "current_concerns": ["å›°å¢ƒ1", "å›°å¢ƒ2"],
   158â†’    "pain_points": ["ç—›ç‚¹1"],
   159â†’    "expectations": ["æœŸæœ›1"],
   160â†’    "goals": ["ç›®æ ‡1"]
   161â†’  }}
   162â†’}}
   163â†’
   164â†’å¦‚æžœæŸä¸ªå­—æ®µæ— æ³•ä»Žå›žç­”ä¸­èŽ·å–ï¼Œè®¾ä¸º null æˆ–ç©ºæ•°ç»„ã€‚
   165â†’åªè¿”å›ž JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚"""
   166â†’
   167â†’
   168â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   169â†’# Interview Service
   170â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   171â†’
   172â†’class InterviewService:
   173â†’    """
   174â†’    AI Interview Service for collecting user context before report generation.
   175â†’
   176â†’    Features:
   177â†’    - Start/continue/skip interview sessions
   178â†’    - Extract structured info from answers
   179â†’    - Generate follow-up questions
   180â†’    - Merge results into user profile
   181â†’    - Database persistence for sessions
   182â†’    """
   183â†’
   184â†’    def __init__(self, llm: Optional[LLMService] = None):
   185â†’        self.llm = llm or get_llm_service()
   186â†’        self._cache: Dict[UUID, InterviewSession] = {}  # In-memory cache
   187â†’
   188â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   189â†’    # Database Operations
   190â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   191â†’
   192â†’    async def _save_session_to_db(self, session: InterviewSession) -> None:
   193â†’        """Save session to database"""
   194â†’        try:
   195â†’            async with get_connection() as conn:
   196â†’                await conn.execute("""
   197â†’                    INSERT INTO interview_sessions (id, user_id, skill, state, questions, current_question_idx, created_at, completed_at)
   198â†’                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
   199â†’                    ON CONFLICT (id) DO UPDATE SET
   200â†’                        state = EXCLUDED.state,
   201â†’                        questions = EXCLUDED.questions,
   202â†’                        current_question_idx = EXCLUDED.current_question_idx,
   203â†’                        completed_at = EXCLUDED.completed_at
   204â†’                """,
   205â†’                    session.id,
   206â†’                    session.user_id,
   207â†’                    session.skill,
   208â†’                    session.state.value,
   209â†’                    json.dumps([{
   210â†’                        "id": q.id,
   211â†’                        "question_text": q.question_text,
   212â†’                        "question_type": q.question_type,
   213â†’                        "answer": q.answer,
   214â†’                        "extracted_info": q.extracted_info,
   215â†’                        "answered_at": q.answered_at.isoformat() if q.answered_at else None,
   216â†’                    } for q in session.questions]),
   217â†’                    session.current_question_idx,
   218â†’                    session.created_at,
   219â†’                    session.completed_at
   220â†’                )
   221â†’        except Exception as e:
   222â†’            logger.error(f"Failed to save interview session to DB: {e}")
   223â†’
   224â†’    async def _load_session_from_db(self, session_id: UUID) -> Optional[InterviewSession]:
   225â†’        """Load session from database"""
   226â†’        try:
   227â†’            async with get_connection() as conn:
   228â†’                row = await conn.fetchrow(
   229â†’                    "SELECT * FROM interview_sessions WHERE id = $1",
   230â†’                    session_id
   231â†’                )
   232â†’                if not row:
   233â†’                    return None
   234â†’
   235â†’                questions_data = json.loads(row["questions"]) if isinstance(row["questions"], str) else row["questions"]
   236â†’                questions = [
   237â†’                    InterviewQuestion(
   238â†’                        id=q["id"],
   239â†’                        question_text=q["question_text"],
   240â†’                        question_type=q["question_type"],
   241â†’                        answer=q.get("answer"),
   242â†’                        extracted_info=q.get("extracted_info"),
   243â†’                        answered_at=datetime.fromisoformat(q["answered_at"]) if q.get("answered_at") else None,
   244â†’                    )
   245â†’                    for q in questions_data
   246â†’                ]
   247â†’
   248â†’                return InterviewSession(
   249â†’                    id=row["id"],
   250â†’                    user_id=row["user_id"],
   251â†’                    skill=row["skill"],
   252â†’                    state=InterviewState(row["state"]),
   253â†’                    questions=questions,
   254â†’                    current_question_idx=row["current_question_idx"],
   255â†’                    created_at=row["created_at"],
   256â†’                    completed_at=row["completed_at"],
   257â†’                )
   258â†’        except Exception as e:
   259â†’            logger.error(f"Failed to load interview session from DB: {e}")
   260â†’            return None
   261â†’
   262â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   263â†’    # Session Management
   264â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   265â†’
   266â†’    async def start_session(
   267â†’        self,
   268â†’        skill: str,
   269â†’        user_id: Optional[UUID] = None,
   270â†’        custom_questions: Optional[List[Dict]] = None
   271â†’    ) -> InterviewSession:
   272â†’        """
   273â†’        Start a new interview session.
   274â†’
   275â†’        Args:
   276â†’            skill: bazi or zodiac
   277â†’            user_id: Optional user ID
   278â†’            custom_questions: Override default questions
   279â†’
   280â†’        Returns:
   281â†’            New InterviewSession
   282â†’        """
   283â†’        session_id = uuid4()
   284â†’
   285â†’        # Build questions list
   286â†’        questions_data = custom_questions or CORE_QUESTIONS
   287â†’        questions = [
   288â†’            InterviewQuestion(
   289â†’                id=q["id"],
   290â†’                question_text=q["question_text"],
   291â†’                question_type=q.get("question_type", "core"),
   292â†’            )
   293â†’            for q in questions_data
   294â†’        ]
   295â†’
   296â†’        session = InterviewSession(
   297â†’            id=session_id,
   298â†’            user_id=user_id,
   299â†’            skill=skill,
   300â†’            state=InterviewState.IN_PROGRESS,
   301â†’            questions=questions,
   302â†’            current_question_idx=0,
   303â†’            created_at=datetime.utcnow(),
   304â†’        )
   305â†’
   306â†’        # Save to database and cache
   307â†’        await self._save_session_to_db(session)
   308â†’        self._cache[session_id] = session
   309â†’        return session
   310â†’
   311â†’    async def get_session(self, session_id: UUID) -> Optional[InterviewSession]:
   312â†’        """Get an existing session from cache or database"""
   313â†’        # Check cache first
   314â†’        if session_id in self._cache:
   315â†’            return self._cache[session_id]
   316â†’
   317â†’        # Load from database
   318â†’        session = await self._load_session_from_db(session_id)
   319â†’        if session:
   320â†’            self._cache[session_id] = session
   321â†’        return session
   322â†’
   323â†’    def get_intro(self) -> str:
   324â†’        """Get interview introduction message"""
   325â†’        return INTERVIEW_INTRO
   326â†’
   327â†’    def get_current_question(self, session: InterviewSession) -> Optional[InterviewQuestion]:
   328â†’        """Get the current question to ask"""
   329â†’        if session.state != InterviewState.IN_PROGRESS:
   330â†’            return None
   331â†’
   332â†’        if session.current_question_idx >= len(session.questions):
   333â†’            return None
   334â†’
   335â†’        return session.questions[session.current_question_idx]
   336â†’
   337â†’    def get_progress(self, session: InterviewSession) -> Tuple[int, int]:
   338â†’        """Get current progress (answered, total)"""
   339â†’        answered = sum(1 for q in session.questions if q.answer is not None)
   340â†’        return answered, len(session.questions)
   341â†’
   342â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   343â†’    # Answer Processing
   344â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   345â†’
   346â†’    async def submit_answer(
   347â†’        self,
   348â†’        session: InterviewSession,
   349â†’        answer: str
   350â†’    ) -> Tuple[Optional[InterviewQuestion], bool]:
   351â†’        """
   352â†’        Submit an answer to the current question.
   353â†’
   354â†’        Args:
   355â†’            session: Current interview session
   356â†’            answer: User's answer
   357â†’
   358â†’        Returns:
   359â†’            Tuple of (next_question or None, is_complete)
   360â†’        """
   361â†’        if session.state != InterviewState.IN_PROGRESS:
   362â†’            return None, session.state == InterviewState.COMPLETED
   363â†’
   364â†’        current_idx = session.current_question_idx
   365â†’        if current_idx >= len(session.questions):
   366â†’            session.state = InterviewState.COMPLETED
   367â†’            session.completed_at = datetime.utcnow()
   368â†’            return None, True
   369â†’
   370â†’        # Save answer to current question
   371â†’        current_question = session.questions[current_idx]
   372â†’        current_question.answer = answer
   373â†’        current_question.answered_at = datetime.utcnow()
   374â†’
   375â†’        # Extract structured info from answer
   376â†’        try:
   377â†’            extracted = await self._extract_answer_info(
   378â†’                current_question.question_text,
   379â†’                answer
   380â†’            )
   381â†’            current_question.extracted_info = extracted
   382â†’        except Exception as e:
   383â†’            logger.warning(f"Failed to extract info from answer: {e}")
   384â†’            current_question.extracted_info = {}
   385â†’
   386â†’        # Move to next question
   387â†’        session.current_question_idx += 1
   388â†’
   389â†’        # Check if complete
   390â†’        if session.current_question_idx >= len(session.questions):
   391â†’            session.state = InterviewState.COMPLETED
   392â†’            session.completed_at = datetime.utcnow()
   393â†’            await self._save_session_to_db(session)
   394â†’            return None, True
   395â†’
   396â†’        # Save progress to database
   397â†’        await self._save_session_to_db(session)
   398â†’
   399â†’        # Return next question
   400â†’        next_question = session.questions[session.current_question_idx]
   401â†’        return next_question, False
   402â†’
   403â†’    async def _extract_answer_info(
   404â†’        self,
   405â†’        question: str,
   406â†’        answer: str
   407â†’    ) -> Dict[str, Any]:
   408â†’        """Extract structured info from an answer using LLM"""
   409â†’        prompt = EXTRACT_ANSWER_PROMPT.format(
   410â†’            question=question,
   411â†’            answer=answer,
   412â†’            extract_fields="career, relationship, concerns, expectations, goals"
   413â†’        )
   414â†’
   415â†’        try:
   416â†’            response = await self.llm.chat(
   417â†’                [create_user_message(prompt)],
   418â†’                temperature=0.2,
   419â†’                max_tokens=800
   420â†’            )
   421â†’
   422â†’            content = response.content.strip()
   423â†’
   424â†’            # Parse JSON from response
   425â†’            if "```json" in content:
   426â†’                content = content.split("```json")[1].split("```")[0].strip()
   427â†’            elif "```" in content:
   428â†’                content = content.split("```")[1].split("```")[0].strip()
   429â†’
   430â†’            return json.loads(content)
   431â†’
   432â†’        except Exception as e:
   433â†’            logger.error(f"Answer extraction failed: {e}")
   434â†’            return {}
   435â†’
   436â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   437â†’    # Skip / Complete
   438â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   439â†’
   440â†’    async def skip_session(self, session: InterviewSession) -> str:
   441â†’        """
   442â†’        Skip the interview (user choice).
   443â†’        Returns a warning message.
   444â†’        """
   445â†’        session.state = InterviewState.SKIPPED
   446â†’        session.completed_at = datetime.utcnow()
   447â†’        await self._save_session_to_db(session)
   448â†’        return INTERVIEW_SKIP_WARNING
   449â†’
   450â†’    def get_result(self, session: InterviewSession) -> InterviewResult:
   451â†’        """
   452â†’        Get final interview result with extracted profile data.
   453â†’        """
   454â†’        if session.state not in (InterviewState.COMPLETED, InterviewState.SKIPPED):
   455â†’            return InterviewResult(
   456â†’                success=False,
   457â†’                extracted_profile={},
   458â†’                summary="è®¿è°ˆå°šæœªå®Œæˆ",
   459â†’                questions_answered=0,
   460â†’                total_questions=len(session.questions)
   461â†’            )
   462â†’
   463â†’        # Merge all extracted info
   464â†’        merged_profile: Dict[str, Any] = {
   465â†’            "life_context": {
   466â†’                "career": {"concerns": []},
   467â†’                "relationship": {"concerns": []},
   468â†’                "current_focus": [],
   469â†’            },
   470â†’            "ai_insights": {
   471â†’                "current_concerns": [],
   472â†’                "pain_points": [],
   473â†’                "expectations": [],
   474â†’                "goals": [],
   475â†’            }
   476â†’        }
   477â†’
   478â†’        questions_answered = 0
   479â†’
   480â†’        for q in session.questions:
   481â†’            if q.answer and q.extracted_info:
   482â†’                questions_answered += 1
   483â†’                self._merge_extracted(merged_profile, q.extracted_info)
   484â†’
   485â†’        # Generate summary
   486â†’        if session.state == InterviewState.SKIPPED:
   487â†’            summary = "ç”¨æˆ·è·³è¿‡äº†è®¿è°ˆ"
   488â†’        elif questions_answered == 0:
   489â†’            summary = "æœªæ”¶é›†åˆ°æœ‰æ•ˆä¿¡æ¯"
   490â†’        else:
   491â†’            concerns = merged_profile.get("ai_insights", {}).get("current_concerns", [])
   492â†’            focus = merged_profile.get("life_context", {}).get("current_focus", [])
   493â†’            summary = f"å·²äº†è§£ç”¨æˆ·å…³æ³¨: {', '.join(concerns[:3] or focus[:3] or ['ä¸€èˆ¬å’¨è¯¢'])}"
   494â†’
   495â†’        return InterviewResult(
   496â†’            success=questions_answered > 0,
   497â†’            extracted_profile=merged_profile,
   498â†’            summary=summary,
   499â†’            questions_answered=questions_answered,
   500â†’            total_questions=len(session.questions)
   501â†’        )
   502â†’
   503â†’    def _merge_extracted(
   504â†’        self,
   505â†’        target: Dict[str, Any],
   506â†’        source: Dict[str, Any]
   507â†’    ) -> None:
   508â†’        """Merge extracted info into target profile"""
   509â†’        for key, value in source.items():
   510â†’            if key not in target:
   511â†’                target[key] = value
   512â†’                continue
   513â†’
   514â†’            if isinstance(value, dict) and isinstance(target[key], dict):
   515â†’                self._merge_extracted(target[key], value)
   516â†’            elif isinstance(value, list) and isinstance(target[key], list):
   517â†’                # Extend list without duplicates
   518â†’                existing = set(str(x) for x in target[key])
   519â†’                for item in value:
   520â†’                    if str(item) not in existing and item:
   521â†’                        target[key].append(item)
   522â†’            elif value is not None:
   523â†’                target[key] = value
   524â†’
   525â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   526â†’    # Profile Score Check
   527â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   528â†’
   529â†’    def check_interview_needed(
   530â†’        self,
   531â†’        profile: Dict[str, Any],
   532â†’        threshold: float = 0.3
   533â†’    ) -> bool:
   534â†’        """
   535â†’        Check if interview is needed based on profile completeness.
   536â†’
   537â†’        Returns True if:
   538â†’        - Profile is empty or missing key fields
   539â†’        - Profile score is below threshold
   540â†’        """
   541â†’        if not profile:
   542â†’            return True
   543â†’
   544â†’        # Calculate profile score
   545â†’        score = 0.0
   546â†’        max_score = 1.0
   547â†’
   548â†’        # Basic info (0.3)
   549â†’        basic = profile.get("basic", {})
   550â†’        if basic.get("birth_datetime"):
   551â†’            score += 0.2
   552â†’        if basic.get("gender"):
   553â†’            score += 0.1
   554â†’
   555â†’        # Life context (0.4)
   556â†’        life = profile.get("life_context", {})
   557â†’        if life.get("career", {}).get("status"):
   558â†’            score += 0.15
   559â†’        if life.get("relationship", {}).get("status"):
   560â†’            score += 0.15
   561â†’        if life.get("current_focus"):
   562â†’            score += 0.1
   563â†’
   564â†’        # AI insights (0.3)
   565â†’        insights = profile.get("ai_insights", {})
   566â†’        if insights.get("current_concerns"):
   567â†’            score += 0.2
   568â†’        if insights.get("personality_traits"):
   569â†’            score += 0.1
   570â†’
   571â†’        return score < threshold
   572â†’
   573â†’
   574â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   575â†’# Global Instance
   576â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   577â†’
   578â†’_interview_service: Optional[InterviewService] = None
   579â†’
   580â†’
   581â†’def get_interview_service() -> InterviewService:
   582â†’    """Get or create global interview service instance"""
   583â†’    global _interview_service
   584â†’    if _interview_service is None:
   585â†’        _interview_service = InterviewService()
   586â†’    return _interview_service
   587â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
