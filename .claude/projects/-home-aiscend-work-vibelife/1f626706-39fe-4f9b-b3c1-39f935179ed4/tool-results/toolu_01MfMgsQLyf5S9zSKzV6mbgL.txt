     1→"""
     2→Report Repository - Data access layer for reports
     3→Based on: vibelife spec v3.0, section 4.6
     4→"""
     5→from datetime import datetime
     6→from typing import Optional, Dict, Any, List
     7→from uuid import UUID
     8→import json
     9→
    10→from .db import get_connection
    11→
    12→
    13→# ═══════════════════════════════════════════════════════════════════════════
    14→# Report CRUD Operations
    15→# ═══════════════════════════════════════════════════════════════════════════
    16→
    17→async def create_report(
    18→    user_id: Optional[UUID],
    19→    skill: str,
    20→    report_type: str = "lite",
    21→    content: Optional[Dict[str, Any]] = None,
    22→    prologue: Optional[str] = None,
    23→    interview_data: Optional[Dict[str, Any]] = None,
    24→    generation_metadata: Optional[Dict[str, Any]] = None,
    25→) -> dict:
    26→    """Create a new report record"""
    27→    async with get_connection() as conn:
    28→        row = await conn.fetchrow(
    29→            """
    30→            INSERT INTO reports (
    31→                user_id, skill, report_type, content, prologue,
    32→                interview_data, generation_metadata
    33→            )
    34→            VALUES ($1, $2, $3, $4, $5, $6, $7)
    35→            RETURNING *
    36→            """,
    37→            user_id,
    38→            skill,
    39→            report_type,
    40→            json.dumps(content or {}),
    41→            prologue,
    42→            json.dumps(interview_data) if interview_data else None,
    43→            json.dumps(generation_metadata) if generation_metadata else None,
    44→        )
    45→        return _row_to_dict(row) if row else None
    46→
    47→
    48→async def get_report(report_id: UUID) -> Optional[dict]:
    49→    """Get report by ID"""
    50→    async with get_connection() as conn:
    51→        row = await conn.fetchrow(
    52→            "SELECT * FROM reports WHERE id = $1",
    53→            report_id
    54→        )
    55→        return _row_to_dict(row) if row else None
    56→
    57→
    58→async def get_report_by_id(report_id: UUID, user_id: Optional[UUID] = None) -> Optional[dict]:
    59→    """Get report by ID with optional user verification"""
    60→    async with get_connection() as conn:
    61→        if user_id:
    62→            row = await conn.fetchrow(
    63→                "SELECT * FROM reports WHERE id = $1 AND user_id = $2",
    64→                report_id, user_id
    65→            )
    66→        else:
    67→            row = await conn.fetchrow(
    68→                "SELECT * FROM reports WHERE id = $1",
    69→                report_id
    70→            )
    71→        return _row_to_dict(row) if row else None
    72→
    73→
    74→async def update_report(
    75→    report_id: UUID,
    76→    content: Optional[Dict[str, Any]] = None,
    77→    prologue: Optional[str] = None,
    78→    image_url: Optional[str] = None,
    79→    image_thumbnail_url: Optional[str] = None,
    80→    is_paid: Optional[bool] = None,
    81→) -> Optional[dict]:
    82→    """Update report content"""
    83→    updates = []
    84→    values = []
    85→    param_idx = 1
    86→
    87→    if content is not None:
    88→        updates.append(f"content = ${param_idx}")
    89→        values.append(json.dumps(content))
    90→        param_idx += 1
    91→
    92→    if prologue is not None:
    93→        updates.append(f"prologue = ${param_idx}")
    94→        values.append(prologue)
    95→        param_idx += 1
    96→
    97→    if image_url is not None:
    98→        updates.append(f"image_url = ${param_idx}")
    99→        values.append(image_url)
   100→        param_idx += 1
   101→
   102→    if image_thumbnail_url is not None:
   103→        updates.append(f"image_thumbnail_url = ${param_idx}")
   104→        values.append(image_thumbnail_url)
   105→        param_idx += 1
   106→
   107→    if is_paid is not None:
   108→        updates.append(f"is_paid = ${param_idx}")
   109→        values.append(is_paid)
   110→        param_idx += 1
   111→
   112→    if not updates:
   113→        return await get_report(report_id)
   114→
   115→    updates.append("updated_at = NOW()")
   116→    values.append(report_id)
   117→
   118→    query = f"""
   119→        UPDATE reports
   120→        SET {', '.join(updates)}
   121→        WHERE id = ${param_idx}
   122→        RETURNING *
   123→    """
   124→
   125→    async with get_connection() as conn:
   126→        row = await conn.fetchrow(query, *values)
   127→        return _row_to_dict(row) if row else None
   128→
   129→
   130→async def update_report_status(
   131→    report_id: UUID,
   132→    is_paid: bool,
   133→    report_type: Optional[str] = None,
   134→) -> Optional[dict]:
   135→    """Update report payment status and optionally upgrade type"""
   136→    async with get_connection() as conn:
   137→        if report_type:
   138→            row = await conn.fetchrow(
   139→                """
   140→                UPDATE reports
   141→                SET is_paid = $2, report_type = $3, updated_at = NOW()
   142→                WHERE id = $1
   143→                RETURNING *
   144→                """,
   145→                report_id, is_paid, report_type
   146→            )
   147→        else:
   148→            row = await conn.fetchrow(
   149→                """
   150→                UPDATE reports
   151→                SET is_paid = $2, updated_at = NOW()
   152→                WHERE id = $1
   153→                RETURNING *
   154→                """,
   155→                report_id, is_paid
   156→            )
   157→        return _row_to_dict(row) if row else None
   158→
   159→
   160→async def list_user_reports(
   161→    user_id: UUID,
   162→    skill: Optional[str] = None,
   163→    limit: int = 20,
   164→    offset: int = 0,
   165→) -> List[dict]:
   166→    """List reports for a user"""
   167→    async with get_connection() as conn:
   168→        if skill:
   169→            rows = await conn.fetch(
   170→                """
   171→                SELECT id, user_id, skill, report_type, is_paid,
   172→                       image_thumbnail_url, created_at, updated_at
   173→                FROM reports
   174→                WHERE user_id = $1 AND skill = $2
   175→                ORDER BY created_at DESC
   176→                LIMIT $3 OFFSET $4
   177→                """,
   178→                user_id, skill, limit, offset
   179→            )
   180→        else:
   181→            rows = await conn.fetch(
   182→                """
   183→                SELECT id, user_id, skill, report_type, is_paid,
   184→                       image_thumbnail_url, created_at, updated_at
   185→                FROM reports
   186→                WHERE user_id = $1
   187→                ORDER BY created_at DESC
   188→                LIMIT $2 OFFSET $3
   189→                """,
   190→                user_id, limit, offset
   191→            )
   192→        return [_row_to_summary(row) for row in rows]
   193→
   194→
   195→async def count_user_reports(user_id: UUID, skill: Optional[str] = None) -> int:
   196→    """Count reports for a user"""
   197→    async with get_connection() as conn:
   198→        if skill:
   199→            return await conn.fetchval(
   200→                "SELECT COUNT(*) FROM reports WHERE user_id = $1 AND skill = $2",
   201→                user_id, skill
   202→            )
   203→        else:
   204→            return await conn.fetchval(
   205→                "SELECT COUNT(*) FROM reports WHERE user_id = $1",
   206→                user_id
   207→            )
   208→
   209→
   210→async def delete_report(report_id: UUID, user_id: UUID) -> bool:
   211→    """Delete a report (user must own it)"""
   212→    async with get_connection() as conn:
   213→        result = await conn.execute(
   214→            "DELETE FROM reports WHERE id = $1 AND user_id = $2",
   215→            report_id, user_id
   216→        )
   217→        return result == "DELETE 1"
   218→
   219→
   220→# ═══════════════════════════════════════════════════════════════════════════
   221→# Helper Functions
   222→# ═══════════════════════════════════════════════════════════════════════════
   223→
   224→def _row_to_dict(row) -> dict:
   225→    """Convert database row to dictionary with proper JSON parsing"""
   226→    if not row:
   227→        return None
   228→
   229→    result = dict(row)
   230→
   231→    # Parse JSON fields
   232→    if result.get("content"):
   233→        if isinstance(result["content"], str):
   234→            result["content"] = json.loads(result["content"])
   235→
   236→    if result.get("interview_data"):
   237→        if isinstance(result["interview_data"], str):
   238→            result["interview_data"] = json.loads(result["interview_data"])
   239→
   240→    if result.get("generation_metadata"):
   241→        if isinstance(result["generation_metadata"], str):
   242→            result["generation_metadata"] = json.loads(result["generation_metadata"])
   243→
   244→    # Convert UUID to string for JSON serialization
   245→    if result.get("id"):
   246→        result["id"] = str(result["id"])
   247→    if result.get("user_id"):
   248→        result["user_id"] = str(result["user_id"])
   249→
   250→    # Convert datetime to ISO string
   251→    if result.get("created_at"):
   252→        result["created_at"] = result["created_at"].isoformat()
   253→    if result.get("updated_at"):
   254→        result["updated_at"] = result["updated_at"].isoformat()
   255→
   256→    return result
   257→
   258→
   259→def _row_to_summary(row) -> dict:
   260→    """Convert database row to summary dictionary (for list views)"""
   261→    if not row:
   262→        return None
   263→
   264→    result = dict(row)
   265→
   266→    # Convert UUID to string
   267→    if result.get("id"):
   268→        result["id"] = str(result["id"])
   269→    if result.get("user_id"):
   270→        result["user_id"] = str(result["user_id"])
   271→
   272→    # Convert datetime to ISO string
   273→    if result.get("created_at"):
   274→        result["created_at"] = result["created_at"].isoformat()
   275→    if result.get("updated_at"):
   276→        result["updated_at"] = result["updated_at"].isoformat()
   277→
   278→    # Add computed fields for frontend
   279→    result["status"] = "completed"  # All persisted reports are completed
   280→    result["title"] = f"{'八字' if result.get('skill') == 'bazi' else '星座'}分析报告"
   281→
   282→    return result
   283→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
