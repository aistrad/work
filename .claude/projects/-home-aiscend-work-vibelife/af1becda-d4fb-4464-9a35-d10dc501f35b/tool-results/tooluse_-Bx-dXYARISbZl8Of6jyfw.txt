     1→"""
     2→Report API Routes
     3→Based on: vibelife spec v3.0, section 4.6
     4→
     5→Endpoints:
     6→- POST /api/v1/report/generate - Generate new report
     7→- GET /api/v1/report/{report_id} - Get report details
     8→- POST /api/v1/report/{report_id}/upgrade - Upgrade to full report
     9→- GET /api/v1/report/user/{user_id} - List user's reports
    10→"""
    11→
    12→import logging
    13→from typing import Optional
    14→from uuid import UUID
    15→from fastapi import APIRouter, HTTPException, Query
    16→from pydantic import BaseModel, Field
    17→
    18→from services.report import (
    19→    get_report_service,
    20→    ReportType,
    21→    ReportStatus,
    22→)
    23→
    24→logger = logging.getLogger(__name__)
    25→router = APIRouter(prefix="/report", tags=["report"])
    26→
    27→
    28→# ═══════════════════════════════════════════════════════════════════════════
    29→# Request/Response Models
    30→# ═══════════════════════════════════════════════════════════════════════════
    31→
    32→class GenerateReportRequest(BaseModel):
    33→    """Request to generate a new report"""
    34→    user_id: str = Field(..., description="User ID")
    35→    skill: str = Field(..., description="Skill type: bazi or zodiac")
    36→    report_type: str = Field(default="lite", description="Report type: lite or full")
    37→    profile: dict = Field(default_factory=dict, description="User profile data")
    38→    interview_result: Optional[dict] = Field(None, description="Interview result")
    39→    voice_mode: str = Field(default="warm", description="Voice mode: warm or sarcastic")
    40→
    41→
    42→class ReportResponse(BaseModel):
    43→    """Report response"""
    44→    success: bool
    45→    report: Optional[dict] = None
    46→    error: Optional[str] = None
    47→
    48→
    49→class ReportListResponse(BaseModel):
    50→    """List of reports response"""
    51→    success: bool
    52→    reports: list = []
    53→    total: int = 0
    54→
    55→
    56→# ═══════════════════════════════════════════════════════════════════════════
    57→# Routes
    58→# ═══════════════════════════════════════════════════════════════════════════
    59→
    60→@router.post("/generate", response_model=ReportResponse)
    61→async def generate_report(request: GenerateReportRequest):
    62→    """
    63→    Generate a new report.
    64→
    65→    This is the main endpoint for creating reports.
    66→    Lite reports are free, full reports require payment.
    67→    """
    68→    try:
    69→        service = get_report_service()
    70→
    71→        # Validate skill
    72→        if request.skill not in ["bazi", "zodiac"]:
    73→            raise HTTPException(status_code=400, detail="Invalid skill type")
    74→
    75→        # Validate report type
    76→        if request.report_type not in ["lite", "full"]:
    77→            raise HTTPException(status_code=400, detail="Invalid report type")
    78→
    79→        # Generate report
    80→        report = await service.generate_report(
    81→            user_id=UUID(request.user_id),
    82→            skill=request.skill,
    83→            report_type=request.report_type,
    84→            profile=request.profile,
    85→            interview_result=request.interview_result,
    86→        )
    87→
    88→        # Return appropriate format based on type
    89→        if request.report_type == "lite":
    90→            return ReportResponse(
    91→                success=True,
    92→                report=report.to_lite_dict(),
    93→            )
    94→        else:
    95→            return ReportResponse(
    96→                success=True,
    97→                report=report.to_dict(),
    98→            )
    99→
   100→    except HTTPException:
   101→        raise
   102→    except Exception as e:
   103→        logger.error(f"Report generation failed: {e}")
   104→        return ReportResponse(
   105→            success=False,
   106→            error=str(e),
   107→        )
   108→
   109→
   110→@router.get("/{report_id}", response_model=ReportResponse)
   111→async def get_report(
   112→    report_id: str,
   113→    user_id: str = Query(..., description="User ID for authorization"),
   114→    full: bool = Query(False, description="Return full report (requires payment)"),
   115→):
   116→    """
   117→    Get a report by ID.
   118→
   119→    If full=False, returns lite version with premium content hidden.
   120→    If full=True, requires the user to have paid for the report.
   121→    """
   122→    try:
   123→        # TODO: Load from database
   124→        # For now, return placeholder
   125→        return ReportResponse(
   126→            success=False,
   127→            error="Report not found. Reports are generated on-demand.",
   128→        )
   129→
   130→    except Exception as e:
   131→        logger.error(f"Get report failed: {e}")
   132→        return ReportResponse(
   133→            success=False,
   134→            error=str(e),
   135→        )
   136→
   137→
   138→@router.post("/{report_id}/upgrade", response_model=ReportResponse)
   139→async def upgrade_report(
   140→    report_id: str,
   141→    user_id: str = Query(..., description="User ID"),
   142→    payment_id: Optional[str] = Query(None, description="Payment transaction ID"),
   143→):
   144→    """
   145→    Upgrade a lite report to full.
   146→
   147→    Requires valid payment confirmation.
   148→    Returns the full report with all content unlocked.
   149→    """
   150→    try:
   151→        # Verify payment
   152→        if not payment_id:
   153→            raise HTTPException(
   154→                status_code=402,
   155→                detail="Payment required. Please complete payment first.",
   156→            )
   157→
   158→        # TODO: Verify payment with billing service
   159→        # TODO: Upgrade report in database
   160→
   161→        return ReportResponse(
   162→            success=False,
   163→            error="Report upgrade requires payment integration",
   164→        )
   165→
   166→    except HTTPException:
   167→        raise
   168→    except Exception as e:
   169→        logger.error(f"Report upgrade failed: {e}")
   170→        return ReportResponse(
   171→            success=False,
   172→            error=str(e),
   173→        )
   174→
   175→
   176→@router.get("/user/{user_id}", response_model=ReportListResponse)
   177→async def list_user_reports(
   178→    user_id: str,
   179→    skill: Optional[str] = Query(None, description="Filter by skill"),
   180→    limit: int = Query(10, ge=1, le=50, description="Max reports to return"),
   181→    offset: int = Query(0, ge=0, description="Offset for pagination"),
   182→):
   183→    """
   184→    List all reports for a user.
   185→
   186→    Returns summary information, not full content.
   187→    """
   188→    try:
   189→        # TODO: Load from database
   190→        return ReportListResponse(
   191→            success=True,
   192→            reports=[],
   193→            total=0,
   194→        )
   195→
   196→    except Exception as e:
   197→        logger.error(f"List reports failed: {e}")
   198→        return ReportListResponse(
   199→            success=False,
   200→            reports=[],
   201→            total=0,
   202→        )
   203→
   204→
   205→@router.post("/preview", response_model=ReportResponse)
   206→async def preview_report(request: GenerateReportRequest):
   207→    """
   208→    Generate a preview (prologue only) without saving.
   209→
   210→    This is useful for showing users what they'll get before
   211→    completing the full interview or payment.
   212→    """
   213→    try:
   214→        from services.report.prologue_generator import PrologueGenerator
   215→
   216→        # Generate just the prologue
   217→        generator = PrologueGenerator()
   218→        prologue = await generator.generate(
   219→            profile=request.profile,
   220→            skill=request.skill,
   221→            interview_summary=request.interview_result.get("summary") if request.interview_result else None,
   222→        )
   223→
   224→        return ReportResponse(
   225→            success=True,
   226→            report={
   227→                "prologue": prologue,
   228→                "is_preview": True,
   229→                "sections": [],  # Empty for preview
   230→            },
   231→        )
   232→
   233→    except Exception as e:
   234→        logger.error(f"Preview generation failed: {e}")
   235→        return ReportResponse(
   236→            success=False,
   237→            error=str(e),
   238→        )
   239→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
