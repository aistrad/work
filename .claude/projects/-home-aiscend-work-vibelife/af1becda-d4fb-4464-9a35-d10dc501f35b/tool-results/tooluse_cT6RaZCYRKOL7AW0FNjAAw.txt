     1→"""
     2→Payment Repository - Data access layer for payments
     3→Based on: vibelife spec v3.0
     4→"""
     5→from datetime import datetime
     6→from typing import Optional, Dict, Any
     7→from uuid import UUID
     8→
     9→from .db import get_connection
    10→
    11→
    12→# ═══════════════════════════════════════════════════════════════════════════
    13→# Payment Records
    14→# ═══════════════════════════════════════════════════════════════════════════
    15→
    16→async def create_payment(
    17→    user_id: Optional[UUID],
    18→    product_type: str,
    19→    product_id: Optional[UUID],
    20→    amount_cents: int,
    21→    currency: str = "CNY",
    22→    provider: Optional[str] = None,
    23→    provider_payment_id: Optional[str] = None,
    24→    provider_metadata: Optional[Dict[str, Any]] = None
    25→) -> dict:
    26→    """Create a payment record"""
    27→    async with get_connection() as conn:
    28→        row = await conn.fetchrow(
    29→            """
    30→            INSERT INTO payments (
    31→                user_id, product_type, product_id,
    32→                amount_cents, currency, status,
    33→                provider, provider_payment_id, provider_metadata
    34→            )
    35→            VALUES ($1, $2, $3, $4, $5, 'pending', $6, $7, $8)
    36→            RETURNING *
    37→            """,
    38→            user_id, product_type, product_id,
    39→            amount_cents, currency,
    40→            provider, provider_payment_id, provider_metadata
    41→        )
    42→        return dict(row) if row else None
    43→
    44→
    45→async def get_payment(payment_id: UUID) -> Optional[dict]:
    46→    """Get payment by ID"""
    47→    async with get_connection() as conn:
    48→        row = await conn.fetchrow(
    49→            "SELECT * FROM payments WHERE id = $1",
    50→            payment_id
    51→        )
    52→        return dict(row) if row else None
    53→
    54→
    55→async def get_payment_by_provider_id(provider: str, provider_payment_id: str) -> Optional[dict]:
    56→    """Get payment by provider payment ID (e.g., Stripe session ID)"""
    57→    async with get_connection() as conn:
    58→        row = await conn.fetchrow(
    59→            """
    60→            SELECT * FROM payments
    61→            WHERE provider = $1 AND provider_payment_id = $2
    62→            """,
    63→            provider, provider_payment_id
    64→        )
    65→        return dict(row) if row else None
    66→
    67→
    68→async def update_payment_status(
    69→    payment_id: UUID,
    70→    status: str,
    71→    paid_at: Optional[datetime] = None
    72→) -> Optional[dict]:
    73→    """Update payment status"""
    74→    async with get_connection() as conn:
    75→        row = await conn.fetchrow(
    76→            """
    77→            UPDATE payments
    78→            SET status = $2, paid_at = $3, updated_at = NOW()
    79→            WHERE id = $1
    80→            RETURNING *
    81→            """,
    82→            payment_id, status, paid_at
    83→        )
    84→        return dict(row) if row else None
    85→
    86→
    87→async def mark_payment_success(
    88→    payment_id: UUID,
    89→    provider_payment_id: Optional[str] = None
    90→) -> Optional[dict]:
    91→    """Mark payment as successful"""
    92→    async with get_connection() as conn:
    93→        row = await conn.fetchrow(
    94→            """
    95→            UPDATE payments
    96→            SET status = 'success', paid_at = NOW(),
    97→                provider_payment_id = COALESCE($2, provider_payment_id),
    98→                updated_at = NOW()
    99→            WHERE id = $1
   100→            RETURNING *
   101→            """,
   102→            payment_id, provider_payment_id
   103→        )
   104→        return dict(row) if row else None
   105→
   106→
   107→async def get_user_payments(
   108→    user_id: UUID,
   109→    limit: int = 20,
   110→    status: Optional[str] = None
   111→) -> list:
   112→    """Get user's payment history"""
   113→    async with get_connection() as conn:
   114→        if status:
   115→            rows = await conn.fetch(
   116→                """
   117→                SELECT * FROM payments
   118→                WHERE user_id = $1 AND status = $2
   119→                ORDER BY created_at DESC
   120→                LIMIT $3
   121→                """,
   122→                user_id, status, limit
   123→            )
   124→        else:
   125→            rows = await conn.fetch(
   126→                """
   127→                SELECT * FROM payments
   128→                WHERE user_id = $1
   129→                ORDER BY created_at DESC
   130→                LIMIT $2
   131→                """,
   132→                user_id, limit
   133→            )
   134→        return [dict(row) for row in rows]
   135→
   136→
   137→async def has_paid_for_product(user_id: UUID, product_type: str, product_id: UUID) -> bool:
   138→    """Check if user has paid for a specific product"""
   139→    async with get_connection() as conn:
   140→        row = await conn.fetchrow(
   141→            """
   142→            SELECT id FROM payments
   143→            WHERE user_id = $1
   144→              AND product_type = $2
   145→              AND product_id = $3
   146→              AND status = 'success'
   147→            LIMIT 1
   148→            """,
   149→            user_id, product_type, product_id
   150→        )
   151→        return row is not None
   152→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
