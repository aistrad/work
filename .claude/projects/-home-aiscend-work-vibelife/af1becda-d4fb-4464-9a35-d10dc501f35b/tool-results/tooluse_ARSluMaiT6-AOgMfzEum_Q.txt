     1→'use client'
     2→
     3→/**
     4→ * LifeKLine - Life K-Line visualization component
     5→ * Based on: vibelife spec v3.0, section 2.2.5
     6→ *
     7→ * Features:
     8→ * - Interactive K-Line chart
     9→ * - Click on inflection points for details
    10→ * - Current year indicator
    11→ * - Phase markers
    12→ */
    13→
    14→import React, { useState, useMemo } from 'react'
    15→import { motion, AnimatePresence } from 'framer-motion'
    16→
    17→// Types
    18→interface DataPoint {
    19→  year: number
    20→  score: number
    21→  is_current: boolean
    22→  phase?: string
    23→  label?: string
    24→}
    25→
    26→interface Phase {
    27→  start_year: number
    28→  end_year: number
    29→  phase: string
    30→  label: string
    31→  description: string
    32→  fortune_trend: string
    33→}
    34→
    35→interface InflectionPoint {
    36→  year: number
    37→  type: string
    38→  significance: number
    39→  title: string
    40→  explanation: string
    41→  is_past: boolean
    42→}
    43→
    44→interface KLineData {
    45→  id: string
    46→  data_points: DataPoint[]
    47→  phases: Phase[]
    48→  inflection_points: InflectionPoint[]
    49→  current_year: number
    50→  current_phase?: Phase
    51→  next_inflection?: InflectionPoint
    52→  now_summary: string
    53→  next_summary: string
    54→}
    55→
    56→interface LifeKLineProps {
    57→  data: KLineData
    58→  onYearClick?: (year: number) => void
    59→  className?: string
    60→}
    61→
    62→// Phase colors
    63→const PHASE_COLORS: Record<string, string> = {
    64→  accumulation: '#4CAF50',  // Green
    65→  breakthrough: '#FF9800',  // Orange
    66→  peak: '#F44336',          // Red
    67→  adjustment: '#9C27B0',    // Purple
    68→  transition: '#2196F3',    // Blue
    69→  foundation: '#795548',    // Brown
    70→}
    71→
    72→// Phase Chinese names
    73→const PHASE_NAMES: Record<string, string> = {
    74→  accumulation: '积累期',
    75→  breakthrough: '突破期',
    76→  peak: '高峰期',
    77→  adjustment: '调整期',
    78→  transition: '过渡期',
    79→  foundation: '基础期',
    80→}
    81→
    82→export default function LifeKLine({
    83→  data,
    84→  onYearClick,
    85→  className = '',
    86→}: LifeKLineProps) {
    87→  const [selectedYear, setSelectedYear] = useState<number | null>(null)
    88→  const [hoveredPoint, setHoveredPoint] = useState<number | null>(null)
    89→
    90→  // Calculate chart dimensions
    91→  const chartWidth = 800
    92→  const chartHeight = 300
    93→  const padding = { top: 40, right: 40, bottom: 60, left: 60 }
    94→  const innerWidth = chartWidth - padding.left - padding.right
    95→  const innerHeight = chartHeight - padding.top - padding.bottom
    96→
    97→  // Get visible range (centered on current year, +/- 20 years)
    98→  const [visibleRange, setVisibleRange] = useState<[number, number]>(() => {
    99→    const current = data.current_year
   100→    return [current - 20, current + 20]
   101→  })
   102→
   103→  // Filter data points to visible range
   104→  const visiblePoints = useMemo(() => {
   105→    return data.data_points.filter(
   106→      p => p.year >= visibleRange[0] && p.year <= visibleRange[1]
   107→    )
   108→  }, [data.data_points, visibleRange])
   109→
   110→  // Scale functions
   111→  const xScale = (year: number) => {
   112→    const range = visibleRange[1] - visibleRange[0]
   113→    return padding.left + ((year - visibleRange[0]) / range) * innerWidth
   114→  }
   115→
   116→  const yScale = (score: number) => {
   117→    return padding.top + innerHeight - (score / 100) * innerHeight
   118→  }
   119→
   120→  // Generate path
   121→  const pathData = useMemo(() => {
   122→    if (visiblePoints.length === 0) return ''
   123→
   124→    return visiblePoints
   125→      .map((point, i) => {
   126→        const x = xScale(point.year)
   127→        const y = yScale(point.score)
   128→        return `${i === 0 ? 'M' : 'L'} ${x} ${y}`
   129→      })
   130→      .join(' ')
   131→  }, [visiblePoints, xScale, yScale])
   132→
   133→  // Generate area fill
   134→  const areaData = useMemo(() => {
   135→    if (visiblePoints.length === 0) return ''
   136→
   137→    const path = visiblePoints
   138→      .map((point, i) => {
   139→        const x = xScale(point.year)
   140→        const y = yScale(point.score)
   141→        return `${i === 0 ? 'M' : 'L'} ${x} ${y}`
   142→      })
   143→      .join(' ')
   144→
   145→    const lastX = xScale(visiblePoints[visiblePoints.length - 1].year)
   146→    const firstX = xScale(visiblePoints[0].year)
   147→    const bottomY = padding.top + innerHeight
   148→
   149→    return `${path} L ${lastX} ${bottomY} L ${firstX} ${bottomY} Z`
   150→  }, [visiblePoints, xScale, yScale, padding.top, innerHeight])
   151→
   152→  // Handle year selection
   153→  const handlePointClick = (year: number) => {
   154→    setSelectedYear(year)
   155→    onYearClick?.(year)
   156→  }
   157→
   158→  // Get inflection point for year
   159→  const getInflectionForYear = (year: number) => {
   160→    return data.inflection_points.find(p => p.year === year)
   161→  }
   162→
   163→  // Get selected point details
   164→  const selectedPointData = useMemo(() => {
   165→    if (!selectedYear) return null
   166→    const point = data.data_points.find(p => p.year === selectedYear)
   167→    const inflection = data.inflection_points.find(p => p.year === selectedYear)
   168→    return { point, inflection }
   169→  }, [selectedYear, data])
   170→
   171→  return (
   172→    <div className={`bg-[#FBF7F1] rounded-2xl overflow-hidden ${className}`}>
   173→      {/* Header */}
   174→      <div className="p-6 border-b border-[#1C1A17]/10">
   175→        <h2 className="text-xl font-semibold text-[#1C1A17]">你的人生 K 线</h2>
   176→        <p className="text-[#1C1A17]/60 mt-1">{data.now_summary}</p>
   177→      </div>
   178→
   179→      {/* Chart */}
   180→      <div className="p-4 overflow-x-auto">
   181→        <svg
   182→          viewBox={`0 0 ${chartWidth} ${chartHeight}`}
   183→          className="w-full min-w-[600px]"
   184→        >
   185→          {/* Grid lines */}
   186→          {[0, 25, 50, 75, 100].map(score => (
   187→            <g key={score}>
   188→              <line
   189→                x1={padding.left}
   190→                y1={yScale(score)}
   191→                x2={chartWidth - padding.right}
   192→                y2={yScale(score)}
   193→                stroke="#1C1A17"
   194→                strokeOpacity={0.1}
   195→                strokeDasharray={score === 50 ? '0' : '4 4'}
   196→              />
   197→              <text
   198→                x={padding.left - 10}
   199→                y={yScale(score)}
   200→                textAnchor="end"
   201→                alignmentBaseline="middle"
   202→                className="text-xs fill-[#1C1A17]/50"
   203→              >
   204→                {score}
   205→              </text>
   206→            </g>
   207→          ))}
   208→
   209→          {/* Year labels */}
   210→          {visiblePoints
   211→            .filter((_, i) => i % 5 === 0)
   212→            .map(point => (
   213→              <text
   214→                key={point.year}
   215→                x={xScale(point.year)}
   216→                y={chartHeight - padding.bottom + 20}
   217→                textAnchor="middle"
   218→                className="text-xs fill-[#1C1A17]/50"
   219→              >
   220→                {point.year}
   221→              </text>
   222→            ))}
   223→
   224→          {/* Area fill */}
   225→          <path
   226→            d={areaData}
   227→            fill="url(#areaGradient)"
   228→            opacity={0.3}
   229→          />
   230→
   231→          {/* Line */}
   232→          <path
   233→            d={pathData}
   234→            fill="none"
   235→            stroke="#B88A44"
   236→            strokeWidth={2}
   237→            strokeLinecap="round"
   238→            strokeLinejoin="round"
   239→          />
   240→
   241→          {/* Inflection points */}
   242→          {data.inflection_points
   243→            .filter(ip => ip.year >= visibleRange[0] && ip.year <= visibleRange[1])
   244→            .map(ip => {
   245→              const point = data.data_points.find(p => p.year === ip.year)
   246→              if (!point) return null
   247→
   248→              return (
   249→                <g key={ip.year}>
   250→                  <circle
   251→                    cx={xScale(ip.year)}
   252→                    cy={yScale(point.score)}
   253→                    r={6}
   254→                    fill={ip.is_past ? '#1C1A17' : '#B88A44'}
   255→                    stroke="white"
   256→                    strokeWidth={2}
   257→                    className="cursor-pointer"
   258→                    onClick={() => handlePointClick(ip.year)}
   259→                  />
   260→                  {/* Label */}
   261→                  <text
   262→                    x={xScale(ip.year)}
   263→                    y={yScale(point.score) - 12}
   264→                    textAnchor="middle"
   265→                    className="text-[10px] fill-[#1C1A17]/70"
   266→                  >
   267→                    {ip.title.split(' - ')[0]}
   268→                  </text>
   269→                </g>
   270→              )
   271→            })}
   272→
   273→          {/* Current year marker */}
   274→          <g>
   275→            <line
   276→              x1={xScale(data.current_year)}
   277→              y1={padding.top}
   278→              x2={xScale(data.current_year)}
   279→              y2={chartHeight - padding.bottom}
   280→              stroke="#B88A44"
   281→              strokeWidth={2}
   282→              strokeDasharray="4 4"
   283→            />
   284→            <text
   285→              x={xScale(data.current_year)}
   286→              y={chartHeight - padding.bottom + 35}
   287→              textAnchor="middle"
   288→              className="text-xs font-medium fill-[#B88A44]"
   289→            >
   290→              现在
   291→            </text>
   292→          </g>
   293→
   294→          {/* Gradient definition */}
   295→          <defs>
   296→            <linearGradient id="areaGradient" x1="0" x2="0" y1="0" y2="1">
   297→              <stop offset="0%" stopColor="#B88A44" stopOpacity={0.4} />
   298→              <stop offset="100%" stopColor="#B88A44" stopOpacity={0} />
   299→            </linearGradient>
   300→          </defs>
   301→        </svg>
   302→      </div>
   303→
   304→      {/* Current Phase Info */}
   305→      {data.current_phase && (
   306→        <div className="px-6 py-4 border-t border-[#1C1A17]/10">
   307→          <div className="flex items-center gap-2 mb-2">
   308→            <span
   309→              className="w-3 h-3 rounded-full"
   310→              style={{ backgroundColor: PHASE_COLORS[data.current_phase.phase] }}
   311→            />
   312→            <span className="font-medium text-[#1C1A17]">
   313→              当前阶段：{PHASE_NAMES[data.current_phase.phase]}
   314→            </span>
   315→          </div>
   316→          <p className="text-sm text-[#1C1A17]/70">
   317→            {data.current_phase.description}
   318→          </p>
   319→        </div>
   320→      )}
   321→
   322→      {/* Next Milestone */}
   323→      {data.next_inflection && (
   324→        <div className="px-6 py-4 border-t border-[#1C1A17]/10 bg-[#B88A44]/5">
   325→          <p className="text-sm text-[#B88A44]">
   326→            下一关键节点：{data.next_summary}
   327→          </p>
   328→        </div>
   329→      )}
   330→
   331→      {/* Selected Point Detail */}
   332→      <AnimatePresence>
   333→        {selectedPointData && (
   334→          <motion.div
   335→            initial={{ opacity: 0, y: 20 }}
   336→            animate={{ opacity: 1, y: 0 }}
   337→            exit={{ opacity: 0, y: 20 }}
   338→            className="px-6 py-4 border-t border-[#1C1A17]/10 bg-white"
   339→          >
   340→            <div className="flex justify-between items-start">
   341→              <div>
   342→                <h3 className="font-semibold text-[#1C1A17]">
   343→                  {selectedYear}年
   344→                </h3>
   345→                {selectedPointData.inflection && (
   346→                  <p className="text-sm text-[#B88A44] mt-1">
   347→                    {selectedPointData.inflection.title}
   348→                  </p>
   349→                )}
   350→              </div>
   351→              <button
   352→                onClick={() => setSelectedYear(null)}
   353→                className="text-[#1C1A17]/50 hover:text-[#1C1A17]"
   354→              >
   355→                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
   356→                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
   357→                </svg>
   358→              </button>
   359→            </div>
   360→            {selectedPointData.inflection && (
   361→              <p className="text-sm text-[#1C1A17]/70 mt-2">
   362→                {selectedPointData.inflection.explanation}
   363→              </p>
   364→            )}
   365→          </motion.div>
   366→        )}
   367→      </AnimatePresence>
   368→
   369→      {/* Legend */}
   370→      <div className="px-6 py-4 border-t border-[#1C1A17]/10 flex flex-wrap gap-4">
   371→        {Object.entries(PHASE_NAMES).map(([key, name]) => (
   372→          <div key={key} className="flex items-center gap-1.5 text-xs text-[#1C1A17]/60">
   373→            <span
   374→              className="w-2.5 h-2.5 rounded-full"
   375→              style={{ backgroundColor: PHASE_COLORS[key] }}
   376→            />
   377→            {name}
   378→          </div>
   379→        ))}
   380→      </div>
   381→    </div>
   382→  )
   383→}
   384→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
