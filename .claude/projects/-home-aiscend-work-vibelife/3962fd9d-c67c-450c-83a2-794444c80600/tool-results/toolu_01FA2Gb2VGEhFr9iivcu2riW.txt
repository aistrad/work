     1→# 推送与仪式系统
     2→
     3→## 概述
     4→
     5→实现蓝图中的"晨谕/午照/夜语"三仪式系统，以及主动推送能力，让 AI 从被动工具升级为主动的"数字存在"。
     6→
     7→---
     8→
     9→## 1. 系统架构
    10→
    11→```
    12→┌─────────────────────────────────────────────────────────┐
    13→│                    推送与仪式系统                         │
    14→├─────────────────────────────────────────────────────────┤
    15→│                                                         │
    16→│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
    17→│  │ 仪式调度器   │    │ 仪式生成器   │    │ 推送服务    │ │
    18→│  │ Scheduler   │───▶│ Generator   │───▶│ Push        │ │
    19→│  └─────────────┘    └─────────────┘    └─────────────┘ │
    20→│         │                  │                  │         │
    21→│         ▼                  ▼                  ▼         │
    22→│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
    23→│  │ 用户偏好    │    │ 上下文编排   │    │ 多渠道分发  │ │
    24→│  │ Preferences │    │ Context     │    │ Channels    │ │
    25→│  └─────────────┘    └─────────────┘    └─────────────┘ │
    26→│                                                         │
    27→└─────────────────────────────────────────────────────────┘
    28→```
    29→
    30→---
    31→
    32→## 2. 仪式调度器
    33→
    34→### 2.1 调度服务
    35→
    36→```python
    37→# services/ritual/scheduler.py
    38→
    39→import asyncio
    40→from datetime import datetime, time
    41→from apscheduler.schedulers.asyncio import AsyncIOScheduler
    42→from apscheduler.triggers.cron import CronTrigger
    43→
    44→class RitualScheduler:
    45→    """仪式调度器 - 管理每日三仪式的定时触发"""
    46→
    47→    def __init__(
    48→        self,
    49→        ritual_generator: RitualGenerator,
    50→        push_service: PushService,
    51→        user_repo: UserRepo
    52→    ):
    53→        self.generator = ritual_generator
    54→        self.push = push_service
    55→        self.user_repo = user_repo
    56→        self.scheduler = AsyncIOScheduler()
    57→
    58→    def start(self):
    59→        """启动调度器"""
    60→        # 每分钟检查需要发送仪式的用户
    61→        self.scheduler.add_job(
    62→            self._process_morning_oracles,
    63→            CronTrigger(minute='*'),
    64→            id='morning_oracle_check'
    65→        )
    66→        self.scheduler.add_job(
    67→            self._process_midday_mirrors,
    68→            CronTrigger(minute='*'),
    69→            id='midday_mirror_check'
    70→        )
    71→        self.scheduler.add_job(
    72→            self._process_night_whispers,
    73→            CronTrigger(minute='*'),
    74→            id='night_whisper_check'
    75→        )
    76→
    77→        self.scheduler.start()
    78→
    79→    async def _process_morning_oracles(self):
    80→        """处理晨谕"""
    81→        current_time = datetime.now()
    82→        users = await self._get_users_for_ritual('morning_oracle', current_time)
    83→
    84→        for user in users:
    85→            try:
    86→                await self._send_morning_oracle(user)
    87→            except Exception as e:
    88→                logger.error(f"Failed morning oracle for {user.vibe_id}: {e}")
    89→
    90→    async def _get_users_for_ritual(self, ritual_type: str, current_time: datetime) -> list:
    91→        """获取当前时间需要接收仪式的用户"""
    92→        current_hour = current_time.hour
    93→        current_minute = current_time.minute
    94→
    95→        # 查询偏好时间匹配的用户
    96→        return await self.user_repo.get_users_by_ritual_time(
    97→            ritual_type=ritual_type,
    98→            hour=current_hour,
    99→            minute=current_minute
   100→        )
   101→
   102→    async def _send_morning_oracle(self, user):
   103→        """发送晨谕"""
   104→        # 检查今日是否已发送
   105→        if await self._already_sent_today(user.vibe_id, 'morning_oracle'):
   106→            return
   107→
   108→        # 生成晨谕
   109→        oracle = await self.generator.generate_morning_oracle(user.vibe_id)
   110→
   111→        # 保存到数据库
   112→        await self._save_ritual(user.vibe_id, 'morning_oracle', oracle)
   113→
   114→        # 发送推送
   115→        await self.push.send(
   116→            user_id=user.vibe_id,
   117→            title="☀️ 今日晨谕",
   118→            body=f"今日能量: {oracle['energy_theme']}",
   119→            data={'type': 'morning_oracle', 'ritual_id': oracle['id']}
   120→        )
   121→```
   122→
   123→### 2.2 批量处理优化
   124→
   125→```python
   126→# services/ritual/batch_processor.py
   127→
   128→class RitualBatchProcessor:
   129→    """批量处理仪式生成，提高效率"""
   130→
   131→    BATCH_SIZE = 100
   132→
   133→    async def process_batch(self, ritual_type: str, users: list):
   134→        """批量处理用户仪式"""
   135→
   136→        # 分批处理
   137→        for i in range(0, len(users), self.BATCH_SIZE):
   138→            batch = users[i:i + self.BATCH_SIZE]
   139→
   140→            # 并行生成仪式
   141→            tasks = [
   142→                self._generate_and_send(user, ritual_type)
   143→                for user in batch
   144→            ]
   145→
   146→            results = await asyncio.gather(*tasks, return_exceptions=True)
   147→
   148→            # 记录失败
   149→            for user, result in zip(batch, results):
   150→                if isinstance(result, Exception):
   151→                    logger.error(f"Ritual failed for {user.vibe_id}: {result}")
   152→
   153→            # 批次间短暂休息，避免过载
   154→            await asyncio.sleep(0.5)
   155→```
   156→
   157→---
   158→
   159→## 3. 仪式生成器
   160→
   161→### 3.1 晨谕生成
   162→
   163→```python
   164→# services/ritual/generators/morning_oracle.py
   165→
   166→class MorningOracleGenerator:
   167→    """晨谕生成器"""
   168→
   169→    PROMPT_TEMPLATE = """
   170→你是 VibeLife，正在为用户生成今日晨谕。
   171→
   172→## 用户信息
   173→- 名字: {user_name}
   174→- 核心本质: {core_essence}
   175→- 内在自我: {inner_self}
   176→
   177→## 今日运势
   178→{daily_fortune}
   179→
   180→## 需要跟进的事项
   181→{follow_ups}
   182→
   183→## 即将发生的事件
   184→{upcoming_events}
   185→
   186→请生成今日晨谕，包含:
   187→
   188→1. **能量主题** (2-3个字，如"突破"、"沉淀"、"连接")
   189→2. **今日预测** (可能遇到的情况，具体且有洞察力)
   190→3. **应对建议** (如果发生了该怎么做)
   191→4. **跟进提醒** (如果有需要跟进的事项，自然地提及)
   192→
   193→风格要求:
   194→- 温暖但不腻，像一个了解你的朋友
   195→- 具体而非泛泛，基于用户的特质
   196→- 简洁有力，总字数不超过150字
   197→
   198→输出 JSON 格式:
   199→{{
   200→    "energy_theme": "...",
   201→    "prediction": "...",
   202→    "advice": "...",
   203→    "follow_up_reminder": "..." // 可选
   204→}}
   205→"""
   206→
   207→    async def generate(self, user_id: str) -> dict:
   208→        """生成晨谕"""
   209→
   210→        # 获取用户上下文
   211→        user = await self.user_repo.get(user_id)
   212→        prism = await self.identity_service.get_prism(user_id)
   213→        fortune = await self.fortune_service.get_daily(user_id)
   214→        follow_ups = await self.memory_service.get_follow_ups(user_id)
   215→        events = await self.event_service.get_upcoming(user_id, days=3)
   216→
   217→        # 构建 prompt
   218→        prompt = self.PROMPT_TEMPLATE.format(
   219→            user_name=user.display_name or "朋友",
   220→            core_essence=prism.get('core_essence', {}).get('summary', '尚未解锁'),
   221→            inner_self=prism.get('inner_self', {}).get('summary', '尚未解锁'),
   222→            daily_fortune=self._format_fortune(fortune),
   223→            follow_ups=self._format_follow_ups(follow_ups),
   224→            upcoming_events=self._format_events(events)
   225→        )
   226→
   227→        # 调用 LLM
   228→        response = await self.llm.generate(
   229→            messages=[{"role": "user", "content": prompt}],
   230→            temperature=0.7
   231→        )
   232→
   233→        oracle = json.loads(response)
   234→        oracle['generated_at'] = datetime.utcnow().isoformat()
   235→
   236→        return oracle
   237→```
   238→
   239→### 3.2 午照生成
   240→
   241→```python
   242→# services/ritual/generators/midday_mirror.py
   243→
   244→class MiddayMirrorGenerator:
   245→    """午照生成器"""
   246→
   247→    PROMPT_TEMPLATE = """
   248→你是 VibeLife，正在为用户生成午间反思。
   249→
   250→## 今日晨谕
   251→能量主题: {morning_theme}
   252→预测: {morning_prediction}
   253→
   254→## 用户特质
   255→{user_traits}
   256→
   257→请生成午照内容:
   258→
   259→1. **反思问题** (询问上午的情况，自然地引用晨谕)
   260→2. **晨谕回顾** (简短提及早上的预测)
   261→
   262→风格要求:
   263→- 像朋友中午发来的关心消息
   264→- 自然、轻松，不要太正式
   265→- 总字数不超过50字
   266→
   267→输出 JSON 格式:
   268→{{
   269→    "check_in_question": "...",
   270→    "morning_reference": "..."
   271→}}
   272→"""
   273→
   274→    async def generate(self, user_id: str) -> dict:
   275→        """生成午照"""
   276→
   277→        # 获取今日晨谕
   278→        today_ritual = await self.ritual_repo.get_today(user_id)
   279→        morning_oracle = today_ritual.get('morning_oracle', {})
   280→
   281→        if not morning_oracle:
   282→            # 如果没有晨谕，生成通用午照
   283→            return await self._generate_generic_midday(user_id)
   284→
   285→        # 获取用户特质
   286→        prism = await self.identity_service.get_prism(user_id)
   287→
   288→        prompt = self.PROMPT_TEMPLATE.format(
   289→            morning_theme=morning_oracle.get('energy_theme', ''),
   290→            morning_prediction=morning_oracle.get('prediction', ''),
   291→            user_traits=prism.get('core_essence', {}).get('summary', '')
   292→        )
   293→
   294→        response = await self.llm.generate(
   295→            messages=[{"role": "user", "content": prompt}],
   296→            temperature=0.7
   297→        )
   298→
   299→        mirror = json.loads(response)
   300→        mirror['generated_at'] = datetime.utcnow().isoformat()
   301→
   302→        return mirror
   303→
   304→    async def process_response(self, user_id: str, response: str) -> dict:
   305→        """处理用户对午照的回复"""
   306→
   307→        # 提取记忆
   308→        memories = await self.memory_extractor.extract_from_text(
   309→            user_id, response
   310→        )
   311→
   312→        # 生成 AI 跟进
   313→        follow_up = await self._generate_follow_up(user_id, response)
   314→
   315→        return {
   316→            'ai_follow_up': follow_up,
   317→            'extracted_memories': memories
   318→        }
   319→```
   320→
   321→### 3.3 夜语生成
   322→
   323→```python
   324→# services/ritual/generators/night_whisper.py
   325→
   326→class NightWhisperGenerator:
   327→    """夜语生成器"""
   328→
   329→    PROMPT_TEMPLATE = """
   330→你是 VibeLife，正在为用户生成晚间夜语。
   331→
   332→## 今日互动摘要
   333→{today_summary}
   334→
   335→## 今日晨谕回顾
   336→能量主题: {morning_theme}
   337→预测: {morning_prediction}
   338→
   339→## 明日运势预览
   340→{tomorrow_preview}
   341→
   342→## 用户特质
   343→{user_traits}
   344→
   345→请生成夜语内容:
   346→
   347→1. **今日总结** (温暖地回顾今天，如果有互动则提及)
   348→2. **明日预览** (简短预告明天的能量)
   349→3. **晚安寄语** (温暖的结束语，可以用用户的名字)
   350→
   351→风格要求:
   352→- 温暖、治愈，像睡前的轻声细语
   353→- 让用户感到被关心和理解
   354→- 总字数不超过100字
   355→
   356→输出 JSON 格式:
   357→{{
   358→    "day_summary": "...",
   359→    "tomorrow_preview": "...",
   360→    "closing_message": "..."
   361→}}
   362→"""
   363→
   364→    async def generate(self, user_id: str) -> dict:
   365→        """生成夜语"""
   366→
   367→        user = await self.user_repo.get(user_id)
   368→        today_ritual = await self.ritual_repo.get_today(user_id)
   369→        morning_oracle = today_ritual.get('morning_oracle', {})
   370→
   371→        # 获取今日互动摘要
   372→        today_summary = await self._get_today_summary(user_id)
   373→
   374→        # 获取明日运势预览
   375→        tomorrow_preview = await self.fortune_service.get_preview(user_id, days=1)
   376→
   377→        # 获取用户特质
   378→        prism = await self.identity_service.get_prism(user_id)
   379→
   380→        prompt = self.PROMPT_TEMPLATE.format(
   381→            today_summary=today_summary,
   382→            morning_theme=morning_oracle.get('energy_theme', ''),
   383→            morning_prediction=morning_oracle.get('prediction', ''),
   384→            tomorrow_preview=tomorrow_preview,
   385→            user_traits=prism.get('core_essence', {}).get('summary', '')
   386→        )
   387→
   388→        response = await self.llm.generate(
   389→            messages=[{"role": "user", "content": prompt}],
   390→            temperature=0.7
   391→        )
   392→
   393→        whisper = json.loads(response)
   394→        whisper['generated_at'] = datetime.utcnow().isoformat()
   395→        whisper['user_name'] = user.display_name
   396→
   397→        return whisper
   398→```
   399→
   400→---
   401→
   402→## 4. 推送服务
   403→
   404→### 4.1 多渠道推送
   405→
   406→```python
   407→# services/push/service.py
   408→
   409→class PushService:
   410→    """多渠道推送服务"""
   411→
   412→    def __init__(
   413→        self,
   414→        web_push: WebPushProvider,
   415→        apns: APNSProvider,
   416→        fcm: FCMProvider,
   417→        wechat: WeChatProvider
   418→    ):
   419→        self.providers = {
   420→            'web': web_push,
   421→            'ios': apns,
   422→            'android': fcm,
   423→            'wechat': wechat
   424→        }
   425→
   426→    async def send(
   427→        self,
   428→        user_id: str,
   429→        title: str,
   430→        body: str,
   431→        data: dict = None,
   432→        channels: list = None
   433→    ):
   434→        """发送推送通知"""
   435→
   436→        # 获取用户的推送订阅
   437→        subscriptions = await self.subscription_repo.get_by_user(user_id)
   438→
   439→        if not subscriptions:
   440→            logger.info(f"No push subscriptions for user {user_id}")
   441→            return
   442→
   443→        # 过滤渠道
   444→        if channels:
   445→            subscriptions = [s for s in subscriptions if s.channel in channels]
   446→
   447→        # 发送到各渠道
   448→        for sub in subscriptions:
   449→            provider = self.providers.get(sub.channel)
   450→            if provider:
   451→                try:
   452→                    await provider.send(
   453→                        subscription=sub,
   454→                        title=title,
   455→                        body=body,
   456→                        data=data
   457→                    )
   458→                except Exception as e:
   459→                    logger.error(f"Push failed for {sub.channel}: {e}")
   460→                    # 标记失败的订阅
   461→                    await self._handle_push_failure(sub, e)
   462→```
   463→
   464→### 4.2 Web Push Provider
   465→
   466→```python
   467→# services/push/providers/web_push.py
   468→
   469→from pywebpush import webpush, WebPushException
   470→
   471→class WebPushProvider:
   472→    """Web Push 推送提供者"""
   473→
   474→    def __init__(self, vapid_private_key: str, vapid_claims: dict):
   475→        self.vapid_private_key = vapid_private_key
   476→        self.vapid_claims = vapid_claims
   477→
   478→    async def send(
   479→        self,
   480→        subscription: PushSubscription,
   481→        title: str,
   482→        body: str,
   483→        data: dict = None
   484→    ):
   485→        """发送 Web Push"""
   486→
   487→        payload = json.dumps({
   488→            'title': title,
   489→            'body': body,
   490→            'data': data or {},
   491→            'icon': '/icons/vibe-icon-192.png',
   492→            'badge': '/icons/vibe-badge.png',
   493→            'tag': data.get('type', 'notification'),
   494→            'actions': self._get_actions(data)
   495→        })
   496→
   497→        try:
   498→            webpush(
   499→                subscription_info=subscription.subscription_info,
   500→                data=payload,
   501→                vapid_private_key=self.vapid_private_key,
   502→                vapid_claims=self.vapid_claims
   503→            )
   504→        except WebPushException as e:
   505→            if e.response.status_code == 410:
   506→                # 订阅已失效
   507→                raise SubscriptionExpiredError(subscription.id)
   508→            raise
   509→
   510→    def _get_actions(self, data: dict) -> list:
   511→        """根据通知类型返回操作按钮"""
   512→
   513→        notification_type = data.get('type', '')
   514→
   515→        if notification_type == 'morning_oracle':
   516→            return [
   517→                {'action': 'view', 'title': '查看详情'},
   518→                {'action': 'chat', 'title': '开始对话'}
   519→            ]
   520→        elif notification_type == 'midday_mirror':
   521→            return [
   522→                {'action': 'respond', 'title': '回复'}
   523→            ]
   524→        elif notification_type == 'event_reminder':
   525→            return [
   526→                {'action': 'view', 'title': '查看'},
   527→                {'action': 'chat', 'title': '聊聊'}
   528→            ]
   529→
   530→        return []
   531→```
   532→
   533→### 4.3 微信推送 Provider
   534→
   535→```python
   536→# services/push/providers/wechat.py
   537→
   538→class WeChatProvider:
   539→    """微信模板消息推送"""
   540→
   541→    TEMPLATE_IDS = {
   542→        'morning_oracle': 'TEMPLATE_ID_MORNING',
   543→        'midday_mirror': 'TEMPLATE_ID_MIDDAY',
   544→        'night_whisper': 'TEMPLATE_ID_NIGHT',
   545→        'event_reminder': 'TEMPLATE_ID_EVENT'
   546→    }
   547→
   548→    async def send(
   549→        self,
   550→        subscription: PushSubscription,
   551→        title: str,
   552→        body: str,
   553→        data: dict = None
   554→    ):
   555→        """发送微信模板消息"""
   556→
   557→        template_id = self.TEMPLATE_IDS.get(data.get('type'), 'TEMPLATE_ID_DEFAULT')
   558→
   559→        message = {
   560→            'touser': subscription.wechat_openid,
   561→            'template_id': template_id,
   562→            'url': f"{settings.WEB_URL}/ritual/{data.get('ritual_id', '')}",
   563→            'data': {
   564→                'first': {'value': title},
   565→                'keyword1': {'value': body},
   566→                'remark': {'value': '点击查看详情'}
   567→            }
   568→        }
   569→
   570→        async with httpx.AsyncClient() as client:
   571→            response = await client.post(
   572→                f"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token={await self._get_access_token()}",
   573→                json=message
   574→            )
   575→            result = response.json()
   576→
   577→            if result.get('errcode') != 0:
   578→                raise WeChatPushError(result.get('errmsg'))
   579→```
   580→
   581→---
   582→
   583→## 5. 推送订阅管理
   584→
   585→### 5.1 数据模型
   586→
   587→```sql
   588→-- 推送订阅表
   589→CREATE TABLE push_subscriptions (
   590→    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
   591→    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),
   592→
   593→    -- 渠道信息
   594→    channel VARCHAR(20) NOT NULL,  -- web, ios, android, wechat
   595→    device_id VARCHAR(255),
   596→
   597→    -- 订阅信息 (各渠道不同)
   598→    subscription_info JSONB NOT NULL,
   599→    -- web: {endpoint, keys: {p256dh, auth}}
   600→    -- ios: {device_token}
   601→    -- android: {fcm_token}
   602→    -- wechat: {openid}
   603→
   604→    -- 状态
   605→    is_active BOOLEAN DEFAULT true,
   606→    last_used_at TIMESTAMP,
   607→    failure_count INTEGER DEFAULT 0,
   608→
   609→    created_at TIMESTAMP DEFAULT NOW(),
   610→    updated_at TIMESTAMP DEFAULT NOW(),
   611→
   612→    UNIQUE(user_id, channel, device_id)
   613→);
   614→
   615→CREATE INDEX idx_push_sub_user ON push_subscriptions(user_id);
   616→CREATE INDEX idx_push_sub_active ON push_subscriptions(is_active) WHERE is_active = true;
   617→```
   618→
   619→### 5.2 订阅 API
   620→
   621→```python
   622→# routes/push.py
   623→
   624→@router.post("/subscribe")
   625→async def subscribe(
   626→    request: SubscribeRequest,
   627→    user: VibeUser = Depends(get_current_user)
   628→):
   629→    """订阅推送"""
   630→
   631→    subscription = await push_service.subscribe(
   632→        user_id=user.vibe_id,
   633→        channel=request.channel,
   634→        subscription_info=request.subscription_info,
   635→        device_id=request.device_id
   636→    )
   637→
   638→    return {"subscription_id": subscription.id}
   639→
   640→@router.post("/unsubscribe")
   641→async def unsubscribe(
   642→    request: UnsubscribeRequest,
   643→    user: VibeUser = Depends(get_current_user)
   644→):
   645→    """取消订阅"""
   646→
   647→    await push_service.unsubscribe(
   648→        user_id=user.vibe_id,
   649→        subscription_id=request.subscription_id
   650→    )
   651→
   652→    return {"status": "unsubscribed"}
   653→
   654→@router.get("/subscriptions")
   655→async def get_subscriptions(user: VibeUser = Depends(get_current_user)):
   656→    """获取用户的推送订阅"""
   657→
   658→    subscriptions = await push_service.get_subscriptions(user.vibe_id)
   659→    return {"subscriptions": subscriptions}
   660→```
   661→
   662→---
   663→
   664→## 6. 仪式 API
   665→
   666→### 6.1 路由定义
   667→
   668→```python
   669→# routes/rituals.py
   670→
   671→@router.get("/today")
   672→async def get_today_rituals(user: VibeUser = Depends(get_current_user)):
   673→    """获取今日仪式"""
   674→
   675→    ritual = await ritual_service.get_today(user.vibe_id)
   676→    return ritual
   677→
   678→@router.post("/midday/respond")
   679→async def respond_to_midday(
   680→    request: MiddayResponseRequest,
   681→    user: VibeUser = Depends(get_current_user)
   682→):
   683→    """回复午照"""
   684→
   685→    result = await ritual_service.process_midday_response(
   686→        user_id=user.vibe_id,
   687→        response=request.response
   688→    )
   689→
   690→    return result
   691→
   692→@router.put("/preferences")
   693→async def update_preferences(
   694→    request: RitualPreferencesRequest,
   695→    user: VibeUser = Depends(get_current_user)
   696→):
   697→    """更新仪式偏好"""
   698→
   699→    await ritual_service.update_preferences(
   700→        user_id=user.vibe_id,
   701→        preferences=request.dict()
   702→    )
   703→
   704→    return {"status": "updated"}
   705→
   706→@router.get("/history")
   707→async def get_ritual_history(
   708→    days: int = 7,
   709→    user: VibeUser = Depends(get_current_user)
   710→):
   711→    """获取仪式历史"""
   712→
   713→    history = await ritual_service.get_history(user.vibe_id, days=days)
   714→    return {"history": history}
   715→```
   716→
   717→---
   718→
   719→## 7. 前端集成
   720→
   721→### 7.1 Service Worker
   722→
   723→```javascript
   724→// public/sw.js
   725→
   726→self.addEventListener('push', (event) => {
   727→  const data = event.data.json()
   728→
   729→  const options = {
   730→    body: data.body,
   731→    icon: data.icon || '/icons/vibe-icon-192.png',
   732→    badge: data.badge || '/icons/vibe-badge.png',
   733→    tag: data.tag,
   734→    data: data.data,
   735→    actions: data.actions || [],
   736→    vibrate: [100, 50, 100],
   737→    requireInteraction: data.tag === 'midday_mirror'
   738→  }
   739→
   740→  event.waitUntil(
   741→    self.registration.showNotification(data.title, options)
   742→  )
   743→})
   744→
   745→self.addEventListener('notificationclick', (event) => {
   746→  event.notification.close()
   747→
   748→  const data = event.notification.data
   749→  let url = '/'
   750→
   751→  if (event.action === 'respond' || event.action === 'chat') {
   752→    url = '/chat'
   753→  } else if (event.action === 'view') {
   754→    url = `/ritual/${data.ritual_id || 'today'}`
   755→  } else if (data.type === 'morning_oracle') {
   756→    url = '/home'
   757→  }
   758→
   759→  event.waitUntil(
   760→    clients.matchAll({ type: 'window' }).then((clientList) => {
   761→      for (const client of clientList) {
   762→        if (client.url.includes(self.location.origin) && 'focus' in client) {
   763→          client.navigate(url)
   764→          return client.focus()
   765→        }
   766→      }
   767→      return clients.openWindow(url)
   768→    })
   769→  )
   770→})
   771→```
   772→
   773→### 7.2 推送订阅 Hook
   774→
   775→```tsx
   776→// hooks/usePushNotifications.ts
   777→
   778→export function usePushNotifications() {
   779→  const [permission, setPermission] = useState<NotificationPermission>('default')
   780→  const [isSubscribed, setIsSubscribed] = useState(false)
   781→
   782→  useEffect(() => {
   783→    if ('Notification' in window) {
   784→      setPermission(Notification.permission)
   785→    }
   786→    checkSubscription()
   787→  }, [])
   788→
   789→  const checkSubscription = async () => {
   790→    if ('serviceWorker' in navigator) {
   791→      const registration = await navigator.serviceWorker.ready
   792→      const subscription = await registration.pushManager.getSubscription()
   793→      setIsSubscribed(!!subscription)
   794→    }
   795→  }
   796→
   797→  const subscribe = async () => {
   798→    // 请求权限
   799→    const permission = await Notification.requestPermission()
   800→    setPermission(permission)
   801→
   802→    if (permission !== 'granted') {
   803→      throw new Error('Notification permission denied')
   804→    }
   805→
   806→    // 获取 Service Worker
   807→    const registration = await navigator.serviceWorker.ready
   808→
   809→    // 订阅推送
   810→    const subscription = await registration.pushManager.subscribe({
   811→      userVisibleOnly: true,
   812→      applicationServerKey: urlBase64ToUint8Array(
   813→        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!
   814→      )
   815→    })
   816→
   817→    // 发送到服务器
   818→    await api.post('/api/v1/push/subscribe', {
   819→      channel: 'web',
   820→      subscription_info: subscription.toJSON()
   821→    })
   822→
   823→    setIsSubscribed(true)
   824→  }
   825→
   826→  const unsubscribe = async () => {
   827→    const registration = await navigator.serviceWorker.ready
   828→    const subscription = await registration.pushManager.getSubscription()
   829→
   830→    if (subscription) {
   831→      await subscription.unsubscribe()
   832→      await api.post('/api/v1/push/unsubscribe')
   833→    }
   834→
   835→    setIsSubscribed(false)
   836→  }
   837→
   838→  return {
   839→    permission,
   840→    isSubscribed,
   841→    subscribe,
   842→    unsubscribe,
   843→    isSupported: 'Notification' in window && 'serviceWorker' in navigator
   844→  }
   845→}
   846→```
   847→
   848→---
   849→
   850→## 8. 实施检查清单
   851→
   852→- [ ] 创建 push_subscriptions 表
   853→- [ ] 实现 RitualScheduler
   854→- [ ] 实现 MorningOracleGenerator
   855→- [ ] 实现 MiddayMirrorGenerator
   856→- [ ] 实现 NightWhisperGenerator
   857→- [ ] 实现 PushService
   858→- [ ] 实现 WebPushProvider
   859→- [ ] 实现 WeChatProvider (可选)
   860→- [ ] 创建仪式 API 路由
   861→- [ ] 创建推送 API 路由
   862→- [ ] 配置 VAPID 密钥
   863→- [ ] 实现 Service Worker
   864→- [ ] 实现 usePushNotifications hook
   865→- [ ] 测试完整仪式流程
   866→- [ ] 配置生产环境调度
   867→
   868→---
   869→
   870→*下一步: [07-迁移与部署](./07-迁移与部署.md)*
   871→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
