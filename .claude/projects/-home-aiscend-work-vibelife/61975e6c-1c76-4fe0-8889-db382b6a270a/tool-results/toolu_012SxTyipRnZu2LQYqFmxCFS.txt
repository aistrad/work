     1→"use client";
     2→
     3→import { useRef, useEffect, useMemo, useCallback } from "react";
     4→import type { UIMessage } from "@ai-sdk/react";
     5→import { ChatMessage } from "./ChatMessage";
     6→import { ChatInput } from "./ChatInput";
     7→import { InsightCard, InsightType } from "@/components/insight/InsightCard";
     8→import { VibeGlyph, BreathAura, type SkillType } from "@/components/core";
     9→import { DailyGreeting } from "@/components/greeting/DailyGreeting";
    10→import { useVibeChat, type SkillId } from "@/hooks/useVibeChat";
    11→
    12→interface InsightData {
    13→  id: string;
    14→  insight_type: InsightType;
    15→  title: string;
    16→  content: string;
    17→}
    18→
    19→/**
    20→ * Extract text content from AI SDK 6 UIMessage
    21→ * UIMessage uses parts array instead of content string
    22→ */
    23→function getMessageContent(message: UIMessage): string {
    24→  if (!message.parts || message.parts.length === 0) {
    25→    // Fallback for messages without parts
    26→    return (message as unknown as { content?: string }).content || '';
    27→  }
    28→
    29→  // Concatenate all text parts
    30→  return message.parts
    31→    .filter((part): part is { type: 'text'; text: string } => part.type === 'text')
    32→    .map(part => part.text)
    33→    .join('');
    34→}
    35→
    36→export type VoiceMode = "warm" | "sarcastic";
    37→
    38→export interface ChatContainerProps {
    39→  skillId: string;
    40→  skill?: SkillType;
    41→  conversationId?: string;
    42→  voiceMode?: VoiceMode;
    43→  onConversationStart?: (id: string) => void;
    44→}
    45→
    46→// ═══════════════════════════════════════════════════════════════════════════
    47→// ChatEmptyState - LUMINOUS PAPER Design System
    48→// 空状态：居中 VibeGlyph + 技能感知文案 + 呼吸光晕
    49→// ═══════════════════════════════════════════════════════════════════════════
    50→
    51→const SKILL_EMPTY_STATE: Record<SkillType, { title: string; subtitle: string }> = {
    52→  bazi: {
    53→    title: "探索你的命理",
    54→    subtitle: "分享你的生辰，开启八字解读之旅",
    55→  },
    56→  zodiac: {
    57→    title: "倾听星辰的声音",
    58→    subtitle: "让星盘为你揭示宇宙的密语",
    59→  },
    60→  mbti: {
    61→    title: "发现真实的自己",
    62→    subtitle: "通过对话，探索你的人格特质",
    63→  },
    64→  attach: {
    65→    title: "理解你的依恋模式",
    66→    subtitle: "探索亲密关系中的自我",
    67→  },
    68→  career: {
    69→    title: "规划你的职业蓝图",
    70→    subtitle: "让我们一起探索你的职业发展方向",
    71→  },
    72→};
    73→
    74→// Quick prompts for each skill
    75→const SKILL_QUICK_PROMPTS: Record<SkillType, string[]> = {
    76→  bazi: [
    77→    "我是1990年5月15日早上8点出生的",
    78→    "帮我分析今年的运势",
    79→    "我的事业运如何？",
    80→    "什么时候适合做重大决定？",
    81→  ],
    82→  zodiac: [
    83→    "我是双子座，帮我看看本周运势",
    84→    "我的太阳星座和上升星座有什么区别？",
    85→    "双子座和什么星座最配？",
    86→    "水逆对我有什么影响？",
    87→  ],
    88→  mbti: [
    89→    "帮我测测我的MBTI类型",
    90→    "INFP适合什么职业？",
    91→    "我是INTJ，如何改善人际关系？",
    92→    "E人和I人有什么本质区别？",
    93→  ],
    94→  attach: [
    95→    "帮我分析我的依恋类型",
    96→    "回避型依恋如何建立亲密关系？",
    97→    "为什么我总是害怕被抛弃？",
    98→    "如何治愈童年的情感创伤？",
    99→  ],
   100→  career: [
   101→    "我该如何规划职业发展？",
   102→    "我适合创业还是打工？",
   103→    "如何在面试中展现自己？",
   104→    "转行需要考虑什么？",
   105→  ],
   106→};
   107→
   108→// 生成当日问候数据
   109→function useDailyGreeting() {
   110→  return useMemo(() => {
   111→    const now = new Date();
   112→    const hour = now.getHours();
   113→
   114→    // 基于时间的问候语
   115→    const greetings = {
   116→      morning: "早安，愿你今日能量满满",
   117→      afternoon: "午后时光，适合沉淀思考",
   118→      evening: "晚间静谧，回顾今日收获",
   119→    };
   120→
   121→    let greeting = greetings.morning;
   122→    if (hour >= 12 && hour < 18) greeting = greetings.afternoon;
   123→    else if (hour >= 18) greeting = greetings.evening;
   124→
   125→    // 节气（简化版，实际应根据日期计算）
   126→    const solarTerms = ["小寒", "大寒", "立春", "雨水", "惊蛰", "春分"];
   127→    const termIdx = Math.floor((now.getMonth() * 2 + Math.floor(now.getDate() / 15)) % 6);
   128→
   129→    return {
   130→      greeting,
   131→      solarTerm: solarTerms[termIdx],
   132→      termDescription: "万物生长",
   133→      todayTip: "今日宜专注当下，一步一脚印",
   134→    };
   135→  }, []);
   136→}
   137→
   138→function ChatEmptyState({ skill, onQuickPrompt }: { skill: SkillType; onQuickPrompt?: (prompt: string) => void }) {
   139→  const config = SKILL_EMPTY_STATE[skill] || SKILL_EMPTY_STATE.bazi;
   140→  const quickPrompts = SKILL_QUICK_PROMPTS[skill] || SKILL_QUICK_PROMPTS.bazi;
   141→  const dailyData = useDailyGreeting();
   142→
   143→  return (
   144→    <div className="flex flex-col items-center justify-center max-w-xl mx-auto px-4 py-6 w-full">
   145→      {/* Daily Greeting 每日问候 */}
   146→      <DailyGreeting
   147→        greeting={dailyData.greeting}
   148→        solarTerm={dailyData.solarTerm}
   149→        termDescription={dailyData.termDescription}
   150→        todayTip={dailyData.todayTip}
   151→        className="mb-6 w-full"
   152→      />
   153→
   154→      {/* Animated glyph with enhanced aura */}
   155→      <div className="relative flex items-center justify-center mb-4">
   156→        {/* Outer pulsing ring */}
   157→        <div className="absolute w-16 h-16 rounded-full border border-skill-primary/20 animate-pulse-slow" />
   158→        <div className="absolute w-24 h-24 rounded-full border border-skill-primary/10 animate-pulse-slower" />
   159→
   160→        {/* Breath aura */}
   161→        <BreathAura
   162→          skill={skill}
   163→          size="sm"
   164→          position="center"
   165→          intensity="medium"
   166→          className="opacity-40"
   167→        />
   168→
   169→        {/* Central glyph */}
   170→        <VibeGlyph
   171→          size="sm"
   172→          skill={skill}
   173→          showAura={true}
   174→          animate={true}
   175→          className="relative z-10"
   176→        />
   177→      </div>
   178→
   179→      {/* Title */}
   180→      <h3 className="text-base md:text-lg font-serif font-semibold text-foreground mb-1 text-center">
   181→        {config.title}
   182→      </h3>
   183→
   184→      {/* Subtitle */}
   185→      <p className="text-sm text-muted-foreground max-w-sm text-center mb-4">
   186→        {config.subtitle}
   187→      </p>
   188→
   189→      {/* Quick prompt suggestions */}
   190→      <div className="w-full space-y-2">
   191→        <p className="text-xs text-muted-foreground/60 text-center mb-2">
   192→          试试这样问
   193→        </p>
   194→        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
   195→          {quickPrompts.slice(0, 4).map((prompt, index) => (
   196→            <button
   197→              key={index}
   198→              onClick={() => onQuickPrompt?.(prompt)}
   199→              className="group relative px-3 py-2 text-left text-sm text-muted-foreground
   200→                       bg-card hover:bg-card/80 border border-border/50 hover:border-border
   201→                       rounded-lg transition-all duration-200
   202→                       hover:shadow-sm"
   203→            >
   204→              <span className="line-clamp-2">{prompt}</span>
   205→            </button>
   206→          ))}
   207→        </div>
   208→      </div>
   209→    </div>
   210→  );
   211→}
   212→
   213→export function ChatContainer({
   214→  skillId,
   215→  skill = "bazi",
   216→  conversationId,
   217→  voiceMode = "warm",
   218→  onConversationStart,
   219→}: ChatContainerProps) {
   220→  const messagesEndRef = useRef<HTMLDivElement>(null);
   221→
   222→  // Map skillId to SkillType if not provided
   223→  const activeSkill: SkillType = skill || (skillId as SkillType) || "bazi";
   224→
   225→  // Use AI SDK powered chat hook
   226→  const {
   227→    messages,
   228→    isLoading,
   229→    sendMessage,
   230→    sendQuickPrompt,
   231→    error,
   232→  } = useVibeChat({
   233→    skillId: (skillId || skill) as SkillId,
   234→    voiceMode,
   235→    conversationId,
   236→    onConversationStart,
   237→    onError: (err) => console.error("Chat error:", err),
   238→  });
   239→
   240→  const scrollToBottom = useCallback(() => {
   241→    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
   242→  }, []);
   243→
   244→  useEffect(() => {
   245→    scrollToBottom();
   246→  }, [messages, scrollToBottom]);
   247→
   248→  // Handle send from ChatInput
   249→  const handleSend = useCallback(
   250→    async (content: string) => {
   251→      await sendMessage(content);
   252→    },
   253→    [sendMessage]
   254→  );
   255→
   256→  // Handle quick prompt from empty state
   257→  const handleQuickPrompt = useCallback(
   258→    async (content: string) => {
   259→      await sendQuickPrompt(content);
   260→    },
   261→    [sendQuickPrompt]
   262→  );
   263→
   264→  const hasMessages = messages.length > 0;
   265→
   266→  return (
   267→    <div className="flex flex-col h-full" data-skill={activeSkill}>
   268→      {/* Messages area - always flex-1 to push input to bottom */}
   269→      <div className="flex-1 overflow-y-auto relative min-h-0">
   270→        {!hasMessages ? (
   271→          /* Empty state - centered within scrollable area */
   272→          <div className="flex flex-col items-center justify-end h-full pb-4 px-4">
   273→            <ChatEmptyState skill={activeSkill} onQuickPrompt={handleQuickPrompt} />
   274→          </div>
   275→        ) : (
   276→          /* Messages list - PC端左对齐，移动端居中 */
   277→          <div className="px-4 pt-4 pb-2 max-w-3xl lg:ml-4 lg:mr-auto mx-auto">
   278→            {messages.map((message) => (
   279→              <div key={message.id}>
   280→                <ChatMessage
   281→                  role={message.role as "user" | "assistant"}
   282→                  content={getMessageContent(message)}
   283→                  isStreaming={isLoading && message.role === "assistant" && message === messages[messages.length - 1]}
   284→                />
   285→              </div>
   286→            ))}
   287→            {/* Show loading indicator when waiting for first response chunk */}
   288→            {isLoading && messages.length > 0 && messages[messages.length - 1].role === "user" && (
   289→              <ChatMessage
   290→                role="assistant"
   291→                content=""
   292→                isStreaming
   293→              />
   294→            )}
   295→            {/* Show error message */}
   296→            {error && (
   297→              <div className="text-red-500 text-sm text-center py-2">
   298→                抱歉，出了点问题。请稍后再试。
   299→              </div>
   300→            )}
   301→            <div ref={messagesEndRef} />
   302→          </div>
   303→        )}
   304→      </div>
   305→
   306→      {/* Input - fixed at bottom */}
   307→      <div className="flex-shrink-0">
   308→        <ChatInput onSend={handleSend} disabled={isLoading} />
   309→      </div>
   310→    </div>
   311→  );
   312→}
   313→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
