     1→"""
     2→VibeLife Stripe Service
     3→Stripe 支付集成服务
     4→"""
     5→
     6→import os
     7→from datetime import datetime
     8→from typing import Optional
     9→from pydantic import BaseModel
    10→from enum import Enum
    11→import logging
    12→
    13→logger = logging.getLogger(__name__)
    14→
    15→# Stripe 配置
    16→STRIPE_SECRET_KEY = os.environ.get("STRIPE_SECRET_KEY", "")
    17→STRIPE_WEBHOOK_SECRET = os.environ.get("STRIPE_WEBHOOK_SECRET", "")
    18→STRIPE_PUBLISHABLE_KEY = os.environ.get("STRIPE_PUBLISHABLE_KEY", "")
    19→
    20→
    21→class PaymentStatus(str, Enum):
    22→    PENDING = "pending"
    23→    SUCCEEDED = "succeeded"
    24→    FAILED = "failed"
    25→    CANCELED = "canceled"
    26→    REFUNDED = "refunded"
    27→
    28→
    29→class CheckoutSession(BaseModel):
    30→    """Stripe Checkout Session"""
    31→    session_id: str
    32→    url: str
    33→    status: str
    34→    customer_id: Optional[str] = None
    35→    subscription_id: Optional[str] = None
    36→
    37→
    38→class PaymentIntent(BaseModel):
    39→    """支付意图"""
    40→    intent_id: str
    41→    amount: int
    42→    currency: str
    43→    status: PaymentStatus
    44→
    45→
    46→class StripeService:
    47→    """Stripe 支付服务"""
    48→
    49→    def __init__(self):
    50→        self.api_key = STRIPE_SECRET_KEY
    51→        self._stripe = None
    52→
    53→    @property
    54→    def stripe(self):
    55→        """延迟加载 Stripe 模块"""
    56→        if self._stripe is None:
    57→            try:
    58→                import stripe
    59→                stripe.api_key = self.api_key
    60→                self._stripe = stripe
    61→            except ImportError:
    62→                logger.warning("Stripe module not installed")
    63→                return None
    64→        return self._stripe
    65→
    66→    async def create_customer(
    67→        self,
    68→        user_id: str,
    69→        email: str,
    70→        name: Optional[str] = None
    71→    ) -> Optional[str]:
    72→        """创建 Stripe 客户"""
    73→        if not self.stripe:
    74→            return None
    75→
    76→        try:
    77→            customer = self.stripe.Customer.create(
    78→                email=email,
    79→                name=name,
    80→                metadata={"user_id": user_id}
    81→            )
    82→            return customer.id
    83→        except Exception as e:
    84→            logger.error(f"Failed to create Stripe customer: {e}")
    85→            return None
    86→
    87→    async def create_checkout_session(
    88→        self,
    89→        user_id: str,
    90→        price_id: str,
    91→        success_url: str,
    92→        cancel_url: str,
    93→        customer_id: Optional[str] = None
    94→    ) -> Optional[CheckoutSession]:
    95→        """创建 Checkout Session"""
    96→        if not self.stripe:
    97→            return None
    98→
    99→        try:
   100→            session_params = {
   101→                "mode": "subscription",
   102→                "payment_method_types": ["card", "alipay", "wechat_pay"],
   103→                "line_items": [{"price": price_id, "quantity": 1}],
   104→                "success_url": success_url,
   105→                "cancel_url": cancel_url,
   106→                "metadata": {"user_id": user_id},
   107→                "payment_method_options": {
   108→                    "wechat_pay": {"client": "web"}
   109→                }
   110→            }
   111→
   112→            if customer_id:
   113→                session_params["customer"] = customer_id
   114→
   115→            session = self.stripe.checkout.Session.create(**session_params)
   116→
   117→            return CheckoutSession(
   118→                session_id=session.id,
   119→                url=session.url,
   120→                status=session.status,
   121→                customer_id=session.customer,
   122→                subscription_id=session.subscription
   123→            )
   124→        except Exception as e:
   125→            logger.error(f"Failed to create checkout session: {e}")
   126→            return None
   127→
   128→    async def create_billing_portal_session(
   129→        self,
   130→        customer_id: str,
   131→        return_url: str
   132→    ) -> Optional[str]:
   133→        """创建账单门户 Session（用于管理订阅）"""
   134→        if not self.stripe:
   135→            return None
   136→
   137→        try:
   138→            session = self.stripe.billing_portal.Session.create(
   139→                customer=customer_id,
   140→                return_url=return_url
   141→            )
   142→            return session.url
   143→        except Exception as e:
   144→            logger.error(f"Failed to create billing portal session: {e}")
   145→            return None
   146→
   147→    async def get_subscription(self, subscription_id: str) -> Optional[dict]:
   148→        """获取订阅信息"""
   149→        if not self.stripe:
   150→            return None
   151→
   152→        try:
   153→            subscription = self.stripe.Subscription.retrieve(subscription_id)
   154→            return {
   155→                "id": subscription.id,
   156→                "status": subscription.status,
   157→                "current_period_start": datetime.fromtimestamp(subscription.current_period_start),
   158→                "current_period_end": datetime.fromtimestamp(subscription.current_period_end),
   159→                "cancel_at_period_end": subscription.cancel_at_period_end,
   160→                "canceled_at": datetime.fromtimestamp(subscription.canceled_at) if subscription.canceled_at else None,
   161→                "plan": {
   162→                    "id": subscription.items.data[0].price.id,
   163→                    "product": subscription.items.data[0].price.product,
   164→                    "amount": subscription.items.data[0].price.unit_amount,
   165→                    "currency": subscription.items.data[0].price.currency,
   166→                    "interval": subscription.items.data[0].price.recurring.interval
   167→                }
   168→            }
   169→        except Exception as e:
   170→            logger.error(f"Failed to get subscription: {e}")
   171→            return None
   172→
   173→    async def cancel_subscription(
   174→        self,
   175→        subscription_id: str,
   176→        cancel_immediately: bool = False
   177→    ) -> bool:
   178→        """取消订阅"""
   179→        if not self.stripe:
   180→            return False
   181→
   182→        try:
   183→            if cancel_immediately:
   184→                self.stripe.Subscription.delete(subscription_id)
   185→            else:
   186→                self.stripe.Subscription.modify(
   187→                    subscription_id,
   188→                    cancel_at_period_end=True
   189→                )
   190→            return True
   191→        except Exception as e:
   192→            logger.error(f"Failed to cancel subscription: {e}")
   193→            return False
   194→
   195→    async def reactivate_subscription(self, subscription_id: str) -> bool:
   196→        """重新激活订阅（取消"周期结束后取消"）"""
   197→        if not self.stripe:
   198→            return False
   199→
   200→        try:
   201→            self.stripe.Subscription.modify(
   202→                subscription_id,
   203→                cancel_at_period_end=False
   204→            )
   205→            return True
   206→        except Exception as e:
   207→            logger.error(f"Failed to reactivate subscription: {e}")
   208→            return False
   209→
   210→    def verify_webhook_signature(
   211→        self,
   212→        payload: bytes,
   213→        signature: str
   214→    ) -> Optional[dict]:
   215→        """验证 Webhook 签名"""
   216→        if not self.stripe:
   217→            return None
   218→
   219→        try:
   220→            event = self.stripe.Webhook.construct_event(
   221→                payload,
   222→                signature,
   223→                STRIPE_WEBHOOK_SECRET
   224→            )
   225→            return {
   226→                "type": event.type,
   227→                "data": event.data.object
   228→            }
   229→        except Exception as e:
   230→            logger.error(f"Webhook signature verification failed: {e}")
   231→            return None
   232→
   233→    async def get_product_prices(self, product_id: str) -> list[dict]:
   234→        """获取产品的所有价格"""
   235→        if not self.stripe:
   236→            return []
   237→
   238→        try:
   239→            prices = self.stripe.Price.list(product=product_id, active=True)
   240→            return [
   241→                {
   242→                    "id": price.id,
   243→                    "amount": price.unit_amount,
   244→                    "currency": price.currency,
   245→                    "interval": price.recurring.interval if price.recurring else None,
   246→                    "interval_count": price.recurring.interval_count if price.recurring else None
   247→                }
   248→                for price in prices.data
   249→            ]
   250→        except Exception as e:
   251→            logger.error(f"Failed to get product prices: {e}")
   252→            return []
   253→
   254→
   255→# Stripe Price IDs - 从环境变量读取，支持不同环境配置
   256→def get_stripe_price_ids() -> dict:
   257→    """Get Stripe Price IDs from environment variables"""
   258→    return {
   259→        # 八字单站订阅
   260→        "bazi_monthly": os.getenv("STRIPE_PRICE_BAZI_MONTHLY", ""),
   261→        "bazi_yearly": os.getenv("STRIPE_PRICE_BAZI_YEARLY", ""),
   262→
   263→        # 星座单站订阅
   264→        "zodiac_monthly": os.getenv("STRIPE_PRICE_ZODIAC_MONTHLY", ""),
   265→        "zodiac_yearly": os.getenv("STRIPE_PRICE_ZODIAC_YEARLY", ""),
   266→
   267→        # MBTI 单站订阅
   268→        "mbti_monthly": os.getenv("STRIPE_PRICE_MBTI_MONTHLY", ""),
   269→        "mbti_yearly": os.getenv("STRIPE_PRICE_MBTI_YEARLY", ""),
   270→
   271→        # VibeLife 全站订阅
   272→        "vibelife_all_monthly": os.getenv("STRIPE_PRICE_VIBELIFE_MONTHLY", ""),
   273→        "vibelife_all_yearly": os.getenv("STRIPE_PRICE_VIBELIFE_YEARLY", ""),
   274→    }
   275→
   276→# Backward compatibility alias
   277→STRIPE_PRICE_IDS = get_stripe_price_ids()
   278→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
