     1→"""
     2→Authentication Service & Dependencies
     3→"""
     4→from typing import Optional
     5→from uuid import UUID
     6→
     7→from fastapi import Depends, HTTPException, status
     8→from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
     9→
    10→from .jwt import JWTService
    11→from stores.user_repo import UserRepository
    12→
    13→
    14→# ─────────────────────────────────────────────────────────────────
    15→# Security scheme
    16→# ─────────────────────────────────────────────────────────────────
    17→
    18→bearer_scheme = HTTPBearer(auto_error=False)
    19→
    20→
    21→# ─────────────────────────────────────────────────────────────────
    22→# Current User Data Class
    23→# ─────────────────────────────────────────────────────────────────
    24→
    25→class CurrentUser:
    26→    """Current authenticated user"""
    27→
    28→    def __init__(
    29→        self,
    30→        user_id: UUID,
    31→        vibe_id: str,
    32→        display_name: Optional[str] = None,
    33→        email: Optional[str] = None
    34→    ):
    35→        self.user_id = user_id
    36→        self.vibe_id = vibe_id
    37→        self.display_name = display_name
    38→        self.email = email
    39→
    40→    def __repr__(self):
    41→        return f"<CurrentUser {self.vibe_id}>"
    42→
    43→
    44→# ─────────────────────────────────────────────────────────────────
    45→# Auth Dependencies
    46→# ─────────────────────────────────────────────────────────────────
    47→
    48→async def get_current_user(
    49→    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme)
    50→) -> CurrentUser:
    51→    """
    52→    Get current authenticated user.
    53→    Raises 401 if not authenticated.
    54→    """
    55→    if not credentials:
    56→        raise HTTPException(
    57→            status_code=status.HTTP_401_UNAUTHORIZED,
    58→            detail="Not authenticated",
    59→            headers={"WWW-Authenticate": "Bearer"},
    60→        )
    61→
    62→    token = credentials.credentials
    63→    payload = JWTService.verify_access_token(token)
    64→
    65→    if not payload:
    66→        raise HTTPException(
    67→            status_code=status.HTTP_401_UNAUTHORIZED,
    68→            detail="Invalid or expired token",
    69→            headers={"WWW-Authenticate": "Bearer"},
    70→        )
    71→
    72→    user_id = payload.get("sub")
    73→    vibe_id = payload.get("vibe_id")
    74→
    75→    if not user_id or not vibe_id:
    76→        raise HTTPException(
    77→            status_code=status.HTTP_401_UNAUTHORIZED,
    78→            detail="Invalid token payload",
    79→            headers={"WWW-Authenticate": "Bearer"},
    80→        )
    81→
    82→    # Optionally verify user still exists
    83→    user = await UserRepository.get_by_id(UUID(user_id))
    84→    if not user or user.get("status") != "active":
    85→        raise HTTPException(
    86→            status_code=status.HTTP_401_UNAUTHORIZED,
    87→            detail="User not found or inactive",
    88→            headers={"WWW-Authenticate": "Bearer"},
    89→        )
    90→
    91→    return CurrentUser(
    92→        user_id=UUID(user_id),
    93→        vibe_id=vibe_id,
    94→        display_name=user.get("display_name")
    95→    )
    96→
    97→
    98→async def get_optional_user(
    99→    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme)
   100→) -> Optional[CurrentUser]:
   101→    """
   102→    Get current user if authenticated, None otherwise.
   103→    Does not raise error if not authenticated.
   104→    """
   105→    if not credentials:
   106→        return None
   107→
   108→    token = credentials.credentials
   109→    payload = JWTService.verify_access_token(token)
   110→
   111→    if not payload:
   112→        return None
   113→
   114→    user_id = payload.get("sub")
   115→    vibe_id = payload.get("vibe_id")
   116→
   117→    if not user_id or not vibe_id:
   118→        return None
   119→
   120→    return CurrentUser(
   121→        user_id=UUID(user_id),
   122→        vibe_id=vibe_id
   123→    )
   124→
   125→
   126→# ─────────────────────────────────────────────────────────────────
   127→# Auth Service Class
   128→# ─────────────────────────────────────────────────────────────────
   129→
   130→class AuthService:
   131→    """Authentication service"""
   132→
   133→    @staticmethod
   134→    async def register(
   135→        email: Optional[str] = None,
   136→        phone: Optional[str] = None,
   137→        password: str = None,
   138→        display_name: Optional[str] = None,
   139→        birth_datetime=None,
   140→        birth_location: Optional[str] = None
   141→    ) -> dict:
   142→        """Register a new user"""
   143→        if not email and not phone:
   144→            raise ValueError("Email or phone is required")
   145→
   146→        if not password:
   147→            raise ValueError("Password is required")
   148→
   149→        # Check if identifier already exists
   150→        auth_type = "email" if email else "phone"
   151→        auth_identifier = email if email else phone
   152→
   153→        existing = await UserRepository.get_auth_by_identifier(auth_type, auth_identifier)
   154→        if existing:
   155→            raise ValueError(f"{auth_type.capitalize()} already registered")
   156→
   157→        # Create user
   158→        user = await UserRepository.create(
   159→            display_name=display_name or (email.split("@")[0] if email else phone[-4:]),
   160→            birth_datetime=birth_datetime,
   161→            birth_location=birth_location
   162→        )
   163→
   164→        # Create auth
   165→        await UserRepository.create_auth(
   166→            user_id=user["id"],
   167→            auth_type=auth_type,
   168→            auth_identifier=auth_identifier,
   169→            auth_credential=password  # Will be hashed in repo
   170→        )
   171→
   172→        # Generate tokens
   173→        access_token = JWTService.create_access_token(
   174→            str(user["id"]), user["vibe_id"]
   175→        )
   176→        refresh_token = JWTService.create_refresh_token(
   177→            str(user["id"]), user["vibe_id"]
   178→        )
   179→
   180→        return {
   181→            "access_token": access_token,
   182→            "refresh_token": refresh_token,
   183→            "token_type": "bearer",
   184→            "expires_in": JWTService.get_token_expiry(),
   185→            "user": {
   186→                "user_id": str(user["id"]),
   187→                "vibe_id": user["vibe_id"],
   188→                "display_name": user["display_name"]
   189→            }
   190→        }
   191→
   192→    @staticmethod
   193→    async def login(
   194→        email: Optional[str] = None,
   195→        phone: Optional[str] = None,
   196→        password: str = None
   197→    ) -> dict:
   198→        """Login user"""
   199→        if not email and not phone:
   200→            raise ValueError("Email or phone is required")
   201→
   202→        auth_type = "email" if email else "phone"
   203→        auth_identifier = email if email else phone
   204→
   205→        # Verify credentials
   206→        user = await UserRepository.verify_auth(auth_type, auth_identifier, password)
   207→
   208→        if not user:
   209→            raise ValueError("Invalid credentials")
   210→
   211→        if user.get("status") != "active":
   212→            raise ValueError("Account is not active")
   213→
   214→        # Generate tokens
   215→        access_token = JWTService.create_access_token(
   216→            str(user["id"]), user["vibe_id"]
   217→        )
   218→        refresh_token = JWTService.create_refresh_token(
   219→            str(user["id"]), user["vibe_id"]
   220→        )
   221→
   222→        return {
   223→            "access_token": access_token,
   224→            "refresh_token": refresh_token,
   225→            "token_type": "bearer",
   226→            "expires_in": JWTService.get_token_expiry(),
   227→            "user": {
   228→                "user_id": str(user["id"]),
   229→                "vibe_id": user["vibe_id"],
   230→                "display_name": user["display_name"]
   231→            }
   232→        }
   233→
   234→    @staticmethod
   235→    async def refresh_token(refresh_token: str) -> dict:
   236→        """Refresh access token"""
   237→        payload = JWTService.verify_refresh_token(refresh_token)
   238→
   239→        if not payload:
   240→            raise ValueError("Invalid or expired refresh token")
   241→
   242→        user_id = payload.get("sub")
   243→        vibe_id = payload.get("vibe_id")
   244→
   245→        # Verify user
   246→        user = await UserRepository.get_by_id(UUID(user_id))
   247→        if not user or user.get("status") != "active":
   248→            raise ValueError("User not found or inactive")
   249→
   250→        # Generate new tokens
   251→        new_access_token = JWTService.create_access_token(user_id, vibe_id)
   252→        new_refresh_token = JWTService.create_refresh_token(user_id, vibe_id)
   253→
   254→        return {
   255→            "access_token": new_access_token,
   256→            "refresh_token": new_refresh_token,
   257→            "token_type": "bearer",
   258→            "expires_in": JWTService.get_token_expiry(),
   259→            "user": {
   260→                "user_id": str(user["id"]),
   261→                "vibe_id": user["vibe_id"],
   262→                "display_name": user["display_name"]
   263→            }
   264→        }
   265→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
