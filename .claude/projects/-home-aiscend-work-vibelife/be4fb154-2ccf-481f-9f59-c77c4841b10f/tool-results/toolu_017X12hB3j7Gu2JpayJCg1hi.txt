     1→"""
     2→Validators v2.0 - 数据验证与跨技能契约校验
     3→
     4→v2.0 更新：
     5→- 新增 Provider/Consumer 契约校验
     6→- imports ⊆ exports 验证
     7→- 版本兼容性检查
     8→- 循环依赖检测
     9→"""
    10→import re
    11→import logging
    12→from typing import Dict, Any, Tuple, List, Optional, Set
    13→from dataclasses import dataclass, field
    14→
    15→logger = logging.getLogger(__name__)
    16→
    17→
    18→# LLM-FIRST: 路径白名单（统一 save/read）
    19→SAVE_PATH_WHITELIST = [
    20→    r"^identity\.birth_info$",
    21→    r"^state\.[A-Za-z0-9_\.]+$",
    22→    r"^preferences\.[A-Za-z0-9_\.]+$",
    23→    r"^skills\.[A-Za-z0-9_]+(\.[A-Za-z0-9_\.]+)*$",
    24→    r"^goals(\.[A-Za-z0-9_\.]+)*$",
    25→]
    26→
    27→
    28→def validate_save_path(path: str) -> bool:
    29→    return any(re.match(p, path) for p in SAVE_PATH_WHITELIST)
    30→
    31→
    32→def validate_show_args(args: Dict[str, Any]) -> Tuple[bool, str]:
    33→    show_type = args.get("type")
    34→    if show_type not in {"skill_list", "recommendation", "card", "insight"}:
    35→        return False, "show.type 必须是 skill_list|recommendation|card|insight"
    36→    if show_type == "card" and not args.get("card_type"):
    37→        return False, "type=card 时必须提供 card_type"
    38→    if show_type == "recommendation":
    39→        data = args.get("data", {})
    40→        if not isinstance(data, dict) or not data.get("skill_id"):
    41→            return False, "recommendation 需要 data.skill_id"
    42→    return True, ""
    43→
    44→
    45→def validate_remind_args(args: Dict[str, Any]) -> Tuple[bool, str]:
    46→    action = args.get("action")
    47→    if action not in {"set", "list", "cancel"}:
    48→        return False, "remind.action 必须是 set|list|cancel"
    49→    if action == "set":
    50→        if not args.get("title"):
    51→            return False, "创建提醒需要 title"
    52→        if not args.get("schedule"):
    53→            return False, "创建提醒需要 schedule"
    54→        st = args.get("schedule_type", "daily")
    55→        if st not in {"once", "daily", "weekly"}:
    56→            return False, "schedule_type 必须是 once|daily|weekly"
    57→    if action == "cancel" and not args.get("id"):
    58→        return False, "取消提醒需要 id"
    59→    return True, ""
    60→
    61→
    62→# ═══════════════════════════════════════════════════════════════════════════
    63→# 跨技能契约校验 (v2.0)
    64→# ═══════════════════════════════════════════════════════════════════════════
    65→
    66→@dataclass
    67→class ContractValidationError:
    68→    """契约校验错误"""
    69→    consumer_id: str
    70→    error_type: str  # tool_not_exported | provider_not_found | version_mismatch | cycle_detected
    71→    message: str
    72→    provider_id: Optional[str] = None
    73→    tool_name: Optional[str] = None
    74→
    75→
    76→@dataclass
    77→class ContractValidationResult:
    78→    """契约校验结果"""
    79→    valid: bool
    80→    errors: List[ContractValidationError] = field(default_factory=list)
    81→    warnings: List[str] = field(default_factory=list)
    82→
    83→    def add_error(self, error: ContractValidationError):
    84→        self.errors.append(error)
    85→        self.valid = False
    86→
    87→    def add_warning(self, warning: str):
    88→        self.warnings.append(warning)
    89→
    90→
    91→def compare_versions(v1: str, v2: str) -> int:
    92→    """比较语义化版本
    93→
    94→    Returns:
    95→        -1 if v1 < v2, 0 if v1 == v2, 1 if v1 > v2
    96→        -1 if versions are invalid (fail-safe: treat as incompatible)
    97→    """
    98→    def parse_version(v: str) -> Tuple[int, int, int]:
    99→        parts = v.split(".")
   100→        major = int(parts[0]) if len(parts) > 0 else 0
   101→        minor = int(parts[1]) if len(parts) > 1 else 0
   102→        patch = int(parts[2]) if len(parts) > 2 else 0
   103→        return (major, minor, patch)
   104→
   105→    try:
   106→        v1_parts = parse_version(v1)
   107→        v2_parts = parse_version(v2)
   108→
   109→        if v1_parts < v2_parts:
   110→            return -1
   111→        elif v1_parts > v2_parts:
   112→            return 1
   113→        return 0
   114→    except (ValueError, IndexError) as e:
   115→        logger.warning(f"Invalid version format: v1={v1}, v2={v2}: {e}")
   116→        return -1  # Fail-safe: treat invalid versions as incompatible
   117→
   118→
   119→def _build_dependency_graph(contracts: Dict[str, Any]) -> Dict[str, Set[str]]:
   120→    """构建依赖图
   121→
   122→    Args:
   123→        contracts: {skill_id: SkillContract}
   124→
   125→    Returns:
   126→        {skill_id: {dependent_skill_ids}}
   127→    """
   128→    graph: Dict[str, Set[str]] = {}
   129→
   130→    for skill_id, contract in contracts.items():
   131→        if skill_id not in graph:
   132→            graph[skill_id] = set()
   133→
   134→        # 添加 imports 依赖
   135→        for imp in contract.imports:
   136→            graph[skill_id].add(imp.from_skill)
   137→
   138→    return graph
   139→
   140→
   141→def _detect_cycle(graph: Dict[str, Set[str]]) -> Optional[List[str]]:
   142→    """检测循环依赖
   143→
   144→    Args:
   145→        graph: 依赖图 {skill_id: {dependent_skill_ids}}
   146→
   147→    Returns:
   148→        循环路径列表，如果没有循环则返回 None
   149→    """
   150→    WHITE, GRAY, BLACK = 0, 1, 2
   151→    color: Dict[str, int] = {node: WHITE for node in graph}
   152→    parent: Dict[str, Optional[str]] = {node: None for node in graph}
   153→
   154→    def dfs(node: str) -> Optional[List[str]]:
   155→        color[node] = GRAY
   156→
   157→        for neighbor in graph.get(node, set()):
   158→            if neighbor not in color:
   159→                # 未知节点（可能是未加载的 skill），跳过
   160→                continue
   161→
   162→            if color[neighbor] == GRAY:
   163→                # 找到循环，回溯路径
   164→                cycle = [neighbor, node]
   165→                current = node
   166→                while parent[current] and parent[current] != neighbor:
   167→                    cycle.append(parent[current])
   168→                    current = parent[current]
   169→                cycle.reverse()
   170→                return cycle
   171→
   172→            if color[neighbor] == WHITE:
   173→                parent[neighbor] = node
   174→                result = dfs(neighbor)
   175→                if result:
   176→                    return result
   177→
   178→        color[node] = BLACK
   179→        return None
   180→
   181→    for node in graph:
   182→        if color[node] == WHITE:
   183→            result = dfs(node)
   184→            if result:
   185→                return result
   186→
   187→    return None
   188→
   189→
   190→def validate_skill_contracts(contracts: Dict[str, Any]) -> ContractValidationResult:
   191→    """校验所有 Skill 的 imports/exports 契约
   192→
   193→    校验内容：
   194→    1. Provider 是否存在
   195→    2. 工具是否在 Provider 的 exports 中
   196→    3. 版本兼容性
   197→    4. 循环依赖检测
   198→
   199→    Args:
   200→        contracts: {skill_id: SkillContract}
   201→
   202→    Returns:
   203→        ContractValidationResult
   204→    """
   205→    result = ContractValidationResult(valid=True)
   206→
   207→    for consumer_id, consumer_contract in contracts.items():
   208→        for imp in consumer_contract.imports:
   209→            provider_id = imp.from_skill
   210→
   211→            # 1. Provider 是否存在
   212→            if provider_id not in contracts:
   213→                result.add_error(ContractValidationError(
   214→                    consumer_id=consumer_id,
   215→                    error_type="provider_not_found",
   216→                    message=f"{consumer_id}: 引用的 {provider_id} 不存在",
   217→                    provider_id=provider_id,
   218→                ))
   219→                continue
   220→
   221→            provider_contract = contracts[provider_id]
   222→
   223→            # 2. Provider 是否有 exports
   224→            if not provider_contract.exports:
   225→                result.add_warning(
   226→                    f"{consumer_id}: {provider_id} 没有 exports 声明，跳过工具校验（兼容期）"
   227→                )
   228→                continue
   229→
   230→            # 3. 工具是否在 exports 中
   231→            for tool_name in imp.tools:
   232→                if not provider_contract.exports.has_tool(tool_name):
   233→                    result.add_error(ContractValidationError(
   234→                        consumer_id=consumer_id,
   235→                        error_type="tool_not_exported",
   236→                        message=f"{consumer_id}: {tool_name} 未在 {provider_id}.exports.tools 中",
   237→                        provider_id=provider_id,
   238→                        tool_name=tool_name,
   239→                    ))
   240→
   241→            # 4. 版本兼容性
   242→            if imp.min_version and provider_contract.exports.api_version:
   243→                if compare_versions(provider_contract.exports.api_version, imp.min_version) < 0:
   244→                    result.add_error(ContractValidationError(
   245→                        consumer_id=consumer_id,
   246→                        error_type="version_mismatch",
   247→                        message=f"{consumer_id}: 要求 {provider_id} >= {imp.min_version}，实际 {provider_contract.exports.api_version}",
   248→                        provider_id=provider_id,
   249→                    ))
   250→
   251→    # 6. Provider 导出工具 Schema 完整性校验（Schema 必填 + 结构基本正确）
   252→    for provider_id, provider_contract in contracts.items():
   253→        if not provider_contract.exports:
   254→            continue
   255→        for exported in provider_contract.exports.tools:
   256→            # 必须提供 input_schema 与 output_schema
   257→            if exported.input_schema is None or exported.output_schema is None:
   258→                result.add_error(ContractValidationError(
   259→                    consumer_id=provider_id,
   260→                    error_type="schema_missing",
   261→                    message=f"{provider_id}: 导出工具 {exported.name} 必须提供 input_schema 与 output_schema",
   262→                    provider_id=provider_id,
   263→                    tool_name=exported.name,
   264→                ))
   265→                continue
   266→            # 结构基本校验
   267→            for which, schema in (("input_schema", exported.input_schema), ("output_schema", exported.output_schema)):
   268→                if getattr(schema, 'type', 'object') != 'object':
   269→                    result.add_error(ContractValidationError(
   270→                        consumer_id=provider_id,
   271→                        error_type="schema_invalid",
   272→                        message=f"{provider_id}: {exported.name}.{which}.type 必须为 'object'",
   273→                        provider_id=provider_id,
   274→                        tool_name=exported.name,
   275→                    ))
   276→                if not isinstance(getattr(schema, 'properties', {}), dict):
   277→                    result.add_error(ContractValidationError(
   278→                        consumer_id=provider_id,
   279→                        error_type="schema_invalid",
   280→                        message=f"{provider_id}: {exported.name}.{which}.properties 必须为对象",
   281→                        provider_id=provider_id,
   282→                        tool_name=exported.name,
   283→                    ))
   284→
   285→    # 5. 循环依赖检测
   286→    graph = _build_dependency_graph(contracts)
   287→    cycle = _detect_cycle(graph)
   288→    if cycle:
   289→        result.add_error(ContractValidationError(
   290→            consumer_id=cycle[0],
   291→            error_type="cycle_detected",
   292→            message=f"检测到循环依赖: {' -> '.join(cycle)}",
   293→        ))
   294→
   295→    return result
   296→
   297→
   298→def validate_cross_skill_tool_access(
   299→    consumer_skill_id: str,
   300→    provider_skill_id: str,
   301→    tool_name: str,
   302→    consumer_contract: Any,
   303→    provider_contract: Any,
   304→) -> Tuple[bool, str]:
   305→    """运行时校验跨技能工具访问
   306→
   307→    Args:
   308→        consumer_skill_id: 调用方 Skill ID
   309→        provider_skill_id: 被调用方 Skill ID
   310→        tool_name: 工具名
   311→        consumer_contract: 调用方契约
   312→        provider_contract: 被调用方契约
   313→
   314→    Returns:
   315→        (是否允许, 错误信息)
   316→    """
   317→    # 1. 检查 consumer 是否声明了 import
   318→    imp = consumer_contract.imports_from(provider_skill_id)
   319→    if not imp:
   320→        return False, f"{tool_name} 未在 {consumer_skill_id} 的 imports 中声明"
   321→
   322→    if tool_name not in imp.tools:
   323→        return False, f"{tool_name} 未在 {consumer_skill_id}.imports[{provider_skill_id}].tools 中"
   324→
   325→    # 2. 检查 provider 是否导出了该工具
   326→    if provider_contract.exports and not provider_contract.exports.has_tool(tool_name):
   327→        return False, f"{tool_name} 未在 {provider_skill_id}.exports.tools 中"
   328→
   329→    return True, ""
   330→
   331→
   332→def is_tool_imported(
   333→    consumer_skill_id: str,
   334→    provider_skill_id: str,
   335→    tool_name: str,
   336→    contracts: Dict[str, Any],
   337→) -> bool:
   338→    """检查工具是否被正确导入
   339→
   340→    Args:
   341→        consumer_skill_id: 调用方 Skill ID
   342→        provider_skill_id: 被调用方 Skill ID
   343→        tool_name: 工具名
   344→        contracts: 所有契约 {skill_id: SkillContract}
   345→
   346→    Returns:
   347→        是否允许访问
   348→    """
   349→    consumer_contract = contracts.get(consumer_skill_id)
   350→    if not consumer_contract:
   351→        return False
   352→
   353→    imp = consumer_contract.imports_from(provider_skill_id)
   354→    if not imp:
   355→        return False
   356→
   357→    return tool_name in imp.tools
   358→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
