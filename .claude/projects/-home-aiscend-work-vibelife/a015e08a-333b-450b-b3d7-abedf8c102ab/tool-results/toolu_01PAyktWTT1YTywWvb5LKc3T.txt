  1450→        result = []
  1451→        for path in paths.keys():
  1452→            if path_prefix and not path.startswith(path_prefix):
  1453→                continue
  1454→            result.append(path)
  1455→
  1456→        result.sort()
  1457→        return result
  1458→
  1459→    # ═══════════════════════════════════════════════════════════════════════════
  1460→    # Skill 状态管理 - REFACTOR_PLAN.md Phase 1
  1461→    # ═══════════════════════════════════════════════════════════════════════════
  1462→
  1463→    @staticmethod
  1464→    async def get_skill_state(user_id: UUID, skill_id: str) -> Dict[str, Any]:
  1465→        """
  1466→        获取 Skill 状态
  1467→
  1468→        按照 REFACTOR_PLAN.md，所有 Skill 数据统一存储在 profile.skills.{skill_id}
  1469→
  1470→        Returns:
  1471→            skill 状态数据，如果不存在则返回空字典
  1472→        """
  1473→        profile = await UnifiedProfileRepository.get_profile(user_id)
  1474→        if not profile:
  1475→            return {}
  1476→        return profile.get("skills", {}).get(skill_id, {})
  1477→
  1478→    @staticmethod
  1479→    async def update_skill_state(
  1480→        user_id: UUID,
  1481→        skill_id: str,
  1482→        section: str,
  1483→        data: Dict[str, Any]
  1484→    ) -> None:
  1485→        """
  1486→        更新 Skill 状态（深度合并）
  1487→
  1488→        使用 PostgreSQL || 操作符进行深度合并，不会覆盖未指定的字段
  1489→
  1490→        Args:
  1491→            user_id: 用户 ID
  1492→            skill_id: Skill ID
  1493→            section: 要更新的部分，如 "north_star"、"protocol"
  1494→            data: 要写入的数据
  1495→        """
  1496→        exists = await fetchval(
  1497→            "SELECT 1 FROM unified_profiles WHERE user_id = $1",
  1498→            user_id
  1499→        )
  1500→
  1501→        if exists:
  1502→            # 使用 jsonb_set + || 进行深度合并
  1503→            await execute(
  1504→                """UPDATE unified_profiles
  1505→                   SET profile = jsonb_set(
  1506→                       jsonb_set(
  1507→                           jsonb_set(
  1508→                               COALESCE(profile, '{}'::jsonb),
  1509→                               '{skills}',
  1510→                               COALESCE(profile -> 'skills', '{}'::jsonb)
  1511→                           ),
  1512→                           ARRAY['skills', $2::text],
  1513→                           COALESCE(profile -> 'skills' -> $2::text, '{}'::jsonb)
  1514→                       ),
  1515→                       ARRAY['skills', $2::text, $3::text],
  1516→                       COALESCE(profile -> 'skills' -> $2::text -> $3::text, '{}'::jsonb) || $4::jsonb
  1517→                   ),
  1518→                   updated_at = NOW()
  1519→                   WHERE user_id = $1""",
  1520→                user_id, skill_id, section, json.dumps(data, ensure_ascii=False, default=str)
  1521→            )
  1522→        else:
  1523→            # 创建新 profile
  1524→            await UnifiedProfileRepository.create_profile(
  1525→                user_id,
  1526→                {"skills": {skill_id: {section: data}}}
  1527→            )
  1528→
  1529→        # 失效缓存
  1530→        await UnifiedProfileRepository._invalidate_cache(user_id, skill_id)
  1531→
  1532→    @staticmethod
  1533→    async def append_to_skill_list(
  1534→        user_id: UUID,
  1535→        skill_id: str,
  1536→        path: str,
  1537→        entry: Dict[str, Any],
  1538→        max_items: int = 100
  1539→    ) -> None:
  1540→        """
  1541→        向 Skill 数据中的列表追加条目
  1542→
  1543→        Args:
  1544→            user_id: 用户 ID
  1545→            skill_id: Skill ID
  1546→            path: 列表路径，如 "journal" 或 "progress.milestones"
  1547→            entry: 要追加的条目
  1548→            max_items: 列表最大长度（超出则删除最旧的）
  1549→        """
  1550→        # 获取当前数据
  1551→        skill_data = await UnifiedProfileRepository.get_skill_state(user_id, skill_id)
  1552→
  1553→        # 解析路径
  1554→        parts = path.split(".")
  1555→        current = skill_data
  1556→        for part in parts[:-1]:
  1557→            current = current.setdefault(part, {})
  1558→
  1559→        # 获取或创建列表
  1560→        list_key = parts[-1]
  1561→        current_list = current.get(list_key, [])
  1562→        if not isinstance(current_list, list):
  1563→            current_list = []
  1564→
  1565→        # 追加并限制长度（新条目在前）
  1566→        current_list = [entry] + current_list[:max_items - 1]
  1567→        current[list_key] = current_list
  1568→
  1569→        # 写回
  1570→        if len(parts) > 1:
  1571→            # 多级路径：更新父级对象
  1572→            await UnifiedProfileRepository.update_skill_state(
  1573→                user_id, skill_id, parts[0], skill_data.get(parts[0], {})
  1574→            )
  1575→        else:
  1576→            # 单级路径：直接更新
  1577→            await UnifiedProfileRepository.update_skill_state(
  1578→                user_id, skill_id, list_key, current_list
  1579→            )
  1580→
  1581→    # ═══════════════════════════════════════════════════════════════════════════
  1582→    # 缓存管理
  1583→    # ═══════════════════════════════════════════════════════════════════════════
  1584→
  1585→    @staticmethod
  1586→    async def _invalidate_cache(user_id: UUID, skill: str = None) -> None:
  1587→        """
  1588→        失效缓存
  1589→
  1590→        Args:
  1591→            user_id: 用户 ID
  1592→            skill: 如果指定，只失效该 skill 的缓存；否则失效所有缓存
  1593→        """
  1594→        try:
  1595→            from stores.profile_cache import get_profile_cache
  1596→            cache = get_profile_cache()
  1597→
  1598→            if skill:
  1599→                # 只失效特定 skill 的缓存
  1600→                await cache.invalidate_by_key(f"{user_id}:{skill}")
  1601→                # 也失效 all 缓存
  1602→                await cache.invalidate_by_key(f"{user_id}:all")
  1603→            else:
  1604→                # 失效该用户所有缓存
  1605→                await cache.invalidate_by_prefix(str(user_id))
  1606→
  1607→            logger.debug(f"缓存已失效: user_id={user_id}, skill={skill}")
  1608→        except Exception as e:
  1609→            logger.warning(f"缓存失效失败: {e}")
  1610→
  1611→
  1612→# ═══════════════════════════════════════════════════════════════════════════
  1613→# Cold Layer - Insights & Timeline (v8)
  1614→# ═══════════════════════════════════════════════════════════════════════════
  1615→
  1616→@dataclass
  1617→class ProfileInsight:
  1618→    """AI 生成的洞察"""
  1619→    id: UUID
  1620→    user_id: UUID
  1621→    insight_type: str  # discovery | pattern | timing | growth
  1622→    skill_id: Optional[str]
  1623→    content: str
  1624→    metadata: Dict[str, Any]
  1625→    created_at: datetime
  1626→
  1627→
  1628→@dataclass
  1629→class TimelineEvent:
  1630→    """时间线事件"""
  1631→    id: UUID
  1632→    user_id: UUID
  1633→    event_type: str  # dayun_change | goal_completed | milestone | life_event
  1634→    event_date: date
  1635→    title: str
  1636→    data: Dict[str, Any]
  1637→    skill_id: Optional[str]
  1638→    created_at: datetime
  1639→
  1640→
  1641→class ColdLayerRepository:
  1642→    """Cold Layer 数据仓库 - 存储长期洞察和时间线事件"""
  1643→
  1644→    @staticmethod
  1645→    async def add_insight(
  1646→        user_id: UUID,
  1647→        insight_type: str,
  1648→        content: str,
  1649→        skill_id: Optional[str] = None,
  1650→        metadata: Optional[Dict[str, Any]] = None
  1651→    ) -> ProfileInsight:
  1652→        """添加 AI 洞察"""
  1653→        from uuid import uuid4
  1654→        insight_id = uuid4()
  1655→
  1656→        await execute(
  1657→            """INSERT INTO vibe_profile_insights (id, user_id, insight_type, skill_id, content, metadata)
  1658→               VALUES ($1, $2, $3, $4, $5, $6::jsonb)""",
  1659→            insight_id, user_id, insight_type, skill_id, content,
  1660→            json.dumps(metadata or {}, ensure_ascii=False)
  1661→        )
  1662→
  1663→        return ProfileInsight(
  1664→            id=insight_id,
  1665→            user_id=user_id,
  1666→            insight_type=insight_type,
  1667→            skill_id=skill_id,
  1668→            content=content,
  1669→            metadata=metadata or {},
  1670→            created_at=datetime.now(timezone.utc)
  1671→        )
  1672→
  1673→    @staticmethod
  1674→    async def get_insights(
  1675→        user_id: UUID,
  1676→        insight_type: Optional[str] = None,
  1677→        skill_id: Optional[str] = None,
  1678→        limit: int = 20
  1679→    ) -> List[ProfileInsight]:
  1680→        """获取用户洞察"""
  1681→        conditions = ["user_id = $1"]
  1682→        params = [user_id]
  1683→        param_idx = 2
  1684→
  1685→        if insight_type:
  1686→            conditions.append(f"insight_type = ${param_idx}")
  1687→            params.append(insight_type)
  1688→            param_idx += 1
  1689→
  1690→        if skill_id:
  1691→            conditions.append(f"skill_id = ${param_idx}")
  1692→            params.append(skill_id)
  1693→            param_idx += 1
  1694→
  1695→        params.append(limit)
  1696→
  1697→        rows = await fetch(
  1698→            f"""SELECT id, user_id, insight_type, skill_id, content, metadata, created_at
  1699→               FROM vibe_profile_insights
  1700→               WHERE {' AND '.join(conditions)}
  1701→               ORDER BY created_at DESC
  1702→               LIMIT ${param_idx}""",
  1703→            *params
  1704→        )
  1705→
  1706→        return [
  1707→            ProfileInsight(
  1708→                id=row["id"],
  1709→                user_id=row["user_id"],
  1710→                insight_type=row["insight_type"],
  1711→                skill_id=row["skill_id"],
  1712→                content=row["content"],
  1713→                metadata=row["metadata"] if isinstance(row["metadata"], dict) else json.loads(row["metadata"] or "{}"),
  1714→                created_at=row["created_at"]
  1715→            )
  1716→            for row in rows
  1717→        ]
  1718→
  1719→    @staticmethod
  1720→    async def add_timeline_event(
  1721→        user_id: UUID,
  1722→        event_type: str,
  1723→        event_date: date,
  1724→        title: str,
  1725→        data: Optional[Dict[str, Any]] = None,
  1726→        skill_id: Optional[str] = None
  1727→    ) -> TimelineEvent:
  1728→        """添加时间线事件"""
  1729→        from uuid import uuid4
  1730→        event_id = uuid4()
  1731→
  1732→        await execute(
  1733→            """INSERT INTO vibe_profile_timeline (id, user_id, event_type, event_date, title, data, skill_id)
  1734→               VALUES ($1, $2, $3, $4, $5, $6::jsonb, $7)""",
  1735→            event_id, user_id, event_type, event_date, title,
  1736→            json.dumps(data or {}, ensure_ascii=False), skill_id
  1737→        )
  1738→
  1739→        return TimelineEvent(
  1740→            id=event_id,
  1741→            user_id=user_id,
  1742→            event_type=event_type,
  1743→            event_date=event_date,
  1744→            title=title,
  1745→            data=data or {},
  1746→            skill_id=skill_id,
  1747→            created_at=datetime.now(timezone.utc)
  1748→        )
  1749→
  1750→    @staticmethod
  1751→    async def get_timeline(
  1752→        user_id: UUID,
  1753→        event_type: Optional[str] = None,
  1754→        start_date: Optional[date] = None,
  1755→        end_date: Optional[date] = None,
  1756→        limit: int = 50
  1757→    ) -> List[TimelineEvent]:
  1758→        """获取时间线事件"""
  1759→        conditions = ["user_id = $1"]
  1760→        params = [user_id]
  1761→        param_idx = 2
  1762→
  1763→        if event_type:
  1764→            conditions.append(f"event_type = ${param_idx}")
  1765→            params.append(event_type)
  1766→            param_idx += 1
  1767→
  1768→        if start_date:
  1769→            conditions.append(f"event_date >= ${param_idx}")
  1770→            params.append(start_date)
  1771→            param_idx += 1
  1772→
  1773→        if end_date:
  1774→            conditions.append(f"event_date <= ${param_idx}")
  1775→            params.append(end_date)
  1776→            param_idx += 1
  1777→
  1778→        params.append(limit)
  1779→
  1780→        rows = await fetch(
  1781→            f"""SELECT id, user_id, event_type, event_date, title, data, skill_id, created_at
  1782→               FROM vibe_profile_timeline
  1783→               WHERE {' AND '.join(conditions)}
  1784→               ORDER BY event_date DESC
  1785→               LIMIT ${param_idx}""",
  1786→            *params
  1787→        )
  1788→
  1789→        return [
  1790→            TimelineEvent(
  1791→                id=row["id"],
  1792→                user_id=row["user_id"],
  1793→                event_type=row["event_type"],
  1794→                event_date=row["event_date"],
  1795→                title=row["title"],
  1796→                data=row["data"] if isinstance(row["data"], dict) else json.loads(row["data"] or "{}"),
  1797→                skill_id=row["skill_id"],
  1798→                created_at=row["created_at"]
  1799→            )
  1800→            for row in rows
  1801→        ]
  1802→
  1803→
  1804→# ═══════════════════════════════════════════════════════════════════════════
  1805→# 便捷函数 (兼容旧代码)
  1806→# ═══════════════════════════════════════════════════════════════════════════
  1807→
  1808→async def get_unified_profile(user_id: UUID) -> Optional[Dict[str, Any]]:
  1809→    """获取统一 Profile (便捷函数)"""
  1810→    return await UnifiedProfileRepository.get_profile(user_id)
  1811→
  1812→
  1813→async def get_unified_profile_with_skill(user_id: UUID, skill: str = None) -> Dict[str, Any]:
  1814→    """
  1815→    获取 Profile 和 Skill 数据 (兼容 profile_cache 接口)
  1816→
  1817→    Returns:
  1818→        {
  1819→            "profile": {...},
  1820→            "skill_data": {...}
  1821→        }
  1822→    """
  1823→    profile = await UnifiedProfileRepository.get_profile(user_id)
  1824→
  1825→    if profile:
  1826→        skill_data = profile.get("skill_data", {})
  1827→        return {
  1828→            "profile": profile,
  1829→            "skill_data": skill_data
  1830→        }
  1831→
  1832→    return {"profile": {}, "skill_data": {}}
  1833→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
