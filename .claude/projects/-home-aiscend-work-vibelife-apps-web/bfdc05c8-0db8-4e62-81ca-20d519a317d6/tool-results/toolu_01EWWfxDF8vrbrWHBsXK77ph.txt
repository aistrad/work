The file /home/aiscend/work/vibelife/apps/web/src/app/api/chat/route.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
    62→    // Create ReadableStream for AI SDK 6 Data Stream Protocol
    63→    const encoder = new TextEncoder();
    64→    const messageId = `msg-${Date.now()}`;
    65→
    66→    const stream = new ReadableStream({
    67→      async start(controller) {
    68→        const reader = response.body?.getReader();
    69→        const decoder = new TextDecoder();
    70→
    71→        if (!reader) {
    72→          controller.close();
    73→          return;
    74→        }
    75→
    76→        let buffer = '';
    77→        let hasStarted = false;
    78→
    79→        try {
    80→          while (true) {
    81→            const { done, value } = await reader.read();
    82→            if (done) break;
    83→
    84→            buffer += decoder.decode(value, { stream: true });
    85→            const lines = buffer.split('\n');
    86→            buffer = lines.pop() || '';
    87→
    88→            for (const line of lines) {
    89→              if (line.startsWith('data: ')) {
    90→                const dataStr = line.slice(6).trim();
    91→                if (!dataStr) continue;
    92→
    93→                try {
    94→                  const data = JSON.parse(dataStr);
    95→
    96→                  if (data.type === 'chunk') {
    97→                    // AI SDK 6 format: just send the text directly with 0: prefix
    98→                    // Format: 0:"text content"\n
    99→                    const textContent = JSON.stringify(data.content);
   100→                    controller.enqueue(encoder.encode(`0:${textContent}\n`));
   101→                    hasStarted = true;
   102→                  } else if (data.type === 'done') {
   103→                    // Send finish message with metadata
   104→                    // Format: d:{"finishReason":"stop","metadata":{...}}\n
   105→                    const finishData = {
   106→                      finishReason: 'stop',
   107→                      usage: { promptTokens: 0, completionTokens: 0 },
   108→                      ...(data.conversation_id && {
   109→                        metadata: {
   110→                          conversation_id: data.conversation_id,
   111→                          skill: data.skill,
   112→                          voice_mode: data.voice_mode,
   113→                        }
   114→                      })
   115→                    };
   116→                    controller.enqueue(encoder.encode(`d:${JSON.stringify(finishData)}\n`));
   117→                  } else if (data.type === 'error') {
   118→                    // Send error in AI SDK format
   119→                    // Format: 3:"error message"\n
   120→                    controller.enqueue(encoder.encode(`3:${JSON.stringify(data.message)}\n`));
   121→                  }
   122→                } catch {
   123→                  // Skip malformed JSON
   124→                }
   125→              }
   126→            }
   127→          }
   128→
   129→          // If we never started (no chunks received), send empty finish
   130→          if (!hasStarted) {
   131→            controller.enqueue(encoder.encode(`d:${JSON.stringify({ finishReason: 'stop' })}\n`));
   132→          }
   133→        } catch (error) {
   134→          // Send error in AI SDK format
   135→          const errorMsg = error instanceof Error ? error.message : 'Unknown error';
   136→          controller.enqueue(encoder.encode(`3:${JSON.stringify(errorMsg)}\n`));
   137→        } finally {
   138→          controller.close();
   139→        }
   140→      },
   141→    });
   142→
   143→    return new Response(stream, {
   144→      headers: {
   145→        'Content-Type': 'text/event-stream',