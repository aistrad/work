     1â†’"""
     2â†’Interview Service - Core interview logic
     3â†’Based on: vibelife spec v3.0, section 4.2
     4â†’
     5â†’Trigger Conditions:
     6â†’- User requests report generation
     7â†’- User info is incomplete (Profile score < threshold)
     8â†’- First-time user
     9â†’
    10â†’Required Questions (2-3):
    11â†’1. Current concerns/pain points
    12â†’2. Life status (career, relationship, etc.)
    13â†’3. Expectations and goals
    14â†’"""
    15â†’import json
    16â†’from typing import Optional, List, Dict, Any, Tuple
    17â†’from uuid import UUID, uuid4
    18â†’from datetime import datetime
    19â†’from dataclasses import dataclass, field, asdict
    20â†’from enum import Enum
    21â†’import logging
    22â†’
    23â†’from services.vibe_engine.llm import get_llm_service, create_user_message, LLMService
    24â†’
    25â†’logger = logging.getLogger(__name__)
    26â†’
    27â†’
    28â†’class InterviewState(str, Enum):
    29â†’    """Interview session states"""
    30â†’    NOT_STARTED = "not_started"
    31â†’    IN_PROGRESS = "in_progress"
    32â†’    COMPLETED = "completed"
    33â†’    SKIPPED = "skipped"
    34â†’
    35â†’
    36â†’@dataclass
    37â†’class InterviewQuestion:
    38â†’    """A single interview question"""
    39â†’    id: str
    40â†’    question_text: str
    41â†’    question_type: str  # core | followup | optional
    42â†’    answer: Optional[str] = None
    43â†’    extracted_info: Optional[Dict[str, Any]] = None
    44â†’    answered_at: Optional[datetime] = None
    45â†’
    46â†’
    47â†’@dataclass
    48â†’class InterviewSession:
    49â†’    """Complete interview session"""
    50â†’    id: UUID
    51â†’    user_id: Optional[UUID]
    52â†’    skill: str  # bazi | zodiac
    53â†’    state: InterviewState
    54â†’    questions: List[InterviewQuestion]
    55â†’    current_question_idx: int
    56â†’    created_at: datetime
    57â†’    completed_at: Optional[datetime] = None
    58â†’
    59â†’    def to_dict(self) -> dict:
    60â†’        return {
    61â†’            "id": str(self.id),
    62â†’            "user_id": str(self.user_id) if self.user_id else None,
    63â†’            "skill": self.skill,
    64â†’            "state": self.state.value,
    65â†’            "questions": [
    66â†’                {
    67â†’                    "id": q.id,
    68â†’                    "question_text": q.question_text,
    69â†’                    "question_type": q.question_type,
    70â†’                    "answer": q.answer,
    71â†’                    "extracted_info": q.extracted_info,
    72â†’                    "answered_at": q.answered_at.isoformat() if q.answered_at else None,
    73â†’                }
    74â†’                for q in self.questions
    75â†’            ],
    76â†’            "current_question_idx": self.current_question_idx,
    77â†’            "created_at": self.created_at.isoformat(),
    78â†’            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
    79â†’        }
    80â†’
    81â†’
    82â†’@dataclass
    83â†’class InterviewResult:
    84â†’    """Final interview extraction result"""
    85â†’    success: bool
    86â†’    extracted_profile: Dict[str, Any]
    87â†’    summary: str
    88â†’    questions_answered: int
    89â†’    total_questions: int
    90â†’
    91â†’
    92â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    93â†’# Core Questions (æŒ‰ spec 4.2)
    94â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    95â†’
    96â†’CORE_QUESTIONS = [
    97â†’    {
    98â†’        "id": "q1_concerns",
    99â†’        "question_text": "ä½ çŽ°åœ¨æœ€æƒ³è§£å†³çš„é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿæˆ–è€…ï¼Œæœ€å›°æ‰°ä½ çš„æ˜¯ä»€ä¹ˆï¼Ÿ",
   100â†’        "question_type": "core",
   101â†’        "extract_fields": ["current_concerns", "pain_points"],
   102â†’    },
   103â†’    {
   104â†’        "id": "q2_life_status",
   105â†’        "question_text": "ç®€å•è¯´è¯´ä½ çŽ°åœ¨çš„çŠ¶æ€ï¼Ÿå·¥ä½œã€æ„Ÿæƒ…ã€è¿˜æ˜¯å…¶ä»–æ–¹é¢ï¼Ÿ",
   106â†’        "question_type": "core",
   107â†’        "extract_fields": ["career_status", "relationship_status", "life_stage"],
   108â†’    },
   109â†’    {
   110â†’        "id": "q3_expectations",
   111â†’        "question_text": "ä½ å¸Œæœ›ä»Žè¿™æ¬¡åˆ†æžä¸­èŽ·å¾—ä»€ä¹ˆï¼Ÿ",
   112â†’        "question_type": "core",
   113â†’        "extract_fields": ["expectations", "goals"],
   114â†’    },
   115â†’]
   116â†’
   117â†’INTERVIEW_INTRO = """ðŸŒŸ åœ¨ç”Ÿæˆä½ çš„ä¸“å±žæŠ¥å‘Šä¹‹å‰...
   118â†’
   119â†’æˆ‘æƒ³æ›´äº†è§£ä½ ä¸€ç‚¹ã€‚è¿™æ ·æˆ‘æ‰èƒ½ç»™ä½ çœŸæ­£æœ‰ç”¨çš„åˆ†æžï¼Œè€Œä¸æ˜¯æ³›æ³›è€Œè°ˆã€‚
   120â†’
   121â†’å‡†å¤‡å¥½äº†å—ï¼Ÿåªéœ€è¦å›žç­” 2-3 ä¸ªé—®é¢˜ã€‚"""
   122â†’
   123â†’INTERVIEW_SKIP_WARNING = """è·³è¿‡è®¿è°ˆåŽï¼ŒæŠ¥å‘Šå¯èƒ½ä¸å¤Ÿç²¾å‡†ï¼Œåªèƒ½åŸºäºŽåŸºç¡€ä¿¡æ¯è¿›è¡Œåˆ†æžã€‚
   124â†’
   125â†’ç¡®å®šè¦è·³è¿‡å—ï¼Ÿ"""
   126â†’
   127â†’
   128â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   129â†’# Answer Extraction Prompt
   130â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   131â†’
   132â†’EXTRACT_ANSWER_PROMPT = """ä»Žç”¨æˆ·å›žç­”ä¸­æŠ½å–ç»“æž„åŒ–ä¿¡æ¯ã€‚
   133â†’
   134â†’é—®é¢˜: {question}
   135â†’ç”¨æˆ·å›žç­”: {answer}
   136â†’
   137â†’è¯·æå–ä»¥ä¸‹å­—æ®µï¼ˆå¦‚æžœèƒ½ä»Žå›žç­”ä¸­èŽ·å–ï¼‰ï¼š
   138â†’{extract_fields}
   139â†’
   140â†’## è¾“å‡ºæ ¼å¼ï¼ˆåªè¾“å‡º JSONï¼‰
   141â†’{{
   142â†’  "life_context": {{
   143â†’    "career": {{
   144â†’      "status": "employed | unemployed | student | freelance | null",
   145â†’      "industry": "è¡Œä¸š | null",
   146â†’      "concerns": ["å…³æ³¨ç‚¹1", "å…³æ³¨ç‚¹2"]
   147â†’    }},
   148â†’    "relationship": {{
   149â†’      "status": "single | in_relationship | married | divorced | null",
   150â†’      "concerns": ["å…³æ³¨ç‚¹1"]
   151â†’    }},
   152â†’    "current_focus": ["å½“å‰å…³æ³¨é¢†åŸŸ"],
   153â†’    "life_stage": "æè¿° | null"
   154â†’  }},
   155â†’  "ai_insights": {{
   156â†’    "current_concerns": ["å›°å¢ƒ1", "å›°å¢ƒ2"],
   157â†’    "pain_points": ["ç—›ç‚¹1"],
   158â†’    "expectations": ["æœŸæœ›1"],
   159â†’    "goals": ["ç›®æ ‡1"]
   160â†’  }}
   161â†’}}
   162â†’
   163â†’å¦‚æžœæŸä¸ªå­—æ®µæ— æ³•ä»Žå›žç­”ä¸­èŽ·å–ï¼Œè®¾ä¸º null æˆ–ç©ºæ•°ç»„ã€‚
   164â†’åªè¿”å›ž JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚"""
   165â†’
   166â†’
   167â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   168â†’# Interview Service
   169â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   170â†’
   171â†’class InterviewService:
   172â†’    """
   173â†’    AI Interview Service for collecting user context before report generation.
   174â†’
   175â†’    Features:
   176â†’    - Start/continue/skip interview sessions
   177â†’    - Extract structured info from answers
   178â†’    - Generate follow-up questions
   179â†’    - Merge results into user profile
   180â†’    """
   181â†’
   182â†’    def __init__(self, llm: Optional[LLMService] = None):
   183â†’        self.llm = llm or get_llm_service()
   184â†’        self._sessions: Dict[UUID, InterviewSession] = {}  # In-memory for now
   185â†’
   186â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   187â†’    # Session Management
   188â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   189â†’
   190â†’    def start_session(
   191â†’        self,
   192â†’        skill: str,
   193â†’        user_id: Optional[UUID] = None,
   194â†’        custom_questions: Optional[List[Dict]] = None
   195â†’    ) -> InterviewSession:
   196â†’        """
   197â†’        Start a new interview session.
   198â†’
   199â†’        Args:
   200â†’            skill: bazi or zodiac
   201â†’            user_id: Optional user ID
   202â†’            custom_questions: Override default questions
   203â†’
   204â†’        Returns:
   205â†’            New InterviewSession
   206â†’        """
   207â†’        session_id = uuid4()
   208â†’
   209â†’        # Build questions list
   210â†’        questions_data = custom_questions or CORE_QUESTIONS
   211â†’        questions = [
   212â†’            InterviewQuestion(
   213â†’                id=q["id"],
   214â†’                question_text=q["question_text"],
   215â†’                question_type=q.get("question_type", "core"),
   216â†’            )
   217â†’            for q in questions_data
   218â†’        ]
   219â†’
   220â†’        session = InterviewSession(
   221â†’            id=session_id,
   222â†’            user_id=user_id,
   223â†’            skill=skill,
   224â†’            state=InterviewState.IN_PROGRESS,
   225â†’            questions=questions,
   226â†’            current_question_idx=0,
   227â†’            created_at=datetime.utcnow(),
   228â†’        )
   229â†’
   230â†’        self._sessions[session_id] = session
   231â†’        return session
   232â†’
   233â†’    def get_session(self, session_id: UUID) -> Optional[InterviewSession]:
   234â†’        """Get an existing session"""
   235â†’        return self._sessions.get(session_id)
   236â†’
   237â†’    def get_intro(self) -> str:
   238â†’        """Get interview introduction message"""
   239â†’        return INTERVIEW_INTRO
   240â†’
   241â†’    def get_current_question(self, session: InterviewSession) -> Optional[InterviewQuestion]:
   242â†’        """Get the current question to ask"""
   243â†’        if session.state != InterviewState.IN_PROGRESS:
   244â†’            return None
   245â†’
   246â†’        if session.current_question_idx >= len(session.questions):
   247â†’            return None
   248â†’
   249â†’        return session.questions[session.current_question_idx]
   250â†’
   251â†’    def get_progress(self, session: InterviewSession) -> Tuple[int, int]:
   252â†’        """Get current progress (answered, total)"""
   253â†’        answered = sum(1 for q in session.questions if q.answer is not None)
   254â†’        return answered, len(session.questions)
   255â†’
   256â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   257â†’    # Answer Processing
   258â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   259â†’
   260â†’    async def submit_answer(
   261â†’        self,
   262â†’        session: InterviewSession,
   263â†’        answer: str
   264â†’    ) -> Tuple[Optional[InterviewQuestion], bool]:
   265â†’        """
   266â†’        Submit an answer to the current question.
   267â†’
   268â†’        Args:
   269â†’            session: Current interview session
   270â†’            answer: User's answer
   271â†’
   272â†’        Returns:
   273â†’            Tuple of (next_question or None, is_complete)
   274â†’        """
   275â†’        if session.state != InterviewState.IN_PROGRESS:
   276â†’            return None, session.state == InterviewState.COMPLETED
   277â†’
   278â†’        current_idx = session.current_question_idx
   279â†’        if current_idx >= len(session.questions):
   280â†’            session.state = InterviewState.COMPLETED
   281â†’            session.completed_at = datetime.utcnow()
   282â†’            return None, True
   283â†’
   284â†’        # Save answer to current question
   285â†’        current_question = session.questions[current_idx]
   286â†’        current_question.answer = answer
   287â†’        current_question.answered_at = datetime.utcnow()
   288â†’
   289â†’        # Extract structured info from answer
   290â†’        try:
   291â†’            extracted = await self._extract_answer_info(
   292â†’                current_question.question_text,
   293â†’                answer
   294â†’            )
   295â†’            current_question.extracted_info = extracted
   296â†’        except Exception as e:
   297â†’            logger.warning(f"Failed to extract info from answer: {e}")
   298â†’            current_question.extracted_info = {}
   299â†’
   300â†’        # Move to next question
   301â†’        session.current_question_idx += 1
   302â†’
   303â†’        # Check if complete
   304â†’        if session.current_question_idx >= len(session.questions):
   305â†’            session.state = InterviewState.COMPLETED
   306â†’            session.completed_at = datetime.utcnow()
   307â†’            return None, True
   308â†’
   309â†’        # Return next question
   310â†’        next_question = session.questions[session.current_question_idx]
   311â†’        return next_question, False
   312â†’
   313â†’    async def _extract_answer_info(
   314â†’        self,
   315â†’        question: str,
   316â†’        answer: str
   317â†’    ) -> Dict[str, Any]:
   318â†’        """Extract structured info from an answer using LLM"""
   319â†’        prompt = EXTRACT_ANSWER_PROMPT.format(
   320â†’            question=question,
   321â†’            answer=answer,
   322â†’            extract_fields="career, relationship, concerns, expectations, goals"
   323â†’        )
   324â†’
   325â†’        try:
   326â†’            response = await self.llm.chat(
   327â†’                [create_user_message(prompt)],
   328â†’                temperature=0.2,
   329â†’                max_tokens=800
   330â†’            )
   331â†’
   332â†’            content = response.content.strip()
   333â†’
   334â†’            # Parse JSON from response
   335â†’            if "```json" in content:
   336â†’                content = content.split("```json")[1].split("```")[0].strip()
   337â†’            elif "```" in content:
   338â†’                content = content.split("```")[1].split("```")[0].strip()
   339â†’
   340â†’            return json.loads(content)
   341â†’
   342â†’        except Exception as e:
   343â†’            logger.error(f"Answer extraction failed: {e}")
   344â†’            return {}
   345â†’
   346â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   347â†’    # Skip / Complete
   348â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   349â†’
   350â†’    def skip_session(self, session: InterviewSession) -> str:
   351â†’        """
   352â†’        Skip the interview (user choice).
   353â†’        Returns a warning message.
   354â†’        """
   355â†’        session.state = InterviewState.SKIPPED
   356â†’        session.completed_at = datetime.utcnow()
   357â†’        return INTERVIEW_SKIP_WARNING
   358â†’
   359â†’    def get_result(self, session: InterviewSession) -> InterviewResult:
   360â†’        """
   361â†’        Get final interview result with extracted profile data.
   362â†’        """
   363â†’        if session.state not in (InterviewState.COMPLETED, InterviewState.SKIPPED):
   364â†’            return InterviewResult(
   365â†’                success=False,
   366â†’                extracted_profile={},
   367â†’                summary="è®¿è°ˆå°šæœªå®Œæˆ",
   368â†’                questions_answered=0,
   369â†’                total_questions=len(session.questions)
   370â†’            )
   371â†’
   372â†’        # Merge all extracted info
   373â†’        merged_profile: Dict[str, Any] = {
   374â†’            "life_context": {
   375â†’                "career": {"concerns": []},
   376â†’                "relationship": {"concerns": []},
   377â†’                "current_focus": [],
   378â†’            },
   379â†’            "ai_insights": {
   380â†’                "current_concerns": [],
   381â†’                "pain_points": [],
   382â†’                "expectations": [],
   383â†’                "goals": [],
   384â†’            }
   385â†’        }
   386â†’
   387â†’        questions_answered = 0
   388â†’
   389â†’        for q in session.questions:
   390â†’            if q.answer and q.extracted_info:
   391â†’                questions_answered += 1
   392â†’                self._merge_extracted(merged_profile, q.extracted_info)
   393â†’
   394â†’        # Generate summary
   395â†’        if session.state == InterviewState.SKIPPED:
   396â†’            summary = "ç”¨æˆ·è·³è¿‡äº†è®¿è°ˆ"
   397â†’        elif questions_answered == 0:
   398â†’            summary = "æœªæ”¶é›†åˆ°æœ‰æ•ˆä¿¡æ¯"
   399â†’        else:
   400â†’            concerns = merged_profile.get("ai_insights", {}).get("current_concerns", [])
   401â†’            focus = merged_profile.get("life_context", {}).get("current_focus", [])
   402â†’            summary = f"å·²äº†è§£ç”¨æˆ·å…³æ³¨: {', '.join(concerns[:3] or focus[:3] or ['ä¸€èˆ¬å’¨è¯¢'])}"
   403â†’
   404â†’        return InterviewResult(
   405â†’            success=questions_answered > 0,
   406â†’            extracted_profile=merged_profile,
   407â†’            summary=summary,
   408â†’            questions_answered=questions_answered,
   409â†’            total_questions=len(session.questions)
   410â†’        )
   411â†’
   412â†’    def _merge_extracted(
   413â†’        self,
   414â†’        target: Dict[str, Any],
   415â†’        source: Dict[str, Any]
   416â†’    ) -> None:
   417â†’        """Merge extracted info into target profile"""
   418â†’        for key, value in source.items():
   419â†’            if key not in target:
   420â†’                target[key] = value
   421â†’                continue
   422â†’
   423â†’            if isinstance(value, dict) and isinstance(target[key], dict):
   424â†’                self._merge_extracted(target[key], value)
   425â†’            elif isinstance(value, list) and isinstance(target[key], list):
   426â†’                # Extend list without duplicates
   427â†’                existing = set(str(x) for x in target[key])
   428â†’                for item in value:
   429â†’                    if str(item) not in existing and item:
   430â†’                        target[key].append(item)
   431â†’            elif value is not None:
   432â†’                target[key] = value
   433â†’
   434â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   435â†’    # Profile Score Check
   436â†’    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   437â†’
   438â†’    def check_interview_needed(
   439â†’        self,
   440â†’        profile: Dict[str, Any],
   441â†’        threshold: float = 0.3
   442â†’    ) -> bool:
   443â†’        """
   444â†’        Check if interview is needed based on profile completeness.
   445â†’
   446â†’        Returns True if:
   447â†’        - Profile is empty or missing key fields
   448â†’        - Profile score is below threshold
   449â†’        """
   450â†’        if not profile:
   451â†’            return True
   452â†’
   453â†’        # Calculate profile score
   454â†’        score = 0.0
   455â†’        max_score = 1.0
   456â†’
   457â†’        # Basic info (0.3)
   458â†’        basic = profile.get("basic", {})
   459â†’        if basic.get("birth_datetime"):
   460â†’            score += 0.2
   461â†’        if basic.get("gender"):
   462â†’            score += 0.1
   463â†’
   464â†’        # Life context (0.4)
   465â†’        life = profile.get("life_context", {})
   466â†’        if life.get("career", {}).get("status"):
   467â†’            score += 0.15
   468â†’        if life.get("relationship", {}).get("status"):
   469â†’            score += 0.15
   470â†’        if life.get("current_focus"):
   471â†’            score += 0.1
   472â†’
   473â†’        # AI insights (0.3)
   474â†’        insights = profile.get("ai_insights", {})
   475â†’        if insights.get("current_concerns"):
   476â†’            score += 0.2
   477â†’        if insights.get("personality_traits"):
   478â†’            score += 0.1
   479â†’
   480â†’        return score < threshold
   481â†’
   482â†’
   483â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   484â†’# Global Instance
   485â†’# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   486â†’
   487â†’_interview_service: Optional[InterviewService] = None
   488â†’
   489â†’
   490â†’def get_interview_service() -> InterviewService:
   491â†’    """Get or create global interview service instance"""
   492â†’    global _interview_service
   493â†’    if _interview_service is None:
   494â†’        _interview_service = InterviewService()
   495â†’    return _interview_service
   496â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
