     1→"""
     2→Conversation Repository - Database operations for conversations
     3→Based on: vibelife spec v3.0 schema (001_v3_schema.sql)
     4→"""
     5→import json
     6→from typing import Optional, List, Dict, Any
     7→from uuid import UUID, uuid4
     8→from datetime import datetime
     9→import logging
    10→
    11→from .db import get_connection, fetchrow, fetch, execute
    12→
    13→logger = logging.getLogger(__name__)
    14→
    15→
    16→# ═══════════════════════════════════════════════════════════════════════════
    17→# Data Models
    18→# ═══════════════════════════════════════════════════════════════════════════
    19→
    20→class ConversationRecord:
    21→    """Conversation database record"""
    22→
    23→    def __init__(
    24→        self,
    25→        id: UUID,
    26→        user_id: Optional[UUID],
    27→        skill: str,
    28→        voice_mode: str,
    29→        title: Optional[str],
    30→        is_active: bool,
    31→        created_at: datetime,
    32→        updated_at: datetime
    33→    ):
    34→        self.id = id
    35→        self.user_id = user_id
    36→        self.skill = skill
    37→        self.voice_mode = voice_mode
    38→        self.title = title
    39→        self.is_active = is_active
    40→        self.created_at = created_at
    41→        self.updated_at = updated_at
    42→
    43→    def to_dict(self) -> dict:
    44→        return {
    45→            "id": str(self.id),
    46→            "user_id": str(self.user_id) if self.user_id else None,
    47→            "skill": self.skill,
    48→            "voice_mode": self.voice_mode,
    49→            "title": self.title,
    50→            "is_active": self.is_active,
    51→            "created_at": self.created_at.isoformat() if self.created_at else None,
    52→            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
    53→        }
    54→
    55→    @classmethod
    56→    def from_row(cls, row: dict) -> "ConversationRecord":
    57→        return cls(
    58→            id=row["id"],
    59→            user_id=row.get("user_id"),
    60→            skill=row["skill"],
    61→            voice_mode=row.get("voice_mode", "warm"),
    62→            title=row.get("title"),
    63→            is_active=row.get("is_active", True),
    64→            created_at=row.get("created_at"),
    65→            updated_at=row.get("updated_at"),
    66→        )
    67→
    68→
    69→# ═══════════════════════════════════════════════════════════════════════════
    70→# Repository Functions
    71→# ═══════════════════════════════════════════════════════════════════════════
    72→
    73→async def create_conversation(
    74→    skill: str,
    75→    user_id: Optional[UUID] = None,
    76→    voice_mode: str = "warm",
    77→    title: Optional[str] = None
    78→) -> ConversationRecord:
    79→    """
    80→    Create a new conversation.
    81→
    82→    Args:
    83→        skill: bazi or zodiac
    84→        user_id: Optional user ID (None for guests)
    85→        voice_mode: warm or sarcastic
    86→        title: Optional conversation title
    87→
    88→    Returns:
    89→        Created ConversationRecord
    90→    """
    91→    conversation_id = uuid4()
    92→
    93→    query = """
    94→        INSERT INTO conversations (id, user_id, skill, voice_mode, title)
    95→        VALUES ($1, $2, $3, $4, $5)
    96→        RETURNING *
    97→    """
    98→
    99→    try:
   100→        async with get_connection() as conn:
   101→            row = await conn.fetchrow(
   102→                query,
   103→                conversation_id,
   104→                user_id,
   105→                skill,
   106→                voice_mode,
   107→                title
   108→            )
   109→            return ConversationRecord.from_row(dict(row))
   110→    except Exception as e:
   111→        logger.error(f"Failed to create conversation: {e}")
   112→        raise
   113→
   114→
   115→async def get_conversation(conversation_id: UUID) -> Optional[ConversationRecord]:
   116→    """Get a conversation by ID"""
   117→    query = "SELECT * FROM conversations WHERE id = $1"
   118→
   119→    try:
   120→        row = await fetchrow(query, conversation_id)
   121→        if row:
   122→            return ConversationRecord.from_row(dict(row))
   123→        return None
   124→    except Exception as e:
   125→        logger.error(f"Failed to get conversation: {e}")
   126→        raise
   127→
   128→
   129→async def list_conversations(
   130→    user_id: UUID,
   131→    skill: Optional[str] = None,
   132→    is_active: Optional[bool] = None,
   133→    limit: int = 20,
   134→    offset: int = 0
   135→) -> List[ConversationRecord]:
   136→    """
   137→    List conversations for a user.
   138→
   139→    Args:
   140→        user_id: User ID
   141→        skill: Optional skill filter
   142→        is_active: Optional active status filter
   143→        limit: Max results
   144→        offset: Pagination offset
   145→
   146→    Returns:
   147→        List of ConversationRecord
   148→    """
   149→    conditions = ["user_id = $1"]
   150→    params = [user_id]
   151→    param_idx = 2
   152→
   153→    if skill:
   154→        conditions.append(f"skill = ${param_idx}")
   155→        params.append(skill)
   156→        param_idx += 1
   157→
   158→    if is_active is not None:
   159→        conditions.append(f"is_active = ${param_idx}")
   160→        params.append(is_active)
   161→        param_idx += 1
   162→
   163→    where_clause = " AND ".join(conditions)
   164→
   165→    query = f"""
   166→        SELECT * FROM conversations
   167→        WHERE {where_clause}
   168→        ORDER BY updated_at DESC
   169→        LIMIT ${param_idx} OFFSET ${param_idx + 1}
   170→    """
   171→    params.extend([limit, offset])
   172→
   173→    try:
   174→        rows = await fetch(query, *params)
   175→        return [ConversationRecord.from_row(dict(row)) for row in rows]
   176→    except Exception as e:
   177→        logger.error(f"Failed to list conversations: {e}")
   178→        raise
   179→
   180→
   181→async def update_conversation(
   182→    conversation_id: UUID,
   183→    voice_mode: Optional[str] = None,
   184→    title: Optional[str] = None,
   185→    is_active: Optional[bool] = None
   186→) -> Optional[ConversationRecord]:
   187→    """Update a conversation"""
   188→    updates = []
   189→    params = []
   190→    param_idx = 1
   191→
   192→    if voice_mode is not None:
   193→        updates.append(f"voice_mode = ${param_idx}")
   194→        params.append(voice_mode)
   195→        param_idx += 1
   196→
   197→    if title is not None:
   198→        updates.append(f"title = ${param_idx}")
   199→        params.append(title)
   200→        param_idx += 1
   201→
   202→    if is_active is not None:
   203→        updates.append(f"is_active = ${param_idx}")
   204→        params.append(is_active)
   205→        param_idx += 1
   206→
   207→    if not updates:
   208→        return await get_conversation(conversation_id)
   209→
   210→    params.append(conversation_id)
   211→
   212→    query = f"""
   213→        UPDATE conversations
   214→        SET {", ".join(updates)}
   215→        WHERE id = ${param_idx}
   216→        RETURNING *
   217→    """
   218→
   219→    try:
   220→        row = await fetchrow(query, *params)
   221→        if row:
   222→            return ConversationRecord.from_row(dict(row))
   223→        return None
   224→    except Exception as e:
   225→        logger.error(f"Failed to update conversation: {e}")
   226→        raise
   227→
   228→
   229→async def delete_conversation(conversation_id: UUID) -> bool:
   230→    """Delete a conversation (cascades to messages)"""
   231→    query = "DELETE FROM conversations WHERE id = $1"
   232→
   233→    try:
   234→        result = await execute(query, conversation_id)
   235→        return "DELETE 1" in result
   236→    except Exception as e:
   237→        logger.error(f"Failed to delete conversation: {e}")
   238→        raise
   239→
   240→
   241→async def count_conversations(
   242→    user_id: UUID,
   243→    skill: Optional[str] = None
   244→) -> int:
   245→    """Count conversations for a user"""
   246→    conditions = ["user_id = $1"]
   247→    params = [user_id]
   248→
   249→    if skill:
   250→        conditions.append("skill = $2")
   251→        params.append(skill)
   252→
   253→    query = f"""
   254→        SELECT COUNT(*) FROM conversations
   255→        WHERE {" AND ".join(conditions)}
   256→    """
   257→
   258→    try:
   259→        async with get_connection() as conn:
   260→            return await conn.fetchval(query, *params)
   261→    except Exception as e:
   262→        logger.error(f"Failed to count conversations: {e}")
   263→        raise
   264→
   265→
   266→async def get_latest_conversation(
   267→    user_id: UUID,
   268→    skill: Optional[str] = None
   269→) -> Optional[ConversationRecord]:
   270→    """Get the most recent active conversation"""
   271→    conditions = ["user_id = $1", "is_active = TRUE"]
   272→    params = [user_id]
   273→
   274→    if skill:
   275→        conditions.append("skill = $2")
   276→        params.append(skill)
   277→
   278→    query = f"""
   279→        SELECT * FROM conversations
   280→        WHERE {" AND ".join(conditions)}
   281→        ORDER BY updated_at DESC
   282→        LIMIT 1
   283→    """
   284→
   285→    try:
   286→        row = await fetchrow(query, *params)
   287→        if row:
   288→            return ConversationRecord.from_row(dict(row))
   289→        return None
   290→    except Exception as e:
   291→        logger.error(f"Failed to get latest conversation: {e}")
   292→        raise
   293→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
