     1→/**
     2→ * useVibeChat - AI SDK 6 useChat wrapper for VibeLife
     3→ *
     4→ * Provides streaming chat with skill and voice mode support
     5→ * Uses AI SDK 6 Data Stream Protocol with DefaultChatTransport
     6→ */
     7→
     8→'use client';
     9→
    10→import { useChat } from '@ai-sdk/react';
    11→import { DefaultChatTransport } from 'ai';
    12→import { useCallback, useMemo } from 'react';
    13→import { getTokens } from '@/lib/api';
    14→
    15→export type SkillId = 'bazi' | 'zodiac' | 'mbti' | 'attach' | 'career';
    16→export type VoiceMode = 'warm' | 'sarcastic';
    17→
    18→export interface UseVibeChatOptions {
    19→  skillId: SkillId;
    20→  voiceMode?: VoiceMode;
    21→  conversationId?: string;
    22→  onConversationStart?: (id: string) => void;
    23→  onError?: (error: Error) => void;
    24→  onFinish?: () => void;
    25→}
    26→
    27→export function useVibeChat({
    28→  skillId,
    29→  voiceMode = 'warm',
    30→  conversationId,
    31→  onConversationStart,
    32→  onError,
    33→  onFinish,
    34→}: UseVibeChatOptions) {
    35→  // Create transport with custom headers and body
    36→  const transport = useMemo(() => {
    37→    const { accessToken } = getTokens();
    38→    return new DefaultChatTransport({
    39→      api: '/api/chat',
    40→      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : undefined,
    41→      body: {
    42→        skill: skillId,
    43→        voice_mode: voiceMode,
    44→        conversation_id: conversationId,
    45→      },
    46→    });
    47→  }, [skillId, voiceMode, conversationId]);
    48→
    49→  // AI SDK 6 useChat hook with transport
    50→  const chat = useChat({
    51→    id: conversationId,
    52→    transport,
    53→    onFinish: ({ message }) => {
    54→      // Extract conversation_id from metadata if available
    55→      const metadata = message.metadata as { conversation_id?: string } | undefined;
    56→      if (metadata?.conversation_id && onConversationStart) {
    57→        onConversationStart(metadata.conversation_id);
    58→      }
    59→      onFinish?.();
    60→    },
    61→    onError: (error) => {
    62→      console.error('Chat error:', error);
    63→      onError?.(error);
    64→    },
    65→  });
    66→
    67→  // Wrapper for sendMessage - AI SDK 6 accepts { text: string }
    68→  const sendVibeMessage = useCallback(
    69→    async (content: string) => {
    70→      return chat.sendMessage({ text: content });
    71→    },
    72→    [chat]
    73→  );
    74→
    75→  // Clear messages and send (for quick prompts)
    76→  const sendQuickPrompt = useCallback(
    77→    async (content: string) => {
    78→      chat.setMessages([]);
    79→      return sendVibeMessage(content);
    80→    },
    81→    [chat, sendVibeMessage]
    82→  );
    83→
    84→  // Compute isLoading from status
    85→  const isLoading = chat.status === 'submitted' || chat.status === 'streaming';
    86→
    87→  return {
    88→    // Core state
    89→    messages: chat.messages,
    90→    status: chat.status,
    91→    isLoading,
    92→    error: chat.error,
    93→
    94→    // Actions
    95→    sendMessage: sendVibeMessage,
    96→    sendQuickPrompt,
    97→    stop: chat.stop,
    98→    clearError: chat.clearError,
    99→
   100→    // For advanced use
   101→    setMessages: chat.setMessages,
   102→    regenerate: chat.regenerate,
   103→
   104→    // Metadata
   105→    conversationId,
   106→    skillId,
   107→    voiceMode,
   108→  };
   109→}
   110→
   111→export default useVibeChat;
   112→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
