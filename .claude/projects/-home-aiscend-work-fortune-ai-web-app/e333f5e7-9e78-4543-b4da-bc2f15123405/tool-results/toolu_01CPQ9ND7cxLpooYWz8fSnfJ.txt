     1→"""
     2→Soul OS 核心服务层
     3→
     4→基于 os_design_claude_mvp.md 的四层架构实现：
     5→- L0 Firmware: 八字事实快照管理
     6→- L1 Schema: PERMA + 行为证据汇总
     7→- L2 Agents: 知识库检索 + Prompt 模板
     8→- L3 Synthesis: GLM 整合 + A2UI 输出
     9→
    10→包含：
    11→- State Score 计算
    12→- 反依赖机制
    13→- JITAI 调节动作库
    14→- Guidance Card 生成
    15→"""
    16→
    17→from __future__ import annotations
    18→
    19→import hashlib
    20→import json
    21→from dataclasses import dataclass, field
    22→from datetime import date, datetime, timedelta, timezone
    23→from enum import Enum
    24→from typing import Any, Dict, List, Optional, Tuple
    25→from uuid import uuid4
    26→
    27→from common.logging import get_logger
    28→from stores import fortune_db
    29→
    30→logger = get_logger(__name__)
    31→
    32→
    33→# =============================================================================
    34→# Enums & Constants
    35→# =============================================================================
    36→
    37→class PersonaStyle(str, Enum):
    38→    STANDARD = "standard"  # 清晰、中性、专业
    39→    WARM = "warm"          # 共情、支持性（默认）
    40→    ROAST = "roast"        # 轻毒舌但不羞辱
    41→
    42→
    43→class CommitmentType(str, Enum):
    44→    START_TASK = "start_task"        # 立刻开始
    45→    SCHEDULE_TASK = "schedule_task"  # 加入计划
    46→    ASK_FOLLOWUP = "ask_followup"    # 澄清问题
    47→    OPT_OUT = "opt_out"              # 暂停/关闭
    48→
    49→
    50→class CommitmentStatus(str, Enum):
    51→    SUGGESTED = "suggested"
    52→    ACTIVE = "active"
    53→    DONE = "done"
    54→    SKIPPED = "skipped"
    55→    CANCELED = "canceled"
    56→
    57→
    58→# JITAI 调节动作库
    59→JITAI_ACTIONS: Dict[str, Dict[str, str]] = {
    60→    "焦虑": {
    61→        "high": "3分钟呼吸降噪：吸气4秒→屏息7秒→呼气8秒，重复3次。",
    62→        "medium": "写下3个最坏情况，并评估每个发生的概率（0-100%）。",
    63→        "low": "列出你现在能控制的3件事。",
    64→    },
    65→    "低落": {
    66→        "high": "做一个最小行动：站起来倒杯水，或走到窗边看30秒。",
    67→        "medium": "回忆一个小成就并写下来：我做到了____。",
    68→        "low": "给自己一句鼓励：这很正常，我正在经历困难。",
    69→    },
    70→    "愤怒": {
    71→        "high": "用力握拳10秒再松开，重复3次。然后深呼吸5次。",
    72→        "medium": "写下：我需要的是____。我的底线是____。",
    73→        "low": "离开当前场景2分钟，做5次深呼吸。",
    74→    },
    75→    "困惑": {
    76→        "high": "写下3个选项和1个最重要的约束条件。",
    77→        "medium": "列出2个选项，问自己：如果只能选一个，我会选哪个？为什么？",
    78→        "low": "画一个简单的决策树：选项A→结果；选项B→结果。",
    79→    },
    80→    "兴奋": {
    81→        "high": "写下这个感觉的来源，并把能量转化为一个2分钟行动。",
    82→        "medium": "记录下这一刻，稍后复盘时用。",
    83→        "low": "享受这个感觉，同时提醒自己不做冲动决策。",
    84→    },
    85→    "平静": {
    86→        "high": "写下今天最想保留的一个做法。",
    87→        "medium": "保持当前状态，安排一个5分钟的延续动作。",
    88→        "low": "保持这个状态，继续当前的事。",
    89→    },
    90→}
    91→
    92→# 心理学翻译规则：八字概念 → 可操作心理语言
    93→BAZI_PSYCHOLOGY_TRANSLATIONS: Dict[str, Dict[str, str]] = {
    94→    "weak": {
    95→        "translation": "你的能量更适合借力/合作，而非单打独斗",
    96→        "action": "本周找一个支持者或合作伙伴",
    97→    },
    98→    "strong": {
    99→        "translation": "你有充沛的内在能量，适合独立行动",
   100→        "action": "设定一个独立完成的小目标",
   101→    },
   102→    "neutral": {
   103→        "translation": "你的能量相对平衡，灵活度高",
   104→        "action": "根据具体情况选择独立或合作",
   105→    },
   106→    "食伤重": {
   107→        "translation": "你有强烈的表达欲和创造力",
   108→        "action": "每天留15分钟自由书写或创作",
   109→    },
   110→    "官杀混杂": {
   111→        "translation": "你可能感受到多重压力或权威冲突",
   112→        "action": "写清哪些压力是你能控制的，哪些不能",
   113→    },
   114→    "桃花星": {
   115→        "translation": "你在关系中有天然的吸引力和敏感度",
   116→        "action": "觉察关系中的边界需求",
   117→    },
   118→    "驿马星": {
   119→        "translation": "你有变动/探索的内在驱力",
   120→        "action": "小范围实验胜过大规模改变",
   121→    },
   122→    "华盖": {
   123→        "translation": "你有独立思考和精神探索的倾向",
   124→        "action": "每周留1小时独处反思时间",
   125→    },
   126→    "天乙贵人": {
   127→        "translation": "你容易获得贵人相助",
   128→        "action": "主动寻求帮助，不要独自扛",
   129→    },
   130→    "文昌": {
   131→        "translation": "你在学习和文字方面有天赋",
   132→        "action": "保持学习习惯，用写作整理思路",
   133→    },
   134→}
   135→
   136→
   137→# =============================================================================
   138→# Data Classes
   139→# =============================================================================
   140→
   141→@dataclass
   142→class StateScore:
   143→    """状态分数 - 把"感觉"变成可训练变量"""
   144→    score: int  # 0-100
   145→    emotion_signal: int  # 40% 权重
   146→    action_signal: int   # 40% 权重
   147→    streak_signal: int   # 20% 权重
   148→    recovery_action: str  # 分数低时的补救动作
   149→
   150→    def to_dict(self) -> Dict[str, Any]:
   151→        return {
   152→            "score": self.score,
   153→            "breakdown": {
   154→                "emotion": self.emotion_signal,
   155→                "action": self.action_signal,
   156→                "streak": self.streak_signal,
   157→            },
   158→            "recovery_action": self.recovery_action,
   159→        }
   160→
   161→
   162→@dataclass
   163→class PermaSnapshot:
   164→    """PERMA 积极心理学快照"""
   165→    positive_emotion: Dict[str, Any] = field(default_factory=dict)
   166→    engagement: Dict[str, Any] = field(default_factory=dict)
   167→    relationships: Dict[str, Any] = field(default_factory=dict)
   168→    meaning: Dict[str, Any] = field(default_factory=dict)
   169→    accomplishment: Dict[str, Any] = field(default_factory=dict)
   170→
   171→    def to_dict(self) -> Dict[str, Any]:
   172→        return {
   173→            "positive_emotion": self.positive_emotion,
   174→            "engagement": self.engagement,
   175→            "relationships": self.relationships,
   176→            "meaning": self.meaning,
   177→            "accomplishment": self.accomplishment,
   178→        }
   179→
   180→
   181→@dataclass
   182→class L1Schema:
   183→    """L1 特质层数据"""
   184→    perma: PermaSnapshot
   185→    cognitive_patterns: Dict[str, Any]
   186→    strengths_in_use: List[str]
   187→    preferences: Dict[str, Any]
   188→
   189→    def to_dict(self) -> Dict[str, Any]:
   190→        return {
   191→            "perma_snapshot": self.perma.to_dict(),
   192→            "cognitive_patterns": self.cognitive_patterns,
   193→            "strengths_in_use": self.strengths_in_use,
   194→            "preferences": self.preferences,
   195→        }
   196→
   197→
   198→@dataclass
   199→class AntiDependencyState:
   200→    """反依赖状态追踪"""
   201→    same_question_count: int = 0
   202→    daily_consult_count: int = 0
   203→    last_action_days: int = 0
   204→    should_intervene: bool = False
   205→    intervention_type: str = ""
   206→    intervention_message: str = ""
   207→    suggested_task: Optional[Dict[str, Any]] = None  # 干预时必须返回的任务
   208→    is_new_user: bool = False  # 是否为新用户（7天内）
   209→
   210→
   211→@dataclass
   212→class GuidanceCard:
   213→    """指导卡片"""
   214→    card_id: str
   215→    card_type: str
   216→    conclusion: str
   217→    why: str
   218→    prescriptions: List[Dict[str, Any]]
   219→    time_window: Dict[str, Any]
   220→    risk_boundary: str
   221→    commitment_ask: str
   222→    actions: List[Dict[str, Any]]
   223→    evidence: Dict[str, Any]
   224→    created_at: str
   225→
   226→    def to_dict(self) -> Dict[str, Any]:
   227→        return {
   228→            "card_id": self.card_id,
   229→            "type": self.card_type,
   230→            "conclusion": self.conclusion,
   231→            "why": self.why,
   232→            "prescriptions": self.prescriptions,
   233→            "time_window": self.time_window,
   234→            "risk_boundary": self.risk_boundary,
   235→            "commitment_ask": self.commitment_ask,
   236→            "actions": self.actions,
   237→            "evidence": self.evidence,
   238→            "created_at": self.created_at,
   239→        }
   240→
   241→
   242→# =============================================================================
   243→# L0 Firmware Layer - 八字事实快照管理
   244→# =============================================================================
   245→
   246→def get_l0_facts(user_id: int) -> Dict[str, Any]:
   247→    """获取 L0 层八字事实快照"""
   248→    snap = fortune_db.fetch_one(
   249→        """
   250→        SELECT facts, facts_hash, compute_version
   251→        FROM fortune_bazi_snapshot
   252→        WHERE user_id = %s
   253→        ORDER BY created_at DESC
   254→        LIMIT 1
   255→        """,
   256→        (int(user_id),),
   257→    )
   258→    if not snap:
   259→        return {"facts": {}, "facts_hash": "", "compute_version": ""}
   260→    return {
   261→        "facts": snap.get("facts") or {},
   262→        "facts_hash": str(snap.get("facts_hash") or ""),
   263→        "compute_version": str(snap.get("compute_version") or ""),
   264→    }
   265→
   266→
   267→def translate_bazi_to_psychology(facts: Dict[str, Any]) -> List[Dict[str, str]]:
   268→    """将八字概念翻译为可操作的心理学语言"""
   269→    translations = []
   270→    bazi = facts.get("bazi", {})
   271→
   272→    # 旺衰翻译
   273→    strength = bazi.get("strength", {})
   274→    status = strength.get("level", "neutral")
   275→    if status in BAZI_PSYCHOLOGY_TRANSLATIONS:
   276→        trans = BAZI_PSYCHOLOGY_TRANSLATIONS[status]
   277→        translations.append({
   278→            "concept": f"日主{status}",
   279→            "translation": trans["translation"],
   280→            "action": trans["action"],
   281→        })
   282→
   283→    # 神煞翻译
   284→    for shensha in bazi.get("shensha", []):
   285→        if shensha.get("hit"):
   286→            name = shensha.get("name", "")
   287→            if name in BAZI_PSYCHOLOGY_TRANSLATIONS:
   288→                trans = BAZI_PSYCHOLOGY_TRANSLATIONS[name]
   289→                translations.append({
   290→                    "concept": name,
   291→                    "translation": trans["translation"],
   292→                    "action": trans["action"],
   293→                })
   294→
   295→    return translations
   296→
   297→
   298→# =============================================================================
   299→# L1 Schema Layer - PERMA + 行为证据汇总
   300→# =============================================================================
   301→
   302→def get_l1_schema(user_id: int, window_days: int = 7) -> L1Schema:
   303→    """获取 L1 层特质图式"""
   304→    uid = int(user_id)
   305→    window_start = datetime.now(timezone.utc) - timedelta(days=window_days)
   306→
   307→    # 获取用户偏好
   308→    prefs = fortune_db.fetch_one(
   309→        "SELECT * FROM fortune_user_preferences WHERE user_id = %s",
   310→        (uid,),
   311→    ) or {}
   312→
   313→    # P: Positive Emotion - 从 checkin 获取
   314→    checkins = fortune_db.fetch_all(
   315→        """
   316→        SELECT mood, intensity, created_at
   317→        FROM fortune_checkin
   318→        WHERE user_id = %s AND created_at >= %s
   319→        ORDER BY created_at DESC
   320→        LIMIT 20
   321→        """,
   322→        (uid, window_start),
   323→    )
   324→
   325→    positive_moods = ["平静", "兴奋", "开心", "满足", "感恩"]
   326→    negative_moods = ["焦虑", "愤怒", "沮丧", "悲伤", "恐惧"]
   327→
   328→    # 分别计算正负面情绪的平均强度
   329→    positive_checkins = [c for c in checkins if c.get("mood") in positive_moods]
   330→    negative_checkins = [c for c in checkins if c.get("mood") in negative_moods]
   331→
   332→    pos_avg = sum(c.get("intensity", 5) for c in positive_checkins) / len(positive_checkins) if positive_checkins else 0
   333→    neg_avg = sum(c.get("intensity", 5) for c in negative_checkins) / len(negative_checkins) if negative_checkins else 0
   334→
   335→    # 正向情绪高强度=加分，负向情绪高强度=扣分，基线5分
   336→    raw_score = pos_avg - neg_avg + 5 if checkins else 5.0
   337→    positive_count = len(positive_checkins)
   338→
   339→    positive_emotion = {
   340→        "score": round(max(0, min(10, raw_score)), 1),
   341→        "trend": "up" if positive_count > len(checkins) / 2 else "stable",
   342→        "recent_count": len(checkins),
   343→    }
   344→
   345→    # E: Engagement - 从 plan enrollment 获取
   346→    enrollments = fortune_db.fetch_all(
   347→        """
   348→        SELECT plan_id, status, current_day
   349→        FROM fortune_plan_enrollment
   350→        WHERE user_id = %s AND status = 'active'
   351→        """,
   352→        (uid,),
   353→    )
   354→
   355→    # 计算完成率
   356→    done_count = fortune_db.fetch_one(
   357→        """
   358→        SELECT COUNT(*) as cnt
   359→        FROM fortune_commitment
   360→        WHERE user_id = %s AND status = 'done' AND created_at >= %s
   361→        """,
   362→        (uid, window_start),
   363→    ) or {}
   364→
   365→    suggested_count = fortune_db.fetch_one(
   366→        """
   367→        SELECT COUNT(*) as cnt
   368→        FROM fortune_commitment
   369→        WHERE user_id = %s AND created_at >= %s
   370→        """,
   371→        (uid, window_start),
   372→    ) or {}
   373→
   374→    total = suggested_count.get("cnt", 0) or 1
   375→    completion_rate = round(done_count.get("cnt", 0) / total, 2) if total else 0
   376→
   377→    engagement = {
   378→        "score": round(completion_rate * 10, 1),  # 0-10 scale
   379→        "active_plans": len(enrollments),
   380→        "completion_rate": completion_rate,
   381→    }
   382→
   383→    # R: Relationships - 从对话中提取（简化版）
   384→    recent_msgs = fortune_db.fetch_all(
   385→        """
   386→        SELECT content
   387→        FROM fortune_conversation_message
   388→        WHERE user_id = %s AND role = 'user' AND created_at >= %s
   389→        ORDER BY created_at DESC
   390→        LIMIT 10
   391→        """,
   392→        (uid, window_start),
   393→    )
   394→
   395→    relationship_keywords = ["同事", "朋友", "家人", "伴侣", "关系"]
   396→    relationship_mentions = sum(
   397→        1 for m in recent_msgs
   398→        if any(kw in (m.get("content") or "") for kw in relationship_keywords)
   399→    )
   400→
   401→    relationships = {
   402→        "score": min(10, relationship_mentions * 2.5),  # 0-10 scale, 4 mentions = 10
   403→        "recent_mentions": relationship_mentions,
   404→        "recent_note": "",
   405→    }
   406→
   407→    # M: Meaning - 从计划参与推断
   408→    aligned_cnt = done_count.get("cnt", 0)
   409→    meaning = {
   410→        "score": min(10, aligned_cnt),  # 0-10 scale
   411→        "core_value": "成长" if enrollments else "探索",
   412→        "aligned_actions": aligned_cnt,
   413→    }
   414→
   415→    # A: Accomplishment
   416→    streak = _calculate_streak(uid)
   417→    weekly_done = done_count.get("cnt", 0)
   418→    accomplishment = {
   419→        "score": min(10, weekly_done + streak * 0.5),  # 0-10 scale
   420→        "weekly_done": weekly_done,
   421→        "streak": streak,
   422→    }
   423→
   424→    perma = PermaSnapshot(
   425→        positive_emotion=positive_emotion,
   426→        engagement=engagement,
   427→        relationships=relationships,
   428→        meaning=meaning,
   429→        accomplishment=accomplishment,
   430→    )
   431→
   432→    return L1Schema(
   433→        perma=perma,
   434→        cognitive_patterns={"identified_schemas": [], "reframe_count": 0},
   435→        strengths_in_use=[],
   436→        preferences={
   437→            "persona_style": prefs.get("persona_style", "warm"),
   438→            "push_enabled": prefs.get("push_enabled", True),
   439→        },
   440→    )
   441→
   442→
   443→def _calculate_streak(user_id: int) -> int:
   444→    """计算连续行动天数"""
   445→    rows = fortune_db.fetch_all(
   446→        """
   447→        SELECT DATE(done_at) as done_date
   448→        FROM fortune_commitment
   449→        WHERE user_id = %s AND status = 'done' AND done_at IS NOT NULL
   450→        ORDER BY done_at DESC
   451→        LIMIT 30
   452→        """,
   453→        (int(user_id),),
   454→    )
   455→
   456→    if not rows:
   457→        return 0
   458→
   459→    dates = sorted(set(r["done_date"] for r in rows if r.get("done_date")), reverse=True)
   460→    if not dates:
   461→        return 0
   462→
   463→    today = date.today()
   464→    streak = 0
   465→    expected = today
   466→
   467→    for d in dates:
   468→        if d == expected or d == expected - timedelta(days=1):
   469→            streak += 1
   470→            expected = d - timedelta(days=1)
   471→        else:
   472→            break
   473→
   474→    return streak
   475→
   476→
   477→# =============================================================================
   478→# State Score 计算
   479→# =============================================================================
   480→
   481→def calculate_state_score(user_id: int, window: str = "24h") -> StateScore:
   482→    """
   483→    计算状态分数（0-100）
   484→
   485→    三信号计算：
   486→    - emotion_signal (40%): 情绪基线
   487→    - action_signal (40%): 行动完成
   488→    - streak_signal (20%): 连续记录
   489→    """
   490→    uid = int(user_id)
   491→
   492→    # 确定时间窗口
   493→    if window == "24h":
   494→        window_start = datetime.now(timezone.utc) - timedelta(hours=24)
   495→    elif window == "7d":
   496→        window_start = datetime.now(timezone.utc) - timedelta(days=7)
   497→    else:
   498→        window_start = datetime.now(timezone.utc) - timedelta(hours=24)
   499→
   500→    # 信号1: 情绪基线（40%权重）
   501→    checkin = fortune_db.fetch_one(
   502→        """
   503→        SELECT mood, intensity
   504→        FROM fortune_checkin
   505→        WHERE user_id = %s AND created_at >= %s
   506→        ORDER BY created_at DESC
   507→        LIMIT 1
   508→        """,
   509→        (uid, window_start),
   510→    )
   511→
   512→    if checkin:
   513→        mood = checkin.get("mood", "")
   514→        intensity = int(checkin.get("intensity", 5))
   515→        positive_moods = ["平静", "兴奋", "开心", "满足", "感恩"]
   516→
   517→        if mood in positive_moods:
   518→            # 正向情绪：强度越高越好
   519→            emotion_signal = intensity * 4
   520→        else:
   521→            # 负向情绪：强度越高越差
   522→            emotion_signal = max(0, (10 - intensity)) * 4
   523→    else:
   524→        emotion_signal = 20  # 无打卡给中性分
   525→
   526→    # 信号2: 行动完成（40%权重）
   527→    done_result = fortune_db.fetch_one(
   528→        """
   529→        SELECT COUNT(*) as cnt
   530→        FROM fortune_commitment
   531→        WHERE user_id = %s AND status = 'done' AND done_at >= %s
   532→        """,
   533→        (uid, window_start),
   534→    ) or {}
   535→    done_count = done_result.get("cnt", 0)
   536→    action_signal = min(done_count * 10, 40)
   537→
   538→    # 信号3: 连续记录（20%权重）
   539→    streak = _calculate_streak(uid)
   540→    streak_signal = min(streak * 4, 20)
   541→
   542→    # 总分
   543→    score = emotion_signal + action_signal + streak_signal
   544→
   545→    # 补救动作
   546→    recovery_action = _get_recovery_action(score, checkin)
   547→
   548→    return StateScore(
   549→        score=score,
   550→        emotion_signal=emotion_signal,
   551→        action_signal=action_signal,
   552→        streak_signal=streak_signal,
   553→        recovery_action=recovery_action,
   554→    )
   555→
   556→
   557→def _get_recovery_action(score: int, last_checkin: Optional[Dict[str, Any]]) -> str:
   558→    """根据分数和最近打卡生成补救动作"""
   559→    if score >= 70:
   560→        return "保持这个状态！今天再完成一个小任务来巩固。"
   561→    elif score >= 50:
   562→        return "做一个2分钟的最小行动，把分数拉上来。"
   563→    elif score >= 30:
   564→        if last_checkin:
   565→            mood = last_checkin.get("mood", "")
   566→            intensity = last_checkin.get("intensity", 5)
   567→            return get_jitai_action(mood, intensity)
   568→        return "先做3分钟呼吸降噪，然后完成一个最小任务。"
   569→    else:
   570→        return "先照顾好自己：喝杯水，做几次深呼吸，然后选一个最小的事情开始。"
   571→
   572→
   573→# =============================================================================
   574→# JITAI 调节动作库
   575→# =============================================================================
   576→
   577→def get_jitai_action(mood: str, intensity: int) -> str:
   578→    """获取 JITAI 即时适应性干预动作"""
   579→    mood = (mood or "").strip()
   580→    intensity = max(0, min(10, int(intensity)))
   581→
   582→    # 确定强度级别
   583→    if intensity >= 7:
   584→        level = "high"
   585→    elif intensity >= 4:
   586→        level = "medium"
   587→    else:
   588→        level = "low"
   589→
   590→    # 查找匹配的动作
   591→    for keyword, actions in JITAI_ACTIONS.items():
   592→        if keyword in mood:
   593→            return actions.get(level, actions.get("medium", ""))
   594→
   595→    # 默认动作
   596→    if intensity >= 7:
   597→        return "先做3分钟呼吸锚点：1分钟呼吸→1分钟身体感受→1分钟选择下一步。"
   598→    return "写下：我现在最需要被满足的一个需求是什么？然后做一个2分钟版本。"
   599→
   600→
   601→def create_checkin_with_jitai(
   602→    user_id: int,
   603→    *,
   604→    mood: str,
   605→    intensity: int,
   606→    note: str = "",
   607→) -> Dict[str, Any]:
   608→    """创建情绪打卡并返回 JITAI 推荐动作"""
   609→    uid = int(user_id)
   610→    mood = (mood or "")[:50]
   611→    intensity = max(0, min(10, int(intensity)))
   612→    note = (note or "")[:1000]
   613→
   614→    # 获取推荐动作
   615→    action = get_jitai_action(mood, intensity)
   616→
   617→    # 写入打卡记录
   618→    fortune_db.execute(
   619→        """
   620→        INSERT INTO fortune_checkin (user_id, mood, intensity, note, recommended_action)
   621→        VALUES (%s, %s, %s, %s, %s)
   622→        """,
   623→        (uid, mood, intensity, note, action),
   624→    )
   625→
   626→    # 创建建议任务
   627→    task_id = str(uuid4())
   628→    fortune_db.execute(
   629→        """
   630→        INSERT INTO fortune_commitment (task_id, user_id, source, commitment_type, title, details, status)
   631→        VALUES (%s::uuid, %s, 'bento', 'start_task', %s, %s::jsonb, 'suggested')
   632→        """,
   633→        (
   634→            task_id,
   635→            uid,
   636→            (action[:200] if action else "情绪调节动作"),
   637→            json.dumps({"from": "checkin", "mood": mood, "intensity": intensity}, ensure_ascii=False),
   638→        ),
   639→    )
   640→
   641→    logger.info(
   642→        "checkin created with jitai",
   643→        extra={"operation": "checkin_jitai", "user_id": uid, "mood": mood, "intensity": intensity},
   644→    )
   645→
   646→    return {
   647→        "mood": mood,
   648→        "intensity": intensity,
   649→        "recommended_action": action,
   650→        "task_id": task_id,
   651→    }
   652→
   653→
   654→# =============================================================================
   655→# 反依赖机制
   656→# =============================================================================
   657→
   658→def check_anti_dependency(user_id: int, current_message: str = "") -> AntiDependencyState:
   659→    """
   660→    检查反依赖触发条件（优化版）
   661→
   662→    优化策略（基于 os_design_claude_mvp v1.md §5）：
   663→    1. 新用户豁免期：注册7天内不触发 anti-dependency
   664→    2. 提升日消息阈值：从5提升到8（有活跃任务时降为5）
   665→    3. 干预时必须返回至少1个可执行任务
   666→    """
   667→    uid = int(user_id)
   668→    today_start = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)
   669→
   670→    state = AntiDependencyState()
   671→
   672→    # 检查用户注册时间，判断是否为新用户
   673→    user_info = fortune_db.fetch_one(
   674→        """
   675→        SELECT created_at, onboarding_completed
   676→        FROM fortune_user
   677→        WHERE user_id = %s
   678→        """,
   679→        (uid,),
   680→    )
   681→    if user_info and user_info.get("created_at"):
   682→        created_at = user_info["created_at"]
   683→        if hasattr(created_at, "tzinfo") and created_at.tzinfo is None:
   684→            created_at = created_at.replace(tzinfo=timezone.utc)
   685→        days_since_register = (datetime.now(timezone.utc) - created_at).days
   686→        onboarding_completed = user_info.get("onboarding_completed", False)
   687→
   688→        # 新用户豁免期：注册7天内且未完成引导
   689→        if days_since_register < 7 and not onboarding_completed:
   690→            state.is_new_user = True
   691→            return state  # 新用户直接返回，不触发 anti-dependency
   692→    else:
   693→        days_since_register = 999
   694→
   695→    # 检查是否有活跃任务
   696→    active_task = fortune_db.fetch_one(
   697→        """
   698→        SELECT task_id, title
   699→        FROM fortune_commitment
   700→        WHERE user_id = %s AND status = 'active'
   701→        ORDER BY created_at DESC
   702→        LIMIT 1
   703→        """,
   704→        (uid,),
   705→    )
   706→    has_active_commitment = active_task is not None
   707→
   708→    # 动态阈值：有活跃任务时降低阈值
   709→    daily_message_limit = 5 if has_active_commitment else 8
   710→
   711→    # 检查当日咨询次数
   712→    daily_count = fortune_db.fetch_one(
   713→        """
   714→        SELECT COUNT(*) as cnt
   715→        FROM fortune_conversation_message
   716→        WHERE user_id = %s AND role = 'user' AND created_at >= %s
   717→        """,
   718→        (uid, today_start),
   719→    ) or {}
   720→    state.daily_consult_count = daily_count.get("cnt", 0)
   721→
   722→    # 检查最近行动天数
   723→    last_action = fortune_db.fetch_one(
   724→        """
   725→        SELECT done_at
   726→        FROM fortune_commitment
   727→        WHERE user_id = %s AND status = 'done'
   728→        ORDER BY done_at DESC
   729→        LIMIT 1
   730→        """,
   731→        (uid,),
   732→    )
   733→    if last_action and last_action.get("done_at"):
   734→        done_at = last_action["done_at"]
   735→        if hasattr(done_at, "tzinfo") and done_at.tzinfo is None:
   736→            done_at = done_at.replace(tzinfo=timezone.utc)
   737→        days_since = (datetime.now(timezone.utc) - done_at).days
   738→        state.last_action_days = days_since
   739→    else:
   740→        state.last_action_days = 999
   741→
   742→    # 检查是否连续问同一问题（简化：检查最近3条消息相似度）
   743→    if current_message:
   744→        recent_msgs = fortune_db.fetch_all(
   745→            """
   746→            SELECT content
   747→            FROM fortune_conversation_message
   748→            WHERE user_id = %s AND role = 'user'
   749→            ORDER BY created_at DESC
   750→            LIMIT 3
   751→            """,
   752→            (uid,),
   753→        )
   754→        similar_count = sum(
   755→            1 for m in recent_msgs
   756→            if _message_similarity(current_message, m.get("content", "")) > 0.7
   757→        )
   758→        state.same_question_count = similar_count
   759→
   760→    # 获取或创建最小可执行任务（干预时必须返回）
   761→    def get_or_create_minimal_task() -> Dict[str, Any]:
   762→        # 优先返回已有的活跃任务
   763→        if active_task:
   764→            return {
   765→                "task_id": str(active_task.get("task_id", "")),
   766→                "title": active_task.get("title", "完成当前任务"),
   767→                "minutes": 5,
   768→                "source": "existing_active",
   769→            }
   770→        # 否则返回一个默认的最小任务
   771→        return {
   772→            "task_id": None,
   773→            "title": "做3分钟呼吸锚点：专注呼吸进出，走神时温和拉回",
   774→            "minutes": 3,
   775→            "source": "default_minimal",
   776→        }
   777→
   778→    # 判断是否需要干预
   779→    if state.same_question_count >= 3:
   780→        state.should_intervene = True
   781→        state.intervention_type = "repeated_question"
   782→        state.suggested_task = get_or_create_minimal_task()
   783→        state.intervention_message = (
   784→            "我注意到你多次问了类似的问题。信息足够了，现在最重要的是做一个小实验。\n\n"
   785→            f"请先完成这个任务：\n> **{state.suggested_task['title']}**（约{state.suggested_task['minutes']}分钟）\n\n"
   786→            "完成后我们再继续。"
   787→        )
   788→    elif state.daily_consult_count >= daily_message_limit:
   789→        state.should_intervene = True
   790→        state.intervention_type = "daily_limit"
   791→        state.suggested_task = get_or_create_minimal_task()
   792→        state.intervention_message = (
   793→            "今天我们聊了很多，信息已经足够了。\n\n"
   794→            f"现在最重要的是**先行动**：\n> **{state.suggested_task['title']}**（约{state.suggested_task['minutes']}分钟）\n\n"
   795→            "完成后我们再继续。"
   796→        )
   797→    elif state.last_action_days >= 7 and not state.is_new_user:
   798→        # 对新用户不触发 no_action 干预
   799→        state.should_intervene = True
   800→        state.intervention_type = "no_action"
   801→        state.suggested_task = get_or_create_minimal_task()
   802→        state.intervention_message = (
   803→            "看起来你已经有一段时间没有完成行动了。\n\n"
   804→            "没关系，我们可以从一个更小的任务开始：\n"
   805→            f"> **{state.suggested_task['title']}**（约{state.suggested_task['minutes']}分钟）\n\n"
   806→            "完成后告诉我。"
   807→        )
   808→
   809→    return state
   810→
   811→
   812→def _message_similarity(msg1: str, msg2: str) -> float:
   813→    """简单的消息相似度计算（基于词重叠）"""
   814→    if not msg1 or not msg2:
   815→        return 0.0
   816→
   817→    words1 = set(msg1.replace("？", " ").replace("。", " ").split())
   818→    words2 = set(msg2.replace("？", " ").replace("。", " ").split())
   819→
   820→    if not words1 or not words2:
   821→        return 0.0
   822→
   823→    intersection = len(words1 & words2)
   824→    union = len(words1 | words2)
   825→
   826→    return intersection / union if union > 0 else 0.0
   827→
   828→
   829→# =============================================================================
   830→# L2 Agents Layer - 知识库检索 + Prompt 模板
   831→# =============================================================================
   832→
   833→def search_knowledge_base(query: str, top_k: int = 12) -> List[Dict[str, Any]]:
   834→    """从知识库检索相关内容"""
   835→    if not query:
   836→        return []
   837→
   838→    # PostgreSQL FTS 检索
   839→    results = fortune_db.fetch_all(
   840→        """
   841→        SELECT c.chunk_id, c.doc_id, c.page_no, c.chunk_no,
   842→               ts_rank(c.content_tsv, plainto_tsquery('simple', %s)) AS rank,
   843→               c.content,
   844→               d.file_name, d.title
   845→        FROM bazi_kb_chunk c
   846→        JOIN bazi_kb_document d ON c.doc_id = d.doc_id
   847→        WHERE c.content_tsv @@ plainto_tsquery('simple', %s)
   848→        ORDER BY rank DESC
   849→        LIMIT %s
   850→        """,
   851→        (query, query, top_k),
   852→    )
   853→
   854→    kb_refs = []
   855→    for r in results or []:
   856→        kb_refs.append({
   857→            "kb_ref": f"kb:doc:{r['doc_id']}:page:{r['page_no']}:chunk:{r['chunk_no']}",
   858→            "content": (r.get("content") or "")[:500],
   859→            "source": r.get("title") or r.get("file_name") or "",
   860→            "rank": r.get("rank", 0),
   861→        })
   862→
   863→    return kb_refs
   864→
   865→
   866→def get_advisor_perspectives(question: str, facts: Dict[str, Any]) -> List[Dict[str, Any]]:
   867→    """获取四个原型顾问的视角（Prompt 模板参数化）"""
   868→    perspectives = [
   869→        {
   870→            "advisor": "关系视角",
   871→            "optimization": "和谐 + 秩序",
   872→            "prompt_hint": "考虑对方感受，先稳定关系，再解决问题",
   873→            "applicable_for": ["人际冲突", "沟通问题", "家庭关系"],
   874→        },
   875→        {
   876→            "advisor": "第一性原理视角",
   877→            "optimization": "真相 + 效率",
   878→            "prompt_hint": "问题的本质是什么？最小验证是什么？",
   879→            "applicable_for": ["决策困境", "职业选择", "重大决定"],
   880→        },
   881→        {
   882→            "advisor": "系统思维视角",
   883→            "optimization": "风险 + 概率",
   884→            "prompt_hint": "有哪些变量？因果链是什么？最坏情况概率多少？",
   885→            "applicable_for": ["复杂问题", "风险评估", "长期规划"],
   886→        },
   887→        {
   888→            "advisor": "效能整合视角",
   889→            "optimization": "平衡 + 可持续",
   890→            "prompt_hint": "重要且不紧急的事优先，建立可持续节奏",
   891→            "applicable_for": ["时间管理", "精力分配", "习惯养成"],
   892→        },
   893→    ]
   894→
   895→    return perspectives
   896→
   897→
   898→# =============================================================================
   899→# L3 Synthesis Layer - GLM 整合 + A2UI 输出
   900→# =============================================================================
   901→
   902→def build_system_prompt(
   903→    user_id: int,
   904→    persona_style: str = "warm",
   905→) -> str:
   906→    """构建 GLM System Prompt（对齐 OS 设计文档附录 A）"""
   907→
   908→    return f"""你是 Fortune AI 的对话 Agent，角色是积极心理学教练（Performance Coach）。
   909→
   910→【产品定位】
   911→人生导航 / 陪伴 / 提升。系统和交互保持"有效而极简"。
   912→
   913→【四层架构理解】
   914→- L0（定数）：用户的八字事实，作为先验约束，不做宿命论解读
   915→- L1（特质）：用户的心理图式和当前状态，作为个性化调节
   916→- L2（策略）：知识库和规则，作为专业依据
   917→- L3（意识）：你的输出，作为整合与行动引导
   918→
   919→【你的优先级（不可逆）】
   920→Coach > Teaching Assistant > Customer Support > Sales
   921→
   922→【硬性规则（必须遵守）】
   923→1) 禁止恐吓、羞辱、宿命论断言；负面信息必须紧接"你可以做什么"的行动处方。
   924→2) 禁止自行计算八字事实；只能基于提供的 facts + evidence 输出。
   925→3) 每次输出必须包含：结论(conclusion) + 依据(why) + ≤3条处方(prescriptions) + 承诺邀请(commitment_ask)。
   926→4) 处方必须包含 if_then（如果____→那么____）。
   927→5) 时间窗口默认只给干预窗口（intervention）；forecast 只能条件句+低置信度。
   928→6) 输出必须是 A2UI JSON，且第一组件必须是 markdown_text。
   929→7) 必须给出可点击 actions（start_task / schedule_task / open_panel / opt_out）。
   930→
   931→【语言风格 persona_style = {persona_style}】
   932→standard：清晰、中性、专业
   933→warm：共情、支持性（默认）
   934→roast：轻毒舌但不羞辱、不对人格做负面定性
   935→
   936→【输出格式（A2UI JSON）】
   937→{{
   938→  "meta": {{"summary": "一句话摘要"}},
   939→  "ui_components": [
   940→    {{"type": "markdown_text", "title": "输出", "data": "### 结论要点\\n...\\n### 行动处方\\n...\\n### 承诺\\n..."}},
   941→    {{"type": "action_buttons", "title": "下一步", "data": [{{"label": "开始行动", "action": {{"type": "start_task"}}}}]}}
   942→  ]
   943→}}
   944→"""
   945→
   946→
   947→def build_user_context(user_id: int) -> Dict[str, Any]:
   948→    """构建用户上下文（L0 + L1 + State Score）"""
   949→    uid = int(user_id)
   950→
   951→    # L0: 八字事实
   952→    l0 = get_l0_facts(uid)
   953→    facts = l0.get("facts", {})
   954→
   955→    # 心理学翻译
   956→    translations = translate_bazi_to_psychology(facts)
   957→
   958→    # L1: 特质图式
   959→    l1 = get_l1_schema(uid)
   960→
   961→    # State Score
   962→    state_score = calculate_state_score(uid)
   963→
   964→    return {
   965→        "l0_facts": facts,
   966→        "l0_facts_hash": l0.get("facts_hash", ""),
   967→        "l0_translations": translations,
   968→        "l1_schema": l1.to_dict(),
   969→        "state_score": state_score.to_dict(),
   970→    }
   971→
   972→
   973→def build_evidence(user_id: int, query: str = "") -> Dict[str, Any]:
   974→    """构建证据（kb_refs + rule_ids + facts_hash）"""
   975→    l0 = get_l0_facts(user_id)
   976→
   977→    # 知识库检索
   978→    kb_refs = []
   979→    if query:
   980→        kb_results = search_knowledge_base(query)
   981→        kb_refs = [r["kb_ref"] for r in kb_results]
   982→
   983→    # 规则 ID
   984→    rule_ids = []
   985→    facts = l0.get("facts", {})
   986→    bazi = facts.get("bazi", {})
   987→
   988→    if bazi.get("strength", {}).get("rule_id"):
   989→        rule_ids.append(bazi["strength"]["rule_id"])
   990→
   991→    for shensha in bazi.get("shensha", []):
   992→        if shensha.get("hit") and shensha.get("rule_id"):
   993→            rule_ids.append(shensha["rule_id"])
   994→
   995→    return {
   996→        "facts_hash": l0.get("facts_hash", ""),
   997→        "kb_refs": kb_refs,
   998→        "rule_ids": rule_ids,
   999→    }
  1000→
  1001→
  1002→def guidance_card_to_a2ui(card: Dict[str, Any]) -> Dict[str, Any]:
  1003→    """将 Guidance Card 转换为 A2UI 格式"""
  1004→    title = "今日指引"
  1005→    conclusion = str(card.get("conclusion") or "")
  1006→    why = str(card.get("why") or "")
  1007→    prescriptions = card.get("prescriptions") or []
  1008→    tw = card.get("time_window") or {}
  1009→    commitment_ask = str(card.get("commitment_ask") or "你愿意先做哪一个？")
  1010→    risk = str(card.get("risk_boundary") or "不替代医疗/法律/投资建议")
  1011→
  1012→    lines: List[str] = []
  1013→    lines.append("### 结论要点")
  1014→    if conclusion:
  1015→        lines.append(f"- {conclusion}")
  1016→    lines.append("")
  1017→
  1018→    if why:
  1019→        lines.append("### 为什么（教练视角）")
  1020→        lines.append(why)
  1021→        lines.append("")
  1022→
  1023→    if prescriptions:
  1024→        lines.append("### 行动处方（≤3条）")
  1025→        for i, p in enumerate(prescriptions[:3], start=1):
  1026→            content = p.get("content", "")
  1027→            if_then = p.get("if_then", "")
  1028→            lines.append(f"{i}) {content}")
  1029→            if if_then:
  1030→                lines.append(f"   - 如果犹豫：{if_then}")
  1031→        lines.append("")
  1032→
  1033→    if tw:
  1034→        lines.append("### 时间窗口")
  1035→        lines.append(f"- {tw.get('value') or ''}（置信度：{tw.get('confidence') or ''}）")
  1036→        lines.append("")
  1037→
  1038→    lines.append("### 风险边界")
  1039→    lines.append(risk)
  1040→    lines.append("")
  1041→    lines.append("### 承诺")
  1042→    lines.append(commitment_ask)
  1043→
  1044→    actions = []
  1045→    for a in card.get("actions") or []:
  1046→        if not isinstance(a, dict):
  1047→            continue
  1048→        label = str(a.get("label") or "")
  1049→        payload = {"type": str(a.get("type") or "")}
  1050→        if a.get("task_id"):
  1051→            payload["task_id"] = str(a["task_id"])
  1052→        actions.append({"label": label, "action": payload})
  1053→
  1054→    return {
  1055→        "meta": {"summary": conclusion[:80] or title},
  1056→        "ui_components": [
  1057→            {"type": "markdown_text", "title": title, "data": "\n".join(lines).strip()},
  1058→            {"type": "action_buttons", "title": "下一步", "data": actions},
  1059→        ],
  1060→    }
  1061→
  1062→
  1063→# =============================================================================
  1064→# Commitment 管理
  1065→# =============================================================================
  1066→
  1067→def create_commitment(
  1068→    user_id: int,
  1069→    *,
  1070→    session_id: Optional[str] = None,
  1071→    card_id: str,
  1072→    source: str,
  1073→    commitment_type: str,
  1074→    title: str,
  1075→    details: Dict[str, Any],
  1076→    due_at: Optional[datetime] = None,
  1077→) -> str:
  1078→    """创建承诺任务"""
  1079→    task_id = str(uuid4())
  1080→    fortune_db.execute(
  1081→        """
  1082→        INSERT INTO fortune_commitment (task_id, user_id, session_id, card_id, source, commitment_type, title, details, status, due_at)
  1083→        VALUES (%s::uuid, %s, %s::uuid, %s::uuid, %s, %s, %s, %s::jsonb, 'suggested', %s)
  1084→        """,
  1085→        (
  1086→            task_id,
  1087→            int(user_id),
  1088→            session_id,
  1089→            card_id,
  1090→            source,
  1091→            commitment_type,
  1092→            (title or "")[:200],
  1093→            json.dumps(details or {}, ensure_ascii=False),
  1094→            due_at,
  1095→        ),
  1096→    )
  1097→
  1098→    logger.info(
  1099→        "commitment created",
  1100→        extra={"operation": "commitment_create", "user_id": int(user_id), "task_id": task_id, "source": source},
  1101→    )
  1102→
  1103→    return task_id
  1104→
  1105→
  1106→def accept_commitment(user_id: int, task_id: str) -> bool:
  1107→    """接受承诺"""
  1108→    result = fortune_db.execute(
  1109→        """
  1110→        UPDATE fortune_commitment
  1111→        SET status = 'active', accepted_at = NOW()
  1112→        WHERE task_id = %s::uuid AND user_id = %s AND status = 'suggested'
  1113→        """,
  1114→        (task_id, int(user_id)),
  1115→    )
  1116→
  1117→    if result > 0:
  1118→        logger.info(
  1119→            "commitment accepted",
  1120→            extra={"operation": "commitment_accept", "user_id": int(user_id), "task_id": task_id},
  1121→        )
  1122→
  1123→    return result > 0
  1124→
  1125→
  1126→def complete_commitment(user_id: int, task_id: str, note: str = "") -> Dict[str, Any]:
  1127→    """完成承诺"""
  1128→    result = fortune_db.execute(
  1129→        """
  1130→        UPDATE fortune_commitment
  1131→        SET status = 'done', done_at = NOW()
  1132→        WHERE task_id = %s::uuid AND user_id = %s AND status IN ('suggested', 'active')
  1133→        """,
  1134→        (task_id, int(user_id)),
  1135→    )
  1136→
  1137→    if result > 0:
  1138→        # 计算新的 State Score
  1139→        new_score = calculate_state_score(user_id)
  1140→
  1141→        logger.info(
  1142→            "commitment completed",
  1143→            extra={
  1144→                "operation": "commitment_complete",
  1145→                "user_id": int(user_id),
  1146→                "task_id": task_id,
  1147→                "new_score": new_score.score,
  1148→            },
  1149→        )
  1150→
  1151→        return {
  1152→            "success": True,
  1153→            "state_score": new_score.to_dict(),
  1154→            "message": "做得好！你的状态分数已更新。",
  1155→        }
  1156→
  1157→    return {"success": False, "message": "任务不存在或已完成"}
  1158→
  1159→
  1160→def list_commitments(
  1161→    user_id: int,
  1162→    *,
  1163→    status: Optional[List[str]] = None,
  1164→    limit: int = 10,
  1165→) -> List[Dict[str, Any]]:
  1166→    """列出承诺任务"""
  1167→    lim = max(1, min(50, int(limit)))
  1168→    sts = status or ["suggested", "active"]
  1169→
  1170→    rows = fortune_db.fetch_all(
  1171→        """
  1172→        SELECT task_id, status, commitment_type, title, details, source, accepted_at, due_at, done_at, created_at
  1173→        FROM fortune_commitment
  1174→        WHERE user_id = %s AND status = ANY(%s)
  1175→        ORDER BY created_at DESC
  1176→        LIMIT %s
  1177→        """,
  1178→        (int(user_id), sts, lim),
  1179→    )
  1180→
  1181→    items = []
  1182→    for r in rows or []:
  1183→        items.append({
  1184→            "task_id": str(r["task_id"]),
  1185→            "status": str(r.get("status") or ""),
  1186→            "commitment_type": str(r.get("commitment_type") or ""),
  1187→            "title": str(r.get("title") or ""),
  1188→            "details": r.get("details") or {},
  1189→            "source": str(r.get("source") or ""),
  1190→            "accepted_at": (str(r["accepted_at"]) if r.get("accepted_at") else None),
  1191→            "due_at": (str(r["due_at"]) if r.get("due_at") else None),
  1192→            "done_at": (str(r["done_at"]) if r.get("done_at") else None),
  1193→            "created_at": str(r.get("created_at") or ""),
  1194→        })
  1195→
  1196→    return items
  1197→
  1198→
  1199→# =============================================================================
  1200→# 综合接口
  1201→# =============================================================================
  1202→
  1203→def get_full_context_for_chat(user_id: int, query: str = "") -> Dict[str, Any]:
  1204→    """获取完整的对话上下文（用于 Chat API）"""
  1205→    uid = int(user_id)
  1206→
  1207→    # 用户偏好
  1208→    prefs = fortune_db.fetch_one(
  1209→        "SELECT persona_style FROM fortune_user_preferences WHERE user_id = %s",
  1210→        (uid,),
  1211→    ) or {}
  1212→    persona_style = prefs.get("persona_style", "warm")
  1213→
  1214→    # 用户上下文
  1215→    user_context = build_user_context(uid)
  1216→
  1217→    # 证据
  1218→    evidence = build_evidence(uid, query)
  1219→
  1220→    # 反依赖检查
  1221→    anti_dep = check_anti_dependency(uid, query)
  1222→
  1223→    # System Prompt
  1224→    system_prompt = build_system_prompt(uid, persona_style)
  1225→
  1226→    return {
  1227→        "system_prompt": system_prompt,
  1228→        "persona_style": persona_style,
  1229→        "user_context": user_context,
  1230→        "evidence": evidence,
  1231→        "anti_dependency": {
  1232→            "should_intervene": anti_dep.should_intervene,
  1233→            "intervention_type": anti_dep.intervention_type,
  1234→            "intervention_message": anti_dep.intervention_message,
  1235→        },
  1236→    }
  1237→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
