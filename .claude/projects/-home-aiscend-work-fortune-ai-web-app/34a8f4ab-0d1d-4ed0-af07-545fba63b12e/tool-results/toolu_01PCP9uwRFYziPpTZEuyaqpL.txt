     1→/**
     2→ * API Layer - 与后端 Soul OS API 通信
     3→ *
     4→ * 后端 API 格式: { ok: boolean, data?: T, error?: { code, message, detail } }
     5→ */
     6→
     7→const API_BASE = process.env.NEXT_PUBLIC_API_BASE || ''
     8→const BASE_PATH = '/new' // Must match next.config.ts basePath
     9→
    10→// Cookie helper
    11→function getCookie(name: string): string {
    12→  if (typeof document === 'undefined') return ''
    13→  const match = document.cookie.match(new RegExp(`(?:^|; )${name.replace(/[-.]/g, '\\$&')}=([^;]*)`))
    14→  return match ? decodeURIComponent(match[1]) : ''
    15→}
    16→
    17→// CSRF headers
    18→function csrfHeaders(): Record<string, string> {
    19→  const csrf = getCookie('fortune_csrf')
    20→  return csrf ? { 'X-CSRF-Token': csrf } : {}
    21→}
    22→
    23→// Generic API response type
    24→interface ApiResponse<T> {
    25→  ok: boolean
    26→  data?: T
    27→  error?: {
    28→    code: string
    29→    message: string
    30→    detail?: Record<string, unknown>
    31→  }
    32→}
    33→
    34→// Fetch with auth
    35→async function fetchApi<T>(
    36→  url: string,
    37→  options: RequestInit = {}
    38→): Promise<T> {
    39→  const headers: Record<string, string> = {
    40→    'Content-Type': 'application/json',
    41→    ...csrfHeaders(),
    42→    ...(options.headers as Record<string, string> || {}),
    43→  }
    44→
    45→  const res = await fetch(`${API_BASE}${url}`, {
    46→    ...options,
    47→    headers,
    48→    credentials: 'include', // Send cookies
    49→  })
    50→
    51→  const json: ApiResponse<T> = await res.json().catch(() => ({ ok: false }))
    52→
    53→  if (!res.ok || !json.ok) {
    54→    if (res.status === 401 || res.status === 403) {
    55→      // Redirect to login (with basePath)
    56→      if (typeof window !== 'undefined') {
    57→        window.location.href = '/new/login'
    58→      }
    59→      throw new Error('Unauthorized')
    60→    }
    61→    throw new Error(json.error?.message || 'Request failed')
    62→  }
    63→
    64→  return json.data as T
    65→}
    66→
    67→// =============================================================================
    68→// Dashboard API Types
    69→// =============================================================================
    70→
    71→export interface StateScore {
    72→  score: number
    73→  breakdown: {
    74→    emotion: number
    75→    action: number
    76→    streak: number
    77→  }
    78→  recovery_action: string | null
    79→}
    80→
    81→export interface PermaScore {
    82→  score: number
    83→  trend?: 'up' | 'down' | 'stable'
    84→}
    85→
    86→export interface PermaData {
    87→  positive_emotion: PermaScore
    88→  engagement: PermaScore
    89→  relationships: PermaScore
    90→  meaning: PermaScore
    91→  accomplishment: PermaScore
    92→}
    93→
    94→export interface TaskItem {
    95→  task_id: string
    96→  title: string
    97→  status: 'suggested' | 'active' | 'done' | 'skipped'
    98→  commitment_type?: 'start_task' | 'schedule_task'
    99→  minutes?: number
   100→  if_then?: string
   101→}
   102→
   103→export interface RiskAlert {
   104→  type: string
   105→  message: string
   106→}
   107→
   108→export interface OverviewData {
   109→  insight: string
   110→  state_score: StateScore
   111→  perma: PermaData
   112→  today_tasks: TaskItem[]
   113→  risk_alerts: RiskAlert[]
   114→}
   115→
   116→export interface L0Translation {
   117→  concept: string
   118→  translation: string
   119→  action: string
   120→}
   121→
   122→export interface L0Facts {
   123→  day_master: string
   124→  strength: string
   125→  translations: L0Translation[]
   126→}
   127→
   128→export interface L1Schema {
   129→  perma_snapshot: PermaData
   130→  cognitive_patterns: {
   131→    identified_schemas: string[]
   132→    reframe_count?: number
   133→  }
   134→  strengths_in_use: string[]
   135→}
   136→
   137→export interface StatusData {
   138→  l0_facts: L0Facts
   139→  l1_schema: L1Schema
   140→  state_score: StateScore
   141→}
   142→
   143→export interface TrendPoint {
   144→  date: string
   145→  score: number
   146→}
   147→
   148→export interface TrendEvent {
   149→  date: string
   150→  type: string
   151→  title: string
   152→}
   153→
   154→export interface TrendsData {
   155→  state_score_history: TrendPoint[]
   156→  events: TrendEvent[]
   157→}
   158→
   159→export interface TasksData {
   160→  active: TaskItem[]
   161→  suggested: TaskItem[]
   162→  completed_recent: TaskItem[]
   163→}
   164→
   165→export interface RelationItem {
   166→  id: string
   167→  name: string
   168→  type: string
   169→  compatibility?: number
   170→}
   171→
   172→export interface RelationsData {
   173→  relations: RelationItem[]
   174→}
   175→
   176→export interface ExploreItem {
   177→  id: string
   178→  title: string
   179→  type: 'mystic' | 'course' | 'artifact'
   180→  description?: string
   181→}
   182→
   183→export interface ExploreData {
   184→  mystic_entries: ExploreItem[]
   185→  courses: ExploreItem[]
   186→  artifacts: ExploreItem[]
   187→}
   188→
   189→export interface CheckinResponse {
   190→  insight: string
   191→  action: {
   192→    content: string
   193→    minutes: number
   194→    if_then: string
   195→  }
   196→  state_score: StateScore
   197→}
   198→
   199→// =============================================================================
   200→// Dashboard API Functions
   201→// =============================================================================
   202→
   203→export async function fetchOverview(): Promise<OverviewData> {
   204→  return fetchApi<OverviewData>('/api/dashboard/overview')
   205→}
   206→
   207→export async function fetchStatus(): Promise<StatusData> {
   208→  return fetchApi<StatusData>('/api/dashboard/status')
   209→}
   210→
   211→export async function fetchTrends(days: number = 7): Promise<TrendsData> {
   212→  return fetchApi<TrendsData>(`/api/dashboard/trends?days=${days}`)
   213→}
   214→
   215→export async function fetchTasks(): Promise<TasksData> {
   216→  return fetchApi<TasksData>('/api/dashboard/tasks')
   217→}
   218→
   219→export async function fetchRelations(): Promise<RelationsData> {
   220→  return fetchApi<RelationsData>('/api/dashboard/relations')
   221→}
   222→
   223→export async function fetchExplore(): Promise<ExploreData> {
   224→  return fetchApi<ExploreData>('/api/dashboard/explore')
   225→}
   226→
   227→// Task Actions
   228→export async function acceptTask(
   229→  taskId: string,
   230→  commitmentType: 'start_task' | 'schedule_task' = 'start_task'
   231→): Promise<{ commitment_id: string; status: string }> {
   232→  return fetchApi('/api/dashboard/task/accept', {
   233→    method: 'POST',
   234→    body: JSON.stringify({ task_id: taskId, commitment_type: commitmentType }),
   235→  })
   236→}
   237→
   238→export async function completeTask(
   239→  taskId: string,
   240→  note: string = ''
   241→): Promise<{ status: string; state_score: StateScore }> {
   242→  return fetchApi('/api/dashboard/task/done', {
   243→    method: 'POST',
   244→    body: JSON.stringify({ task_id: taskId, note }),
   245→  })
   246→}
   247→
   248→export async function skipTask(
   249→  taskId: string,
   250→  reason: string = ''
   251→): Promise<{ status: string }> {
   252→  return fetchApi('/api/dashboard/task/skip', {
   253→    method: 'POST',
   254→    body: JSON.stringify({ task_id: taskId, reason }),
   255→  })
   256→}
   257→
   258→// Checkin
   259→export async function submitCheckin(
   260→  mood: string,
   261→  intensity: number,
   262→  note: string = ''
   263→): Promise<CheckinResponse> {
   264→  return fetchApi('/api/dashboard/checkin', {
   265→    method: 'POST',
   266→    body: JSON.stringify({ mood, intensity, note }),
   267→  })
   268→}
   269→
   270→// =============================================================================
   271→// Chat API
   272→// =============================================================================
   273→
   274→// Feature flag for new Agent Runtime (Next.js)
   275→const USE_NEW_RUNTIME = process.env.NEXT_PUBLIC_USE_NEW_RUNTIME === 'true'
   276→
   277→export interface ChatMessage {
   278→  role: 'user' | 'assistant'
   279→  content: string
   280→  timestamp?: string
   281→  toolInvocations?: ToolInvocation[]
   282→}
   283→
   284→export interface ToolInvocation {
   285→  toolCallId: string
   286→  toolName: string
   287→  args: Record<string, unknown>
   288→  result?: unknown
   289→}
   290→
   291→export interface SendChatRequest {
   292→  message: string
   293→  session_id?: string
   294→  command?: string
   295→}
   296→
   297→export interface SendChatResponse {
   298→  session_id: string
   299→  reply: string
   300→  ui_components?: unknown[]
   301→  toolInvocations?: ToolInvocation[]
   302→}
   303→
   304→export async function sendChatMessage(
   305→  message: string,
   306→  sessionId?: string
   307→): Promise<SendChatResponse> {
   308→  const result = await fetchApi<{
   309→    session_id: string
   310→    assistant_message?: { role: string; a2ui?: unknown }
   311→    suggested_tasks?: unknown[]
   312→  }>('/api/chat/send', {
   313→    method: 'POST',
   314→    body: JSON.stringify({ text: message, session_id: sessionId }),
   315→  })
   316→
   317→  // Extract reply from a2ui response
   318→  const a2ui = result.assistant_message?.a2ui as { ui_components?: Array<{ type: string; data: string }> } | undefined
   319→  const markdownComponent = a2ui?.ui_components?.find(c => c.type === 'markdown_text')
   320→  const reply = markdownComponent?.data || ''
   321→
   322→  return {
   323→    session_id: result.session_id,
   324→    reply,
   325→    ui_components: a2ui?.ui_components,
   326→  }
   327→}
   328→
   329→// =============================================================================
   330→// Auth API
   331→// =============================================================================
   332→
   333→export interface LoginRequest {
   334→  email: string
   335→  password: string
   336→}
   337→
   338→export interface LoginResponse {
   339→  user_id: number
   340→  email: string
   341→}
   342→
   343→export interface RegisterRequest {
   344→  email: string
   345→  password: string
   346→  name: string
   347→  gender: string
   348→  birthday_local: string
   349→  tz_offset_hours: number
   350→  location: {
   351→    name: string
   352→    longitude: number
   353→    latitude: number
   354→  }
   355→}
   356→
   357→export interface RegisterResponse {
   358→  user_id: number
   359→  email: string
   360→  profile_summary: {
   361→    name: string
   362→    gender: string
   363→    location_name: string
   364→  }
   365→}
   366→
   367→export interface UserInfo {
   368→  user_id: number
   369→  email: string
   370→  name: string
   371→  persona_style: string
   372→}
   373→
   374→export type ChatBackend = 'agent_service' | 'fastapi'
   375→
   376→export interface UserPreferences {
   377→  persona_style: 'standard' | 'warm' | 'roast'
   378→  push_enabled: boolean
   379→  push_time: string
   380→  quiet_hours_start: string
   381→  quiet_hours_end: string
   382→  chat_backend: ChatBackend
   383→}
   384→
   385→export async function login(email: string, password: string): Promise<LoginResponse> {
   386→  const res = await fetch(`${API_BASE}/api/auth/login`, {
   387→    method: 'POST',
   388→    headers: { 'Content-Type': 'application/json' },
   389→    credentials: 'include',
   390→    body: JSON.stringify({ email, password }),
   391→  })
   392→  const json = await res.json()
   393→  if (!res.ok || !json.ok) {
   394→    throw new Error(json.error?.message || 'Login failed')
   395→  }
   396→  return json.data
   397→}
   398→
   399→export async function register(data: RegisterRequest): Promise<RegisterResponse> {
   400→  const res = await fetch(`${API_BASE}/api/auth/register`, {
   401→    method: 'POST',
   402→    headers: { 'Content-Type': 'application/json' },
   403→    credentials: 'include',
   404→    body: JSON.stringify(data),
   405→  })
   406→  const json = await res.json()
   407→  if (!res.ok || !json.ok) {
   408→    throw new Error(json.error?.message || 'Register failed')
   409→  }
   410→  return json.data
   411→}
   412→
   413→export async function logout(): Promise<void> {
   414→  await fetchApi('/api/auth/logout', { method: 'POST' })
   415→}
   416→
   417→export async function fetchMe(): Promise<UserInfo> {
   418→  return fetchApi<UserInfo>('/api/auth/me')
   419→}
   420→
   421→export async function fetchPreferences(): Promise<UserPreferences> {
   422→  return fetchApi<UserPreferences>('/api/user/preferences')
   423→}
   424→
   425→export async function updatePreferences(
   426→  patch: Partial<Pick<UserPreferences, 'persona_style' | 'push_enabled' | 'push_time' | 'quiet_hours_start' | 'quiet_hours_end' | 'chat_backend'>>
   427→): Promise<void> {
   428→  await fetchApi('/api/user/preferences', {
   429→    method: 'PUT',
   430→    body: JSON.stringify(patch),
   431→  })
   432→}
   433→
   434→// SSE Chat Stream
   435→export function streamChatMessage(
   436→  message: string,
   437→  sessionId: string | undefined,
   438→  onChunk: (chunk: string) => void,
   439→  onDone: (fullResponse: SendChatResponse) => void,
   440→  onError: (error: Error) => void
   441→): () => void {
   442→  const controller = new AbortController()
   443→
   444→  const params = new URLSearchParams({ message })
   445→  if (sessionId) params.set('session_id', sessionId)
   446→
   447→  let resolvedSessionId = sessionId || ''
   448→
   449→  fetch(`${API_BASE}/api/chat/stream?${params}`, {
   450→    method: 'GET',
   451→    credentials: 'include',
   452→    headers: csrfHeaders(),
   453→    signal: controller.signal,
   454→  })
   455→    .then(async (response) => {
   456→      if (!response.ok) {
   457→        // Backward-compatible fallback: older backends may not implement /api/chat/stream yet.
   458→        if (response.status === 404 || response.status === 405) {
   459→          const fallback = await sendChatMessage(message, sessionId)
   460→          onDone(fallback)
   461→          return
   462→        }
   463→        const errorText = await response.text().catch(() => '')
   464→        const detail = errorText ? `: ${errorText.slice(0, 200)}` : ''
   465→        throw new Error(`Stream request failed (${response.status})${detail}`)
   466→      }
   467→
   468→      const reader = response.body?.getReader()
   469→      if (!reader) throw new Error('No reader')
   470→
   471→      const decoder = new TextDecoder()
   472→      let buffer = ''
   473→      let fullContent = ''
   474→
   475→      while (true) {
   476→        const { done, value } = await reader.read()
   477→        if (done) break
   478→
   479→        buffer += decoder.decode(value, { stream: true })
   480→        const lines = buffer.split('\n')
   481→        buffer = lines.pop() || ''
   482→
   483→        for (const line of lines) {
   484→          if (line.startsWith('data: ')) {
   485→            const data = line.slice(6)
   486→            if (data === '[DONE]') {
   487→              onDone({
   488→                session_id: resolvedSessionId,
   489→                reply: fullContent,
   490→              })
   491→              return
   492→            }
   493→            try {
   494→              const json = JSON.parse(data)
   495→              if (json?.type === 'meta' && typeof json.session_id === 'string') {
   496→                resolvedSessionId = json.session_id
   497→              } else if (json?.type === 'delta' && typeof json.delta === 'string') {
   498→                fullContent += json.delta
   499→                onChunk(json.delta)
   500→              } else if (json?.type === 'final' && json.data) {
   501→                const sid = typeof json.data.session_id === 'string' ? json.data.session_id : resolvedSessionId
   502→                resolvedSessionId = sid
   503→
   504→                const a2ui = json.data?.assistant_message?.a2ui as
   505→                  | { ui_components?: Array<{ type: string; data: unknown }> }
   506→                  | undefined
   507→                const markdownComponent = a2ui?.ui_components?.find((c) => c.type === 'markdown_text')
   508→                const reply = typeof markdownComponent?.data === 'string' ? markdownComponent.data : fullContent
   509→
   510→                onDone({
   511→                  session_id: sid,
   512→                  reply,
   513→                  ui_components: a2ui?.ui_components,
   514→                })
   515→                return
   516→              } else if (json?.type === 'error' && typeof json.error === 'string') {
   517→                throw new Error(json.error)
   518→              } else if (typeof json?.content === 'string') {
   519→                // Backward-compatible: {content:"..."}
   520→                fullContent += json.content
   521→                onChunk(json.content)
   522→              }
   523→            } catch {
   524→              // Skip invalid JSON
   525→            }
   526→          }
   527→        }
   528→      }
   529→    })
   530→    .catch((err) => {
   531→      if (err.name !== 'AbortError') {
   532→        onError(err)
   533→      }
   534→    })
   535→
   536→  return () => controller.abort()
   537→}
   538→
   539→// New Agent Runtime streaming (Vercel AI SDK data stream)
   540→export function streamChatMessageNew(
   541→  message: string,
   542→  sessionId: string | undefined,
   543→  command: string | undefined,
   544→  onChunk: (chunk: string) => void,
   545→  onToolCall: (toolInvocation: ToolInvocation) => void,
   546→  onDone: (fullResponse: SendChatResponse) => void,
   547→  onError: (error: Error) => void
   548→): () => void {
   549→  const controller = new AbortController()
   550→
   551→  fetch(`${BASE_PATH}/api/chat`, {
   552→    method: 'POST',
   553→    headers: {
   554→      'Content-Type': 'application/json',
   555→    },
   556→    credentials: 'include',
   557→    body: JSON.stringify({
   558→      session_id: sessionId || null,
   559→      message,
   560→      command: command || null,
   561→    }),
   562→    signal: controller.signal,
   563→  })
   564→    .then(async (response) => {
   565→      if (!response.ok) {
   566→        const errorText = await response.text().catch(() => '')
   567→        throw new Error(`Request failed (${response.status}): ${errorText.slice(0, 200)}`)
   568→      }
   569→
   570→      // Get session info from headers
   571→      const resolvedSessionId = response.headers.get('X-Session-Id') || sessionId || ''
   572→
   573→      const reader = response.body?.getReader()
   574→      if (!reader) throw new Error('No reader')
   575→
   576→      const decoder = new TextDecoder()
   577→      let buffer = ''
   578→      let fullContent = ''
   579→      const toolInvocations: ToolInvocation[] = []
   580→
   581→      // Parse Vercel AI SDK data stream format
   582→      while (true) {
   583→        const { done, value } = await reader.read()
   584→        if (done) break
   585→
   586→        buffer += decoder.decode(value, { stream: true })
   587→        const lines = buffer.split('\n')
   588→        buffer = lines.pop() || ''
   589→
   590→        for (const line of lines) {
   591→          if (!line.trim()) continue
   592→
   593→          // Vercel AI SDK data stream format: "type:json\n"
   594→          const colonIndex = line.indexOf(':')
   595→          if (colonIndex === -1) continue
   596→
   597→          const type = line.slice(0, colonIndex)
   598→          const dataStr = line.slice(colonIndex + 1)
   599→
   600→          try {
   601→            switch (type) {
   602→              case '0': // Text chunk
   603→                const text = JSON.parse(dataStr) as string
   604→                fullContent += text
   605→                onChunk(text)
   606→                break
   607→
   608→              case '9': // Tool call
   609→                const toolCall = JSON.parse(dataStr) as {
   610→                  toolCallId: string
   611→                  toolName: string
   612→                  args: Record<string, unknown>
   613→                }
   614→                const invocation: ToolInvocation = {
   615→                  ...toolCall,
   616→                  result: undefined,
   617→                }
   618→                toolInvocations.push(invocation)
   619→                onToolCall(invocation)
   620→                break
   621→
   622→              case 'a': // Tool result
   623→                const toolResult = JSON.parse(dataStr) as {
   624→                  toolCallId: string
   625→                  result: unknown
   626→                }
   627→                const existingInvocation = toolInvocations.find(
   628→                  (t) => t.toolCallId === toolResult.toolCallId
   629→                )
   630→                if (existingInvocation) {
   631→                  existingInvocation.result = toolResult.result
   632→                  onToolCall(existingInvocation)
   633→                }
   634→                break
   635→
   636→              case 'd': // Finish message
   637→                // Stream complete
   638→                break
   639→
   640→              case 'e': // Error
   641→                const error = JSON.parse(dataStr)
   642→                throw new Error(error.message || 'Stream error')
   643→
   644→              default:
   645→                // Unknown type, skip
   646→                break
   647→            }
   648→          } catch (parseError) {
   649→            console.warn('[chat] Failed to parse stream data:', line)
   650→          }
   651→        }
   652→      }
   653→
   654→      // Stream complete
   655→      onDone({
   656→        session_id: resolvedSessionId,
   657→        reply: fullContent,
   658→        toolInvocations: toolInvocations.length > 0 ? toolInvocations : undefined,
   659→      })
   660→    })
   661→    .catch((err) => {
   662→      if (err.name !== 'AbortError') {
   663→        onError(err)
   664→      }
   665→    })
   666→
   667→  return () => controller.abort()
   668→}
   669→
   670→// Smart stream function that picks the right implementation
   671→export function streamChat(
   672→  message: string,
   673→  sessionId: string | undefined,
   674→  options: {
   675→    command?: string
   676→    onChunk: (chunk: string) => void
   677→    onToolCall?: (toolInvocation: ToolInvocation) => void
   678→    onDone: (fullResponse: SendChatResponse) => void
   679→    onError: (error: Error) => void
   680→  }
   681→): () => void {
   682→  if (USE_NEW_RUNTIME) {
   683→    return streamChatMessageNew(
   684→      message,
   685→      sessionId,
   686→      options.command,
   687→      options.onChunk,
   688→      options.onToolCall || (() => {}),
   689→      options.onDone,
   690→      options.onError
   691→    )
   692→  } else {
   693→    return streamChatMessage(
   694→      message,
   695→      sessionId,
   696→      options.onChunk,
   697→      options.onDone,
   698→      options.onError
   699→    )
   700→  }
   701→}
   702→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
