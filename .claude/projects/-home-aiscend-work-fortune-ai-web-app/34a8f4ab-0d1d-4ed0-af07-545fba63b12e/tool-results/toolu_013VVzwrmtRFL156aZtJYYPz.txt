The file /home/aiscend/work/fortune_ai/web-app/src/lib/api.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   537→
   538→  return () => controller.abort()
   539→}
   540→
   541→// New Agent Runtime streaming (Vercel AI SDK 6.0 UI Message Stream)
   542→export function streamChatMessageNew(
   543→  message: string,
   544→  sessionId: string | undefined,
   545→  command: string | undefined,
   546→  onChunk: (chunk: string) => void,
   547→  onToolCall: (toolInvocation: ToolInvocation) => void,
   548→  onDone: (fullResponse: SendChatResponse) => void,
   549→  onError: (error: Error) => void
   550→): () => void {
   551→  const controller = new AbortController()
   552→
   553→  // Use async IIFE to handle async/await properly
   554→  ;(async () => {
   555→    try {
   556→      const response = await fetch(`${BASE_PATH}/api/chat`, {
   557→        method: 'POST',
   558→        headers: {
   559→          'Content-Type': 'application/json',
   560→        },
   561→        credentials: 'include',
   562→        body: JSON.stringify({
   563→          session_id: sessionId || null,
   564→          message,
   565→          command: command || null,
   566→        }),
   567→        signal: controller.signal,
   568→      })
   569→
   570→      if (!response.ok) {
   571→        const errorText = await response.text().catch(() => '')
   572→        throw new Error(`Request failed (${response.status}): ${errorText.slice(0, 200)}`)
   573→      }
   574→
   575→      // Get session info from headers
   576→      const resolvedSessionId = response.headers.get('X-Session-Id') || sessionId || ''
   577→
   578→      if (!response.body) {
   579→        throw new Error('No response body')
   580→      }
   581→
   582→      let fullContent = ''
   583→      const toolInvocations: ToolInvocation[] = []
   584→
   585→      // Use AI SDK 6.0 official stream parser
   586→      const stream = parseUIMessageStream(response.body)
   587→
   588→      for await (const part of stream) {
   589→        switch (part.type) {
   590→          case 'text':
   591→            // Text chunk from streaming
   592→            fullContent += part.text
   593→            onChunk(part.text)
   594→            break
   595→
   596→          case 'tool-invocation':
   597→            // Tool call with optional result
   598→            const invocation: ToolInvocation = {
   599→              toolCallId: part.toolInvocation.toolCallId,
   600→              toolName: part.toolInvocation.toolName,
   601→              args: part.toolInvocation.args as Record<string, unknown>,
   602→              result: part.toolInvocation.result,
   603→            }
   604→            // Update existing or add new
   605→            const existingIdx = toolInvocations.findIndex(
   606→              (t) => t.toolCallId === invocation.toolCallId
   607→            )
   608→            if (existingIdx >= 0) {
   609→              toolInvocations[existingIdx] = invocation
   610→            } else {
   611→              toolInvocations.push(invocation)
   612→            }
   613→            onToolCall(invocation)
   614→            break
   615→
   616→          case 'message':
   617→            // Complete message - extract text content
   618→            const msg = part.message as UIMessage
   619→            if (msg.role === 'assistant') {
   620→              // Extract text from parts if available
   621→              const textParts = msg.parts?.filter((p) => p.type === 'text') || []
   622→              for (const textPart of textParts) {
   623→                if ('text' in textPart && textPart.text) {
   624→                  // Only update if we haven't accumulated this text yet
   625→                  if (!fullContent.includes(textPart.text)) {
   626→                    fullContent = textPart.text
   627→                  }
   628→                }
   629→              }
   630→            }
   631→            break
   632→
   633→          case 'error':
   634→            throw new Error(part.error)
   635→        }
   636→      }
   637→
   638→      // Stream complete
   639→      onDone({
   640→        session_id: resolvedSessionId,
   641→        reply: fullContent,
   642→        toolInvocations: toolInvocations.length > 0 ? toolInvocations : undefined,
   643→      })
   644→    } catch (err) {
   645→      if ((err as Error).name !== 'AbortError') {
   646→        onError(err as Error)
   647→      }
   648→    }
   649→  })()
   650→
   651→  return () => controller.abort()
   652→}
   653→
   654→// Smart stream function that picks the right implementation
   655→export function streamChat(
   656→  message: string,