     1→"""
     2→Digital Twin Service.
     3→
     4→REQ: REQ-TWIN-001 ~ REQ-TWIN-005
     5→Design: §3.1.1 ~ §3.1.3
     6→HOS-REF: §1.2, §1.3, §10.5.2
     7→"""
     8→
     9→from __future__ import annotations
    10→
    11→import json
    12→from datetime import datetime, timezone
    13→from typing import Any, Dict, List, Optional, Tuple
    14→
    15→from common.logging import get_logger
    16→from models.twin import (
    17→    DimensionScores,
    18→    TwinData,
    19→    TwinHistoryEntry,
    20→    TwinHistoryResponse,
    21→    TwinLayer,
    22→    TwinUpdateEvent,
    23→    TwinUpdateResult,
    24→)
    25→from stores import fortune_db
    26→
    27→logger = get_logger(__name__)
    28→
    29→
    30→class TwinServiceError(Exception):
    31→    """Base exception for twin service errors."""
    32→    pass
    33→
    34→
    35→class TwinNotFoundError(TwinServiceError):
    36→    """Twin not found for user."""
    37→    pass
    38→
    39→
    40→def _now_utc() -> datetime:
    41→    return datetime.now(timezone.utc)
    42→
    43→
    44→def _row_to_twin(row: Dict[str, Any]) -> TwinData:
    45→    """Convert database row to TwinData model."""
    46→    dimension_scores_raw = row.get("dimension_scores") or {}
    47→    if isinstance(dimension_scores_raw, str):
    48→        dimension_scores_raw = json.loads(dimension_scores_raw)
    49→
    50→    return TwinData(
    51→        twin_id=row.get("twin_id"),
    52→        user_id=row["user_id"],
    53→        metadata_astrology=row.get("metadata_astrology") or {},
    54→        metadata_psychology=row.get("metadata_psychology") or {},
    55→        metadata_memory=row.get("metadata_memory") or {},
    56→        dynamic_astro=row.get("dynamic_astro") or {},
    57→        dynamic_bio=row.get("dynamic_bio") or {},
    58→        dynamic_social=row.get("dynamic_social") or {},
    59→        dynamic_emotional=row.get("dynamic_emotional") or {},
    60→        aura_points=row.get("aura_points") or 0,
    61→        overall_wellbeing=float(row.get("overall_wellbeing") or 50.0),
    62→        growth_streak=row.get("growth_streak") or 0,
    63→        dimension_scores=DimensionScores(**dimension_scores_raw),
    64→        compute_version=row.get("compute_version") or "v1.0",
    65→        last_full_refresh=row.get("last_full_refresh"),
    66→        created_at=row.get("created_at"),
    67→        updated_at=row.get("updated_at"),
    68→    )
    69→
    70→
    71→def _get_bazi_data_for_user(user_id: int) -> Dict[str, Any]:
    72→    """
    73→    Fetch bazi snapshot data for user.
    74→    Returns empty dict if no bazi data exists.
    75→    """
    76→    row = fortune_db.fetch_one(
    77→        """
    78→        SELECT facts, facts_hash, compute_version
    79→        FROM fortune_bazi_snapshot
    80→        WHERE user_id = %s
    81→        ORDER BY created_at DESC
    82→        LIMIT 1
    83→        """,
    84→        [user_id],
    85→    )
    86→    if not row:
    87→        return {}
    88→
    89→    facts = row.get("facts") or {}
    90→    if isinstance(facts, str):
    91→        facts = json.loads(facts)
    92→
    93→    return {
    94→        "bazi": facts,
    95→        "facts_hash": row.get("facts_hash"),
    96→        "compute_version": row.get("compute_version"),
    97→    }
    98→
    99→
   100→# =============================================================================
   101→# TASK-1.2.1: create_twin
   102→# =============================================================================
   103→
   104→def create_twin(user_id: int) -> TwinData:
   105→    """
   106→    Create a new digital twin for user.
   107→
   108→    REQ: REQ-TWIN-001
   109→    Design: §3.1.1 步骤 1-3
   110→
   111→    - Idempotent: returns existing twin if already exists
   112→    - Syncs bazi data from fortune_bazi_snapshot to L1
   113→    - Initializes all default values
   114→    """
   115→    # Check if twin already exists (idempotent)
   116→    existing = fortune_db.fetch_one(
   117→        "SELECT * FROM fortune_digital_twin WHERE user_id = %s",
   118→        [user_id],
   119→    )
   120→    if existing:
   121→        logger.debug("twin_exists user_id=%s twin_id=%s", user_id, existing["twin_id"])
   122→        return _row_to_twin(existing)
   123→
   124→    # Fetch bazi data for L1 metadata
   125→    bazi_data = _get_bazi_data_for_user(user_id)
   126→
   127→    # Initialize default dimension scores
   128→    default_dimensions = {
   129→        "energy": 50,
   130→        "clarity": 50,
   131→        "connection": 50,
   132→        "growth": 50,
   133→        "balance": 50,
   134→    }
   135→
   136→    # Insert new twin
   137→    row = fortune_db.execute_returning_one(
   138→        """
   139→        INSERT INTO fortune_digital_twin (
   140→            user_id,
   141→            metadata_astrology,
   142→            metadata_psychology,
   143→            metadata_memory,
   144→            dynamic_astro,
   145→            dynamic_bio,
   146→            dynamic_social,
   147→            dynamic_emotional,
   148→            aura_points,
   149→            overall_wellbeing,
   150→            growth_streak,
   151→            dimension_scores,
   152→            compute_version,
   153→            created_at,
   154→            updated_at
   155→        ) VALUES (
   156→            %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
   157→        )
   158→        RETURNING *
   159→        """,
   160→        [
   161→            user_id,
   162→            json.dumps(bazi_data),  # metadata_astrology
   163→            json.dumps({}),  # metadata_psychology
   164→            json.dumps({}),  # metadata_memory
   165→            json.dumps({}),  # dynamic_astro
   166→            json.dumps({}),  # dynamic_bio
   167→            json.dumps({}),  # dynamic_social
   168→            json.dumps({}),  # dynamic_emotional
   169→            0,  # aura_points
   170→            50.0,  # overall_wellbeing
   171→            0,  # growth_streak
   172→            json.dumps(default_dimensions),  # dimension_scores
   173→            "v1.0",  # compute_version
   174→            _now_utc(),  # created_at
   175→            _now_utc(),  # updated_at
   176→        ],
   177→    )
   178→
   179→    if not row:
   180→        raise TwinServiceError(f"Failed to create twin for user {user_id}")
   181→
   182→    logger.info("twin_created user_id=%s twin_id=%s", user_id, row["twin_id"])
   183→    return _row_to_twin(row)
   184→
   185→
   186→# =============================================================================
   187→# TASK-1.2.2: get_twin
   188→# =============================================================================
   189→
   190→def get_twin(
   191→    user_id: int,
   192→    layers: Optional[List[TwinLayer]] = None,
   193→    auto_create: bool = True,
   194→) -> TwinData:
   195→    """
   196→    Get digital twin for user.
   197→
   198→    REQ: REQ-TWIN-002
   199→    Design: §3.1.2 步骤 1-3
   200→
   201→    Args:
   202→        user_id: User ID
   203→        layers: Optional list of layers to include (default: all)
   204→        auto_create: If True, create twin if not exists
   205→
   206→    Returns:
   207→        TwinData with requested layers
   208→    """
   209→    row = fortune_db.fetch_one(
   210→        "SELECT * FROM fortune_digital_twin WHERE user_id = %s",
   211→        [user_id],
   212→    )
   213→
   214→    if not row:
   215→        if auto_create:
   216→            logger.debug("twin_auto_create user_id=%s", user_id)
   217→            return create_twin(user_id)
   218→        raise TwinNotFoundError(f"Twin not found for user {user_id}")
   219→
   220→    twin = _row_to_twin(row)
   221→    logger.debug("twin_query user_id=%s twin_id=%s", user_id, twin.twin_id)
   222→    return twin
   223→
   224→
   225→def get_twin_by_layer(
   226→    user_id: int,
   227→    layer: str,
   228→    auto_create: bool = True,
   229→) -> Dict[str, Any]:
   230→    """
   231→    Get specific layer data for user's twin.
   232→
   233→    Args:
   234→        user_id: User ID
   235→        layer: Layer name ('L1', 'L2', 'L3', or 'all')
   236→        auto_create: If True, create twin if not exists
   237→
   238→    Returns:
   239→        Dict with layer data
   240→    """
   241→    twin = get_twin(user_id, auto_create=auto_create)
   242→
   243→    if layer == "all":
   244→        return twin.model_dump()
   245→    elif layer == "L1":
   246→        return twin.get_layer(TwinLayer.L1)
   247→    elif layer == "L2":
   248→        return twin.get_layer(TwinLayer.L2)
   249→    elif layer == "L3":
   250→        return twin.get_layer(TwinLayer.L3)
   251→    else:
   252→        raise ValueError(f"Invalid layer: {layer}")
   253→
   254→
   255→# =============================================================================
   256→# TASK-1.2.3: update_twin
   257→# =============================================================================
   258→
   259→def _parse_json_path(path: str) -> Tuple[str, List[str]]:
   260→    """
   261→    Parse JSON path to column name and path parts.
   262→
   263→    Example:
   264→        'dynamic_emotional.current_mood' -> ('dynamic_emotional', ['current_mood'])
   265→        'metadata_astrology.bazi.day_master' -> ('metadata_astrology', ['bazi', 'day_master'])
   266→    """
   267→    parts = path.split(".")
   268→    if not parts:
   269→        raise ValueError(f"Invalid path: {path}")
   270→
   271→    column = parts[0]
   272→    path_parts = parts[1:] if len(parts) > 1 else []
   273→
   274→    # Validate column name
   275→    valid_columns = {
   276→        "metadata_astrology", "metadata_psychology", "metadata_memory",
   277→        "dynamic_astro", "dynamic_bio", "dynamic_social", "dynamic_emotional",
   278→        "dimension_scores",
   279→    }
   280→    if column not in valid_columns:
   281→        raise ValueError(f"Invalid column in path: {column}")
   282→
   283→    return column, path_parts
   284→
   285→
   286→def _get_nested_value(data: Dict[str, Any], path_parts: List[str]) -> Any:
   287→    """Get nested value from dict using path parts."""
   288→    current = data
   289→    for part in path_parts:
   290→        if isinstance(current, dict):
   291→            current = current.get(part)
   292→        else:
   293→            return None
   294→    return current
   295→
   296→
   297→def _set_nested_value(data: Dict[str, Any], path_parts: List[str], value: Any) -> Dict[str, Any]:
   298→    """Set nested value in dict using path parts. Returns new dict."""
   299→    if not path_parts:
   300→        return value if isinstance(value, dict) else data
   301→
   302→    result = dict(data)
   303→    current = result
   304→
   305→    for i, part in enumerate(path_parts[:-1]):
   306→        if part not in current or not isinstance(current[part], dict):
   307→            current[part] = {}
   308→        current[part] = dict(current[part])
   309→        current = current[part]
   310→
   311→    current[path_parts[-1]] = value
   312→    return result
   313→
   314→
   315→def update_twin(event: TwinUpdateEvent) -> TwinUpdateResult:
   316→    """
   317→    Update digital twin data.
   318→
   319→    REQ: REQ-TWIN-003
   320→    Design: §3.1.3 步骤 1-5
   321→
   322→    - Uses transaction for atomicity
   323→    - Supports nested path updates via jsonb_set
   324→    - Records old_value and new_value in log
   325→    - Triggers L3 recalculation if L2 is updated
   326→    """
   327→    user_id = event.user_id
   328→    column, path_parts = _parse_json_path(event.path)
   329→
   330→    # Get current twin
   331→    row = fortune_db.fetch_one(
   332→        "SELECT * FROM fortune_digital_twin WHERE user_id = %s FOR UPDATE",
   333→        [user_id],
   334→    )
   335→    if not row:
   336→        # Auto-create twin if not exists
   337→        twin = create_twin(user_id)
   338→        row = fortune_db.fetch_one(
   339→            "SELECT * FROM fortune_digital_twin WHERE user_id = %s FOR UPDATE",
   340→            [user_id],
   341→        )
   342→
   343→    twin_id = row["twin_id"]
   344→
   345→    # Get current column value
   346→    current_data = row.get(column) or {}
   347→    if isinstance(current_data, str):
   348→        current_data = json.loads(current_data)
   349→
   350→    # Get old value
   351→    old_value = _get_nested_value(current_data, path_parts) if path_parts else current_data
   352→
   353→    # Set new value
   354→    if path_parts:
   355→        new_data = _set_nested_value(current_data, path_parts, event.new_value)
   356→    else:
   357→        new_data = event.new_value if isinstance(event.new_value, dict) else current_data
   358→
   359→    # Update database
   360→    fortune_db.execute(
   361→        f"""
   362→        UPDATE fortune_digital_twin
   363→        SET {column} = %s, updated_at = %s
   364→        WHERE twin_id = %s
   365→        """,
   366→        [json.dumps(new_data), _now_utc(), twin_id],
   367→    )
   368→
   369→    # Write update log
   370→    log_row = fortune_db.execute_returning_one(
   371→        """
   372→        INSERT INTO fortune_twin_update_log (
   373→            twin_id, trigger_type, layer, path, old_value, new_value,
   374→            confidence, source, created_at
   375→        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
   376→        RETURNING log_id
   377→        """,
   378→        [
   379→            twin_id,
   380→            event.trigger,
   381→            event.layer.value,
   382→            event.path,
   383→            json.dumps(old_value) if old_value is not None else None,
   384→            json.dumps(event.new_value),
   385→            event.confidence,
   386→            event.source,
   387→            _now_utc(),
   388→        ],
   389→    )
   390→
   391→    log_id = log_row["log_id"] if log_row else None
   392→
   393→    # Trigger L3 recalculation if L2 was updated
   394→    dimensions_recalculated = False
   395→    if event.layer == TwinLayer.L2:
   396→        recalculate_dimensions(user_id)
   397→        dimensions_recalculated = True
   398→
   399→    logger.info(
   400→        "twin_update user_id=%s twin_id=%s path=%s layer=%s trigger=%s",
   401→        user_id, twin_id, event.path, event.layer.value, event.trigger
   402→    )
   403→
   404→    return TwinUpdateResult(
   405→        updated=True,
   406→        log_id=log_id,
   407→        old_value=old_value,
   408→        new_value=event.new_value,
   409→        dimensions_recalculated=dimensions_recalculated,
   410→    )
   411→
   412→
   413→# =============================================================================
   414→# TASK-1.2.4: recalculate_dimensions
   415→# =============================================================================
   416→
   417→def recalculate_dimensions(user_id: int) -> DimensionScores:
   418→    """
   419→    Recalculate L3 dimension scores from L2 data.
   420→
   421→    REQ: REQ-TWIN-004
   422→    Design: §3.1.3 步骤 4
   423→
   424→    Dimension formulas:
   425→    - energy: f(mood_intensity, sleep_score, activity_level)
   426→    - clarity: f(focus_score, stress_level, meditation_minutes)
   427→    - connection: f(social_interactions, buffs_received, relationship_quality)
   428→    - growth: f(commitments_completed, streak, learning_activities)
   429→    - balance: f(work_life_ratio, emotional_stability, routine_adherence)
   430→    """
   431→    row = fortune_db.fetch_one(
   432→        """
   433→        SELECT dynamic_bio, dynamic_social, dynamic_emotional,
   434→               aura_points, growth_streak
   435→        FROM fortune_digital_twin
   436→        WHERE user_id = %s
   437→        """,
   438→        [user_id],
   439→    )
   440→
   441→    if not row:
   442→        raise TwinNotFoundError(f"Twin not found for user {user_id}")
   443→
   444→    # Parse L2 data
   445→    bio = row.get("dynamic_bio") or {}
   446→    social = row.get("dynamic_social") or {}
   447→    emotional = row.get("dynamic_emotional") or {}
   448→    aura = row.get("aura_points") or 0
   449→    streak = row.get("growth_streak") or 0
   450→
   451→    if isinstance(bio, str):
   452→        bio = json.loads(bio)
   453→    if isinstance(social, str):
   454→        social = json.loads(social)
   455→    if isinstance(emotional, str):
   456→        emotional = json.loads(emotional)
   457→
   458→    # Calculate energy dimension
   459→    mood_intensity = emotional.get("mood_intensity", 5)
   460→    sleep_score = bio.get("sleep_score", 50)
   461→    activity_level = bio.get("activity_level", 50)
   462→    energy = (mood_intensity * 5 + sleep_score * 0.3 + activity_level * 0.2)
   463→    energy = max(0, min(100, energy))
   464→
   465→    # Calculate clarity dimension
   466→    focus_score = emotional.get("focus_score", 50)
   467→    stress_level = emotional.get("stress_level", 50)
   468→    meditation_minutes = bio.get("meditation_minutes", 0)
   469→    clarity = focus_score * 0.4 + (100 - stress_level) * 0.4 + min(meditation_minutes, 30) * 0.67
   470→    clarity = max(0, min(100, clarity))
   471→
   472→    # Calculate connection dimension
   473→    social_interactions = social.get("interactions_today", 0)
   474→    buffs_received = social.get("recent_buffs_received", 0)
   475→    relationship_quality = social.get("relationship_quality", 50)
   476→    connection = min(social_interactions * 5, 30) + min(buffs_received * 10, 30) + relationship_quality * 0.4
   477→    connection = max(0, min(100, connection))
   478→
   479→    # Calculate growth dimension
   480→    commitments_completed = social.get("commitments_completed_week", 0)
   481→    learning_activities = bio.get("learning_activities", 0)
   482→    growth = min(commitments_completed * 10, 40) + min(streak * 2, 30) + min(learning_activities * 5, 30)
   483→    growth = max(0, min(100, growth))
   484→
   485→    # Calculate balance dimension
   486→    work_life_ratio = bio.get("work_life_ratio", 50)
   487→    emotional_stability = 100 - abs(emotional.get("mood_volatility", 0))
   488→    routine_adherence = bio.get("routine_adherence", 50)
   489→    balance = work_life_ratio * 0.3 + emotional_stability * 0.4 + routine_adherence * 0.3
   490→    balance = max(0, min(100, balance))
   491→
   492→    # Create dimension scores
   493→    scores = DimensionScores(
   494→        energy=energy,
   495→        clarity=clarity,
   496→        connection=connection,
   497→        growth=growth,
   498→        balance=balance,
   499→    )
   500→
   501→    # Calculate overall wellbeing
   502→    overall = (energy + clarity + connection + growth + balance) / 5
   503→
   504→    # Update database
   505→    fortune_db.execute(
   506→        """
   507→        UPDATE fortune_digital_twin
   508→        SET dimension_scores = %s,
   509→            overall_wellbeing = %s,
   510→            updated_at = %s
   511→        WHERE user_id = %s
   512→        """,
   513→        [json.dumps(scores.model_dump()), overall, _now_utc(), user_id],
   514→    )
   515→
   516→    logger.debug("dimension_recalc user_id=%s scores=%s", user_id, scores.model_dump())
   517→    return scores
   518→
   519→
   520→# =============================================================================
   521→# Additional helpers
   522→# =============================================================================
   523→
   524→def get_twin_history(
   525→    user_id: int,
   526→    limit: int = 20,
   527→    offset: int = 0,
   528→    trigger_type: Optional[str] = None,
   529→    layer: Optional[TwinLayer] = None,
   530→) -> TwinHistoryResponse:
   531→    """
   532→    Get twin update history.
   533→
   534→    REQ: REQ-TWIN-005
   535→    Design: §3.1 (扩展)
   536→    """
   537→    # Get twin_id
   538→    twin_row = fortune_db.fetch_one(
   539→        "SELECT twin_id FROM fortune_digital_twin WHERE user_id = %s",
   540→        [user_id],
   541→    )
   542→    if not twin_row:
   543→        return TwinHistoryResponse(entries=[], total_count=0, limit=limit, offset=offset)
   544→
   545→    twin_id = twin_row["twin_id"]
   546→
   547→    # Build query
   548→    conditions = ["twin_id = %s"]
   549→    params: List[Any] = [twin_id]
   550→
   551→    if trigger_type:
   552→        conditions.append("trigger_type = %s")
   553→        params.append(trigger_type)
   554→
   555→    if layer:
   556→        conditions.append("layer = %s")
   557→        params.append(layer.value)
   558→
   559→    where_clause = " AND ".join(conditions)
   560→
   561→    # Get total count
   562→    count_row = fortune_db.fetch_one(
   563→        f"SELECT COUNT(*) as cnt FROM fortune_twin_update_log WHERE {where_clause}",
   564→        params,
   565→    )
   566→    total_count = count_row["cnt"] if count_row else 0
   567→
   568→    # Get entries
   569→    params.extend([limit, offset])
   570→    rows = fortune_db.fetch_all(
   571→        f"""
   572→        SELECT * FROM fortune_twin_update_log
   573→        WHERE {where_clause}
   574→        ORDER BY created_at DESC
   575→        LIMIT %s OFFSET %s
   576→        """,
   577→        params,
   578→    )
   579→
   580→    entries = []
   581→    for row in rows:
   582→        old_val = row.get("old_value")
   583→        new_val = row.get("new_value")
   584→        if isinstance(old_val, str):
   585→            old_val = json.loads(old_val)
   586→        if isinstance(new_val, str):
   587→            new_val = json.loads(new_val)
   588→
   589→        entries.append(TwinHistoryEntry(
   590→            log_id=row["log_id"],
   591→            trigger_type=row["trigger_type"],
   592→            layer=TwinLayer(row["layer"]),
   593→            path=row["path"],
   594→            old_value=old_val,
   595→            new_value=new_val,
   596→            confidence=float(row["confidence"]),
   597→            source=row["source"],
   598→            created_at=row["created_at"],
   599→        ))
   600→
   601→    return TwinHistoryResponse(
   602→        entries=entries,
   603→        total_count=total_count,
   604→        limit=limit,
   605→        offset=offset,
   606→    )
   607→
   608→
   609→def sync_bazi_to_twin(user_id: int) -> bool:
   610→    """
   611→    Sync latest bazi snapshot to twin's L1 metadata.
   612→
   613→    Called when bazi data is updated.
   614→    """
   615→    bazi_data = _get_bazi_data_for_user(user_id)
   616→    if not bazi_data:
   617→        return False
   618→
   619→    # Check if twin exists
   620→    row = fortune_db.fetch_one(
   621→        "SELECT twin_id FROM fortune_digital_twin WHERE user_id = %s",
   622→        [user_id],
   623→    )
   624→
   625→    if not row:
   626→        # Create twin with bazi data
   627→        create_twin(user_id)
   628→        return True
   629→
   630→    # Update existing twin
   631→    fortune_db.execute(
   632→        """
   633→        UPDATE fortune_digital_twin
   634→        SET metadata_astrology = %s, updated_at = %s
   635→        WHERE user_id = %s
   636→        """,
   637→        [json.dumps(bazi_data), _now_utc(), user_id],
   638→    )
   639→
   640→    logger.info("bazi_synced_to_twin user_id=%s", user_id)
   641→    return True
   642→
   643→
   644→def increment_aura(user_id: int, amount: int, reason: str = "action") -> int:
   645→    """
   646→    Increment user's aura points.
   647→
   648→    Returns new aura total.
   649→    """
   650→    row = fortune_db.execute_returning_one(
   651→        """
   652→        UPDATE fortune_digital_twin
   653→        SET aura_points = aura_points + %s, updated_at = %s
   654→        WHERE user_id = %s
   655→        RETURNING aura_points
   656→        """,
   657→        [amount, _now_utc(), user_id],
   658→    )
   659→
   660→    if not row:
   661→        # Create twin first
   662→        twin = create_twin(user_id)
   663→        row = fortune_db.execute_returning_one(
   664→            """
   665→            UPDATE fortune_digital_twin
   666→            SET aura_points = aura_points + %s, updated_at = %s
   667→            WHERE user_id = %s
   668→            RETURNING aura_points
   669→            """,
   670→            [amount, _now_utc(), user_id],
   671→        )
   672→
   673→    new_aura = row["aura_points"] if row else 0
   674→    logger.debug("aura_increment user_id=%s amount=%s new_total=%s reason=%s", user_id, amount, new_aura, reason)
   675→    return new_aura
   676→
   677→
   678→def increment_growth_streak(user_id: int) -> int:
   679→    """
   680→    Increment user's growth streak.
   681→
   682→    Returns new streak count.
   683→    """
   684→    row = fortune_db.execute_returning_one(
   685→        """
   686→        UPDATE fortune_digital_twin
   687→        SET growth_streak = growth_streak + 1, updated_at = %s
   688→        WHERE user_id = %s
   689→        RETURNING growth_streak
   690→        """,
   691→        [_now_utc(), user_id],
   692→    )
   693→
   694→    if not row:
   695→        twin = create_twin(user_id)
   696→        return 1
   697→
   698→    return row["growth_streak"]
   699→
   700→
   701→def reset_growth_streak(user_id: int) -> None:
   702→    """Reset user's growth streak to 0."""
   703→    fortune_db.execute(
   704→        """
   705→        UPDATE fortune_digital_twin
   706→        SET growth_streak = 0, updated_at = %s
   707→        WHERE user_id = %s
   708→        """,
   709→        [_now_utc(), user_id],
   710→    )
   711→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
