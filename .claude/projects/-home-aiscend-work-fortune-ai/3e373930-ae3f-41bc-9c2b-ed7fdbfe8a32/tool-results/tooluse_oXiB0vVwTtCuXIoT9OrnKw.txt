The file /home/aiscend/work/fortune_ai/stores/fortune_db.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   136→        cur.execute(sql, tuple(params or []))
   137→        return int(cur.rowcount or 0)
   138→
   139→
   140→def execute_returning_one(sql: str, params: Sequence[Any] | None = None) -> Optional[Dict[str, Any]]:
   141→    with db_cursor(dict_cursor=True) as cur:
   142→        cur.execute(sql, tuple(params or []))
   143→        row = cur.fetchone()
   144→        return dict(row) if row else None
   145→
   146→
   147→# =============================================================================
   148→# Transaction Context for Multi-Step Atomic Operations
   149→# =============================================================================
   150→
   151→class TransactionContext:
   152→    """
   153→    事务上下文，支持多步操作原子化。
   154→
   155→    用于解决 FOR UPDATE 锁在独立事务中立即释放的问题。
   156→    所有操作在同一个数据库连接和事务中执行。
   157→
   158→    Usage:
   159→        with fortune_db.transaction() as tx:
   160→            row = tx.fetch_one("SELECT * FROM t WHERE id = %s FOR UPDATE", [id])
   161→            tx.execute("UPDATE t SET x = %s WHERE id = %s", [new_val, id])
   162→            tx.execute_returning_one("INSERT INTO log (...) RETURNING id", [...])
   163→            # 退出 with 块时自动 commit，异常时自动 rollback
   164→    """
   165→
   166→    def __init__(self, cursor):
   167→        self._cur = cursor
   168→
   169→    def fetch_one(self, sql: str, params: Sequence[Any] | None = None) -> Optional[Dict[str, Any]]:
   170→        """Execute query and return single row as dict."""
   171→        self._cur.execute(sql, tuple(params or []))
   172→        row = self._cur.fetchone()
   173→        return dict(row) if row else None
   174→
   175→    def fetch_all(self, sql: str, params: Sequence[Any] | None = None) -> List[Dict[str, Any]]:
   176→        """Execute query and return all rows as list of dicts."""
   177→        self._cur.execute(sql, tuple(params or []))
   178→        rows = self._cur.fetchall() or []
   179→        return [dict(r) for r in rows]
   180→
   181→    def execute(self, sql: str, params: Sequence[Any] | None = None) -> int:
   182→        """Execute statement and return affected row count."""
   183→        self._cur.execute(sql, tuple(params or []))
   184→        return int(self._cur.rowcount or 0)
   185→
   186→    def execute_returning_one(self, sql: str, params: Sequence[Any] | None = None) -> Optional[Dict[str, Any]]:
   187→        """Execute statement with RETURNING and return single row."""
   188→        self._cur.execute(sql, tuple(params or []))
   189→        row = self._cur.fetchone()
   190→        return dict(row) if row else None
   191→
   192→    def execute_many(self, sql: str, params_list: Iterable[Sequence[Any]]) -> int:
   193→        """Execute statement for multiple parameter sets."""
   194→        total = 0
   195→        for params in params_list:
   196→            self._cur.execute(sql, tuple(params))
   197→            total += int(self._cur.rowcount or 0)
   198→        return total
   199→
   200→
   201→@contextmanager
   202→def transaction():
   203→    """
   204→    事务上下文管理器，用于多步原子操作。
   205→
   206→    解决问题：
   207→    - fetch_one/execute 等函数每次调用都是独立事务
   208→    - FOR UPDATE 锁在函数返回时立即释放
   209→    - 多步操作无法保证原子性
   210→
   211→    使用场景：
   212→    - twin_service.update_twin(): SELECT FOR UPDATE + UPDATE + INSERT log
   213→    - currency_service.add_currency(): UPDATE balance + INSERT ledger
   214→    - social_service.join_luck_chain(): SELECT FOR UPDATE + INSERT + UPDATE count
   215→
   216→    Example:
   217→        with fortune_db.transaction() as tx:
   218→            # 所有操作在同一事务中
   219→            row = tx.fetch_one("SELECT * FROM t WHERE id = %s FOR UPDATE", [id])
   220→            if row:
   221→                tx.execute("UPDATE t SET val = %s WHERE id = %s", [new_val, id])
   222→            # 退出时自动 commit
   223→    """
   224→    with db_conn() as conn:
   225→        cur = conn.cursor(cursor_factory=RealDictCursor)
   226→        try:
   227→            yield TransactionContext(cur)
   228→            conn.commit()
   229→        except Exception:
   230→            try:
   231→                conn.rollback()
   232→            except Exception:
   233→                pass
   234→            raise
   235→        finally:
   236→            cur.close()
   237→