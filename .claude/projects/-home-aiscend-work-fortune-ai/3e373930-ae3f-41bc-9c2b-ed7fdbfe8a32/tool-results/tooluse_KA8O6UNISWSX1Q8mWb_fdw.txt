   500→```typescript
   501→// lib/ai/agents/expert-factory.ts
   502→interface ExpertConfig {
   503→  domain: 'bazi' | 'ziwei' | 'zodiac' | 'mbti' | 'perma';
   504→  name: string;
   505→  knowledgeBase: string;      // KB 路径
   506→  systemPromptTemplate: string;
   507→}
   508→
   509→const expertConfigs: ExpertConfig[] = [
   510→  {
   511→    domain: 'bazi',
   512→    name: '八字专家',
   513→    knowledgeBase: 'kb/bazi',
   514→    systemPromptTemplate: `你是八字命理专家，基于用户的八字数据提供解读。
   515→
   516→【专业规范】
   517→- 基于四柱（年月日时）进行分析
   518→- 结合十神、神煞、大运流年
   519→- 翻译为现代心理学语言
   520→- 禁止绝对预测，使用概率语言`,
   521→  },
   522→  {
   523→    domain: 'zodiac',
   524→    name: '星座专家',
   525→    knowledgeBase: 'kb/astrology',
   526→    systemPromptTemplate: `你是占星学专家，基于星盘数据提供解读。
   527→
   528→【专业规范】
   529→- 分析太阳、月亮、上升等关键配置
   530→- 关注当前行星过境影响
   531→- 结合积极心理学框架
   532→- 给出可行动的建议`,
   533→  },
   534→  // ... 更多专家配置
   535→];
   536→
   537→export function createExpertAgent(domain: ExpertConfig['domain']): AgentConfig {
   538→  const config = expertConfigs.find(c => c.domain === domain);
   539→  if (!config) throw new Error(`Unknown expert domain: ${domain}`);
   540→
   541→  return {
   542→    id: `expert-${domain}`,
   543→    name: config.name,
   544→    model: 'glm:glm-4',
   545→    systemPrompt: config.systemPromptTemplate,
   546→    tools: [
   547→      tool({
   548→        name: 'search_domain_kb',
   549→        description: `搜索${config.name}知识库`,
   550→        parameters: z.object({ query: z.string() }),
   551→        execute: async ({ query }) => {
   552→          // 实现：领域特定 RAG
   553→        },
   554→      }),
   555→    ],
   556→  };
   557→}
   558→```
   559→
   560→### 2.4 可插拔知识库系统（Pluggable Knowledge Base）
   561→
   562→> **核心设计**：每个 Agent 都可动态绑定多个知识库，用户可根据偏好/付费状态灵活配置
   563→
   564→#### 2.4.1 知识库注册表架构
   565→
   566→```typescript
   567→// lib/kb/registry.ts
   568→
   569→/**
   570→ * 知识库类型定义
   571→ */
   572→interface KnowledgeBase {
   573→  kb_id: string;                    // 唯一标识
   574→  name: string;                     // 显示名称
   575→  domain: KBDomain;                 // 领域分类
   576→  description: string;
   577→
   578→  // 访问控制
   579→  access_level: 'free' | 'basic' | 'premium' | 'enterprise';
   580→  price_coins: number;              // 解锁所需金币（0=免费）
   581→
   582→  // 技术配置
   583→  retrieval_config: {
   584→    type: 'fts' | 'vector' | 'hybrid';  // 检索类型
   585→    collection: string;                   // pgvector collection 或 FTS 表
   586→    embedding_model?: string;             // 向量模型
   587→    top_k: number;                        // 默认返回条数
   588→    rerank?: boolean;                     // 是否重排序
   589→  };
   590→
   591→  // 元信息
   592→  chunk_count: number;
   593→  last_updated: Date;
   594→  version: string;
   595→
   596→  // 可用性
   597→  is_active: boolean;
   598→  compatible_agents: string[];      // 兼容的 Agent ID 列表
   599→}
   600→
   601→type KBDomain =
   602→  | 'astrology'      // 占星/星座
   603→  | 'bazi'           // 八字命理
   604→  | 'ziwei'          // 紫薇斗数
   605→  | 'psychology'     // 心理学
   606→  | 'practice'       // 练习/仪式
   607→  | 'relationship'   // 关系/合盘
   608→  | 'custom';        // 用户自定义
   609→
   610→/**
   611→ * 知识库注册表
   612→ */
   613→class KBRegistry {
   614→  private kbs: Map<string, KnowledgeBase> = new Map();
   615→
   616→  // 注册知识库
   617→  register(kb: KnowledgeBase): void {
   618→    this.kbs.set(kb.kb_id, kb);
   619→  }
   620→
   621→  // 获取用户可用的知识库列表
   622→  async getAvailableForUser(userId: string): Promise<KnowledgeBase[]> {
   623→    const userAccess = await this.getUserAccessLevel(userId);
   624→    const unlockedKBs = await this.getUserUnlockedKBs(userId);
   625→
   626→    return Array.from(this.kbs.values()).filter(kb => {
   627→      // 检查访问级别或已解锁
   628→      return kb.is_active && (
   629→        this.accessLevelSufficient(userAccess, kb.access_level) ||
   630→        unlockedKBs.includes(kb.kb_id)
   631→      );
   632→    });
   633→  }
   634→
   635→  // 获取 Agent 绑定的知识库
   636→  async getKBsForAgent(agentId: string, userId: string): Promise<KnowledgeBase[]> {
   637→    const userKBs = await this.getAvailableForUser(userId);
   638→    const userBindings = await this.getUserAgentKBBindings(userId, agentId);
   639→
   640→    return userKBs.filter(kb =>
   641→      kb.compatible_agents.includes(agentId) &&
   642→      (userBindings.length === 0 || userBindings.includes(kb.kb_id))
   643→    );
   644→  }
   645→
   646→  // 解锁知识库（付费）
   647→  async unlockKB(userId: string, kbId: string): Promise<UnlockResult> {
   648→    const kb = this.kbs.get(kbId);
   649→    if (!kb) throw new Error('KB not found');
   650→
   651→    // 扣除金币
   652→    const deducted = await deductCurrency(userId, kb.price_coins, {
   653→      category: 'spend',
   654→      reason: 'unlock_kb',
   655→      ref_type: 'kb',
   656→      ref_id: kbId,
   657→    });
   658→
   659→    if (!deducted) {
   660→      return { success: false, error: 'insufficient_balance' };
   661→    }
   662→
   663→    // 记录解锁
   664→    await db.insert(fortune_user_kb, {
   665→      user_id: userId,
   666→      kb_id: kbId,
   667→      unlocked_at: new Date(),
   668→      unlock_source: 'purchase',
   669→    });
   670→
   671→    return { success: true, kb };
   672→  }
   673→}
   674→
   675→export const kbRegistry = new KBRegistry();
   676→```
   677→
   678→#### 2.4.2 用户知识库配置
   679→
   680→```typescript
   681→// lib/kb/user-config.ts
   682→
   683→/**
   684→ * 用户 Agent-KB 绑定配置
   685→ */
   686→interface UserAgentKBConfig {
   687→  user_id: string;
   688→  agent_id: string;
   689→  kb_ids: string[];           // 启用的知识库列表（有序）
   690→  custom_weights?: Record<string, number>;  // 知识库权重
   691→  updated_at: Date;
   692→}
   693→
   694→/**
   695→ * 获取用户对特定 Agent 的知识库配置
   696→ */
   697→async function getUserAgentKBConfig(
   698→  userId: string,
   699→  agentId: string
   700→): Promise<UserAgentKBConfig> {
   701→  // 1. 查询用户配置
   702→  const config = await db.query(
   703→    `SELECT * FROM fortune_user_agent_kb WHERE user_id = $1 AND agent_id = $2`,
   704→    [userId, agentId]
   705→  );
   706→
   707→  if (config) return config;
   708→
   709→  // 2. 返回默认配置（所有可用 KB）
   710→  const availableKBs = await kbRegistry.getKBsForAgent(agentId, userId);
   711→  return {
   712→    user_id: userId,
   713→    agent_id: agentId,
   714→    kb_ids: availableKBs.map(kb => kb.kb_id),
   715→    updated_at: new Date(),
   716→  };
   717→}
   718→
   719→/**
   720→ * 更新用户 Agent-KB 配置
   721→ */
   722→async function updateUserAgentKBConfig(
   723→  userId: string,
   724→  agentId: string,
   725→  kbIds: string[],
   726→  weights?: Record<string, number>
   727→): Promise<void> {
   728→  // 验证用户有权限访问这些 KB
   729→  const available = await kbRegistry.getAvailableForUser(userId);
   730→  const availableIds = new Set(available.map(kb => kb.kb_id));
   731→
   732→  const invalidKBs = kbIds.filter(id => !availableIds.has(id));
   733→  if (invalidKBs.length > 0) {
   734→    throw new Error(`Unauthorized KB access: ${invalidKBs.join(', ')}`);
   735→  }
   736→
   737→  await db.upsert(fortune_user_agent_kb, {
   738→    user_id: userId,
   739→    agent_id: agentId,
   740→    kb_ids: kbIds,
   741→    custom_weights: weights || {},
   742→    updated_at: new Date(),
   743→  });
   744→}
   745→```
   746→
   747→#### 2.4.3 混合检索实现
   748→
   749→```typescript
   750→// lib/kb/retriever.ts
   751→
   752→interface RetrievalRequest {
   753→  query: string;
   754→  userId: string;
   755→  agentId: string;
   756→  limit?: number;
   757→  filters?: Record<string, any>;
   758→}
   759→
   760→interface RetrievalResult {
   761→  chunks: KBChunk[];
   762→  sources: { kb_id: string; kb_name: string; count: number }[];
   763→  total_searched: number;
   764→}
   765→
   766→/**
   767→ * 多知识库混合检索
   768→ */
   769→async function retrieveFromKBs(req: RetrievalRequest): Promise<RetrievalResult> {
   770→  const config = await getUserAgentKBConfig(req.userId, req.agentId);
   771→  const kbs = await Promise.all(
   772→    config.kb_ids.map(id => kbRegistry.get(id))
   773→  );
   774→
   775→  const allChunks: KBChunk[] = [];
   776→  const sources: RetrievalResult['sources'] = [];
   777→
   778→  for (const kb of kbs) {
   779→    if (!kb) continue;
   780→
   781→    const weight = config.custom_weights?.[kb.kb_id] || 1.0;
   782→    const kbLimit = Math.ceil((req.limit || 5) * weight);
   783→
   784→    let chunks: KBChunk[];
   785→
   786→    switch (kb.retrieval_config.type) {
   787→      case 'fts':
   788→        chunks = await ftsSearch(kb, req.query, kbLimit);
   789→        break;
   790→      case 'vector':
   791→        chunks = await vectorSearch(kb, req.query, kbLimit);
   792→        break;
   793→      case 'hybrid':
   794→        chunks = await hybridSearch(kb, req.query, kbLimit);
   795→        break;
   796→    }
   797→
   798→    // 添加来源标记
   799→    chunks.forEach(c => {
   800→      c.source_kb_id = kb.kb_id;
   801→      c.source_kb_name = kb.name;
   802→      c.weight = weight;
   803→    });
   804→
   805→    allChunks.push(...chunks);
   806→    sources.push({ kb_id: kb.kb_id, kb_name: kb.name, count: chunks.length });
   807→  }
   808→
   809→  // 重排序（如果配置了）
   810→  const rerankedChunks = await rerankChunks(allChunks, req.query, req.limit || 5);
   811→
   812→  return {
   813→    chunks: rerankedChunks,
   814→    sources,
   815→    total_searched: kbs.length,
   816→  };
   817→}
   818→
   819→/**
   820→ * FTS 全文搜索
   821→ */
   822→async function ftsSearch(kb: KnowledgeBase, query: string, limit: number): Promise<KBChunk[]> {
   823→  return db.query(`
   824→    SELECT chunk_id, content, title, meta,
   825→           ts_rank(content_tsv, plainto_tsquery('simple', $1)) as score
   826→    FROM fortune_kb_chunk
   827→    WHERE collection = $2 AND content_tsv @@ plainto_tsquery('simple', $1)
   828→    ORDER BY score DESC
   829→    LIMIT $3
   830→  `, [query, kb.retrieval_config.collection, limit]);
   831→}
   832→
   833→/**
   834→ * 向量搜索
   835→ */
   836→async function vectorSearch(kb: KnowledgeBase, query: string, limit: number): Promise<KBChunk[]> {
   837→  // 生成查询向量
   838→  const queryEmbedding = await generateEmbedding(query, kb.retrieval_config.embedding_model);
   839→
   840→  return db.query(`
   841→    SELECT chunk_id, content, title, meta,
   842→           1 - (embedding <=> $1::vector) as score
   843→    FROM fortune_kb_chunk
   844→    WHERE collection = $2
   845→    ORDER BY embedding <=> $1::vector
   846→    LIMIT $3
   847→  `, [queryEmbedding, kb.retrieval_config.collection, limit]);
   848→}
   849→
   850→/**
   851→ * 混合搜索（FTS + Vector）
   852→ */
   853→async function hybridSearch(kb: KnowledgeBase, query: string, limit: number): Promise<KBChunk[]> {
   854→  const [ftsResults, vectorResults] = await Promise.all([
   855→    ftsSearch(kb, query, limit * 2),
   856→    vectorSearch(kb, query, limit * 2),
   857→  ]);
   858→
   859→  // 融合得分（RRF - Reciprocal Rank Fusion）
   860→  const merged = rrfMerge(ftsResults, vectorResults, limit);
   861→  return merged;
   862→}
   863→```
   864→
   865→#### 2.4.4 预置知识库配置
   866→
   867→```typescript
   868→// lib/kb/presets.ts
   869→
   870→/**
   871→ * 系统预置知识库
   872→ */
   873→const PRESET_KNOWLEDGE_BASES: KnowledgeBase[] = [
   874→  // ===== 免费知识库 =====
   875→  {
   876→    kb_id: 'psychology-basics',
   877→    name: '积极心理学基础',
   878→    domain: 'psychology',
   879→    description: 'PERMA 模型、优势理论、正念基础',
   880→    access_level: 'free',
   881→    price_coins: 0,
   882→    retrieval_config: {
   883→      type: 'hybrid',
   884→      collection: 'kb_psychology_basics',
   885→      embedding_model: 'text-embedding-3-small',
   886→      top_k: 5,
   887→      rerank: true,
   888→    },
   889→    chunk_count: 500,
   890→    is_active: true,
   891→    compatible_agents: ['coach', 'analyst'],
   892→  },
   893→  {
   894→    kb_id: 'bazi-basics',
   895→    name: '八字入门',
   896→    domain: 'bazi',
   897→    description: '四柱基础、五行生克、十神概念',
   898→    access_level: 'free',
   899→    price_coins: 0,
   900→    retrieval_config: {
   901→      type: 'hybrid',
   902→      collection: 'kb_bazi_basics',
   903→      top_k: 5,
   904→    },
   905→    chunk_count: 300,
   906→    is_active: true,
   907→    compatible_agents: ['coach', 'expert-bazi'],
   908→  },
   909→
   910→  // ===== 基础付费知识库 =====
   911→  {
   912→    kb_id: 'bazi-advanced',
   913→    name: '八字进阶',
   914→    domain: 'bazi',
   915→    description: '格局分析、大运流年、神煞详解',
   916→    access_level: 'basic',
   917→    price_coins: 100,
   918→    retrieval_config: {
   919→      type: 'hybrid',
   920→      collection: 'kb_bazi_advanced',
   921→      top_k: 8,
   922→      rerank: true,
   923→    },
   924→    chunk_count: 1200,
   925→    is_active: true,
   926→    compatible_agents: ['expert-bazi'],
   927→  },
   928→  {
   929→    kb_id: 'zodiac-transits',
   930→    name: '星座行运',
   931→    domain: 'astrology',
   932→    description: '行星过境、逆行影响、相位解读',
   933→    access_level: 'basic',
   934→    price_coins: 80,
   935→    retrieval_config: {
   936→      type: 'vector',
   937→      collection: 'kb_zodiac_transits',
   938→      embedding_model: 'text-embedding-3-small',
   939→      top_k: 6,
   940→    },
   941→    chunk_count: 800,
   942→    is_active: true,
   943→    compatible_agents: ['coach', 'expert-zodiac'],
   944→  },
   945→
   946→  // ===== 高级付费知识库 =====
   947→  {
   948→    kb_id: 'ziwei-master',
   949→    name: '紫微斗数精解',
   950→    domain: 'ziwei',
   951→    description: '命宫详解、四化飞星、流年流月',
   952→    access_level: 'premium',
   953→    price_coins: 300,
   954→    retrieval_config: {
   955→      type: 'hybrid',
   956→      collection: 'kb_ziwei_master',
   957→      top_k: 10,
   958→      rerank: true,
   959→    },
   960→    chunk_count: 2000,
   961→    is_active: true,
   962→    compatible_agents: ['expert-ziwei'],
   963→  },
   964→  {
   965→    kb_id: 'relationship-dynamics',
   966→    name: '关系动力学',
   967→    domain: 'relationship',
   968→    description: '依附理论、合盘解读、关系修复',
   969→    access_level: 'premium',
   970→    price_coins: 200,
   971→    retrieval_config: {
   972→      type: 'hybrid',
   973→      collection: 'kb_relationship',
   974→      top_k: 8,
   975→      rerank: true,
   976→    },
   977→    chunk_count: 1500,
   978→    is_active: true,
   979→    compatible_agents: ['social', 'coach'],
   980→  },
   981→  {
   982→    kb_id: 'shadow-work',
   983→    name: '阴影工作坊',
   984→    domain: 'psychology',
   985→    description: '荣格阴影理论、内在小孩、创伤疗愈',
   986→    access_level: 'premium',
   987→    price_coins: 250,
   988→    retrieval_config: {
   989→      type: 'hybrid',
   990→      collection: 'kb_shadow_work',
   991→      top_k: 8,
   992→      rerank: true,
   993→    },
   994→    chunk_count: 1000,
   995→    is_active: true,
   996→    compatible_agents: ['coach', 'analyst'],
   997→  },
   998→];
   999→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
