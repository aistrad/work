   260→        """,
   261→        [user_id, trigger_id, expires_at, expires_at],
   262→    )
   263→
   264→
   265→def clear_expired_cooldowns() -> int:
   266→    """Clear expired cooldowns. Returns count of cleared."""
   267→    result = fortune_db.execute(
   268→        "DELETE FROM fortune_jitai_cooldown WHERE expires_at < %s",
   269→        [_now_utc()],
   270→    )
   271→    return result
   272→
   273→
   274→# =============================================================================
   275→# Condition Evaluation
   276→# =============================================================================
   277→
   278→def _evaluate_time_condition(condition: Dict[str, Any], user_tz_offset: float = 8.0) -> bool:
   279→    """Evaluate a time-based condition."""
   280→    now = _now_utc()
   281→    # Convert to user's local time
   282→    user_now = now + timedelta(hours=user_tz_offset)
   283→    current_time = user_now.time()
   284→
   285→    cond_type = condition.get("type")
   286→
   287→    if cond_type == "time_range":
   288→        start = datetime.strptime(condition["start_time"], "%H:%M:%S").time()
   289→        end = datetime.strptime(condition["end_time"], "%H:%M:%S").time()
   290→        return start <= current_time <= end
   291→
   292→    elif cond_type == "specific_time":
   293→        target = datetime.strptime(condition["specific_time"], "%H:%M:%S").time()
   294→        # Allow 30 minute window
   295→        target_dt = datetime.combine(user_now.date(), target)
   296→        diff = abs((user_now - target_dt).total_seconds())
   297→        return diff <= 1800  # 30 minutes
   298→
   299→    elif cond_type == "day_of_week":
   300→        days = condition.get("days", [])
   301→        return user_now.weekday() in days
   302→
   303→    return False
   304→
   305→
   306→def _evaluate_state_condition(condition: Dict[str, Any], twin_data: Dict[str, Any]) -> bool:
   307→    """Evaluate a state-based condition."""
   308→    cond_type = condition.get("type")
   309→
   310→    if cond_type == "twin_field":
   311→        field_path = condition.get("field_path", "")
   312→        operator = condition.get("operator")
   313→        target_value = condition.get("value")
   314→
   315→        # Navigate to field
   316→        current = twin_data
   317→        for part in field_path.split("."):
   318→            if isinstance(current, dict):
   319→                current = current.get(part)
   320→            else:
   321→                return False
   322→
   323→        if current is None:
   324→            return False
   325→
   326→        # Compare
   327→        if operator == "lt":
   328→            return current < target_value
   329→        elif operator == "gt":
   330→            return current > target_value
   331→        elif operator == "eq":
   332→            return current == target_value
   333→        elif operator == "lte":
   334→            return current <= target_value
   335→        elif operator == "gte":
   336→            return current >= target_value
   337→        elif operator == "between":
   338→            value_max = condition.get("value_max")
   339→            return target_value <= current <= value_max

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
