   300→        return value if isinstance(value, dict) else data
   301→
   302→    result = dict(data)
   303→    current = result
   304→
   305→    for i, part in enumerate(path_parts[:-1]):
   306→        if part not in current or not isinstance(current[part], dict):
   307→            current[part] = {}
   308→        current[part] = dict(current[part])
   309→        current = current[part]
   310→
   311→    current[path_parts[-1]] = value
   312→    return result
   313→
   314→
   315→def update_twin(event: TwinUpdateEvent) -> TwinUpdateResult:
   316→    """
   317→    Update digital twin data.
   318→
   319→    REQ: REQ-TWIN-003
   320→    Design: §3.1.3 步骤 1-5
   321→
   322→    - Uses transaction for atomicity
   323→    - Supports nested path updates via jsonb_set
   324→    - Records old_value and new_value in log
   325→    - Triggers L3 recalculation if L2 is updated
   326→    """
   327→    user_id = event.user_id
   328→    column, path_parts = _parse_json_path(event.path)
   329→
   330→    # Get current twin
   331→    row = fortune_db.fetch_one(
   332→        "SELECT * FROM fortune_digital_twin WHERE user_id = %s FOR UPDATE",
   333→        [user_id],
   334→    )
   335→    if not row:
   336→        # Auto-create twin if not exists
   337→        twin = create_twin(user_id)
   338→        row = fortune_db.fetch_one(
   339→            "SELECT * FROM fortune_digital_twin WHERE user_id = %s FOR UPDATE",
   340→            [user_id],
   341→        )
   342→
   343→    twin_id = row["twin_id"]
   344→
   345→    # Get current column value
   346→    current_data = row.get(column) or {}
   347→    if isinstance(current_data, str):
   348→        current_data = json.loads(current_data)
   349→
   350→    # Get old value
   351→    old_value = _get_nested_value(current_data, path_parts) if path_parts else current_data
   352→
   353→    # Set new value
   354→    if path_parts:
   355→        new_data = _set_nested_value(current_data, path_parts, event.new_value)
   356→    else:
   357→        new_data = event.new_value if isinstance(event.new_value, dict) else current_data
   358→
   359→    # Update database
   360→    fortune_db.execute(
   361→        f"""
   362→        UPDATE fortune_digital_twin
   363→        SET {column} = %s, updated_at = %s
   364→        WHERE twin_id = %s
   365→        """,
   366→        [json.dumps(new_data), _now_utc(), twin_id],
   367→    )
   368→
   369→    # Write update log
   370→    log_row = fortune_db.execute_returning_one(
   371→        """
   372→        INSERT INTO fortune_twin_update_log (
   373→            twin_id, trigger_type, layer, path, old_value, new_value,
   374→            confidence, source, created_at
   375→        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
   376→        RETURNING log_id
   377→        """,
   378→        [
   379→            twin_id,
   380→            event.trigger,
   381→            event.layer.value,
   382→            event.path,
   383→            json.dumps(old_value) if old_value is not None else None,
   384→            json.dumps(event.new_value),
   385→            event.confidence,
   386→            event.source,
   387→            _now_utc(),
   388→        ],
   389→    )
   390→
   391→    log_id = log_row["log_id"] if log_row else None
   392→
   393→    # Trigger L3 recalculation if L2 was updated
   394→    dimensions_recalculated = False
   395→    if event.layer == TwinLayer.L2:
   396→        recalculate_dimensions(user_id)
   397→        dimensions_recalculated = True
   398→
   399→    logger.info(

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
