     1→"""
     2→Soul OS 核心服务层
     3→
     4→基于 os_design_claude_mvp.md 的四层架构实现：
     5→- L0 Firmware: 八字事实快照管理
     6→- L1 Schema: PERMA + 行为证据汇总
     7→- L2 Agents: 知识库检索 + Prompt 模板
     8→- L3 Synthesis: GLM 整合 + A2UI 输出
     9→
    10→包含：
    11→- State Score 计算
    12→- 反依赖机制
    13→- JITAI 调节动作库
    14→- Guidance Card 生成
    15→"""
    16→
    17→from __future__ import annotations
    18→
    19→import hashlib
    20→import json
    21→from dataclasses import dataclass, field
    22→from datetime import date, datetime, timedelta, timezone
    23→from enum import Enum
    24→from typing import Any, Dict, List, Optional, Tuple
    25→from uuid import uuid4
    26→
    27→from common.logging import get_logger
    28→from stores import fortune_db
    29→
    30→logger = get_logger(__name__)
    31→
    32→
    33→# =============================================================================
    34→# Enums & Constants
    35→# =============================================================================
    36→
    37→class PersonaStyle(str, Enum):
    38→    STANDARD = "standard"  # 清晰、中性、专业
    39→    WARM = "warm"          # 共情、支持性（默认）
    40→    ROAST = "roast"        # 轻毒舌但不羞辱
    41→
    42→
    43→class CommitmentType(str, Enum):
    44→    START_TASK = "start_task"        # 立刻开始
    45→    SCHEDULE_TASK = "schedule_task"  # 加入计划
    46→    ASK_FOLLOWUP = "ask_followup"    # 澄清问题
    47→    OPT_OUT = "opt_out"              # 暂停/关闭
    48→
    49→
    50→class CommitmentStatus(str, Enum):
    51→    SUGGESTED = "suggested"
    52→    ACTIVE = "active"
    53→    DONE = "done"
    54→    SKIPPED = "skipped"
    55→    CANCELED = "canceled"
    56→
    57→
    58→# JITAI 调节动作库
    59→JITAI_ACTIONS: Dict[str, Dict[str, str]] = {
    60→    "焦虑": {
    61→        "high": "3分钟呼吸降噪：吸气4秒→屏息7秒→呼气8秒，重复3次。",
    62→        "medium": "写下3个最坏情况，并评估每个发生的概率（0-100%）。",
    63→        "low": "列出你现在能控制的3件事。",
    64→    },
    65→    "低落": {
    66→        "high": "做一个最小行动：站起来倒杯水，或走到窗边看30秒。",
    67→        "medium": "回忆一个小成就并写下来：我做到了____。",
    68→        "low": "给自己一句鼓励：这很正常，我正在经历困难。",
    69→    },
    70→    "愤怒": {
    71→        "high": "用力握拳10秒再松开，重复3次。然后深呼吸5次。",
    72→        "medium": "写下：我需要的是____。我的底线是____。",
    73→        "low": "离开当前场景2分钟，做5次深呼吸。",
    74→    },
    75→    "困惑": {
    76→        "high": "写下3个选项和1个最重要的约束条件。",
    77→        "medium": "问自己：如果只能选一个，我会选哪个？为什么？",
    78→        "low": "画一个简单的决策树：选项A→结果；选项B→结果。",
    79→    },
    80→    "兴奋": {
    81→        "high": "写下这个感觉的来源，并把能量转化为一个2分钟行动。",
    82→        "medium": "记录下这一刻，稍后复盘时用。",
    83→        "low": "享受这个感觉，同时提醒自己不做冲动决策。",
    84→    },
    85→    "平静": {
    86→        "high": "写下今天最想保留的一个做法。",
    87→        "medium": "安排一个5分钟的延续动作。",
    88→        "low": "保持这个状态，继续当前的事。",
    89→    },
    90→}
    91→
    92→# 心理学翻译规则：八字概念 → 可操作心理语言
    93→BAZI_PSYCHOLOGY_TRANSLATIONS: Dict[str, Dict[str, str]] = {
    94→    "weak": {
    95→        "translation": "你的能量更适合借力/合作，而非单打独斗",
    96→        "action": "本周找一个支持者或合作伙伴",
    97→    },
    98→    "strong": {
    99→        "translation": "你有充沛的内在能量，适合独立行动",
   100→        "action": "设定一个独立完成的小目标",
   101→    },
   102→    "neutral": {
   103→        "translation": "你的能量相对平衡，灵活度高",
   104→        "action": "根据具体情况选择独立或合作",
   105→    },
   106→    "食伤重": {
   107→        "translation": "你有强烈的表达欲和创造力",
   108→        "action": "每天留15分钟自由书写或创作",
   109→    },
   110→    "官杀混杂": {
   111→        "translation": "你可能感受到多重压力或权威冲突",
   112→        "action": "写清哪些压力是你能控制的，哪些不能",
   113→    },
   114→    "桃花": {
   115→        "translation": "你在关系中有天然的吸引力和敏感度",
   116→        "action": "觉察关系中的边界需求",
   117→    },
   118→    "驿马": {
   119→        "translation": "你有变动/探索的内在驱力",
   120→        "action": "小范围实验胜过大规模改变",
   121→    },
   122→    "华盖": {
   123→        "translation": "你有独立思考和精神探索的倾向",
   124→        "action": "每周留1小时独处反思时间",
   125→    },
   126→    "天乙贵人": {
   127→        "translation": "你容易获得贵人相助",
   128→        "action": "主动寻求帮助，不要独自扛",
   129→    },
   130→    "文昌": {
   131→        "translation": "你在学习和文字方面有天赋",
   132→        "action": "保持学习习惯，用写作整理思路",
   133→    },
   134→}
   135→
   136→
   137→# =============================================================================
   138→# Data Classes
   139→# =============================================================================
   140→
   141→@dataclass
   142→class StateScore:
   143→    """状态分数 - 把"感觉"变成可训练变量"""
   144→    score: int  # 0-100
   145→    emotion_signal: int  # 40% 权重
   146→    action_signal: int   # 40% 权重
   147→    streak_signal: int   # 20% 权重
   148→    recovery_action: str  # 分数低时的补救动作
   149→
   150→    def to_dict(self) -> Dict[str, Any]:
   151→        return {
   152→            "score": self.score,
   153→            "breakdown": {
   154→                "emotion": self.emotion_signal,
   155→                "action": self.action_signal,
   156→                "streak": self.streak_signal,
   157→            },
   158→            "recovery_action": self.recovery_action,
   159→        }
   160→
   161→
   162→@dataclass
   163→class PermaSnapshot:
   164→    """PERMA 积极心理学快照"""
   165→    positive_emotion: Dict[str, Any] = field(default_factory=dict)
   166→    engagement: Dict[str, Any] = field(default_factory=dict)
   167→    relationships: Dict[str, Any] = field(default_factory=dict)
   168→    meaning: Dict[str, Any] = field(default_factory=dict)
   169→    accomplishment: Dict[str, Any] = field(default_factory=dict)
   170→
   171→    def to_dict(self) -> Dict[str, Any]:
   172→        return {
   173→            "positive_emotion": self.positive_emotion,
   174→            "engagement": self.engagement,
   175→            "relationships": self.relationships,
   176→            "meaning": self.meaning,
   177→            "accomplishment": self.accomplishment,
   178→        }
   179→
   180→
   181→@dataclass
   182→class L1Schema:
   183→    """L1 特质层数据"""
   184→    perma: PermaSnapshot
   185→    cognitive_patterns: Dict[str, Any]
   186→    strengths_in_use: List[str]
   187→    preferences: Dict[str, Any]
   188→
   189→    def to_dict(self) -> Dict[str, Any]:
   190→        return {
   191→            "perma_snapshot": self.perma.to_dict(),
   192→            "cognitive_patterns": self.cognitive_patterns,
   193→            "strengths_in_use": self.strengths_in_use,
   194→            "preferences": self.preferences,
   195→        }
   196→
   197→
   198→@dataclass
   199→class AntiDependencyState:
   200→    """反依赖状态追踪"""
   201→    same_question_count: int = 0
   202→    daily_consult_count: int = 0
   203→    last_action_days: int = 0
   204→    should_intervene: bool = False
   205→    intervention_type: str = ""
   206→    intervention_message: str = ""
   207→
   208→
   209→@dataclass
   210→class GuidanceCard:
   211→    """指导卡片"""
   212→    card_id: str
   213→    card_type: str
   214→    conclusion: str
   215→    why: str
   216→    prescriptions: List[Dict[str, Any]]
   217→    time_window: Dict[str, Any]
   218→    risk_boundary: str
   219→    commitment_ask: str
   220→    actions: List[Dict[str, Any]]
   221→    evidence: Dict[str, Any]
   222→    created_at: str
   223→
   224→    def to_dict(self) -> Dict[str, Any]:
   225→        return {
   226→            "card_id": self.card_id,
   227→            "type": self.card_type,
   228→            "conclusion": self.conclusion,
   229→            "why": self.why,
   230→            "prescriptions": self.prescriptions,
   231→            "time_window": self.time_window,
   232→            "risk_boundary": self.risk_boundary,
   233→            "commitment_ask": self.commitment_ask,
   234→            "actions": self.actions,
   235→            "evidence": self.evidence,
   236→            "created_at": self.created_at,
   237→        }
   238→
   239→
   240→# =============================================================================
   241→# L0 Firmware Layer - 八字事实快照管理
   242→# =============================================================================
   243→
   244→def get_l0_facts(user_id: int) -> Dict[str, Any]:
   245→    """获取 L0 层八字事实快照"""
   246→    snap = fortune_db.fetch_one(
   247→        """
   248→        SELECT facts, facts_hash, compute_version
   249→        FROM fortune_bazi_snapshot
   250→        WHERE user_id = %s
   251→        ORDER BY created_at DESC
   252→        LIMIT 1
   253→        """,
   254→        (int(user_id),),
   255→    )
   256→    if not snap:
   257→        return {"facts": {}, "facts_hash": "", "compute_version": ""}
   258→    return {
   259→        "facts": snap.get("facts") or {},
   260→        "facts_hash": str(snap.get("facts_hash") or ""),
   261→        "compute_version": str(snap.get("compute_version") or ""),
   262→    }
   263→
   264→
   265→def translate_bazi_to_psychology(facts: Dict[str, Any]) -> List[Dict[str, str]]:
   266→    """将八字概念翻译为可操作的心理学语言"""
   267→    translations = []
   268→    bazi = facts.get("bazi", {})
   269→
   270→    # 旺衰翻译
   271→    strength = bazi.get("strength", {})
   272→    status = strength.get("status", "neutral")
   273→    if status in BAZI_PSYCHOLOGY_TRANSLATIONS:
   274→        trans = BAZI_PSYCHOLOGY_TRANSLATIONS[status]
   275→        translations.append({
   276→            "concept": f"日主{status}",
   277→            "translation": trans["translation"],
   278→            "action": trans["action"],
   279→        })
   280→
   281→    # 神煞翻译
   282→    for shensha in bazi.get("shensha", []):
   283→        if shensha.get("hit"):
   284→            name = shensha.get("name", "")
   285→            if name in BAZI_PSYCHOLOGY_TRANSLATIONS:
   286→                trans = BAZI_PSYCHOLOGY_TRANSLATIONS[name]
   287→                translations.append({
   288→                    "concept": name,
   289→                    "translation": trans["translation"],
   290→                    "action": trans["action"],
   291→                })
   292→
   293→    return translations
   294→
   295→
   296→# =============================================================================
   297→# L1 Schema Layer - PERMA + 行为证据汇总
   298→# =============================================================================
   299→
   300→def get_l1_schema(user_id: int, window_days: int = 7) -> L1Schema:
   301→    """获取 L1 层特质图式"""
   302→    uid = int(user_id)
   303→    window_start = datetime.now(timezone.utc) - timedelta(days=window_days)
   304→
   305→    # 获取用户偏好
   306→    prefs = fortune_db.fetch_one(
   307→        "SELECT * FROM fortune_user_preferences WHERE user_id = %s",
   308→        (uid,),
   309→    ) or {}
   310→
   311→    # P: Positive Emotion - 从 checkin 获取
   312→    checkins = fortune_db.fetch_all(
   313→        """
   314→        SELECT mood, intensity, created_at
   315→        FROM fortune_checkin
   316→        WHERE user_id = %s AND created_at >= %s
   317→        ORDER BY created_at DESC
   318→        LIMIT 20
   319→        """,
   320→        (uid, window_start),
   321→    )
   322→
   323→    positive_moods = ["平静", "兴奋", "开心", "满足", "感恩"]
   324→    positive_count = sum(1 for c in checkins if c.get("mood") in positive_moods)
   325→    avg_intensity = sum(c.get("intensity", 5) for c in checkins) / len(checkins) if checkins else 5
   326→
   327→    positive_emotion = {
   328→        "score": round(10 - avg_intensity, 1) if checkins else 5.0,  # 反转：低强度=好
   329→        "trend": "up" if positive_count > len(checkins) / 2 else "stable",
   330→        "recent_count": len(checkins),
   331→    }
   332→
   333→    # E: Engagement - 从 plan enrollment 获取
   334→    enrollments = fortune_db.fetch_all(
   335→        """
   336→        SELECT plan_id, status, current_day
   337→        FROM fortune_plan_enrollment
   338→        WHERE user_id = %s AND status = 'active'
   339→        """,
   340→        (uid,),
   341→    )
   342→
   343→    # 计算完成率
   344→    done_count = fortune_db.fetch_one(
   345→        """
   346→        SELECT COUNT(*) as cnt
   347→        FROM fortune_commitment
   348→        WHERE user_id = %s AND status = 'done' AND created_at >= %s
   349→        """,
   350→        (uid, window_start),
   351→    ) or {}
   352→
   353→    suggested_count = fortune_db.fetch_one(
   354→        """
   355→        SELECT COUNT(*) as cnt
   356→        FROM fortune_commitment
   357→        WHERE user_id = %s AND created_at >= %s
   358→        """,
   359→        (uid, window_start),
   360→    ) or {}
   361→
   362→    total = suggested_count.get("cnt", 0) or 1
   363→    completion_rate = round(done_count.get("cnt", 0) / total, 2) if total else 0
   364→
   365→    engagement = {
   366→        "active_plans": len(enrollments),
   367→        "completion_rate": completion_rate,
   368→    }
   369→
   370→    # R: Relationships - 从对话中提取（简化版）
   371→    recent_msgs = fortune_db.fetch_all(
   372→        """
   373→        SELECT content
   374→        FROM fortune_conversation_message
   375→        WHERE user_id = %s AND role = 'user' AND created_at >= %s
   376→        ORDER BY created_at DESC
   377→        LIMIT 10
   378→        """,
   379→        (uid, window_start),
   380→    )
   381→
   382→    relationship_keywords = ["同事", "朋友", "家人", "伴侣", "关系"]
   383→    relationship_mentions = sum(
   384→        1 for m in recent_msgs
   385→        if any(kw in (m.get("content") or "") for kw in relationship_keywords)
   386→    )
   387→
   388→    relationships = {
   389→        "recent_mentions": relationship_mentions,
   390→        "recent_note": "",
   391→    }
   392→
   393→    # M: Meaning - 从计划参与推断
   394→    meaning = {
   395→        "core_value": "成长" if enrollments else "探索",
   396→        "aligned_actions": done_count.get("cnt", 0),
   397→    }
   398→
   399→    # A: Accomplishment
   400→    streak = _calculate_streak(uid)
   401→    accomplishment = {
   402→        "weekly_done": done_count.get("cnt", 0),
   403→        "streak": streak,
   404→    }
   405→
   406→    perma = PermaSnapshot(
   407→        positive_emotion=positive_emotion,
   408→        engagement=engagement,
   409→        relationships=relationships,
   410→        meaning=meaning,
   411→        accomplishment=accomplishment,
   412→    )
   413→
   414→    return L1Schema(
   415→        perma=perma,
   416→        cognitive_patterns={"identified_schemas": [], "reframe_count": 0},
   417→        strengths_in_use=[],
   418→        preferences={
   419→            "persona_style": prefs.get("persona_style", "warm"),
   420→            "push_enabled": prefs.get("push_enabled", True),
   421→        },
   422→    )
   423→
   424→
   425→def _calculate_streak(user_id: int) -> int:
   426→    """计算连续行动天数"""
   427→    rows = fortune_db.fetch_all(
   428→        """
   429→        SELECT DATE(done_at) as done_date
   430→        FROM fortune_commitment
   431→        WHERE user_id = %s AND status = 'done' AND done_at IS NOT NULL
   432→        ORDER BY done_at DESC
   433→        LIMIT 30
   434→        """,
   435→        (int(user_id),),
   436→    )
   437→
   438→    if not rows:
   439→        return 0
   440→
   441→    dates = sorted(set(r["done_date"] for r in rows if r.get("done_date")), reverse=True)
   442→    if not dates:
   443→        return 0
   444→
   445→    today = date.today()
   446→    streak = 0
   447→    expected = today
   448→
   449→    for d in dates:
   450→        if d == expected or d == expected - timedelta(days=1):
   451→            streak += 1
   452→            expected = d - timedelta(days=1)
   453→        else:
   454→            break
   455→
   456→    return streak
   457→
   458→
   459→# =============================================================================
   460→# State Score 计算
   461→# =============================================================================
   462→
   463→def calculate_state_score(user_id: int, window: str = "24h") -> StateScore:
   464→    """
   465→    计算状态分数（0-100）
   466→
   467→    三信号计算：
   468→    - emotion_signal (40%): 情绪基线
   469→    - action_signal (40%): 行动完成
   470→    - streak_signal (20%): 连续记录
   471→    """
   472→    uid = int(user_id)
   473→
   474→    # 确定时间窗口
   475→    if window == "24h":
   476→        window_start = datetime.now(timezone.utc) - timedelta(hours=24)
   477→    elif window == "7d":
   478→        window_start = datetime.now(timezone.utc) - timedelta(days=7)
   479→    else:
   480→        window_start = datetime.now(timezone.utc) - timedelta(hours=24)
   481→
   482→    # 信号1: 情绪基线（40%权重）
   483→    checkin = fortune_db.fetch_one(
   484→        """
   485→        SELECT mood, intensity
   486→        FROM fortune_checkin
   487→        WHERE user_id = %s AND created_at >= %s
   488→        ORDER BY created_at DESC
   489→        LIMIT 1
   490→        """,
   491→        (uid, window_start),
   492→    )
   493→
   494→    if checkin:
   495→        intensity = int(checkin.get("intensity", 5))
   496→        # 反转：intensity 越高（负面越强）→ 分数越低
   497→        emotion_signal = max(0, (10 - intensity)) * 4
   498→    else:
   499→        emotion_signal = 20  # 无打卡给中性分
   500→
   501→    # 信号2: 行动完成（40%权重）
   502→    done_result = fortune_db.fetch_one(
   503→        """
   504→        SELECT COUNT(*) as cnt
   505→        FROM fortune_commitment
   506→        WHERE user_id = %s AND status = 'done' AND done_at >= %s
   507→        """,
   508→        (uid, window_start),
   509→    ) or {}
   510→    done_count = done_result.get("cnt", 0)
   511→    action_signal = min(done_count * 10, 40)
   512→
   513→    # 信号3: 连续记录（20%权重）
   514→    streak = _calculate_streak(uid)
   515→    streak_signal = min(streak * 4, 20)
   516→
   517→    # 总分
   518→    score = emotion_signal + action_signal + streak_signal
   519→
   520→    # 补救动作
   521→    recovery_action = _get_recovery_action(score, checkin)
   522→
   523→    return StateScore(
   524→        score=score,
   525→        emotion_signal=emotion_signal,
   526→        action_signal=action_signal,
   527→        streak_signal=streak_signal,
   528→        recovery_action=recovery_action,
   529→    )
   530→
   531→
   532→def _get_recovery_action(score: int, last_checkin: Optional[Dict[str, Any]]) -> str:
   533→    """根据分数和最近打卡生成补救动作"""
   534→    if score >= 70:
   535→        return "保持这个状态！今天再完成一个小任务来巩固。"
   536→    elif score >= 50:
   537→        return "做一个2分钟的最小行动，把分数拉上来。"
   538→    elif score >= 30:
   539→        if last_checkin:
   540→            mood = last_checkin.get("mood", "")
   541→            intensity = last_checkin.get("intensity", 5)
   542→            return get_jitai_action(mood, intensity)
   543→        return "先做3分钟呼吸降噪，然后完成一个最小任务。"
   544→    else:
   545→        return "先照顾好自己：喝杯水，做几次深呼吸，然后选一个最小的事情开始。"
   546→
   547→
   548→# =============================================================================
   549→# JITAI 调节动作库
   550→# =============================================================================
   551→
   552→def get_jitai_action(mood: str, intensity: int) -> str:
   553→    """获取 JITAI 即时适应性干预动作"""
   554→    mood = (mood or "").strip()
   555→    intensity = max(0, min(10, int(intensity)))
   556→
   557→    # 确定强度级别
   558→    if intensity >= 7:
   559→        level = "high"
   560→    elif intensity >= 4:
   561→        level = "medium"
   562→    else:
   563→        level = "low"
   564→
   565→    # 查找匹配的动作
   566→    for keyword, actions in JITAI_ACTIONS.items():
   567→        if keyword in mood:
   568→            return actions.get(level, actions.get("medium", ""))
   569→
   570→    # 默认动作
   571→    if intensity >= 7:
   572→        return "先做3分钟呼吸锚点：1分钟呼吸→1分钟身体感受→1分钟选择下一步。"
   573→    return "写下：我现在最需要被满足的一个需求是什么？然后做一个2分钟版本。"
   574→
   575→
   576→def create_checkin_with_jitai(
   577→    user_id: int,
   578→    *,
   579→    mood: str,
   580→    intensity: int,
   581→    note: str = "",
   582→) -> Dict[str, Any]:
   583→    """创建情绪打卡并返回 JITAI 推荐动作"""
   584→    uid = int(user_id)
   585→    mood = (mood or "")[:50]
   586→    intensity = max(0, min(10, int(intensity)))
   587→    note = (note or "")[:1000]
   588→
   589→    # 获取推荐动作
   590→    action = get_jitai_action(mood, intensity)
   591→
   592→    # 写入打卡记录
   593→    fortune_db.execute(
   594→        """
   595→        INSERT INTO fortune_checkin (user_id, mood, intensity, note, recommended_action)
   596→        VALUES (%s, %s, %s, %s, %s)
   597→        """,
   598→        (uid, mood, intensity, note, action),
   599→    )
   600→
   601→    # 创建建议任务
   602→    task_id = str(uuid4())
   603→    fortune_db.execute(
   604→        """
   605→        INSERT INTO fortune_commitment (task_id, user_id, source, commitment_type, title, details, status)
   606→        VALUES (%s::uuid, %s, 'bento', 'start_task', %s, %s::jsonb, 'suggested')
   607→        """,
   608→        (
   609→            task_id,
   610→            uid,
   611→            (action[:200] if action else "情绪调节动作"),
   612→            json.dumps({"from": "checkin", "mood": mood, "intensity": intensity}, ensure_ascii=False),
   613→        ),
   614→    )
   615→
   616→    logger.info(
   617→        "checkin created with jitai",
   618→        extra={"operation": "checkin_jitai", "user_id": uid, "mood": mood, "intensity": intensity},
   619→    )
   620→
   621→    return {
   622→        "mood": mood,
   623→        "intensity": intensity,
   624→        "recommended_action": action,
   625→        "task_id": task_id,
   626→    }
   627→
   628→
   629→# =============================================================================
   630→# 反依赖机制
   631→# =============================================================================
   632→
   633→def check_anti_dependency(user_id: int, current_message: str = "") -> AntiDependencyState:
   634→    """检查反依赖触发条件"""
   635→    uid = int(user_id)
   636→    today_start = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)
   637→
   638→    state = AntiDependencyState()
   639→
   640→    # 检查当日咨询次数
   641→    daily_count = fortune_db.fetch_one(
   642→        """
   643→        SELECT COUNT(*) as cnt
   644→        FROM fortune_conversation_message
   645→        WHERE user_id = %s AND role = 'user' AND created_at >= %s
   646→        """,
   647→        (uid, today_start),
   648→    ) or {}
   649→    state.daily_consult_count = daily_count.get("cnt", 0)
   650→
   651→    # 检查最近行动天数
   652→    last_action = fortune_db.fetch_one(
   653→        """
   654→        SELECT done_at
   655→        FROM fortune_commitment
   656→        WHERE user_id = %s AND status = 'done'
   657→        ORDER BY done_at DESC
   658→        LIMIT 1
   659→        """,
   660→        (uid,),
   661→    )
   662→    if last_action and last_action.get("done_at"):
   663→        days_since = (datetime.now(timezone.utc) - last_action["done_at"].replace(tzinfo=timezone.utc)).days
   664→        state.last_action_days = days_since
   665→    else:
   666→        state.last_action_days = 999
   667→
   668→    # 检查是否连续问同一问题（简化：检查最近3条消息相似度）
   669→    if current_message:
   670→        recent_msgs = fortune_db.fetch_all(
   671→            """
   672→            SELECT content
   673→            FROM fortune_conversation_message
   674→            WHERE user_id = %s AND role = 'user'
   675→            ORDER BY created_at DESC
   676→            LIMIT 3
   677→            """,
   678→            (uid,),
   679→        )
   680→        similar_count = sum(
   681→            1 for m in recent_msgs
   682→            if _message_similarity(current_message, m.get("content", "")) > 0.7
   683→        )
   684→        state.same_question_count = similar_count
   685→
   686→    # 判断是否需要干预
   687→    if state.same_question_count >= 3:
   688→        state.should_intervene = True
   689→        state.intervention_type = "repeated_question"
   690→        state.intervention_message = (
   691→            "我注意到你多次问了类似的问题。信息足够了，现在最重要的是做一个小实验。\n\n"
   692→            "请先完成这个5-15分钟的行动，然后我们再继续：\n"
   693→            "**写下你最担心的3个结果，并给每个打一个概率分（0-100%）**"
   694→        )
   695→    elif state.daily_consult_count > 5:
   696→        state.should_intervene = True
   697→        state.intervention_type = "daily_limit"
   698→        state.intervention_message = (
   699→            "今天我们聊了很多，信息已经足够了。\n\n"
   700→            "现在最重要的是**先行动**：请从今天的建议中选一个最小的任务开始。\n"
   701→            "完成后我们再继续。"
   702→        )
   703→    elif state.last_action_days >= 7:
   704→        state.should_intervene = True
   705→        state.intervention_type = "no_action"
   706→        state.intervention_message = (
   707→            "看起来你已经有一段时间没有完成行动了。\n\n"
   708→            "没关系，我们可以从一个更小的任务开始。\n"
   709→            "**今天只做一件事：站起来走几步，或者喝杯水。**\n"
   710→            "完成后告诉我。"
   711→        )
   712→
   713→    return state
   714→
   715→
   716→def _message_similarity(msg1: str, msg2: str) -> float:
   717→    """简单的消息相似度计算（基于词重叠）"""
   718→    if not msg1 or not msg2:
   719→        return 0.0
   720→
   721→    words1 = set(msg1.replace("？", " ").replace("。", " ").split())
   722→    words2 = set(msg2.replace("？", " ").replace("。", " ").split())
   723→
   724→    if not words1 or not words2:
   725→        return 0.0
   726→
   727→    intersection = len(words1 & words2)
   728→    union = len(words1 | words2)
   729→
   730→    return intersection / union if union > 0 else 0.0
   731→
   732→
   733→# =============================================================================
   734→# L2 Agents Layer - 知识库检索 + Prompt 模板
   735→# =============================================================================
   736→
   737→def search_knowledge_base(query: str, top_k: int = 12) -> List[Dict[str, Any]]:
   738→    """从知识库检索相关内容"""
   739→    if not query:
   740→        return []
   741→
   742→    # PostgreSQL FTS 检索
   743→    results = fortune_db.fetch_all(
   744→        """
   745→        SELECT c.chunk_id, c.doc_id, c.page_no, c.chunk_no,
   746→               ts_rank(c.content_tsv, plainto_tsquery('simple', %s)) AS rank,
   747→               c.content,
   748→               d.file_name, d.title
   749→        FROM bazi_kb_chunk c
   750→        JOIN bazi_kb_document d ON c.doc_id = d.doc_id
   751→        WHERE c.content_tsv @@ plainto_tsquery('simple', %s)
   752→        ORDER BY rank DESC
   753→        LIMIT %s
   754→        """,
   755→        (query, query, top_k),
   756→    )
   757→
   758→    kb_refs = []
   759→    for r in results or []:
   760→        kb_refs.append({
   761→            "kb_ref": f"kb:doc:{r['doc_id']}:page:{r['page_no']}:chunk:{r['chunk_no']}",
   762→            "content": (r.get("content") or "")[:500],
   763→            "source": r.get("title") or r.get("file_name") or "",
   764→            "rank": r.get("rank", 0),
   765→        })
   766→
   767→    return kb_refs
   768→
   769→
   770→def get_advisor_perspectives(question: str, facts: Dict[str, Any]) -> List[Dict[str, Any]]:
   771→    """获取四个原型顾问的视角（Prompt 模板参数化）"""
   772→    perspectives = [
   773→        {
   774→            "advisor": "关系视角",
   775→            "optimization": "和谐 + 秩序",
   776→            "prompt_hint": "考虑对方感受，先稳定关系，再解决问题",
   777→            "applicable_for": ["人际冲突", "沟通问题", "家庭关系"],
   778→        },
   779→        {
   780→            "advisor": "第一性原理视角",
   781→            "optimization": "真相 + 效率",
   782→            "prompt_hint": "问题的本质是什么？最小验证是什么？",
   783→            "applicable_for": ["决策困境", "职业选择", "重大决定"],
   784→        },
   785→        {
   786→            "advisor": "系统思维视角",
   787→            "optimization": "风险 + 概率",
   788→            "prompt_hint": "有哪些变量？因果链是什么？最坏情况概率多少？",
   789→            "applicable_for": ["复杂问题", "风险评估", "长期规划"],
   790→        },
   791→        {
   792→            "advisor": "效能整合视角",
   793→            "optimization": "平衡 + 可持续",
   794→            "prompt_hint": "重要且不紧急的事优先，建立可持续节奏",
   795→            "applicable_for": ["时间管理", "精力分配", "习惯养成"],
   796→        },
   797→    ]
   798→
   799→    return perspectives
   800→
   801→
   802→# =============================================================================
   803→# L3 Synthesis Layer - GLM 整合 + A2UI 输出
   804→# =============================================================================
   805→
   806→def build_system_prompt(
   807→    user_id: int,
   808→    persona_style: str = "warm",
   809→) -> str:
   810→    """构建 GLM System Prompt（对齐 OS 设计文档附录 A）"""
   811→
   812→    return f"""你是 Fortune AI 的对话 Agent，角色是积极心理学教练（Performance Coach）。
   813→
   814→【产品定位】
   815→人生导航 / 陪伴 / 提升。系统和交互保持"有效而极简"。
   816→
   817→【四层架构理解】
   818→- L0（定数）：用户的八字事实，作为先验约束，不做宿命论解读
   819→- L1（特质）：用户的心理图式和当前状态，作为个性化调节
   820→- L2（策略）：知识库和规则，作为专业依据
   821→- L3（意识）：你的输出，作为整合与行动引导
   822→
   823→【你的优先级（不可逆）】
   824→Coach > Teaching Assistant > Customer Support > Sales
   825→
   826→【硬性规则（必须遵守）】
   827→1) 禁止恐吓、羞辱、宿命论断言；负面信息必须紧接"你可以做什么"的行动处方。
   828→2) 禁止自行计算八字事实；只能基于提供的 facts + evidence 输出。
   829→3) 每次输出必须包含：结论(conclusion) + 依据(why) + ≤3条处方(prescriptions) + 承诺邀请(commitment_ask)。
   830→4) 处方必须包含 if_then（如果____→那么____）。
   831→5) 时间窗口默认只给干预窗口（intervention）；forecast 只能条件句+低置信度。
   832→6) 输出必须是 A2UI JSON，且第一组件必须是 markdown_text。
   833→7) 必须给出可点击 actions（start_task / schedule_task / open_panel / opt_out）。
   834→
   835→【语言风格 persona_style = {persona_style}】
   836→standard：清晰、中性、专业
   837→warm：共情、支持性（默认）
   838→roast：轻毒舌但不羞辱、不对人格做负面定性
   839→
   840→【输出格式（A2UI JSON）】
   841→{{
   842→  "meta": {{"summary": "一句话摘要"}},
   843→  "ui_components": [
   844→    {{"type": "markdown_text", "title": "输出", "data": "### 结论要点\\n...\\n### 行动处方\\n...\\n### 承诺\\n..."}},
   845→    {{"type": "action_buttons", "title": "下一步", "data": [{{"label": "开始行动", "action": {{"type": "start_task"}}}}]}}
   846→  ]
   847→}}
   848→"""
   849→
   850→
   851→def build_user_context(user_id: int) -> Dict[str, Any]:
   852→    """构建用户上下文（L0 + L1 + State Score）"""
   853→    uid = int(user_id)
   854→
   855→    # L0: 八字事实
   856→    l0 = get_l0_facts(uid)
   857→    facts = l0.get("facts", {})
   858→
   859→    # 心理学翻译
   860→    translations = translate_bazi_to_psychology(facts)
   861→
   862→    # L1: 特质图式
   863→    l1 = get_l1_schema(uid)
   864→
   865→    # State Score
   866→    state_score = calculate_state_score(uid)
   867→
   868→    return {
   869→        "l0_facts": facts,
   870→        "l0_facts_hash": l0.get("facts_hash", ""),
   871→        "l0_translations": translations,
   872→        "l1_schema": l1.to_dict(),
   873→        "state_score": state_score.to_dict(),
   874→    }
   875→
   876→
   877→def build_evidence(user_id: int, query: str = "") -> Dict[str, Any]:
   878→    """构建证据（kb_refs + rule_ids + facts_hash）"""
   879→    l0 = get_l0_facts(user_id)
   880→
   881→    # 知识库检索
   882→    kb_refs = []
   883→    if query:
   884→        kb_results = search_knowledge_base(query)
   885→        kb_refs = [r["kb_ref"] for r in kb_results]
   886→
   887→    # 规则 ID
   888→    rule_ids = []
   889→    facts = l0.get("facts", {})
   890→    bazi = facts.get("bazi", {})
   891→
   892→    if bazi.get("strength", {}).get("rule_id"):
   893→        rule_ids.append(bazi["strength"]["rule_id"])
   894→
   895→    for shensha in bazi.get("shensha", []):
   896→        if shensha.get("hit") and shensha.get("rule_id"):
   897→            rule_ids.append(shensha["rule_id"])
   898→
   899→    return {
   900→        "facts_hash": l0.get("facts_hash", ""),
   901→        "kb_refs": kb_refs,
   902→        "rule_ids": rule_ids,
   903→    }
   904→
   905→
   906→def guidance_card_to_a2ui(card: Dict[str, Any]) -> Dict[str, Any]:
   907→    """将 Guidance Card 转换为 A2UI 格式"""
   908→    title = "今日指引"
   909→    conclusion = str(card.get("conclusion") or "")
   910→    why = str(card.get("why") or "")
   911→    prescriptions = card.get("prescriptions") or []
   912→    tw = card.get("time_window") or {}
   913→    commitment_ask = str(card.get("commitment_ask") or "你愿意先做哪一个？")
   914→    risk = str(card.get("risk_boundary") or "不替代医疗/法律/投资建议")
   915→
   916→    lines: List[str] = []
   917→    lines.append("### 结论要点")
   918→    if conclusion:
   919→        lines.append(f"- {conclusion}")
   920→    lines.append("")
   921→
   922→    if why:
   923→        lines.append("### 为什么（教练视角）")
   924→        lines.append(why)
   925→        lines.append("")
   926→
   927→    if prescriptions:
   928→        lines.append("### 行动处方（≤3条）")
   929→        for i, p in enumerate(prescriptions[:3], start=1):
   930→            content = p.get("content", "")
   931→            if_then = p.get("if_then", "")
   932→            lines.append(f"{i}) {content}")
   933→            if if_then:
   934→                lines.append(f"   - 如果犹豫：{if_then}")
   935→        lines.append("")
   936→
   937→    if tw:
   938→        lines.append("### 时间窗口")
   939→        lines.append(f"- {tw.get('value') or ''}（置信度：{tw.get('confidence') or ''}）")
   940→        lines.append("")
   941→
   942→    lines.append("### 风险边界")
   943→    lines.append(risk)
   944→    lines.append("")
   945→    lines.append("### 承诺")
   946→    lines.append(commitment_ask)
   947→
   948→    actions = []
   949→    for a in card.get("actions") or []:
   950→        if not isinstance(a, dict):
   951→            continue
   952→        label = str(a.get("label") or "")
   953→        payload = {"type": str(a.get("type") or "")}
   954→        if a.get("task_id"):
   955→            payload["task_id"] = str(a["task_id"])
   956→        actions.append({"label": label, "action": payload})
   957→
   958→    return {
   959→        "meta": {"summary": conclusion[:80] or title},
   960→        "ui_components": [
   961→            {"type": "markdown_text", "title": title, "data": "\n".join(lines).strip()},
   962→            {"type": "action_buttons", "title": "下一步", "data": actions},
   963→        ],
   964→    }
   965→
   966→
   967→# =============================================================================
   968→# Commitment 管理
   969→# =============================================================================
   970→
   971→def create_commitment(
   972→    user_id: int,
   973→    *,
   974→    session_id: Optional[str] = None,
   975→    card_id: str,
   976→    source: str,
   977→    commitment_type: str,
   978→    title: str,
   979→    details: Dict[str, Any],
   980→    due_at: Optional[datetime] = None,
   981→) -> str:
   982→    """创建承诺任务"""
   983→    task_id = str(uuid4())
   984→    fortune_db.execute(
   985→        """
   986→        INSERT INTO fortune_commitment (task_id, user_id, session_id, card_id, source, commitment_type, title, details, status, due_at)
   987→        VALUES (%s::uuid, %s, %s::uuid, %s::uuid, %s, %s, %s, %s::jsonb, 'suggested', %s)
   988→        """,
   989→        (
   990→            task_id,
   991→            int(user_id),
   992→            session_id,
   993→            card_id,
   994→            source,
   995→            commitment_type,
   996→            (title or "")[:200],
   997→            json.dumps(details or {}, ensure_ascii=False),
   998→            due_at,
   999→        ),
  1000→    )
  1001→
  1002→    logger.info(
  1003→        "commitment created",
  1004→        extra={"operation": "commitment_create", "user_id": int(user_id), "task_id": task_id, "source": source},
  1005→    )
  1006→
  1007→    return task_id
  1008→
  1009→
  1010→def accept_commitment(user_id: int, task_id: str) -> bool:
  1011→    """接受承诺"""
  1012→    result = fortune_db.execute(
  1013→        """
  1014→        UPDATE fortune_commitment
  1015→        SET status = 'active', accepted_at = NOW()
  1016→        WHERE task_id = %s::uuid AND user_id = %s AND status = 'suggested'
  1017→        """,
  1018→        (task_id, int(user_id)),
  1019→    )
  1020→
  1021→    if result > 0:
  1022→        logger.info(
  1023→            "commitment accepted",
  1024→            extra={"operation": "commitment_accept", "user_id": int(user_id), "task_id": task_id},
  1025→        )
  1026→
  1027→    return result > 0
  1028→
  1029→
  1030→def complete_commitment(user_id: int, task_id: str, note: str = "") -> Dict[str, Any]:
  1031→    """完成承诺"""
  1032→    result = fortune_db.execute(
  1033→        """
  1034→        UPDATE fortune_commitment
  1035→        SET status = 'done', done_at = NOW()
  1036→        WHERE task_id = %s::uuid AND user_id = %s AND status IN ('suggested', 'active')
  1037→        """,
  1038→        (task_id, int(user_id)),
  1039→    )
  1040→
  1041→    if result > 0:
  1042→        # 计算新的 State Score
  1043→        new_score = calculate_state_score(user_id)
  1044→
  1045→        logger.info(
  1046→            "commitment completed",
  1047→            extra={
  1048→                "operation": "commitment_complete",
  1049→                "user_id": int(user_id),
  1050→                "task_id": task_id,
  1051→                "new_score": new_score.score,
  1052→            },
  1053→        )
  1054→
  1055→        return {
  1056→            "success": True,
  1057→            "state_score": new_score.to_dict(),
  1058→            "message": "做得好！你的状态分数已更新。",
  1059→        }
  1060→
  1061→    return {"success": False, "message": "任务不存在或已完成"}
  1062→
  1063→
  1064→def list_commitments(
  1065→    user_id: int,
  1066→    *,
  1067→    status: Optional[List[str]] = None,
  1068→    limit: int = 10,
  1069→) -> List[Dict[str, Any]]:
  1070→    """列出承诺任务"""
  1071→    lim = max(1, min(50, int(limit)))
  1072→    sts = status or ["suggested", "active"]
  1073→
  1074→    rows = fortune_db.fetch_all(
  1075→        """
  1076→        SELECT task_id, status, commitment_type, title, details, source, accepted_at, due_at, done_at, created_at
  1077→        FROM fortune_commitment
  1078→        WHERE user_id = %s AND status = ANY(%s)
  1079→        ORDER BY created_at DESC
  1080→        LIMIT %s
  1081→        """,
  1082→        (int(user_id), sts, lim),
  1083→    )
  1084→
  1085→    items = []
  1086→    for r in rows or []:
  1087→        items.append({
  1088→            "task_id": str(r["task_id"]),
  1089→            "status": str(r.get("status") or ""),
  1090→            "commitment_type": str(r.get("commitment_type") or ""),
  1091→            "title": str(r.get("title") or ""),
  1092→            "details": r.get("details") or {},
  1093→            "source": str(r.get("source") or ""),
  1094→            "accepted_at": (str(r["accepted_at"]) if r.get("accepted_at") else None),
  1095→            "due_at": (str(r["due_at"]) if r.get("due_at") else None),
  1096→            "done_at": (str(r["done_at"]) if r.get("done_at") else None),
  1097→            "created_at": str(r.get("created_at") or ""),
  1098→        })
  1099→
  1100→    return items
  1101→
  1102→
  1103→# =============================================================================
  1104→# 综合接口
  1105→# =============================================================================
  1106→
  1107→def get_full_context_for_chat(user_id: int, query: str = "") -> Dict[str, Any]:
  1108→    """获取完整的对话上下文（用于 Chat API）"""
  1109→    uid = int(user_id)
  1110→
  1111→    # 用户偏好
  1112→    prefs = fortune_db.fetch_one(
  1113→        "SELECT persona_style FROM fortune_user_preferences WHERE user_id = %s",
  1114→        (uid,),
  1115→    ) or {}
  1116→    persona_style = prefs.get("persona_style", "warm")
  1117→
  1118→    # 用户上下文
  1119→    user_context = build_user_context(uid)
  1120→
  1121→    # 证据
  1122→    evidence = build_evidence(uid, query)
  1123→
  1124→    # 反依赖检查
  1125→    anti_dep = check_anti_dependency(uid, query)
  1126→
  1127→    # System Prompt
  1128→    system_prompt = build_system_prompt(uid, persona_style)
  1129→
  1130→    return {
  1131→        "system_prompt": system_prompt,
  1132→        "persona_style": persona_style,
  1133→        "user_context": user_context,
  1134→        "evidence": evidence,
  1135→        "anti_dependency": {
  1136→            "should_intervene": anti_dep.should_intervene,
  1137→            "intervention_type": anti_dep.intervention_type,
  1138→            "intervention_message": anti_dep.intervention_message,
  1139→        },
  1140→    }
  1141→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
