     1→from __future__ import annotations
     2→
     3→import re
     4→from datetime import datetime, time, timezone
     5→from typing import Any, Dict, Optional
     6→from zoneinfo import ZoneInfo
     7→
     8→from fastapi import APIRouter, Request
     9→from fastapi.responses import JSONResponse
    10→from pydantic import BaseModel, Field
    11→
    12→from api.deps import require_auth, require_csrf
    13→from services import bento_service
    14→from stores import fortune_db
    15→
    16→
    17→router = APIRouter(prefix="/api/bento", tags=["bento"])
    18→
    19→
    20→def _ok(data: Dict[str, Any] | None = None) -> JSONResponse:
    21→    return JSONResponse({"ok": True, "data": data or {}})
    22→
    23→
    24→def _err(status: int, code: str, message: str, detail: Optional[Dict[str, Any]] = None) -> JSONResponse:
    25→    return JSONResponse(
    26→        {"ok": False, "error": {"code": code, "message": message, "detail": detail or {}}},
    27→        status_code=status,
    28→    )
    29→
    30→
    31→_UUID_RE = re.compile(r"^[0-9a-fA-F-]{36}$")
    32→
    33→
    34→class CommitmentAcceptRequest(BaseModel):
    35→    task_id: str = Field(..., min_length=36, max_length=36)
    36→    commitment_type: Optional[str] = Field(None, description="start_task|schedule_task")
    37→
    38→
    39→class CommitmentDoneRequest(BaseModel):
    40→    task_id: str = Field(..., min_length=36, max_length=36)
    41→
    42→
    43→class CheckinRequest(BaseModel):
    44→    mood: str = Field(..., min_length=1, max_length=50)
    45→    intensity: int = Field(..., ge=0, le=10)
    46→    note: str = Field("", max_length=1000)
    47→
    48→
    49→def _end_of_today_utc(user_id: int) -> datetime:
    50→    prefs = fortune_db.fetch_one("SELECT push_timezone FROM fortune_user_preferences WHERE user_id=%s", (int(user_id),)) or {}
    51→    tz_name = str(prefs.get("push_timezone") or "Asia/Shanghai")
    52→    try:
    53→        tz = ZoneInfo(tz_name)
    54→    except Exception:
    55→        tz = ZoneInfo("Asia/Shanghai")
    56→    now_local = datetime.now(tz)
    57→    end_local = datetime.combine(now_local.date(), time(23, 0, 0), tzinfo=tz)
    58→    return end_local.astimezone(timezone.utc)
    59→
    60→
    61→@router.get("/today")
    62→def today(request: Request):
    63→    auth = require_auth(request)
    64→    user_id = int(auth["user_id"])
    65→    data = bento_service.get_today_guidance(user_id)
    66→    return _ok(data)
    67→
    68→
    69→@router.get("/actions")
    70→def actions(request: Request):
    71→    auth = require_auth(request)
    72→    user_id = int(auth["user_id"])
    73→    items = bento_service.list_commitments(user_id, status=["suggested", "active"], limit=12)
    74→    return _ok({"tasks": items})
    75→
    76→
    77→@router.post("/commitment/accept")
    78→def accept_commitment(req: CommitmentAcceptRequest, request: Request):
    79→    auth = require_auth(request)
    80→    require_csrf(request, auth)
    81→    user_id = int(auth["user_id"])
    82→    task_id = (req.task_id or "").strip()
    83→    if not _UUID_RE.match(task_id):
    84→        return _err(400, "invalid_request", "invalid_task_id")
    85→
    86→    ctype = (req.commitment_type or "").strip() if req.commitment_type else None
    87→    if ctype is not None and ctype not in ("start_task", "schedule_task"):
    88→        return _err(400, "invalid_request", "invalid_commitment_type")
    89→    due_at = _end_of_today_utc(user_id) if ctype == "schedule_task" else None
    90→
    91→    row = fortune_db.execute_returning_one(
    92→        """
    93→        UPDATE fortune_commitment
    94→        SET
    95→          status = 'active',
    96→          accepted_at = COALESCE(accepted_at, now()),
    97→          commitment_type = COALESCE(%s, commitment_type),
    98→          due_at = COALESCE(%s, due_at)
    99→        WHERE task_id=%s AND user_id=%s AND status IN ('suggested','active')
   100→        RETURNING task_id, status, accepted_at
   101→        """,
   102→        (ctype, due_at, task_id, user_id),
   103→    )
   104→    if not row:
   105→        return _err(404, "not_found", "task_not_found")
   106→    return _ok({"task_id": str(row["task_id"]), "status": str(row["status"]), "accepted_at": str(row.get("accepted_at") or "")})
   107→
   108→
   109→@router.post("/commitment/done")
   110→def done_commitment(req: CommitmentDoneRequest, request: Request):
   111→    """
   112→    Mark a commitment as done.
   113→
   114→    Implements the full feedback loop:
   115→    1. Update commitment status to 'done'
   116→    2. Award Aura points (currency)
   117→    3. Update twin growth_streak
   118→    4. Trigger L3 dimension recalculation
   119→
   120→    This closes the "做了事→属性变化→反馈" loop from BP v1.md.
   121→    """
   122→    auth = require_auth(request)
   123→    require_csrf(request, auth)
   124→    user_id = int(auth["user_id"])
   125→    task_id = (req.task_id or "").strip()
   126→    if not _UUID_RE.match(task_id):
   127→        return _err(400, "invalid_request", "invalid_task_id")
   128→
   129→    row = fortune_db.execute_returning_one(
   130→        """
   131→        UPDATE fortune_commitment
   132→        SET
   133→          status = 'done',
   134→          done_at = now()
   135→        WHERE task_id=%s AND user_id=%s AND status IN ('active','suggested')
   136→        RETURNING task_id, status, done_at, title
   137→        """,
   138→        (task_id, user_id),
   139→    )
   140→    if not row:
   141→        return _err(404, "not_found", "task_not_found")
   142→
   143→    # === Feedback Loop Implementation ===
   144→    aura_earned = 0
   145→    new_streak = 0
   146→
   147→    try:
   148→        # 1. Award Aura points
   149→        from services import currency_service
   150→        from models.currency import CurrencyType, LedgerCategory
   151→
   152→        entry = currency_service.add_currency(
   153→            user_id=user_id,
   154→            currency_type=CurrencyType.AURA,
   155→            amount=10,  # Base reward for completing a commitment
   156→            category=LedgerCategory.EARN,
   157→            reason="commitment_complete",
   158→            ref_type="commitment",
   159→            ref_id=task_id,
   160→            description=f"完成任务: {row.get('title', '')}",
   161→        )
   162→        aura_earned = entry.amount
   163→    except Exception as e:
   164→        # Log but don't fail the request
   165→        import logging
   166→        logging.getLogger(__name__).warning("Failed to award Aura for commitment: %s", str(e))
   167→
   168→    try:
   169→        # 2. Update twin growth_streak
   170→        from services import twin_service
   171→
   172→        new_streak = twin_service.increment_growth_streak(user_id)
   173→    except Exception as e:
   174→        import logging
   175→        logging.getLogger(__name__).warning("Failed to update growth_streak: %s", str(e))
   176→
   177→    try:
   178→        # 3. Update twin dynamic state (commitments completed this week)
   179→        from services import twin_service
   180→        from models.twin import TwinLayer, TwinUpdateEvent
   181→
   182→        twin_data = twin_service.get_twin(user_id)
   183→        current_completed = 0
   184→        if twin_data.dynamic_social:
   185→            current_completed = twin_data.dynamic_social.get("commitments_completed_week", 0)
   186→
   187→        twin_service.update_twin(TwinUpdateEvent(
   188→            user_id=user_id,
   189→            layer=TwinLayer.L2,
   190→            path="dynamic_social.commitments_completed_week",
   191→            new_value=current_completed + 1,
   192→            confidence=1.0,
   193→            source="system",
   194→            trigger="commitment_done",
   195→        ))
   196→        # Note: update_twin automatically triggers L3 recalculation for L2 updates
   197→    except Exception as e:
   198→        import logging
   199→        logging.getLogger(__name__).warning("Failed to update twin for commitment: %s", str(e))
   200→
   201→    return _ok({
   202→        "task_id": str(row["task_id"]),
   203→        "status": str(row["status"]),
   204→        "done_at": str(row.get("done_at") or ""),
   205→        "rewards": {
   206→            "aura_earned": aura_earned,
   207→            "new_streak": new_streak,
   208→        },
   209→    })
   210→
   211→
   212→@router.post("/checkin")
   213→def checkin(req: CheckinRequest, request: Request):
   214→    auth = require_auth(request)
   215→    require_csrf(request, auth)
   216→    user_id = int(auth["user_id"])
   217→    data = bento_service.create_checkin(user_id, mood=req.mood, intensity=int(req.intensity), note=req.note)
   218→    md = f"### 情绪打卡\n- 情绪：{req.mood}（{int(req.intensity)}/10）\n\n### 推荐动作\n- {data['recommended_action']}\n\n你愿意现在开始吗？"
   219→    a2ui = {
   220→        "meta": {"summary": "情绪打卡"},
   221→        "ui_components": [
   222→            {"type": "markdown_text", "title": "情绪打卡", "data": md},
   223→            {
   224→                "type": "action_buttons",
   225→                "title": "下一步",
   226→                "data": [
   227→                    {"label": "开始这个动作", "action": {"type": "start_task", "task_id": data["task_id"]}},
   228→                    {"label": "加入今日计划", "action": {"type": "schedule_task", "task_id": data["task_id"]}},
   229→                    {"label": "先不需要", "action": {"type": "opt_out"}},
   230→                ],
   231→            },
   232→        ],
   233→    }
   234→    return _ok({"task_id": data["task_id"], "recommended_action": data["recommended_action"], "a2ui": a2ui})
   235→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
