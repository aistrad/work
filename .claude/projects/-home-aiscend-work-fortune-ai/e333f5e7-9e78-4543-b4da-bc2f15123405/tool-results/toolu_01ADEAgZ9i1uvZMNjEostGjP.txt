     1→from __future__ import annotations
     2→
     3→import os
     4→from typing import Any, Dict, Optional
     5→
     6→from fastapi import HTTPException, Request
     7→
     8→from services import auth_service
     9→from services.security import sha256_hex
    10→
    11→
    12→# =============================================================================
    13→# Service Token for Internal API Trust Boundary
    14→# =============================================================================
    15→
    16→# Service token for internal API calls (Next.js → FastAPI)
    17→# Must be set in both environments and kept secret
    18→INTERNAL_SERVICE_TOKEN = os.getenv("FORTUNE_INTERNAL_SERVICE_TOKEN", "")
    19→
    20→# Allowed internal IPs (fallback when token not configured)
    21→INTERNAL_ALLOWED_IPS = {"127.0.0.1", "::1", "localhost"}
    22→
    23→
    24→def require_internal_auth(request: Request) -> Dict[str, Any]:
    25→    """
    26→    Verify internal API call is authorized.
    27→
    28→    Trust boundary: Internal APIs should only be called by server-side code
    29→    (Next.js API routes), never directly from browser.
    30→
    31→    Verification order:
    32→    1. X-Service-Token header (preferred, required in production)
    33→    2. IP whitelist (fallback for local dev)
    34→    3. Session cookie (for user context extraction)
    35→    """
    36→    # 1. Check service token (primary mechanism)
    37→    token = (request.headers.get("X-Service-Token") or "").strip()
    38→    if INTERNAL_SERVICE_TOKEN:
    39→        if not token:
    40→            raise HTTPException(
    41→                status_code=403,
    42→                detail="missing_service_token",
    43→            )
    44→        if token != INTERNAL_SERVICE_TOKEN:
    45→            raise HTTPException(
    46→                status_code=403,
    47→                detail="invalid_service_token",
    48→            )
    49→    else:
    50→        # Token not configured - check IP whitelist (dev mode only)
    51→        client_ip = get_client_ip(request)
    52→        if client_ip not in INTERNAL_ALLOWED_IPS:
    53→            raise HTTPException(
    54→                status_code=403,
    55→                detail="internal_api_access_denied",
    56→            )
    57→
    58→    # 2. Still require valid session for user context
    59→    auth = get_current_auth(request)
    60→    if not auth:
    61→        raise HTTPException(status_code=401, detail="unauthorized")
    62→
    63→    return auth
    64→
    65→
    66→def get_client_ip(request: Request) -> str:
    67→    try:
    68→        return request.client.host if request.client else ""
    69→    except Exception:
    70→        return ""
    71→
    72→
    73→def get_user_agent(request: Request) -> str:
    74→    return (request.headers.get("user-agent") or "")[:500]
    75→
    76→
    77→def get_current_auth(request: Request) -> Optional[Dict[str, Any]]:
    78→    session_token = request.cookies.get("fortune_session") or ""
    79→    return auth_service.get_user_by_session_token(session_token)
    80→
    81→
    82→def require_auth(request: Request) -> Dict[str, Any]:
    83→    auth = get_current_auth(request)
    84→    if not auth:
    85→        raise HTTPException(status_code=401, detail="unauthorized")
    86→    return auth
    87→
    88→
    89→def require_csrf(request: Request, auth: Dict[str, Any]) -> None:
    90→    token = (request.headers.get("X-CSRF-Token") or "").strip()
    91→    if not token:
    92→        raise HTTPException(status_code=403, detail="missing_csrf")
    93→    got = sha256_hex(token)
    94→    expected = str(auth.get("csrf_token_hash") or "")
    95→    if not expected or got != expected:
    96→        raise HTTPException(status_code=403, detail="invalid_csrf")
    97→
    98→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
