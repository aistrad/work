     1→/**
     2→ * Fortune AI Agent Runtime - Chat API Route
     3→ *
     4→ * This is the main entry point for AI chat interactions.
     5→ * Uses Vercel AI SDK for streaming responses with tool execution.
     6→ *
     7→ * Architecture:
     8→ * 1. Auth from Cookie (fortune_session)
     9→ * 2. Fetch context from FastAPI internal API
    10→ * 3. Start run (record user message)
    11→ * 4. Stream response with Vercel AI SDK
    12→ * 5. Finalize run (commit all side effects)
    13→ */
    14→import { streamText } from 'ai';
    15→import { cookies } from 'next/headers';
    16→
    17→import { selectModel } from '@/lib/models/model-provider';
    18→import { buildSystemPrompt, buildMessages, fetchContext, type UserContext } from '@/lib/context/context-builder';
    19→import { getToolsForCommandWithContext } from '@/lib/skills';
    20→
    21→const FASTAPI_URL = process.env.FASTAPI_URL || 'http://localhost:8230';
    22→const INTERNAL_SERVICE_TOKEN = process.env.FORTUNE_INTERNAL_SERVICE_TOKEN || '';
    23→
    24→// Helper to build internal API headers
    25→function internalHeaders(sessionCookie: string): Record<string, string> {
    26→  const headers: Record<string, string> = {
    27→    'Content-Type': 'application/json',
    28→    Cookie: `fortune_session=${sessionCookie}`,
    29→  };
    30→  if (INTERNAL_SERVICE_TOKEN) {
    31→    headers['X-Service-Token'] = INTERNAL_SERVICE_TOKEN;
    32→  }
    33→  return headers;
    34→}
    35→
    36→// Request body type
    37→interface ChatRequest {
    38→  session_id?: string | null;
    39→  message: string;
    40→  command?: string | null;
    41→}
    42→
    43→// Response from run/start
    44→interface RunStartResponse {
    45→  run_id: string;
    46→  session_id: string;
    47→  user_message_id: number;
    48→}
    49→
    50→export async function POST(req: Request) {
    51→  const correlationId = `chat-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`;
    52→
    53→  try {
    54→    // 1. Get session cookie
    55→    const cookieStore = await cookies();
    56→    const sessionCookie = cookieStore.get('fortune_session')?.value;
    57→
    58→    if (!sessionCookie) {
    59→      return new Response(JSON.stringify({ error: 'unauthorized' }), {
    60→        status: 401,
    61→        headers: { 'Content-Type': 'application/json' },
    62→      });
    63→    }
    64→
    65→    // 2. Parse request body
    66→    const body: ChatRequest = await req.json();
    67→    const { session_id, message, command } = body;
    68→
    69→    if (!message || typeof message !== 'string' || message.trim().length === 0) {
    70→      return new Response(JSON.stringify({ error: 'invalid_message' }), {
    71→        status: 400,
    72→        headers: { 'Content-Type': 'application/json' },
    73→      });
    74→    }
    75→
    76→    // 3. Fetch context from FastAPI
    77→    let context: UserContext;
    78→    try {
    79→      context = await fetchContext(session_id ?? null, message, sessionCookie);
    80→    } catch (error) {
    81→      console.error('[chat] Failed to fetch context:', error);
    82→      return new Response(JSON.stringify({ error: 'context_fetch_failed' }), {
    83→        status: 502,
    84→        headers: { 'Content-Type': 'application/json' },
    85→      });
    86→    }
    87→
    88→    // 4. Start run (record user message)
    89→    let runData: RunStartResponse;
    90→    try {
    91→      const startRes = await fetch(`${FASTAPI_URL}/internal/chat/run/start`, {
    92→        method: 'POST',
    93→        headers: internalHeaders(sessionCookie),
    94→        body: JSON.stringify({
    95→          session_id: session_id ?? null,
    96→          message,
    97→          correlation_id: correlationId,
    98→        }),
    99→      });
   100→
   101→      if (!startRes.ok) {
   102→        throw new Error(`run/start failed: ${startRes.status}`);
   103→      }
   104→
   105→      runData = await startRes.json();
   106→    } catch (error) {
   107→      console.error('[chat] Failed to start run:', error);
   108→      return new Response(JSON.stringify({ error: 'run_start_failed' }), {
   109→        status: 502,
   110→        headers: { 'Content-Type': 'application/json' },
   111→      });
   112→    }
   113→
   114→    // 5. Build system prompt and messages
   115→    const systemPrompt = buildSystemPrompt(context);
   116→    const messages = buildMessages(context, message);
   117→
   118→    // 6. Select tools based on command (with user context for auth)
   119→    const tools = getToolsForCommandWithContext(command, { sessionCookie });
   120→
   121→    // 7. Stream response with Vercel AI SDK
   122→    const result = streamText({
   123→      model: selectModel(),
   124→      system: systemPrompt,
   125→      messages,
   126→      tools,
   127→      maxSteps: 5, // Allow up to 5 tool calls per request
   128→
   129→      // Finalize run when streaming completes
   130→      onFinish: async ({ text, steps, usage }) => {
   131→        try {
   132→          // Collect tool calls and A2UI cards from steps
   133→          const allToolCalls: Array<{ toolName: string; args: unknown }> = [];
   134→          const a2uiCards: Array<Record<string, unknown>> = [];
   135→
   136→          // Type-safe iteration over steps
   137→          const stepsArray = steps as Array<{
   138→            toolCalls?: Array<{ toolName: string; args: unknown }>;
   139→            toolResults?: Array<{ result: unknown }>;
   140→          }> | undefined;
   141→
   142→          for (const step of stepsArray || []) {
   143→            if (step.toolCalls) {
   144→              for (const tc of step.toolCalls) {
   145→                allToolCalls.push({
   146→                  toolName: tc.toolName,
   147→                  args: tc.args,
   148→                });
   149→              }
   150→            }
   151→            if (step.toolResults) {
   152→              for (const tr of step.toolResults) {
   153→                if (
   154→                  tr.result &&
   155→                  typeof tr.result === 'object' &&
   156→                  'type' in tr.result &&
   157→                  (tr.result as Record<string, unknown>).type === 'a2ui_card'
   158→                ) {
   159→                  a2uiCards.push(tr.result as Record<string, unknown>);
   160→                }
   161→              }
   162→            }
   163→          }
   164→
   165→          // Finalize run
   166→          await fetch(`${FASTAPI_URL}/internal/chat/run/finalize`, {
   167→            method: 'POST',
   168→            headers: internalHeaders(sessionCookie),
   169→            body: JSON.stringify({
   170→              run_id: runData.run_id,
   171→              session_id: runData.session_id,
   172→              assistant_content: text,
   173→              tool_calls: allToolCalls.length > 0 ? allToolCalls : undefined,
   174→              a2ui_cards: a2uiCards.length > 0 ? a2uiCards : undefined,
   175→              prompt_tokens: usage?.promptTokens ?? 0,
   176→              completion_tokens: usage?.completionTokens ?? 0,
   177→            }),
   178→          });
   179→        } catch (error) {
   180→          console.error('[chat] Failed to finalize run:', error);
   181→          // Don't throw - the response has already been sent
   182→        }
   183→      },
   184→    });
   185→
   186→    // 8. Return streaming response
   187→    // Add session_id to response headers for client to track
   188→    const response = result.toDataStreamResponse();
   189→
   190→    // Clone response to add custom headers
   191→    const headers = new Headers(response.headers);
   192→    headers.set('X-Session-Id', runData.session_id);
   193→    headers.set('X-Run-Id', runData.run_id);
   194→    headers.set('X-Correlation-Id', correlationId);
   195→
   196→    return new Response(response.body, {
   197→      status: response.status,
   198→      headers,
   199→    });
   200→  } catch (error) {
   201→    console.error('[chat] Unexpected error:', error);
   202→    return new Response(
   203→      JSON.stringify({
   204→        error: 'internal_error',
   205→        correlation_id: correlationId,
   206→      }),
   207→      {
   208→        status: 500,
   209→        headers: { 'Content-Type': 'application/json' },
   210→      }
   211→    );
   212→  }
   213→}
   214→
   215→// Health check for the chat endpoint
   216→export async function GET() {
   217→  return new Response(JSON.stringify({ status: 'ok', service: 'agent_runtime' }), {
   218→    headers: { 'Content-Type': 'application/json' },
   219→  });
   220→}
   221→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
