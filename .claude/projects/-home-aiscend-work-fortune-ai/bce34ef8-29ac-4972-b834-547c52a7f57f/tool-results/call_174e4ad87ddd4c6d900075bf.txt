     1→from typing import Dict, Any, List
     2→
     3→from common.logging import get_logger
     4→from services.tieban.engines import engine_stem, engine_hex, engine_day_mutation
     5→from services.tieban.mapping import verse_id_mapping
     6→
     7→logger = get_logger(__name__)
     8→
     9→ENGINE_PRIORITY = {"stem": 0, "stem_hehua": 1, "hex": 2, "day_mut": 3}
    10→PILLAR_PRIORITY = {"year": 0, "month": 1, "day": 2, "hour": 3, "all": 4}
    11→
    12→
    13→def build_candidate_pool(pillars_contexts: List[Dict[str, Any]], ruleset: Dict[str, Any], tables: Dict[str, Any]) -> Dict[str, Any]:
    14→    secret_table = tables["hex_secret_table"]
    15→    hex_constants = tables["hex_constants"]
    16→    candidates: List[Dict[str, Any]] = []
    17→    ke_cfg = ruleset.get("ke") or {}
    18→    ke_values = ke_cfg.get("values")
    19→    ke_ranges = ke_cfg.get("ke_ranges") or [1, 8]
    20→    if isinstance(ke_values, list) and ke_values:
    21→        ke_list = [int(k) for k in ke_values]
    22→    else:
    23→        if isinstance(ke_ranges, list) and len(ke_ranges) == 2:
    24→            start, end = int(ke_ranges[0]), int(ke_ranges[1])
    25→        else:
    26→            start, end = 1, 8
    27→        if start > end:
    28→            start, end = end, start
    29→        ke_list = list(range(start, end + 1))
    30→
    31→    for ctx in pillars_contexts:
    32→        pillars = ctx["pillars"]
    33→        stem_res = engine_stem(pillars, ruleset)
    34→        base_candidates: List[Dict[str, Any]] = []
    35→        base_candidates.append({"engine": "stem", "pillar": "all", "base": stem_res["base"], "meta": stem_res})
    36→        for alt in stem_res["alts"]:
    37→            base_candidates.append({"engine": "stem_hehua", "pillar": "all", "base": alt, "meta": stem_res})
    38→
    39→        hex_res = engine_hex(pillars, ruleset, secret_table, hex_constants)
    40→        for item in hex_res:
    41→            for b in item["base_values"]:
    42→                base_candidates.append(
    43→                    {
    44→                        "engine": "hex",
    45→                        "pillar": item["pillar"],
    46→                        "base": int(b),
    47→                        "meta": {"upper": item["upper"], "lower": item["lower"], "mode": item["mode"]},
    48→                    }
    49→                )
    50→
    51→        # Day mutation
    52→        day_cfg = ruleset.get("day_mutation", {}) or {}
    53→        include_secondary = bool(day_cfg.get("include_secondary", False))
    54→        day_hex: List[int] = []
    55→        for item in hex_res:
    56→            if item["pillar"] != "day":
    57→                continue
    58→            bases = item.get("base_values") or []
    59→            if not bases:
    60→                continue
    61→            if include_secondary:
    62→                day_hex.extend(bases)
    63→            else:
    64→                day_hex.append(bases[0])
    65→        for b in engine_day_mutation(day_hex, ruleset):
    66→            base_candidates.append({"engine": "day_mut", "pillar": "day", "base": int(b), "meta": {"source": "day"}})
    67→
    68→        # expand by ke
    69→        for base_item in base_candidates:
    70→            for ke in ke_list:
    71→                verse_ids = verse_id_mapping(base_item["base"], ke, ruleset)
    72→                candidates.append(
    73→                    {
    74→                        "context_id": ctx["id"],
    75→                        "engine": base_item["engine"],
    76→                        "pillar": base_item["pillar"],
    77→                        "base": base_item["base"],
    78→                        "ke": ke,
    79→                        "verse_ids": verse_ids,
    80→                        "trace": base_item["meta"],
    81→                    }
    82→                )
    83→
    84→    # stable sort + dedupe
    85→    candidates.sort(
    86→        key=lambda c: (
    87→            str(c.get("context_id")),
    88→            ENGINE_PRIORITY.get(c.get("engine"), 9),
    89→            PILLAR_PRIORITY.get(c.get("pillar"), 9),
    90→            int(c.get("base", 0)),
    91→            int(c.get("ke", 0)),
    92→        )
    93→    )
    94→    dedupe_key = ruleset.get("candidate_pool", {}).get("dedupe_key", "context_base_ke")
    95→    seen = set()
    96→    deduped: List[Dict[str, Any]] = []
    97→    for c in candidates:
    98→        if dedupe_key == "context_base_ke":
    99→            key = (c.get("context_id"), c.get("base"), c.get("ke"))
   100→        else:
   101→            key = (c.get("context_id"), c.get("base"), c.get("ke"))
   102→        if key in seen:
   103→            continue
   104→        seen.add(key)
   105→        deduped.append(c)
   106→
   107→    max_candidates = int(ruleset.get("candidate_pool", {}).get("max_candidates", len(deduped)))
   108→    truncated = False
   109→    if max_candidates > 0 and len(deduped) > max_candidates:
   110→        deduped = deduped[:max_candidates]
   111→        truncated = True
   112→
   113→    logger.info(
   114→        "candidate pool built",
   115→        extra={"operation": "tieban_pool_build", "count": len(deduped), "truncated": truncated},
   116→    )
   117→    return {
   118→        "candidates": deduped,
   119→        "count": len(deduped),
   120→        "truncated": truncated,
   121→    }
   122→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
