     1→from typing import Dict, Any, List, Tuple
     2→
     3→from common.logging import get_logger
     4→
     5→logger = get_logger(__name__)
     6→
     7→
     8→def _split_pillar(pillar: str) -> Tuple[str, str]:
     9→    if not pillar or len(pillar) < 2:
    10→        raise ValueError(f"invalid pillar: {pillar}")
    11→    return pillar[0], pillar[1]
    12→
    13→
    14→def engine_stem(pillars: Dict[str, str], ruleset: Dict[str, Any]) -> Dict[str, Any]:
    15→    stem_number_map = ruleset["stem_number_map"]
    16→    order = ruleset["stem_digit_order"]
    17→    digits: List[int] = []
    18→    stems_by_pos: List[str] = []
    19→    for key in order:
    20→        stem, _ = _split_pillar(pillars[key])
    21→        stems_by_pos.append(stem)
    22→        digits.append(int(stem_number_map[stem]))
    23→    base_a = digits[0] * 1000 + digits[1] * 100 + digits[2] * 10 + digits[3]
    24→
    25→    alts: List[int] = []
    26→    # hehua rules
    27→    hehua_rules = ruleset.get("hehua_rules", [])
    28→    wuxing_map = ruleset.get("wuxing_number_map", {})
    29→    month_branch = _split_pillar(pillars["month"])[1]
    30→    for rule in hehua_rules:
    31→        pair = rule.get("pair", [])
    32→        if len(pair) != 2:
    33→            continue
    34→        if not all(s in stems_by_pos for s in pair):
    35→            continue
    36→        months_allow = rule.get("months_allow", [])
    37→        blocked = rule.get("blocked_if_contains", [])
    38→        if months_allow and month_branch not in months_allow:
    39→            continue
    40→        if any(b in stems_by_pos for b in blocked):
    41→            continue
    42→        result_wuxing = rule.get("result_wuxing")
    43→        if result_wuxing not in wuxing_map:
    44→            continue
    45→        alt_digits = digits.copy()
    46→        for idx, stem in enumerate(stems_by_pos):
    47→            if stem in pair:
    48→                alt_digits[idx] = int(wuxing_map[result_wuxing])
    49→        alt_base = alt_digits[0] * 1000 + alt_digits[1] * 100 + alt_digits[2] * 10 + alt_digits[3]
    50→        if alt_base != base_a:
    51→            alts.append(alt_base)
    52→
    53→    return {"base": base_a, "alts": list(dict.fromkeys(alts)), "stem_sum": sum(digits), "digits": digits}
    54→
    55→
    56→def engine_hex(pillars: Dict[str, str], ruleset: Dict[str, Any], secret_table: Dict[str, Dict[str, List[int]]], hex_constants: Dict[str, int]) -> List[Dict[str, Any]]:
    57→    tmap = ruleset["trigram_map"]
    58→    stem_to_tri = tmap["stem_to_trigram"]
    59→    branch_to_tri = tmap["branch_to_trigram"]
    60→    tri_num = tmap["trigram_number"]
    61→    outputs: List[Dict[str, Any]] = []
    62→    for key in ("year", "month", "day", "hour"):
    63→        stem, branch = _split_pillar(pillars[key])
    64→        upper = stem_to_tri[stem]
    65→        lower = branch_to_tri[branch]
    66→        base_values: List[int] = []
    67→        mode = "secret"
    68→        if upper in secret_table and lower in secret_table[upper]:
    69→            base_values = [int(x) for x in secret_table[upper][lower]]
    70→        else:
    71→            mode = "formula"
    72→            head = int(tri_num[upper])
    73→            tail = int(tri_num[lower])
    74→            hex_code = f"{upper}-{lower}"
    75→            sum_yao = hex_constants.get(hex_code)
    76→            if sum_yao is None:
    77→                raise ValueError(f"missing hex_constants for {hex_code}")
    78→            base_values = [head * 1000 + int(sum_yao) - tail]
    79→        outputs.append(
    80→            {
    81→                "pillar": key,
    82→                "upper": upper,
    83→                "lower": lower,
    84→                "base_values": base_values,
    85→                "mode": mode,
    86→            }
    87→        )
    88→    return outputs
    89→
    90→
    91→def engine_day_mutation(day_hex_bases: List[int], ruleset: Dict[str, Any]) -> List[int]:
    92→    cfg = ruleset.get("day_mutation", {})
    93→    if not cfg.get("enabled"):
    94→        return []
    95→    depth = int(cfg.get("depth", 4))
    96→    step = int(cfg.get("step", 96))
    97→    # v8 规范：默认包含中心值（k=0），即 primary 本身也计入
    98→    include_zero = bool(cfg.get("include_zero", True))
    99→    out: List[int] = []
   100→    for b in day_hex_bases:
   101→        for k in range(-depth, depth + 1):
   102→            if k == 0 and not include_zero:
   103→                continue
   104→            out.append(b + step * k)
   105→    return out
   106→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
