     1→from typing import Dict, Any, List
     2→
     3→
     4→def _normalize_range(val: int, range_min: int, range_max: int) -> int:
     5→    span = range_max - range_min + 1
     6→    if span <= 0:
     7→        return val
     8→    return range_min + ((val - range_min) % span)
     9→
    10→
    11→def _apply_avoid_ten(ids: List[int], rule: Dict[str, Any]) -> List[int]:
    12→    if not rule:
    13→        return ids
    14→    if rule.get("mode") == "skip_last_digit_0":
    15→        return [i for i in ids if i % 10 != 0]
    16→    return ids
    17→
    18→
    19→def verse_id_mapping(base: int, ke: int, ruleset: Dict[str, Any]) -> List[int]:
    20→    cfg = ruleset["verse_id_mapping"]
    21→    range_min = int(cfg.get("range_min", 1001))
    22→    range_max = int(cfg.get("range_max", 13000))
    23→    step = int(cfg.get("step", 96))
    24→    holes = set(int(x) for x in cfg.get("holes", []))
    25→    mode = str(cfg.get("mode", "linear")).lower()
    26→
    27→    base_ke = base + (ke - 1)
    28→    base_norm = _normalize_range(base_ke, range_min, range_max)
    29→    if step <= 0:
    30→        return []
    31→
    32→    ids: List[int] = []
    33→    if mode == "wrap":
    34→        span = range_max - range_min + 1
    35→        cycle = span // step if step > 0 else 0
    36→        if cycle <= 0:
    37→            return []
    38→        for i in range(cycle):
    39→            val = range_min + ((base_norm - range_min + step * i) % span)
    40→            if val not in holes:
    41→                ids.append(val)
    42→    else:
    43→        current = base_norm
    44→        while current <= range_max:
    45→            if current not in holes:
    46→                ids.append(current)
    47→            current += step
    48→    ids = _apply_avoid_ten(ids, ruleset.get("avoid_ten_rule"))
    49→    return ids
    50→
    51→
    52→def apply_linear_offsets(ids: List[int], ruleset: Dict[str, Any]) -> List[int]:
    53→    cfgs = ruleset.get("linear_offsets", [])
    54→    range_min = int(ruleset["verse_id_mapping"].get("range_min", 1001))
    55→    range_max = int(ruleset["verse_id_mapping"].get("range_max", 13000))
    56→    out = set(ids)
    57→    for cfg in cfgs:
    58→        step = int(cfg.get("step", 0))
    59→        n_min = int(cfg.get("n_min", 0))
    60→        n_max = int(cfg.get("n_max", 0))
    61→        for vid in ids:
    62→            for n in range(n_min, n_max + 1):
    63→                if n == 0:
    64→                    continue
    65→                cand = vid + step * n
    66→                if range_min <= cand <= range_max:
    67→                    out.add(cand)
    68→    return sorted(out)
    69→
    70→
    71→def secret_jump_search(ids: List[int], secret_keys: List[int], ruleset: Dict[str, Any]) -> List[int]:
    72→    cfg = ruleset.get("secret_jump_search", {})
    73→    if not cfg.get("enabled"):
    74→        return ids
    75→    range_min = int(ruleset["verse_id_mapping"].get("range_min", 1001))
    76→    range_max = int(ruleset["verse_id_mapping"].get("range_max", 13000))
    77→    out = set(ids)
    78→    mode = cfg.get("mode", "add_sub")
    79→    for vid in ids:
    80→        for k in secret_keys:
    81→            if mode in ("add_sub", "add"):
    82→                cand = vid + k
    83→                if range_min <= cand <= range_max:
    84→                    out.add(cand)
    85→            if mode in ("add_sub", "sub"):
    86→                cand = vid - k
    87→                if range_min <= cand <= range_max:
    88→                    out.add(cand)
    89→    return sorted(out)
    90→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
