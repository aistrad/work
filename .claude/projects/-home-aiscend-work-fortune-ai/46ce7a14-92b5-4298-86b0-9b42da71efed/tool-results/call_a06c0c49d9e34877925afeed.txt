     1→import hashlib
     2→import os
     3→from datetime import datetime
     4→from typing import Dict, Optional, Tuple
     5→
     6→from common.logging import get_logger
     7→import os
     8→from services.bazi_engine import BaziResult, calculate_bazi, ensure_location
     9→from integrations import backend_router as be
    10→from services import conversation_store
    11→import user_store
    12→import json
    13→
    14→logger = get_logger(__name__)
    15→
    16→# 默认 System Prompt（当未提供自定义 system_prompt 时使用）
    17→DEFAULT_SYSTEM_PROMPT = (
    18→    "你是一个八字大师，基于以下信息和你的命理知识（滴天髓，《穷通宝鉴》、《三命通会》、《金不换》等经典）深度解盘，并将解盘结果以现代人熟悉的方式返回，语气建设性。"
    19→)
    20→
    21→
    22→def _birthday_iso(data: Dict) -> str:
    23→    return f"{data['year']:04d}-{data['month']:02d}-{data['day']:02d} {data['hour']:02d}:{data['minute']:02d}:00"
    24→
    25→
    26→def _compute_idempotent_key(data: Dict, location: Dict) -> str:
    27→    base = f"{data['name']}|{_birthday_iso(data)}|{location.get('longitude')}|{location.get('latitude')}|{location.get('name','')}"
    28→    return hashlib.sha256(base.encode("utf-8")).hexdigest()
    29→
    30→
    31→def _build_prompt(user_data: Dict, bazi: BaziResult) -> str:
    32→    bazi_text = f"{bazi.year_pillar}年 {bazi.month_pillar}月 {bazi.day_pillar}日 {bazi.hour_pillar}时"
    33→    return f"""
    34→请作为一位专业的国学与命理学研究专家，对以下八字进行深度解析报告。
    35→
    36→客户信息：
    37→- 姓名：{user_data['name']}
    38→- 性别：{user_data['gender']}
    39→- 出生地：{user_data.get('location_name') or bazi.location.get('name') or '北京'}（经度 {bazi.location.get('longitude')}, 纬度 {bazi.location.get('latitude')}）
    40→- 八字排盘：{bazi_text}
    41→
    42→要求：
    43→1. 全局格局分析：日主强弱、喜用神、格局。
    44→2. 性格深层剖析：结合五行生克。
    45→3. 流年大运推演：结合当前年份（{datetime.now().year}），预测未来3-5年关键转折点。
    46→4. 人生建议：事业、财运、健康可执行建议。
    47→输出不少于 2000 字，结构严谨、逻辑清晰。
    48→""".strip()
    49→
    50→
    51→def _build_standard_prompt(bazi: BaziResult, system_prompt: Optional[str] = None) -> str:
    52→    """Build prompt for standard model.
    53→
    54→    - If caller provides system_prompt: send it verbatim followed only by八字数据，不追加默认规则。
    55→    - Otherwise fall back到默认规则模板（保持原结构化 Markdown 要求）。
    56→    """
    57→    bazi_text = (
    58→        f"年柱：{bazi.year_pillar}\n"
    59→        f"月柱：{bazi.month_pillar}\n"
    60→        f"日柱：{bazi.day_pillar}\n"
    61→        f"时柱：{bazi.hour_pillar}\n"
    62→    )
    63→    user_block = (
    64→        f"待解读八字：\n{bazi_text}\n"
    65→        f"地点：{bazi.location.get('name','')}（经度 {bazi.location.get('longitude')}, 纬度 {bazi.location.get('latitude')}）\n"
    66→    )
    67→    if system_prompt and system_prompt.strip():
    68→        return system_prompt.strip() + "\n\n" + user_block
    69→
    70→    # 默认采用统一的系统提示 + 八字信息
    71→    return DEFAULT_SYSTEM_PROMPT + "\n\n" + user_block
    72→
    73→
    74→def _build_deep_research_prompt(bazi: BaziResult, system_prompt: Optional[str] = None) -> str:
    75→    user_block = (
    76→        f"年柱：{bazi.year_pillar}\n月柱：{bazi.month_pillar}\n日柱：{bazi.day_pillar}\n时柱：{bazi.hour_pillar}\n"
    77→        f"地点：{bazi.location.get('name','')}（经度 {bazi.location.get('longitude')}, 纬度 {bazi.location.get('latitude')}）。\n"
    78→    )
    79→    if system_prompt and system_prompt.strip():
    80→        return system_prompt.strip() + "\n\n" + user_block
    81→
    82→    # 默认采用统一的系统提示 + 八字信息
    83→    return DEFAULT_SYSTEM_PROMPT + "\n\n" + user_block
    84→
    85→
    86→def _pack_title_meta(meta: Dict[str, str], readable_title: str) -> str:
    87→    import json
    88→
    89→    return f"{json.dumps(meta, ensure_ascii=False)}|||{readable_title}"
    90→
    91→
    92→def _parse_title_meta(packed: str) -> Dict[str, str]:
    93→    try:
    94→        meta_s, _title = packed.split("|||", 1)
    95→        import json
    96→
    97→        return json.loads(meta_s)
    98→    except Exception:
    99→        return {}
   100→
   101→
   102→def _ensure_user_record(
   103→    name: str,
   104→    birthday_iso: str,
   105→    location: Dict,
   106→    bazi: BaziResult,
   107→    correlation_id: str,
   108→    gender: Optional[str] = None,
   109→) -> Tuple[int, str]:
   110→    user = user_store.get_fortune_user_by_name(name)
   111→    base_url = os.getenv("GEMINI_BASE_URL", "https://gemini.local/user")
   112→
   113→    if user:
   114→        gemini_url = user.get("gemini_url") or f"{base_url}/{user['user_id']}"
   115→        user_id = user["user_id"]
   116→        return user_id, gemini_url
   117→
   118→    bazi_digest = f"{bazi.year_pillar}-{bazi.month_pillar}-{bazi.day_pillar}-{bazi.hour_pillar}"
   119→    user = user_store.create_fortune_user(
   120→        name=name,
   121→        birthday=birthday_iso,
   122→        location=location,
   123→        bazi_digest=bazi_digest,
   124→        gemini_url=f"{base_url}/{os.getenv('ENV', 'dev')}-{int(datetime.utcnow().timestamp())}",
   125→        notes="auto-created",
   126→        gender=(gender or None),
   127→    )
   128→    logger.info(
   129→        "created fortune_user",
   130→        extra={"operation": "user_create", "user_id": user["user_id"], "correlation_id": correlation_id},
   131→    )
   132→    return user["user_id"], user["gemini_url"]
   133→
   134→
   135→def _ensure_user_dir(user_id: int, bazi: BaziResult, gemini_url: str) -> None:
   136→    user_dir = os.path.join("user", str(user_id))
   137→    os.makedirs(user_dir, exist_ok=True)
   138→    metadata_path = os.path.join(user_dir, "profile.json")
   139→    payload = {
   140→        "user_id": user_id,
   141→        "gemini_url": gemini_url,
   142→        "bazi": {
   143→            "year_pillar": bazi.year_pillar,
   144→            "month_pillar": bazi.month_pillar,
   145→            "day_pillar": bazi.day_pillar,
   146→            "hour_pillar": bazi.hour_pillar,
   147→            "wuxing": bazi.wuxing,
   148→            "location": bazi.location,
   149→            "used_default_location": bazi.used_default_location,
   150→            "calculated_at": bazi.calculated_at.isoformat(),
   151→        },
   152→    }
   153→    import json
   154→
   155→    with open(metadata_path, "w", encoding="utf-8") as f:
   156→        json.dump(payload, f, ensure_ascii=False, indent=2)
   157→
   158→
   159→def _pick_valid_gemini_url(tasks: list[dict]) -> Optional[str]:
   160→    """Pick a usable gemini_url from tasks.
   161→
   162→    - Prefer the latest non-empty url.
   163→    - Filter out placeholder navigation urls (ending with '/app').
   164→    """
   165→    if not tasks:
   166→        return None
   167→    for t in reversed(tasks):
   168→        url = (t or {}).get("gemini_url") or ""
   169→        if not url:
   170→            continue
   171→        if isinstance(url, bytes):
   172→            try:
   173→                url = url.decode("utf-8", errors="ignore")
   174→            except Exception:
   175→                continue
   176→        url = str(url).strip()
   177→        if not url or url.endswith("/app"):
   178→            continue
   179→        if not (url.startswith("http://") or url.startswith("https://")):
   180→            # keep conservative; skip strange schemes
   181→            continue
   182→        return url
   183→    return None
   184→
   185→
   186→def sync_job_gemini_url_to_user(job_id: int) -> bool:
   187→    """Read gemini_url from tasks and sync to fortune_user and local profile.
   188→
   189→    Returns True if an update likely happened; False otherwise. Best-effort and idempotent.
   190→    """
   191→    try:
   192→        user_id = conversation_store.find_user_by_job(job_id)
   193→    except Exception:
   194→        user_id = None
   195→    if not user_id:
   196→        return False
   197→
   198→    try:
   199→        tasks = get_tasks_by_job_id(job_id) or []
   200→    except Exception:
   201→        tasks = []
   202→    url = _pick_valid_gemini_url(tasks)
   203→    if not url:
   204→        return False
   205→
   206→    # Update DB/user store
   207→    try:
   208→        user_store.update_fortune_user_gemini_url(user_id, url)
   209→    except Exception:
   210→        # non-fatal
   211→        pass
   212→
   213→    # Update local profile.json if present
   214→    try:
   215→        user_dir = os.path.join("user", str(user_id))
   216→        profile = os.path.join(user_dir, "profile.json")
   217→        if os.path.isfile(profile):
   218→            with open(profile, "r", encoding="utf-8") as f:
   219→                data = json.load(f)
   220→            if isinstance(data, dict):
   221→                if data.get("gemini_url") != url:
   222→                    data["gemini_url"] = url
   223→                    tmp = profile + ".tmp"
   224→                    with open(tmp, "w", encoding="utf-8") as wf:
   225→                        json.dump(data, wf, ensure_ascii=False, indent=2)
   226→                    os.replace(tmp, profile)
   227→    except Exception:
   228→        pass
   229→
   230→    return True
   231→
   232→
   233→def submit_bazi_task(user_data: Dict, correlation_id: Optional[str] = None):
   234→    correlation_id = correlation_id or "manual"
   235→    loc_input = {
   236→        "longitude": user_data.get("longitude"),
   237→        "latitude": user_data.get("latitude"),
   238→        "name": user_data.get("location_name"),
   239→    }
   240→    location, used_default = ensure_location(loc_input)
   241→    birthday_iso = _birthday_iso(user_data)
   242→    idempotent_key = _compute_idempotent_key(user_data, location)
   243→
   244→    bazi = calculate_bazi(
   245→        user_data["year"],
   246→        user_data["month"],
   247→        user_data["day"],
   248→        user_data["hour"],
   249→        user_data["minute"],
   250→        location,
   251→    )
   252→    user_id, gemini_url = _ensure_user_record(
   253→        user_data["name"], birthday_iso, location, bazi, correlation_id, user_data.get("gender")
   254→    )
   255→    _ensure_user_dir(user_id, bazi, gemini_url)
   256→
   257→    prompt = _build_prompt(user_data, bazi)
   258→    tasks = [
   259→        {
   260→            "model": "deep_research",
   261→            "task_name": "analysis",
   262→            "prompt": prompt,
   263→            "input_file_path": "",
   264→            "output_file_type": "md",
   265→            "save_doc": True,
   266→        }
   267→    ]
   268→    job_name = f"{user_data['name']} - 八字深度报告"
   269→    # mimic gemini_db_test: if same job_name exists, reuse it
   270→    existing = get_gemini_job_by_job_name(job_name)
   271→    if existing:
   272→        job_id = existing["id"]
   273→        logger.info(
   274→            "reuse existing job",
   275→            extra={"operation": "task_submit", "job_id": job_id, "reason": "duplicate job_name"},
   276→        )
   277→        return job_id, user_id, used_default, bazi
   278→
   279→    user_email = os.getenv("GEMINI_USER_EMAIL")
   280→    err, job_id, task_ids = create_gemini_job(job_name, tasks) if not user_email else create_gemini_job(job_name, tasks, user_email)  # type: ignore[misc]
   281→    if err:
   282→        raise RuntimeError(err)
   283→    logger.info(
   284→        "task submitted",
   285→        extra={
   286→            "operation": "task_submit",
   287→            "job_id": job_id,
   288→            "task_ids": task_ids,
   289→            "user_id": user_id,
   290→            "correlation_id": correlation_id,
   291→            "used_default_location": used_default,
   292→            "idempotent_key": idempotent_key,
   293→        },
   294→    )
   295→    # persist conversation prompt and job→user mapping
   296→    try:
   297→        conversation_store.save_job_index(job_id, user_id)
   298→        conversation_store.append_prompt(user_id, job_id, prompt, "deep_research")
   299→    except Exception:
   300→        pass
   301→    return job_id, user_id, used_default, bazi
   302→
   303→
   304→def submit_bazi_task_v2(user_data: Dict, correlation_id: Optional[str] = None, backend_hint: Optional[str] = None, force_nonce: Optional[str] = None):
   305→    """v2 提交流程：封装 title 元数据，字段同 design v2.md。
   306→
   307→    user_data 需包含：openid, src, name, gender, year, month, day, hour, minute, longitude?, latitude?, location_name?
   308→    """
   309→    correlation_id = correlation_id or "manual"
   310→    loc_input = {
   311→        "longitude": user_data.get("longitude"),
   312→        "latitude": user_data.get("latitude"),
   313→        "name": user_data.get("location_name"),
   314→    }
   315→    location, used_default = ensure_location(loc_input)
   316→    birthday_iso = _birthday_iso(user_data)
   317→    idempotent_key = _compute_idempotent_key(user_data, location)
   318→
   319→    bazi = calculate_bazi(
   320→        user_data["year"],
   321→        user_data["month"],
   322→        user_data["day"],
   323→        user_data["hour"],
   324→        user_data["minute"],
   325→        location,
   326→    )
   327→    user_id, gemini_url = _ensure_user_record(
   328→        user_data["name"], birthday_iso, location, bazi, correlation_id, user_data.get("gender")
   329→    )
   330→    _ensure_user_dir(user_id, bazi, gemini_url)
   331→
   332→    # 模型选择与 Prompt 组装
   333→    model = (user_data.get("model") or "standard").strip().lower()
   334→    system_prompt = user_data.get("system_prompt") or None
   335→    if model not in ("standard", "deep_research", "deep_research", "deep_research"):
   336→        model = "standard"
   337→    if model == "standard":
   338→        prompt = _build_standard_prompt(bazi, system_prompt)
   339→    else:
   340→        prompt = _build_deep_research_prompt(bazi, system_prompt)
   341→
   342→    tasks = [
   343→        {
   344→            "model": model,
   345→            "task_name": "bazi_reading",
   346→            "prompt": prompt,
   347→            "input_file_path": "",
   348→            "output_file_type": "md",
   349→            "save_doc": True,
   350→        }
   351→    ]
   352→
   353→    meta = {"openid": user_data.get("openid", ""), "src": user_data.get("src", "wechat"), "ver": "2.0"}
   354→    if force_nonce:
   355→        meta["nonce"] = force_nonce
   356→    job_name = _pack_title_meta(meta, f"{user_data['name']}的八字深度报告")
   357→    # duplicate check like gemini_db_test
   358→    existing = be.get_gemini_job_by_job_name(job_name, backend=backend_hint)
   359→    if existing:
   360→        # 只读合规场景：避免复用已完成或疑似占位的旧任务，强制新建
   361→        try:
   362→            existing_tasks = be.get_tasks_by_job_id(existing["id"], backend=backend_hint) or []
   363→        except Exception:
   364→            existing_tasks = []
   365→        if existing_tasks:
   366→            main = existing_tasks[0]
   367→            st = int(main.get("status", 0) or 0)
   368→            txt = (main.get("output_text") or "")[:200]
   369→            is_placeholder = '"summary": "示例报告"' in txt and '"wuxing_chart"' in txt
   370→            if st < 10 and not is_placeholder:
   371→                # 仍在处理中的同名任务，复用它
   372→                job_id = existing["id"]
   373→                logger.info(
   374→                    "reuse existing job v2 (pending)",
   375→                    extra={"operation": "task_submit_v2", "job_id": job_id},
   376→                )
   377→                return job_id, user_id, used_default, bazi
   378→            # 否则：旧任务已完成或疑似占位，改为新建（避免返回假完成）
   379→        # 为确保唯一性，给 readable title 加时间戳后缀
   380→        import time
   381→        meta = {"openid": user_data.get("openid", ""), "src": user_data.get("src", "wechat"), "ver": "2.0", "nonce": force_nonce or int(time.time())}
   382→        job_name = _pack_title_meta(meta, f"{user_data['name']}的八字深度报告")
   383→
   384→    user_email = os.getenv("GEMINI_USER_EMAIL")
   385→    # CLI 后端需要至少 1 个 task；若为空给出清晰错误
   386→    if not tasks:
   387→        raise RuntimeError("no_tasks_built")
   388→    err, job_id, task_ids = be.create_gemini_job(job_name, tasks, user_email, backend=backend_hint)  # type: ignore[misc]
   389→    if err:
   390→        raise RuntimeError(err)
   391→    logger.info(
   392→        "task submitted v2",
   393→        extra={
   394→            "operation": "task_submit_v2",
   395→            "job_id": job_id,
   396→            "task_ids": task_ids,
   397→            "user_id": user_id,
   398→            "correlation_id": correlation_id,
   399→            "used_default_location": used_default,
   400→            "idempotent_key": idempotent_key,
   401→        },
   402→    )
   403→    # persist conversation prompt and job→user mapping
   404→    try:
   405→        conversation_store.save_job_index(job_id, user_id)
   406→        conversation_store.append_prompt(user_id, job_id, prompt, model)
   407→    except Exception:
   408→        pass
   409→    return job_id, user_id, used_default, bazi
   410→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
