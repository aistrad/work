     1→from fastapi import FastAPI, HTTPException, Request
     2→from fastapi.responses import HTMLResponse, StreamingResponse, RedirectResponse
     3→from starlette.middleware.gzip import GZipMiddleware
     4→from fastapi.staticfiles import StaticFiles
     5→from fastapi.templating import Jinja2Templates
     6→from pydantic import BaseModel, Field, validator
     7→from typing import Optional, Dict, Any, Tuple, List
     8→from uuid import uuid4
     9→import os
    10→import urllib.parse
    11→import json
    12→import re
    13→import time
    14→from datetime import datetime
    15→
    16→from common.logging import get_logger
    17→from services import task_service
    18→from services.rectification import rectify_birth_time_v2, rectify_birth_time_v2_iter
    19→from services import rectification_v3
    20→from user_store import update_fortune_user_rectification_by_name, get_fortune_user_by_name, create_fortune_user
    21→from services.bazi_engine import calculate_bazi
    22→from services.bazi_engine import DEFAULT_LOCATION
    23→from services import prompt_store
    24→import os as _os
    25→from integrations import backend_router as be
    26→from services.conversation_store import append_output, append_prompt, find_user_by_job, save_job_index
    27→from common.a2ui import validate_a2ui, ValidationError
    28→import httpx
    29→from services.task_service import sync_job_gemini_url_to_user
    30→from services import rectification_store
    31→from services.tieban import service as tieban_service
    32→
    33→logger = get_logger(__name__)
    34→app = FastAPI(title="Fortune AI API")
    35→app.add_middleware(GZipMiddleware, minimum_size=1024)
    36→
    37→# Strong cache for static files to speed up repeat loads
    38→@app.middleware("http")
    39→async def _static_cache_mw(request: Request, call_next):
    40→    response = await call_next(request)
    41→    try:
    42→        path = request.url.path
    43→        if path.startswith("/static/"):
    44→            # 1 year immutable cache; files are content-addressed by deploy hash only via manual bumps
    45→            response.headers.setdefault("Cache-Control", "public, max-age=31536000, immutable")
    46→    except Exception:
    47→        pass
    48→    return response
    49→app.mount("/static", StaticFiles(directory="api/static"), name="static")
    50→templates = Jinja2Templates(directory="api/templates")
    51→
    52→
    53→class BaziRequest(BaseModel):
    54→    name: str = Field(..., min_length=1)
    55→    gender: str = Field(..., min_length=1)
    56→    year: int
    57→    month: int
    58→    day: int
    59→    hour: int
    60→    minute: int
    61→    longitude: Optional[float] = None
    62→    latitude: Optional[float] = None
    63→    location_name: Optional[str] = None
    64→    system_prompt: Optional[str] = None
    65→
    66→    @validator("longitude")
    67→    def longitude_range(cls, v):
    68→        if v is None:
    69→            return v
    70→        if v < -180 or v > 180:
    71→            raise ValueError("longitude out of range")
    72→        return v
    73→
    74→
    75→class AskRequest(BaseModel):
    76→    """Ask on Bazi (sync) request payload (REQ-003)."""
    77→    name: str = Field(..., min_length=1)
    78→    gender: str = Field(..., min_length=1)
    79→    date: str = Field(..., description="YYYY-MM-DD")
    80→    time: str = Field(..., description="HH:MM[:SS]")
    81→    tz_offset_hours: Optional[float] = Field(8.0, description="Local time offset from UTC in hours, default +8")
    82→    longitude: Optional[float] = None
    83→    latitude: Optional[float] = None
    84→    location_name: Optional[str] = None
    85→    question: str = Field("", description="User question text")
    86→    model: Optional[str] = Field("standard", description="Model hint")
    87→
    88→
    89→class ChatMessage(BaseModel):
    90→    role: str = Field(..., description="user|assistant")
    91→    text: str = Field(..., min_length=1)
    92→
    93→
    94→class ChatAskRequest(BaseModel):
    95→    name: Optional[str] = None
    96→    session_id: Optional[str] = None
    97→    system_prompt: Optional[str] = None
    98→    messages: List[ChatMessage]
    99→    model: Optional[str] = Field("standard", description="Model hint")
   100→
   101→
   102→def _parse_date_time(date_str: str, time_str: str) -> Tuple[int, int, int, int, int]:
   103→    """Parse 'YYYY-MM-DD' and 'HH:MM[:SS]' into ints.
   104→
   105→    Returns: year, month, day, hour, minute
   106→    """
   107→    try:
   108→        y, m, d = [int(x) for x in date_str.split("-")]
   109→        parts = time_str.split(":")
   110→        hh = int(parts[0]); mm = int(parts[1]);
   111→        return y, m, d, hh, mm
   112→    except Exception:
   113→        raise HTTPException(status_code=400, detail="invalid_date_time")
   114→
   115→
   116→def _wuxing_counts(wuxing: Optional[str]) -> Dict[str, int]:
   117→    counts = {"金": 0, "木": 0, "水": 0, "火": 0, "土": 0}
   118→    if not wuxing:
   119→        return counts
   120→    for ch in counts:
   121→        counts[ch] = wuxing.count(ch)
   122→    return counts
   123→
   124→
   125→def _build_chat_prompt(system_prompt: Optional[str], messages: List[ChatMessage]) -> str:
   126→    lines: List[str] = []
   127→    if system_prompt and system_prompt.strip():
   128→        lines.append(system_prompt.strip())
   129→    lines.append("【对话】")
   130→    for m in messages:
   131→        role = "用户" if m.role == "user" else "助手"
   132→        lines.append(f"{role}: {m.text}")
   133→    lines.append("助手:")
   134→    return "\n".join(lines)
   135→
   136→
   137→def _latest_report_summary_for_user(name: str) -> Tuple[Optional[str], Optional[str]]:
   138→    """Find latest assistant text for a user name from local conversation logs.
   139→
   140→    Returns (summary_text, doc_url)
   141→    """
   142→    try:
   143→        from user_store import get_fortune_user_by_name
   144→    except Exception:
   145→        return None, None
   146→    u = get_fortune_user_by_name(name)
   147→    if not u or u.get("user_id") is None:
   148→        return None, None
   149→    uid = int(u["user_id"])  # type: ignore
   150→    conv_dir = os.path.join("user", str(uid), "conversations")
   151→    if not os.path.isdir(conv_dir):
   152→        return None, None
   153→    latest_path = None
   154→    latest_mtime = 0.0
   155→    for fn in os.listdir(conv_dir):
   156→        if not fn.endswith(".jsonl"):
   157→            continue
   158→        p = os.path.join(conv_dir, fn)
   159→        try:
   160→            mt = os.path.getmtime(p)
   161→        except Exception:
   162→            continue
   163→        if mt > latest_mtime:
   164→            latest_mtime = mt
   165→            latest_path = p
   166→    if not latest_path:
   167→        return None, None
   168→    last_text = None
   169→    doc_url = None
   170→    try:
   171→        with open(latest_path, "r", encoding="utf-8") as f:
   172→            for line in f:
   173→                line = line.strip()
   174→                if not line:
   175→                    continue
   176→                try:
   177→                    rec = json.loads(line)
   178→                except Exception:
   179→                    continue
   180→                if rec.get("role") == "assistant":
   181→                    last_text = rec.get("content") or last_text
   182→                    if rec.get("doc_url"):
   183→                        doc_url = rec.get("doc_url")
   184→    except Exception:
   185→        return None, None
   186→    if not last_text:
   187→        return None, None
   188→    # 300–600 字摘要（简单截断作为占位）
   189→    summary = str(last_text).strip()
   190→    if len(summary) > 600:
   191→        summary = summary[:600] + "…"
   192→    return summary, doc_url
   193→
   194→
   195→class AskRequest(BaseModel):
   196→    """Ask on Bazi (sync) request payload (REQ-003)."""
   197→    name: str = Field(..., min_length=1)
   198→    gender: str = Field(..., min_length=1)
   199→    date: str = Field(..., description="YYYY-MM-DD")
   200→    time: str = Field(..., description="HH:MM[:SS]")
   201→    tz_offset_hours: Optional[float] = Field(8.0, description="Local time offset from UTC in hours, default +8")
   202→    longitude: Optional[float] = None
   203→    latitude: Optional[float] = None
   204→    location_name: Optional[str] = None
   205→    question: str = Field("", description="User question text")
   206→    model: Optional[str] = Field("standard", description="Model hint")
   207→
   208→
   209→class RectifyEvent(BaseModel):
   210→    date: str
   211→    type: str
   212→    impact: Optional[str] = None
   213→
   214→
   215→class RectifyRequest(BaseModel):
   216→    name: str = Field(..., min_length=1)
   217→    birthday: str = Field(..., description="YYYY-MM-DD")
   218→    latitude: Optional[float] = None
   219→    longitude: Optional[float] = None
   220→    window_start: str = Field(..., description="HH:MM or HH:MM:SS")
   221→    window_end: str = Field(..., description="HH:MM or HH:MM:SS")
   222→    events: list[RectifyEvent]
   223→    tz_offset_hours: Optional[float] = Field(8.0, description="Local time offset from UTC in hours, default +8")
   224→    debug: Optional[bool] = Field(False, description="Return debug breakdown when true")
   225→
   226→
   227→class SystemPromptSaveRequest(BaseModel):
   228→    openid: str = Field("web", description="User identifier for prompt history grouping")
   229→    text: str = Field(..., min_length=1, description="System prompt text")
   230→    model: Optional[str] = Field("standard", description="Associated model suggestion")
   231→
   232→class BaziAskRequest(BaseModel):
   233→    question: str
   234→    name: Optional[str] = None
   235→    gender: Optional[str] = None
   236→    date: Optional[str] = None
   237→    time: Optional[str] = None
   238→    tz_offset_hours: Optional[float] = 8.0
   239→    location_name: Optional[str] = None
   240→    longitude: Optional[float] = None
   241→    latitude: Optional[float] = None
   242→
   243→
   244→class TiebanInitRequest(BaseModel):
   245→    name: str = Field(..., min_length=1)
   246→    gender: str = Field(..., min_length=1)
   247→    date: str = Field(..., description="YYYY-MM-DD")
   248→    time: str = Field(..., description="HH:MM or HH:MM:SS")
   249→    tz_offset_hours: Optional[float] = Field(8.0, description="Local time offset from UTC in hours, default +8")
   250→    location_name: Optional[str] = None
   251→    longitude: Optional[float] = None
   252→    latitude: Optional[float] = None
   253→    known_facts: Optional[Dict[str, Any]] = None
   254→    ruleset_names: Optional[list[str]] = None
   255→    debug: Optional[bool] = False
   256→
   257→
   258→class TiebanVerifyRequest(BaseModel):
   259→    run_id: str
   260→    answers: Dict[str, Any]
   261→    state_version: Optional[str] = None
   262→
   263→
   264→class TiebanLockRequest(BaseModel):
   265→    run_id: str
   266→    state_version: Optional[str] = None
   267→
   268→
   269→class TiebanSelectRequest(BaseModel):
   270→    run_id: str
   271→    candidate_id: str
   272→    state_version: Optional[str] = None
   273→
   274→
   275→def _persist_rectification_result(req: RectifyRequest, result, lat: float, lon: float) -> None:
   276→    """Best-effort persistence of rectification results to fortune_user."""
   277→    user_id: Optional[int] = None
   278→    used_default_location = (req.latitude is None) or (req.longitude is None)
   279→    try:
   280→        user = get_fortune_user_by_name(req.name)
   281→        if not user:
   282→            bt_local = result.best_time_local
   283→            bazi = calculate_bazi(
   284→                bt_local.year,
   285→                bt_local.month,
   286→                bt_local.day,
   287→                bt_local.hour,
   288→                bt_local.minute,
   289→                {"longitude": lon, "latitude": lat, "name": req.name},
   290→            )
   291→            base_url = os.getenv("GEMINI_BASE_URL", "https://gemini.local/user")
   292→            create_fortune_user(
   293→                name=req.name,
   294→                birthday=f"{bt_local.year:04d}-{bt_local.month:02d}-{bt_local.day:02d} {bt_local.hour:02d}:{bt_local.minute:02d}:{bt_local.second:02d}",
   295→                location={"longitude": lon, "latitude": lat, "name": req.name},
   296→                bazi_digest=f"{bazi.year_pillar}-{bazi.month_pillar}-{bazi.day_pillar}-{bazi.hour_pillar}",
   297→                gemini_url=f"{base_url}/{os.getenv('ENV','dev')}-{int(result.best_time_utc.timestamp())}",
   298→                notes="created by rectify",
   299→            )
   300→            user = get_fortune_user_by_name(req.name)
   301→        if user and user.get("user_id") is not None:
   302→            try:
   303→                user_id = int(user["user_id"])
   304→            except Exception:
   305→                user_id = None
   306→    except Exception:
   307→        user_id = None
   308→
   309→    # DB persistence (may fail if columns not yet migrated).
   310→    try:
   311→        update_fortune_user_rectification_by_name(
   312→            name=req.name,
   313→            rectified_time=result.best_time_utc.isoformat(),
   314→            birth_window={
   315→                "start": result.window_start_utc.isoformat(),
   316→                "end": result.window_end_utc.isoformat(),
   317→                "start_local": result.window_start_local.isoformat(),
   318→                "end_local": result.window_end_local.isoformat(),
   319→                "tz_offset_hours": req.tz_offset_hours or 8.0,
   320→                "step_seconds": 30,
   321→                "location": {"longitude": lon, "latitude": lat, "used_default": used_default_location},
   322→            },
   323→            life_events=[e.dict() for e in req.events],
   324→        )
   325→    except Exception as e:
   326→        logger.warning("rectify persist db failed", extra={"operation": "rectify_persist_db", "error": str(e)[:200]})
   327→
   328→    # Local persistence (always attempt) for audit/debug without exposing via API.
   329→    if user_id is not None:
   330→        try:
   331→            req_payload = {
   332→                "birthday": req.birthday,
   333→                "tz_offset_hours": req.tz_offset_hours or 8.0,
   334→                "latitude": lat,
   335→                "longitude": lon,
   336→                "used_default_location": used_default_location,
   337→                "window_start": req.window_start,
   338→                "window_end": req.window_end,
   339→                "events": [e.dict() for e in req.events],
   340→            }
   341→            result_payload = _rectify_response_payload(result, received_events=req_payload["events"])
   342→            rec = rectification_store.make_rectification_record(name=req.name, req_payload=req_payload, result_payload=result_payload)
   343→            rectification_store.save_rectification_run(user_id, rec)
   344→        except Exception:
   345→            return
   346→
   347→
   348→def _rectify_response_payload(result, received_events: Optional[list] = None) -> Dict[str, Any]:
   349→    payload: Dict[str, Any] = {
   350→        "status": "ok",
   351→        "best_time": result.best_time_utc.isoformat(),
   352→        "best_local_time": result.best_time_local.isoformat(),
   353→        "candidates": [
   354→            {
   355→                "time": c.time_utc.isoformat(),
   356→                "local_time": c.time_local.isoformat(),
   357→                "score": round(float(c.score), 3),
   358→                **({"breakdown": c.breakdown} if c.breakdown is not None else {}),
   359→            }
   360→            for c in result.candidates
   361→        ],
   362→        "window": {
   363→            "start": result.window_start_utc.isoformat(),
   364→            "end": result.window_end_utc.isoformat(),
   365→            "start_local": result.window_start_local.isoformat(),
   366→            "end_local": result.window_end_local.isoformat(),
   367→            "location": getattr(result, "window_location", None) or None,
   368→        },
   369→        "used_swisseph": result.used_swisseph,
   370→    }
   371→    if result.debug is not None:
   372→        payload["debug"] = result.debug
   373→    if received_events is not None:
   374→        payload["received_events"] = received_events
   375→    return payload
   376→
   377→
   378→@app.on_event("startup")
   379→def startup():
   380→    if os.getenv("STUB_DB") == "1":
   381→        return
   382→    # 初始化保留给 gemini 后端；cli 后端无需池化
   383→    if os.getenv("GEMINI_BACKEND", "gemini").lower() != "cli":
   384→        try:
   385→            from integrations.gemini_repo import init_connection_pool
   386→            init_connection_pool()
   387→        except Exception:
   388→            pass
   389→
   390→
   391→@app.get("/healthz")
   392→def healthz():
   393→    return {"status": "ok"}
   394→
   395→
   396→@app.get("/", include_in_schema=False)
   397→def root_redirect():
   398→    # Redirect root to the /bazi page for better UX
   399→    return RedirectResponse(url="/bazi", status_code=307)
   400→
   401→
   402→@app.get("/bazi", response_class=HTMLResponse)
   403→def page_bazi(request: Request):
   404→    # 使用新版页面（视觉风格与 /tieban 对齐，复用 tieban.css）
   405→    return templates.TemplateResponse("bazi.html", {"request": request})
   406→
   407→
   408→@app.get("/tieban", response_class=HTMLResponse)
   409→def tieban_page(request: Request):
   410→    asset_version = os.getenv("ASSET_VER") or str(int(time.time() // 3600))
   411→    return templates.TemplateResponse("tieban.html", {"request": request, "asset_version": asset_version})
   412→
   413→@app.get("/bazi2", response_class=HTMLResponse)
   414→def bazi2_page(request: Request):
   415→    # 兼容旧链接：跳转到 /main
   416→    return RedirectResponse(url="/main", status_code=307)
   417→
   418→@app.get("/main", response_class=HTMLResponse)
   419→def bazi_main_page(request: Request):
   420→    """Two-pane prototype: chat (left) + workbench (right)."""
   421→    if os.getenv("ASSET_VER"):
   422→        asset_version = os.getenv("ASSET_VER")
   423→    else:
   424→        try:
   425→            css_m = os.path.getmtime(os.path.join("api", "static", "ui.css"))
   426→            js_m = os.path.getmtime(os.path.join("api", "static", "ui.js"))
   427→            asset_version = str(int(max(css_m, js_m)))
   428→        except Exception:
   429→            asset_version = str(int(time.time()))
   430→    return templates.TemplateResponse("bazi2.html", {"request": request, "asset_version": asset_version})
   431→
   432→
   433→# ------------------------------ Conversations History (list + detail) ------------------------------
   434→
   435→
   436→@app.get("/api/conversations")
   437→def api_conversations(name: str, limit: int = 20):
   438→    """List recent conversation sessions for a user name (best-effort local only)."""
   439→    try:
   440→        u = get_fortune_user_by_name(name)
   441→    except Exception:
   442→        u = None
   443→    if not u or u.get("user_id") is None:
   444→        return {"sessions": []}
   445→    uid = int(u["user_id"])  # type: ignore
   446→    conv_dir = os.path.join("user", str(uid), "conversations")
   447→    if not os.path.isdir(conv_dir):
   448→        return {"sessions": []}
   449→    items: list[dict] = []
   450→    for fn in os.listdir(conv_dir):
   451→        if not fn.endswith(".jsonl"):
   452→            continue
   453→        p = os.path.join(conv_dir, fn)
   454→        try:
   455→            mt = os.path.getmtime(p)
   456→        except Exception:
   457→            continue
   458→        # read last assistant snippet
   459→        preview = None
   460→        try:
   461→            with open(p, "r", encoding="utf-8") as f:
   462→                for line in f:
   463→                    try:
   464→                        rec = json.loads(line.strip())
   465→                    except Exception:
   466→                        continue
   467→                    if rec.get("role") == "assistant":
   468→                        preview = rec.get("content") or preview
   469→        except Exception:
   470→            preview = None
   471→        items.append({
   472→            "session_id": fn[:-6],
   473→            "updated_at": datetime.utcfromtimestamp(mt).isoformat() + "Z",
   474→            "preview": (preview or "")[:160],
   475→        })
   476→    items.sort(key=lambda x: x["updated_at"], reverse=True)
   477→    return {"sessions": items[: max(1, int(limit))]}
   478→
   479→
   480→@app.get("/api/conversations/detail")
   481→def api_conversations_detail(name: str, session_id: str):
   482→    if not re.fullmatch(r"[A-Za-z0-9_-]{1,128}", session_id or ""):
   483→        raise HTTPException(status_code=400, detail="invalid_session_id")
   484→    try:
   485→        u = get_fortune_user_by_name(name)
   486→    except Exception:
   487→        u = None
   488→    if not u or u.get("user_id") is None:
   489→        raise HTTPException(status_code=404, detail="user_not_found")
   490→    uid = int(u["user_id"])  # type: ignore
   491→    conv_dir = os.path.join("user", str(uid), "conversations")
   492→    p = os.path.join(conv_dir, f"{session_id}.jsonl")
   493→    if not os.path.isfile(p):
   494→        raise HTTPException(status_code=404, detail="session_not_found")
   495→    msgs: list[dict] = []
   496→    with open(p, "r", encoding="utf-8") as f:
   497→        for line in f:
   498→            try:
   499→                rec = json.loads(line.strip())
   500→            except Exception:
   501→                continue
   502→            role = rec.get("role") or "assistant"
   503→            text = rec.get("content") or ""
   504→            msgs.append({"role": role, "text": text, "ts": rec.get("ts")})
   505→    return {"messages": msgs}
   506→
   507→
   508→@app.get("/api/user/by-name")
   509→def api_user_by_name(name: str):
   510→    """Return basic user info and birth fields for autofill; best-effort, read-only."""
   511→    try:
   512→        u = get_fortune_user_by_name(name)
   513→    except Exception:
   514→        u = None
   515→    if not u:
   516→        return {"found": False}
   517→    # Parse birth date/time
   518→    date_str = ""; time_str = ""
   519→    bday = str(u.get("birthday") or "")
   520→    if bday:
   521→        parts = bday.split()
   522→        if len(parts) >= 1:
   523→            date_str = parts[0]
   524→        if len(parts) >= 2:
   525→            time_str = parts[1]
   526→    loc = u.get("location") or {}
   527→    birth_fields = {
   528→        "date": date_str,
   529→        "time": time_str,
   530→        "location_name": (loc.get("name") if isinstance(loc, dict) else None) or "",
   531→        "longitude": (loc.get("longitude") if isinstance(loc, dict) else None),
   532→        "latitude": (loc.get("latitude") if isinstance(loc, dict) else None),
   533→    }
   534→    return {"found": True, "user": u, "birth_fields": birth_fields}
   535→
   536→
   537→@app.post("/api/chat/ask")
   538→def api_chat_ask(req: ChatAskRequest):
   539→    audit_id = str(uuid4())
   540→    if not req or not req.messages:
   541→        raise HTTPException(status_code=400, detail="empty_messages")
   542→    msgs = [m for m in req.messages if (m.text or "").strip()]
   543→    msgs = msgs[-10:]
   544→    prompt = _build_chat_prompt(req.system_prompt, msgs)
   545→    if os.getenv("DEMO_MODE") == "1":
   546→        return {"status": "processing", "job_id": 101, "audit_id": audit_id}
   547→
   548→    model = (req.model or "standard").strip().lower()
   549→    tasks = [
   550→        {
   551→            "model": model,
   552→            "task_name": "chat",
   553→            "prompt": prompt,
   554→            "input_file_path": "",
   555→            "output_file_type": "md",
   556→            "save_doc": True,
   557→        }
   558→    ]
   559→    job_name = f"{req.name or 'Chat'} - 对话 {int(time.time())}"
   560→    user_email = os.getenv("GEMINI_USER_EMAIL")
   561→    err, job_id, task_ids = create_gemini_job(job_name, tasks) if not user_email else create_gemini_job(job_name, tasks, user_email)  # type: ignore[misc]
   562→    if err or not job_id:
   563→        logger.error("chat job create failed", extra={"operation": "chat_ask", "error": str(err), "audit_id": audit_id})
   564→        raise HTTPException(status_code=500, detail="chat_failed")
   565→    logger.info("chat job created", extra={"operation": "chat_ask", "job_id": job_id, "task_ids": task_ids, "audit_id": audit_id})
   566→
   567→    if req.name:
   568→        try:
   569→            u = get_fortune_user_by_name(req.name)
   570→            user_id = int(u.get("user_id")) if u and u.get("user_id") is not None else None
   571→        except Exception:
   572→            user_id = None
   573→        if user_id is not None:
   574→            try:
   575→                last_user = next((m.text for m in reversed(msgs) if m.role == "user"), "")
   576→                if last_user:
   577→                    append_prompt(user_id, job_id, last_user, req.model or "standard")
   578→                save_job_index(job_id, user_id)
   579→            except Exception:
   580→                pass
   581→
   582→    return {"status": "processing", "job_id": job_id, "audit_id": audit_id}
   583→
   584→
   585→@app.post("/api/bazi/ask")
   586→def api_bazi_ask_placeholder(req: BaziAskRequest):
   587→    # 兼容占位：若缺出生信息，提示用户在右侧填写；否则转发给正式端点
   588→    if not req or not (req.date and req.time and req.name and req.gender):
   589→        if (req.question or '').strip() == '':
   590→            raise HTTPException(status_code=400, detail="empty_question")
   591→        return {"status": "ok", "answer_md": "（占位）请在右侧填写出生信息后再次提问。"}
   592→    full = AskRequest(
   593→        name=req.name, gender=req.gender, date=req.date, time=req.time,
   594→        tz_offset_hours=float(req.tz_offset_hours or 8.0), longitude=req.longitude, latitude=req.latitude, location_name=req.location_name,
   595→        question=req.question or "", model="standard",
   596→    )
   597→    return api_bazi_ask(full)  # type: ignore
   598→
   599→
   600→# ------------------------------ Ask on Bazi (sync + SSE) ------------------------------
   601→
   602→
   603→@app.post("/api/bazi/ask")
   604→def api_bazi_ask(req: AskRequest):
   605→    """Synchronous Ask endpoint (REQ-003)."""
   606→    audit_id = str(uuid4())
   607→    try:
   608→        y, m, d, hh, mm = _parse_date_time(req.date, req.time)
   609→        bazi = calculate_bazi(
   610→            y, m, d, hh, mm,
   611→            {"longitude": req.longitude or DEFAULT_LOCATION["longitude"],
   612→             "latitude": req.latitude or DEFAULT_LOCATION["latitude"],
   613→             "name": req.location_name or DEFAULT_LOCATION.get("name", "")},
   614→        )
   615→        counts = _wuxing_counts(bazi.wuxing)
   616→        report_summary, doc_url = _latest_report_summary_for_user(req.name)
   617→
   618→        # Build structured markdown per spec
   619→        lines = []
   620→        lines.append("### 结论要点")
   621→        trend = ", ".join([f"{k}{v}" for k, v in counts.items() if v > 0]) or "暂无"
   622→        lines.append(f"- 五行倾向：{trend}")
   623→        lines.append("- 近期关注：事业/健康/情绪（结合个人上下文自检）")
   624→        lines.append("")
   625→        lines.append("### 依据与引用")
   626→        lines.append(f"- 四柱：{bazi.year_pillar}・{bazi.month_pillar}・{bazi.day_pillar}・{bazi.hour_pillar}")
   627→        lines.append(f"- 五行：{bazi.wuxing or '未知'}")
   628→        if report_summary:
   629→            lines.append("- 历史报告摘要：")
   630→            lines.append(report_summary)
   631→        else:
   632→            lines.append("- 历史报告：未找到，已仅基于八字作答")
   633→        lines.append("")
   634→        lines.append("### 不确定性与下一步")
   635→        lines.append("- 若存在校准结果，请补充校准时间以提升准确度。")
   636→        lines.append("- 可提供近三年关键事件以获得更个性化建议。")
   637→
   638→        answer_md = "\n".join(lines)
   639→
   640→        # Best-effort: append conversation snapshot to local logs
   641→        try:
   642→            u = get_fortune_user_by_name(req.name)
   643→            user_id = int(u.get("user_id")) if u and u.get("user_id") is not None else None
   644→        except Exception:
   645→            user_id = None
   646→        try:
   647→            if user_id is not None:
   648→                session_id = int(time.time())
   649→                if req.question:
   650→                    append_prompt(user_id, session_id, req.question, req.model or "standard")
   651→                append_output(user_id, session_id, answer_md, url=doc_url)
   652→        except Exception:
   653→            pass
   654→
   655→        return {
   656→            "status": "ok",
   657→            "answer_md": answer_md,
   658→            "used_context": {
   659→                "bazi_used": {
   660→                    "year_pillar": bazi.year_pillar,
   661→                    "month_pillar": bazi.month_pillar,
   662→                    "day_pillar": bazi.day_pillar,
   663→                    "hour_pillar": bazi.hour_pillar,
   664→                    "wuxing": bazi.wuxing,
   665→                    "counts": counts,
   666→                },
   667→                "report_used": bool(report_summary),
   668→                "doc_url": doc_url,
   669→            },
   670→            "audit_id": audit_id,
   671→        }
   672→    except HTTPException:
   673→        raise
   674→    except Exception as e:
   675→        logger.error("ask sync failed", extra={"operation": "bazi_ask_sync", "error": str(e), "audit_id": audit_id})
   676→        raise HTTPException(status_code=500, detail="ask_failed")
   677→
   678→
   679→@app.get("/api/bazi/ask/stream")
   680→def api_bazi_ask_stream(
   681→    name: str,
   682→    gender: str,
   683→    date: str,
   684→    time: str,
   685→    tz_offset_hours: float = 8.0,
   686→    longitude: Optional[float] = None,
   687→    latitude: Optional[float] = None,
   688→    location_name: Optional[str] = None,
   689→    question: str = "",
   690→    model: str = "standard",
   691→):
   692→    audit_id = str(uuid4())
   693→
   694→    def _sse(obj: Dict[str, Any]) -> bytes:
   695→        return (f"data: {json.dumps(obj, ensure_ascii=False)}\n\n").encode("utf-8")
   696→
   697→    def _gen():
   698→        try:
   699→            y, m, d, hh, mm = _parse_date_time(date, time)
   700→            bazi = calculate_bazi(
   701→                y, m, d, hh, mm,
   702→                {"longitude": longitude or DEFAULT_LOCATION["longitude"],
   703→                 "latitude": latitude or DEFAULT_LOCATION["latitude"],
   704→                 "name": location_name or DEFAULT_LOCATION.get("name", "")},
   705→            )
   706→            counts = _wuxing_counts(bazi.wuxing)
   707→            report_summary, _doc_url = _latest_report_summary_for_user(name)
   708→
   709→            chunks = [
   710→                {"type": "chunk", "text": "### 结论要点\n"},
   711→                {"type": "chunk", "text": f"- 五行倾向：{', '.join([f'{k}{v}' for k,v in counts.items() if v>0]) or '暂无'}\n"},
   712→                {"type": "chunk", "text": "\n### 依据与引用\n"},
   713→                {"type": "chunk", "text": f"- 四柱：{bazi.year_pillar}・{bazi.month_pillar}・{bazi.day_pillar}・{bazi.hour_pillar}\n"},
   714→                {"type": "chunk", "text": f"- 五行：{bazi.wuxing or '未知'}\n"},
   715→            ]
   716→            if report_summary:
   717→                chunks.append({"type": "chunk", "text": "- 历史报告摘要：\n" + report_summary + "\n"})
   718→            else:
   719→                chunks.append({"type": "chunk", "text": "- 历史报告：未找到，已仅基于八字作答\n"})
   720→            chunks.extend([
   721→                {"type": "chunk", "text": "\n### 不确定性与下一步\n"},
   722→                {"type": "chunk", "text": "- 若存在校准结果，请补充校准时间以提升准确度。\n"},
   723→                {"type": "chunk", "text": "- 可提供近三年关键事件以获得更个性化建议。\n"},
   724→            ])
   725→
   726→            for c in chunks:
   727→                yield _sse({**c, "audit_id": audit_id})
   728→                time.sleep(0.05)
   729→
   730→            yield _sse({
   731→                "type": "done",
   732→                "audit_id": audit_id,
   733→            })
   734→        except Exception as e:
   735→            logger.error("ask stream failed", extra={"operation": "bazi_ask_stream", "error": str(e), "audit_id": audit_id})
   736→            yield _sse({"type": "error", "detail": "ask_failed", "audit_id": audit_id})
   737→
   738→    return StreamingResponse(
   739→        _gen(),
   740→        media_type="text/event-stream",
   741→        headers={"Cache-Control": "no-cache", "X-Accel-Buffering": "no"},
   742→    )
   743→
   744→
   745→@app.get("/h5/a2ui", response_class=HTMLResponse)
   746→def h5_a2ui(request: Request):
   747→    # 允许通过 query 传 openid 以加载 system prompt 历史
   748→    params = dict(request.query_params)
   749→    openid = params.get("userid") or params.get("openid") or ""
   750→    history = []
   751→    presets = prompt_store.get_presets()
   752→    if openid:
   753→        try:
   754→            history = prompt_store.get_history_for_openid(openid, limit=20)
   755→        except Exception:
   756→            history = []
   757→    return templates.TemplateResponse("a2ui.html", {"request": request, "openid": openid, "prompt_history": history, "prompt_presets": presets})
   758→
   759→
   760→@app.get("/fortune", response_class=HTMLResponse)
   761→def fortune(request: Request):
   762→    """Same page under /fortune for Telegram link compatibility."""
   763→    # Mirror /h5/a2ui behavior for prompt history/presets
   764→    params = dict(request.query_params)
   765→    openid = params.get("userid") or params.get("openid") or ""
   766→    history = []
   767→    presets = prompt_store.get_presets()
   768→    if openid:
   769→        try:
   770→            history = prompt_store.get_history_for_openid(openid, limit=20)
   771→        except Exception:
   772→            history = []
   773→    return templates.TemplateResponse("a2ui.html", {"request": request, "openid": openid, "prompt_history": history, "prompt_presets": presets})
   774→
   775→
   776→@app.get("/api/system-prompts")
   777→def api_system_prompts(openid: str = "web"):
   778→    try:
   779→        presets = prompt_store.get_presets()
   780→        history = prompt_store.get_history_for_openid(openid, limit=50)
   781→        return {"presets": presets, "history": history}
   782→    except Exception as e:
   783→        logger.warning("system prompt fetch failed", extra={"operation": "api_system_prompts", "error": str(e)})
   784→        raise HTTPException(status_code=500, detail="system_prompt_error")
   785→
   786→
   787→@app.post("/api/system-prompts")
   788→def api_save_system_prompt(req: SystemPromptSaveRequest):
   789→    try:
   790→        txt = (req.text or "").strip()
   791→        if not txt:
   792→            return {"status": "ignored"}
   793→        prompt_store.append_for_openid(req.openid or "web", txt, req.model or "standard")
   794→        return {"status": "ok"}
   795→    except Exception as e:
   796→        logger.warning("system prompt save failed", extra={"operation": "api_save_system_prompt", "error": str(e)})
   797→        raise HTTPException(status_code=500, detail="system_prompt_error")
   798→
   799→
   800→@app.post("/api/tieban/init")
   801→def api_tieban_init(req: TiebanInitRequest):
   802→    try:
   803→        payload = req.dict()
   804→        result = tieban_service.init_tieban(payload)
   805→        return result
   806→    except Exception as e:
   807→        logger.error("tieban init failed", extra={"operation": "tieban_init", "error": str(e)[:200]})
   808→        raise HTTPException(status_code=500, detail="tieban_init_error")
   809→
   810→
   811→@app.post("/api/tieban/verify")
   812→def api_tieban_verify(req: TiebanVerifyRequest):
   813→    try:
   814→        result = tieban_service.verify_tieban(req.run_id, req.answers, req.state_version)
   815→        return result
   816→    except Exception as e:
   817→        if str(e) == "state_version_conflict":
   818→            raise HTTPException(status_code=409, detail="state_version_conflict")
   819→        logger.error("tieban verify failed", extra={"operation": "tieban_verify", "error": str(e)[:200]})
   820→        raise HTTPException(status_code=500, detail="tieban_verify_error")
   821→
   822→
   823→@app.post("/api/tieban/select")
   824→def api_tieban_select(req: TiebanSelectRequest):
   825→    try:
   826→        result = tieban_service.select_tieban(req.run_id, req.candidate_id, req.state_version)
   827→        return result
   828→    except Exception as e:
   829→        if str(e) == "state_version_conflict":
   830→            raise HTTPException(status_code=409, detail="state_version_conflict")
   831→        if str(e) in ("missing_required_facts", "required_fact_not_matched", "candidate_not_found"):
   832→            raise HTTPException(status_code=400, detail=str(e))
   833→        logger.error("tieban select failed", extra={"operation": "tieban_select", "error": str(e)[:200]})
   834→        raise HTTPException(status_code=500, detail="tieban_select_error")
   835→
   836→
   837→@app.post("/api/tieban/lock")
   838→def api_tieban_lock(req: TiebanLockRequest):
   839→    try:
   840→        result = tieban_service.lock_tieban(req.run_id, req.state_version)
   841→        return result
   842→    except Exception as e:
   843→        if str(e) == "state_version_conflict":
   844→            raise HTTPException(status_code=409, detail="state_version_conflict")
   845→        if str(e) == "deprecated_use_select":
   846→            raise HTTPException(status_code=400, detail="deprecated_use_select")
   847→        logger.error("tieban lock failed", extra={"operation": "tieban_lock", "error": str(e)[:200]})
   848→        raise HTTPException(status_code=500, detail="tieban_lock_error")
   849→
   850→
   851→@app.get("/api/tieban/report")
   852→def api_tieban_report(run_id: str):
   853→    try:
   854→        return tieban_service.get_report(run_id)
   855→    except Exception as e:
   856→        logger.error("tieban report failed", extra={"operation": "tieban_report", "error": str(e)[:200]})
   857→        raise HTTPException(status_code=404, detail="tieban_report_error")
   858→
   859→
   860→@app.post("/api/calculate")
   861→def create_report(req: BaziRequest, backend: str | None = None):
   862→    correlation_id = str(uuid4())
   863→    try:
   864→        # 先计算八字命盘并即时返回；后台另起 v2 任务走“standard”模型
   865→        base = req.dict()
   866→        job_id, user_id, used_default, bazi = task_service.submit_bazi_task_v2(
   867→            {
   868→                "openid": "web",
   869→                "src": "web",
   870→                "model": "standard",
   871→                **base,
   872→            },
   873→            correlation_id=correlation_id,
   874→            backend_hint=backend,
   875→        )
   876→        try:
   877→            if req.system_prompt:
   878→                prompt_store.append_for_openid("web", req.system_prompt, "standard")
   879→        except Exception:
   880→            pass
   881→        return {
   882→            "job_id": job_id,
   883→            "user_id": user_id,
   884→            "status": "processing",
   885→            "used_default_location": used_default,
   886→            "default_location": DEFAULT_LOCATION if used_default else None,
   887→            "bazi": {
   888→                "year_pillar": bazi.year_pillar,
   889→                "month_pillar": bazi.month_pillar,
   890→                "day_pillar": bazi.day_pillar,
   891→                "hour_pillar": bazi.hour_pillar,
   892→                "wuxing": bazi.wuxing,
   893→                "location": bazi.location,
   894→            },
   895→        }
   896→    except ValueError as ve:
   897→        logger.warning("validation failed", extra={"operation": "api_calculate", "error": str(ve), "correlation_id": correlation_id})
   898→        raise HTTPException(status_code=400, detail=str(ve))
   899→    except Exception as e:
   900→        msg = str(e)
   901→        logger.error("calculate failed", extra={"operation": "api_calculate", "error": msg, "correlation_id": correlation_id})
   902→        if msg in ("empty_prompt", "no_tasks", "no_tasks_built"):
   903→            raise HTTPException(status_code=400, detail=msg)
   904→        raise HTTPException(status_code=500, detail="internal_error")
   905→
   906→
   907→@app.get("/api/report/{job_id}")
   908→def get_report(job_id: int, backend: str | None = None):
   909→    tasks = be.get_tasks_by_job_id(job_id, backend=backend)
   910→    if not tasks:
   911→        return {"status": "error", "message": "no_tasks"}
   912→
   913→    main_task = tasks[0]
   914→    status_val = main_task.get("status", 0)
   915→    if status_val < 99:
   916→        return {"status": "processing", "progress": status_val}
   917→    if not main_task.get("output_text") and not main_task.get("output_url"):
   918→        # For CLI backend, try expose the first inline file as a download link
   919→        if (backend or os.getenv("GEMINI_BACKEND", "gemini")).strip().lower() == "cli":
   920→            try:
   921→                from integrations.cli_worker_repo import list_output_files_by_job_id
   922→                files = list_output_files_by_job_id(job_id)
   923→                if files:
   924→                    # choose the first file; if it has content, we can stream it via /api/files
   925→                    dl = f"/api/files/{job_id}?backend=cli"
   926→                    return {"status": "completed", "content": None, "doc_url": dl}
   927→            except Exception:
   928→                pass
   929→        return {"status": "error", "message": "task_missing_output"}
   930→
   931→    content = main_task.get("output_text")
   932→    doc_url = main_task.get("output_url")
   933→    # persist conversation output if user is known
   934→    try:
   935→        uid = find_user_by_job(job_id)
   936→        if uid is not None and (content or doc_url):
   937→            append_output(uid, job_id, content or "", doc_url)
   938→    except Exception:
   939→        pass
   940→
   941→    # best-effort: sync gemini_url to fortune_user when job is done
   942→    try:
   943→        sync_job_gemini_url_to_user(job_id)
   944→    except Exception:
   945→        pass
   946→
   947→    return {
   948→        "status": "completed",
   949→        "content": content,
   950→        "doc_url": doc_url,
   951→    }
   952→
   953→
   954→@app.post("/api/rectify")
   955→def api_rectify(req: RectifyRequest):
   956→    try:
   957→        # 对于未提供经纬度的情况，使用默认北京经纬度（与八字计算一致）
   958→        lat = req.latitude if req.latitude is not None else DEFAULT_LOCATION["latitude"]
   959→        lon = req.longitude if req.longitude is not None else DEFAULT_LOCATION["longitude"]
   960→        result = rectify_birth_time_v2(
   961→            name=req.name,
   962→            birthday=req.birthday,
   963→            lat=lat,
   964→            lon=lon,
   965→            window_start_hms=req.window_start,
   966→            window_end_hms=req.window_end,
   967→            events_raw=[e.dict() for e in req.events],
   968→            tz_offset_hours=req.tz_offset_hours or 8.0,
   969→            step_seconds=30,
   970→            debug=bool(req.debug),
   971→        )
   972→        _persist_rectification_result(req, result, lat=lat, lon=lon)
   973→        return _rectify_response_payload(result, received_events=[e.dict() for e in req.events])
   974→    except Exception as e:
   975→        logger.error("rectify failed", extra={"operation": "api_rectify", "error": str(e)})
   976→        raise HTTPException(status_code=400, detail="rectify_failed")
   977→
   978→
   979→@app.post("/api/rectify/stream")
   980→def api_rectify_stream(req: RectifyRequest):
   981→    lat = req.latitude if req.latitude is not None else DEFAULT_LOCATION["latitude"]
   982→    lon = req.longitude if req.longitude is not None else DEFAULT_LOCATION["longitude"]
   983→    correlation_id = str(uuid4())
   984→
   985→    def _sse(obj: Dict[str, Any]) -> bytes:
   986→        return (f"data: {json.dumps(obj, ensure_ascii=False)}\n\n").encode("utf-8")
   987→
   988→    def _gen():
   989→        try:
   990→            received_events = [e.dict() for e in req.events]
   991→            for msg in rectify_birth_time_v2_iter(
   992→                name=req.name,
   993→                birthday=req.birthday,
   994→                lat=lat,
   995→                lon=lon,
   996→                window_start_hms=req.window_start,
   997→                window_end_hms=req.window_end,
   998→                events_raw=[e.dict() for e in req.events],
   999→                tz_offset_hours=req.tz_offset_hours or 8.0,
  1000→                step_seconds=30,
  1001→                debug=bool(req.debug),
  1002→            ):
  1003→                if msg.get("type") == "result":
  1004→                    result = msg["result"]
  1005→                    _persist_rectification_result(req, result, lat=lat, lon=lon)
  1006→                    yield _sse({"type": "done", **_rectify_response_payload(result, received_events=received_events)})
  1007→                else:
  1008→                    out = dict(msg)
  1009→                    out.setdefault("correlation_id", correlation_id)
  1010→                    yield _sse(out)
  1011→        except Exception as e:
  1012→            logger.error(
  1013→                "rectify stream failed",
  1014→                extra={"operation": "api_rectify_stream", "error": str(e), "correlation_id": correlation_id},
  1015→            )
  1016→            yield _sse({"type": "error", "detail": "rectify_failed", "correlation_id": correlation_id})
  1017→
  1018→    return StreamingResponse(
  1019→        _gen(),
  1020→        media_type="text/event-stream",
  1021→        headers={"Cache-Control": "no-cache", "X-Accel-Buffering": "no"},
  1022→    )
  1023→
  1024→
  1025→# ------------------------------ v3 (interval + fuzzy distribution) ------------------------------
  1026→
  1027→
  1028→@app.post("/api/rectify/v3")
  1029→def api_rectify_v3(req: RectifyRequest):
  1030→    try:
  1031→        lat = req.latitude if req.latitude is not None else DEFAULT_LOCATION["latitude"]
  1032→        lon = req.longitude if req.longitude is not None else DEFAULT_LOCATION["longitude"]
  1033→        result = rectification_v3.rectify_birth_time_v3(
  1034→            name=req.name,
  1035→            birthday=req.birthday,
  1036→            lat=lat,
  1037→            lon=lon,
  1038→            window_start_hms=req.window_start,
  1039→            window_end_hms=req.window_end,
  1040→            events_raw=[e.dict() for e in req.events],
  1041→            tz_offset_hours=req.tz_offset_hours or 8.0,
  1042→            step_seconds=30,
  1043→        )
  1044→        _persist_rectification_result(req, result, lat=lat, lon=lon)
  1045→        result["received_events"] = [e.dict() for e in req.events]
  1046→        return result
  1047→    except Exception as e:
  1048→        logger.error("rectify v3 failed", extra={"operation": "api_rectify_v3", "error": str(e)})
  1049→        raise HTTPException(status_code=400, detail="rectify_failed")
  1050→
  1051→
  1052→@app.post("/api/rectify/v3/stream")
  1053→def api_rectify_v3_stream(req: RectifyRequest):
  1054→    lat = req.latitude if req.latitude is not None else DEFAULT_LOCATION["latitude"]
  1055→    lon = req.longitude if req.longitude is not None else DEFAULT_LOCATION["longitude"]
  1056→    correlation_id = str(uuid4())
  1057→
  1058→    def _sse(obj: Dict[str, Any]) -> bytes:
  1059→        return (f"data: {json.dumps(obj, ensure_ascii=False)}\n\n").encode("utf-8")
  1060→
  1061→    def _gen():
  1062→        try:
  1063→            received_events = [e.dict() for e in req.events]
  1064→            for msg in rectification_v3.rectify_birth_time_v3_iter(
  1065→                name=req.name,
  1066→                birthday=req.birthday,
  1067→                lat=lat,
  1068→                lon=lon,
  1069→                window_start_hms=req.window_start,
  1070→                window_end_hms=req.window_end,
  1071→                events_raw=received_events,
  1072→                tz_offset_hours=req.tz_offset_hours or 8.0,
  1073→                step_seconds=30,
  1074→            ):
  1075→                if msg.get("type") == "result":
  1076→                    res = msg["result"]
  1077→                    res["received_events"] = received_events
  1078→                    _persist_rectification_result(req, res, lat=lat, lon=lon)
  1079→                    yield _sse({"type": "done", **res})
  1080→                else:
  1081→                    out = dict(msg)
  1082→                    out.setdefault("correlation_id", correlation_id)
  1083→                    yield _sse(out)
  1084→        except Exception as e:
  1085→            logger.error(
  1086→                "rectify v3 stream failed",
  1087→                extra={"operation": "api_rectify_v3_stream", "error": str(e), "correlation_id": correlation_id},
  1088→            )
  1089→            yield _sse({"type": "error", "detail": "rectify_failed", "correlation_id": correlation_id})
  1090→
  1091→    return StreamingResponse(
  1092→        _gen(),
  1093→        media_type="text/event-stream",
  1094→        headers={"Cache-Control": "no-cache", "X-Accel-Buffering": "no"},
  1095→    )
  1096→
  1097→
  1098→# ------------------------------
  1099→# v2 API per docs/design v2.md
  1100→# ------------------------------
  1101→
  1102→class V2SubmitBirthData(BaseModel):
  1103→    name: str
  1104→    gender: str
  1105→    year: int
  1106→    month: int
  1107→    day: int
  1108→    hour: int
  1109→    minute: int
  1110→    longitude: Optional[float] = None
  1111→    latitude: Optional[float] = None
  1112→    location_name: Optional[str] = None
  1113→
  1114→
  1115→class V2SubmitRequest(BaseModel):
  1116→    openid: str = Field(..., min_length=3)
  1117→    src: str = Field("wechat", description="来源渠道")
  1118→    model: str = Field("standard", description="Gemini 模型：standard | deep_research")
  1119→    system_prompt: Optional[str] = Field(None, description="可选 system prompt，拼接在八字前作为提示")
  1120→    birth_data: V2SubmitBirthData
  1121→
  1122→
  1123→@app.post("/api/v2/submit")
  1124→def v2_submit(req: V2SubmitRequest, backend: str | None = None):
  1125→    correlation_id = str(uuid4())
  1126→    try:
  1127→        if os.getenv("DEMO_MODE") == "1":
  1128→            # 极简演示：不依赖 DB，直接返回一个模拟 job_id
  1129→            return {
  1130→                "job_id": 101,
  1131→                "user_id": 1,
  1132→                "status": "processing",
  1133→                "eta_seconds": 2,
  1134→                "used_default_location": False,
  1135→                "default_location": None,
  1136→            }
  1137→        # 为降低 CLI 后端的幂等去重概率，这里在 v2 提交强制注入一次性 nonce
  1138→        from time import time as _now
  1139→        job_id, user_id, used_default, bazi = task_service.submit_bazi_task_v2(
  1140→            {
  1141→                "openid": req.openid,
  1142→                "src": req.src,
  1143→                "model": req.model,
  1144→                "system_prompt": req.system_prompt,
  1145→                **req.birth_data.dict(),
  1146→            },
  1147→            correlation_id=correlation_id,
  1148→            backend_hint=backend,
  1149→            force_nonce=str(int(_now())),
  1150→        )
  1151→        # 记录 prompt 历史（本地 user/prompts/openid_xxx/prompts.json），不写 gemini 表
  1152→        try:
  1153→            if req.system_prompt:
  1154→                prompt_store.append_for_openid(req.openid, req.system_prompt, req.model)
  1155→        except Exception as _:
  1156→            pass
  1157→        return {
  1158→            "job_id": job_id,
  1159→            "user_id": user_id,
  1160→            "status": "processing",
  1161→            "eta_seconds": 120,
  1162→            "used_default_location": used_default,
  1163→            "default_location": DEFAULT_LOCATION if used_default else None,
  1164→            "bazi": {
  1165→                "year_pillar": bazi.year_pillar,
  1166→                "month_pillar": bazi.month_pillar,
  1167→                "day_pillar": bazi.day_pillar,
  1168→                "hour_pillar": bazi.hour_pillar,
  1169→                "wuxing": bazi.wuxing,
  1170→                "location": bazi.location,
  1171→            },
  1172→        }
  1173→    except ValueError as ve:
  1174→        logger.warning("v2 submit validation failed", extra={"operation": "api_v2_submit", "error": str(ve), "correlation_id": correlation_id})
  1175→        raise HTTPException(status_code=400, detail=str(ve))
  1176→    except Exception as e:
  1177→        msg = str(e)
  1178→        logger.error("v2 submit failed", extra={"operation": "api_v2_submit", "error": msg, "correlation_id": correlation_id})
  1179→        if msg in ("empty_prompt", "no_tasks", "no_tasks_built"):
  1180→            raise HTTPException(status_code=400, detail=msg)
  1181→        raise HTTPException(status_code=500, detail="internal_error")
  1182→
  1183→
  1184→@app.get("/api/v2/report/{job_id}")
  1185→def v2_report(job_id: int, backend: str | None = None) -> Dict[str, Any]:
  1186→    if os.getenv("DEMO_MODE") == "1":
  1187→        # 极简演示：不再返回写库示例，仅提示处理中
  1188→        return {"status": "processing", "progress": 0}
  1189→
  1190→    tasks = be.get_tasks_by_job_id(job_id, backend=backend)
  1191→    if not tasks:
  1192→        return {"status": "error", "message": "no_tasks"}
  1193→
  1194→    main_task = tasks[0]
  1195→    status_val = int(main_task.get("status", 0) or 0)
  1196→    if status_val < 10:
  1197→        return {"status": "processing", "progress": status_val}
  1198→
  1199→    output_text = main_task.get("output_text")
  1200→    output_url = main_task.get("output_url")
  1201→    if not output_text:
  1202→        # 兼容仅有文档链接（output_url）而无内嵌文本的情况
  1203→        if output_url:
  1204→            # best-effort: persist conversation output (url only)
  1205→            try:
  1206→                uid = find_user_by_job(job_id)
  1207→                if uid is not None:
  1208→                    append_output(uid, job_id, "", output_url)
  1209→            except Exception:
  1210→                pass
  1211→            # best-effort: sync gemini_url when job is done
  1212→            try:
  1213→                sync_job_gemini_url_to_user(job_id)
  1214→            except Exception:
  1215→                pass
  1216→            # 返回可阅读的占位 A2UI（Markdown 组件 + 下载链接）
  1217→            md = f"报告已生成，但未返回内嵌文本。请点击下载文档：\n\n[下载报告]({output_url})"
  1218→            return {"status": "completed", "a2ui_data": {"meta": {"summary": "报告已生成（文档链接）"}, "ui_components": [{"type": "markdown_text", "title": "模型输出", "data": md}]}}
  1219→        return {"status": "error", "message": "task_missing_output"}
  1220→
  1221→    try:
  1222→        import json
  1223→
  1224→        a2ui = json.loads(output_text)
  1225→        validate_a2ui(a2ui)
  1226→        # persist conversation output for v2 as well
  1227→        try:
  1228→            uid = find_user_by_job(job_id)
  1229→            if uid is not None:
  1230→                append_output(uid, job_id, output_text)
  1231→        except Exception:
  1232→            pass
  1233→        # best-effort: sync gemini_url to fortune_user when job is done or parsable
  1234→        try:
  1235→            sync_job_gemini_url_to_user(job_id)
  1236→        except Exception:
  1237→            pass
  1238→        return {"status": "completed", "a2ui_data": a2ui}
  1239→    except ValidationError as ve:
  1240→        # 若为合法 JSON 但不符合 A2UI，按 Markdown 文本回退
  1241→        return {"status": "completed", "a2ui_data": {"meta": {"summary": "模型返回非规范 A2UI，已按 Markdown 展示"}, "ui_components": [{"type": "markdown_text", "title": "模型输出", "data": output_text}]}}
  1242→    except Exception:
  1243→        # 非 JSON：按 Markdown 文本回退
  1244→        return {"status": "completed", "a2ui_data": {"meta": {"summary": output_text[:60]}, "ui_components": [{"type": "markdown_text", "title": "模型输出", "data": output_text}]}}
  1245→
  1246→
  1247→# ------------------------------
  1248→# Files API (CLI backend output streaming)
  1249→# ------------------------------
  1250→
  1251→
  1252→@app.get("/api/files/{job_id}")
  1253→def api_files(job_id: int, backend: str | None = None, filename: str | None = None):
  1254→    b = (backend or os.getenv("GEMINI_BACKEND", "gemini")).strip().lower()
  1255→    if b != "cli":
  1256→        raise HTTPException(status_code=400, detail="files_only_available_for_cli")
  1257→    try:
  1258→        from integrations.cli_worker_repo import fetch_output_file_content, list_output_files_by_job_id
  1259→        fname, content = fetch_output_file_content(job_id, filename)
  1260→        if content is None:
  1261→            # return a lightweight index for UX when nothing inline
  1262→            files = list_output_files_by_job_id(job_id)
  1263→            return {"files": files}
  1264→        media = "text/plain"
  1265→        # simple heuristic: .md/.txt → text/plain; otherwise octet-stream
  1266→        if fname and (str(fname).endswith(".md") or str(fname).endswith(".txt")):
  1267→            media = "text/plain; charset=utf-8"
  1268→        headers = {"Content-Disposition": f"inline; filename={fname or 'output.txt'}"}
  1269→        return StreamingResponse(iter([content]), media_type=media, headers=headers)
  1270→    except HTTPException:
  1271→        raise
  1272→    except Exception as e:
  1273→        logger.error("files endpoint failed", extra={"operation": "api_files", "error": str(e)[:200]})
  1274→        raise HTTPException(status_code=500, detail="files_error")
  1275→
  1276→
  1277→# ------------------------------
  1278→# WeCom OAuth (Tencent Cloud friendly)
  1279→# ------------------------------
  1280→
  1281→
  1282→@app.get("/qy/oauth/redirect")
  1283→def qy_oauth_redirect():
  1284→    corp_id = os.getenv("QY_CORP_ID")
  1285→    agent_id = os.getenv("QY_AGENT_ID")
  1286→    redirect_uri = os.getenv("QY_REDIRECT_URI")
  1287→    if not (corp_id and agent_id and redirect_uri):
  1288→        raise HTTPException(status_code=500, detail="missing_qy_env")
  1289→    auth_url = (
  1290→        "https://open.weixin.qq.com/connect/oauth2/authorize?"
  1291→        + urllib.parse.urlencode(
  1292→            {
  1293→                "appid": corp_id,
  1294→                "redirect_uri": redirect_uri,
  1295→                "response_type": "code",
  1296→                "scope": "snsapi_base",
  1297→                "state": "a2ui",
  1298→                "agentid": agent_id,
  1299→            }
  1300→        )
  1301→        + "#wechat_redirect"
  1302→    )
  1303→    return {"auth_url": auth_url}
  1304→
  1305→
  1306→@app.get("/qy/oauth/callback")
  1307→def qy_oauth_callback(code: str, request: Request):
  1308→    corp_id = os.getenv("QY_CORP_ID")
  1309→    corp_secret = os.getenv("QY_CORP_SECRET")
  1310→    if not (corp_id and corp_secret):
  1311→        raise HTTPException(status_code=500, detail="missing_qy_env")
  1312→
  1313→    # 1) get access token
  1314→    token_url = "https://qyapi.weixin.qq.com/cgi-bin/gettoken"
  1315→    user_url = "https://qyapi.weixin.qq.com/cgi-bin/auth/getuserinfo"
  1316→    with httpx.Client(timeout=10.0) as client:
  1317→        r1 = client.get(token_url, params={"corpid": corp_id, "corpsecret": corp_secret})
  1318→        r1.raise_for_status()
  1319→        tok = r1.json()
  1320→        access_token = tok.get("access_token")
  1321→        if not access_token:
  1322→            raise HTTPException(status_code=502, detail="qy_token_error")
  1323→        r2 = client.get(user_url, params={"access_token": access_token, "code": code})
  1324→        r2.raise_for_status()
  1325→        info = r2.json()
  1326→
  1327→    userid = info.get("UserId") or info.get("userid") or info.get("external_userid")
  1328→    if not userid:
  1329→        raise HTTPException(status_code=400, detail="qy_no_user")
  1330→
  1331→    # Put userid in query and bounce to H5
  1332→    h5_path = os.getenv("QY_H5_PATH", "/h5/a2ui")
  1333→    target = f"{h5_path}?userid={urllib.parse.quote(userid)}"
  1334→    return templates.TemplateResponse(
  1335→        "redirect.html",
  1336→        {"request": request, "target": target},
  1337→    )
  1338→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
