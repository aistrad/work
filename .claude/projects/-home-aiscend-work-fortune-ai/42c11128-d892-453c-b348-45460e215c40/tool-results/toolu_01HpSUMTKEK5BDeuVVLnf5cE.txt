   300→  toolInvocations?: ToolInvocation[]
   301→}
   302→
   303→export async function sendChatMessage(
   304→  message: string,
   305→  sessionId?: string
   306→): Promise<SendChatResponse> {
   307→  const result = await fetchApi<{
   308→    session_id: string
   309→    assistant_message?: { role: string; a2ui?: unknown }
   310→    suggested_tasks?: unknown[]
   311→  }>('/api/chat/send', {
   312→    method: 'POST',
   313→    body: JSON.stringify({ text: message, session_id: sessionId }),
   314→  })
   315→
   316→  // Extract reply from a2ui response
   317→  const a2ui = result.assistant_message?.a2ui as { ui_components?: Array<{ type: string; data: string }> } | undefined
   318→  const markdownComponent = a2ui?.ui_components?.find(c => c.type === 'markdown_text')
   319→  const reply = markdownComponent?.data || ''
   320→
   321→  return {
   322→    session_id: result.session_id,
   323→    reply,
   324→    ui_components: a2ui?.ui_components,
   325→  }
   326→}
   327→
   328→// =============================================================================
   329→// Auth API
   330→// =============================================================================
   331→
   332→export interface LoginRequest {
   333→  email: string
   334→  password: string
   335→}
   336→
   337→export interface LoginResponse {
   338→  user_id: number
   339→  email: string
   340→}
   341→
   342→export interface RegisterRequest {
   343→  email: string
   344→  password: string
   345→  name: string
   346→  gender: string
   347→  birthday_local: string
   348→  tz_offset_hours: number
   349→  location: {
   350→    name: string
   351→    longitude: number
   352→    latitude: number
   353→  }
   354→}
   355→
   356→export interface RegisterResponse {
   357→  user_id: number
   358→  email: string
   359→  profile_summary: {
   360→    name: string
   361→    gender: string
   362→    location_name: string
   363→  }
   364→}
   365→
   366→export interface UserInfo {
   367→  user_id: number
   368→  email: string
   369→  name: string
   370→  persona_style: string
   371→}
   372→
   373→export type ChatBackend = 'agent_service' | 'fastapi'
   374→
   375→export interface UserPreferences {
   376→  persona_style: 'standard' | 'warm' | 'roast'
   377→  push_enabled: boolean
   378→  push_time: string
   379→  quiet_hours_start: string
   380→  quiet_hours_end: string
   381→  chat_backend: ChatBackend
   382→}
   383→
   384→export async function login(email: string, password: string): Promise<LoginResponse> {
   385→  const res = await fetch(`${API_BASE}/api/auth/login`, {
   386→    method: 'POST',
   387→    headers: { 'Content-Type': 'application/json' },
   388→    credentials: 'include',
   389→    body: JSON.stringify({ email, password }),
   390→  })
   391→  const json = await res.json()
   392→  if (!res.ok || !json.ok) {
   393→    throw new Error(json.error?.message || 'Login failed')
   394→  }
   395→  return json.data
   396→}
   397→
   398→export async function register(data: RegisterRequest): Promise<RegisterResponse> {
   399→  const res = await fetch(`${API_BASE}/api/auth/register`, {
   400→    method: 'POST',
   401→    headers: { 'Content-Type': 'application/json' },
   402→    credentials: 'include',
   403→    body: JSON.stringify(data),
   404→  })
   405→  const json = await res.json()
   406→  if (!res.ok || !json.ok) {
   407→    throw new Error(json.error?.message || 'Register failed')
   408→  }
   409→  return json.data
   410→}
   411→
   412→export async function logout(): Promise<void> {
   413→  await fetchApi('/api/auth/logout', { method: 'POST' })
   414→}
   415→
   416→export async function fetchMe(): Promise<UserInfo> {
   417→  return fetchApi<UserInfo>('/api/auth/me')
   418→}
   419→
   420→export async function fetchPreferences(): Promise<UserPreferences> {
   421→  return fetchApi<UserPreferences>('/api/user/preferences')
   422→}
   423→
   424→export async function updatePreferences(
   425→  patch: Partial<Pick<UserPreferences, 'persona_style' | 'push_enabled' | 'push_time' | 'quiet_hours_start' | 'quiet_hours_end' | 'chat_backend'>>
   426→): Promise<void> {
   427→  await fetchApi('/api/user/preferences', {
   428→    method: 'PUT',
   429→    body: JSON.stringify(patch),
   430→  })
   431→}
   432→
   433→// SSE Chat Stream
   434→export function streamChatMessage(
   435→  message: string,
   436→  sessionId: string | undefined,
   437→  onChunk: (chunk: string) => void,
   438→  onDone: (fullResponse: SendChatResponse) => void,
   439→  onError: (error: Error) => void
   440→): () => void {
   441→  const controller = new AbortController()
   442→
   443→  const params = new URLSearchParams({ message })
   444→  if (sessionId) params.set('session_id', sessionId)
   445→
   446→  let resolvedSessionId = sessionId || ''
   447→
   448→  fetch(`${API_BASE}/api/chat/stream?${params}`, {
   449→    method: 'GET',
   450→    credentials: 'include',
   451→    headers: csrfHeaders(),
   452→    signal: controller.signal,
   453→  })
   454→    .then(async (response) => {
   455→      if (!response.ok) {
   456→        // Backward-compatible fallback: older backends may not implement /api/chat/stream yet.
   457→        if (response.status === 404 || response.status === 405) {
   458→          const fallback = await sendChatMessage(message, sessionId)
   459→          onDone(fallback)
   460→          return
   461→        }
   462→        const errorText = await response.text().catch(() => '')
   463→        const detail = errorText ? `: ${errorText.slice(0, 200)}` : ''
   464→        throw new Error(`Stream request failed (${response.status})${detail}`)
   465→      }
   466→
   467→      const reader = response.body?.getReader()
   468→      if (!reader) throw new Error('No reader')
   469→
   470→      const decoder = new TextDecoder()
   471→      let buffer = ''
   472→      let fullContent = ''
   473→
   474→      while (true) {
   475→        const { done, value } = await reader.read()
   476→        if (done) break
   477→
   478→        buffer += decoder.decode(value, { stream: true })
   479→        const lines = buffer.split('\n')
   480→        buffer = lines.pop() || ''
   481→
   482→        for (const line of lines) {
   483→          if (line.startsWith('data: ')) {
   484→            const data = line.slice(6)
   485→            if (data === '[DONE]') {
   486→              onDone({
   487→                session_id: resolvedSessionId,
   488→                reply: fullContent,
   489→              })
   490→              return
   491→            }
   492→            try {
   493→              const json = JSON.parse(data)
   494→              if (json?.type === 'meta' && typeof json.session_id === 'string') {
   495→                resolvedSessionId = json.session_id
   496→              } else if (json?.type === 'delta' && typeof json.delta === 'string') {
   497→                fullContent += json.delta
   498→                onChunk(json.delta)
   499→              } else if (json?.type === 'final' && json.data) {

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
