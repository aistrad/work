     1→/**
     2→ * Fortune AI Agent Runtime - Chat API Route
     3→ *
     4→ * This is the main entry point for AI chat interactions.
     5→ * Uses Vercel AI SDK for streaming responses with tool execution.
     6→ *
     7→ * Architecture:
     8→ * 1. Auth from Cookie (fortune_session)
     9→ * 2. Fetch context from FastAPI internal API
    10→ * 3. Start run (record user message)
    11→ * 4. Stream response with Vercel AI SDK
    12→ * 5. Finalize run (commit all side effects)
    13→ */
    14→import { streamText } from 'ai';
    15→import { cookies } from 'next/headers';
    16→
    17→import { selectModel } from '@/lib/models/model-provider';
    18→import { buildSystemPrompt, buildMessages, fetchContext, type UserContext } from '@/lib/context/context-builder';
    19→import { getToolsForCommand } from '@/lib/skills';
    20→
    21→const FASTAPI_URL = process.env.FASTAPI_URL || 'http://localhost:8230';
    22→
    23→// Request body type
    24→interface ChatRequest {
    25→  session_id?: string | null;
    26→  message: string;
    27→  command?: string | null;
    28→}
    29→
    30→// Response from run/start
    31→interface RunStartResponse {
    32→  run_id: string;
    33→  session_id: string;
    34→  user_message_id: number;
    35→}
    36→
    37→export async function POST(req: Request) {
    38→  const correlationId = `chat-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`;
    39→
    40→  try {
    41→    // 1. Get session cookie
    42→    const cookieStore = await cookies();
    43→    const sessionCookie = cookieStore.get('fortune_session')?.value;
    44→
    45→    if (!sessionCookie) {
    46→      return new Response(JSON.stringify({ error: 'unauthorized' }), {
    47→        status: 401,
    48→        headers: { 'Content-Type': 'application/json' },
    49→      });
    50→    }
    51→
    52→    // 2. Parse request body
    53→    const body: ChatRequest = await req.json();
    54→    const { session_id, message, command } = body;
    55→
    56→    if (!message || typeof message !== 'string' || message.trim().length === 0) {
    57→      return new Response(JSON.stringify({ error: 'invalid_message' }), {
    58→        status: 400,
    59→        headers: { 'Content-Type': 'application/json' },
    60→      });
    61→    }
    62→
    63→    // 3. Fetch context from FastAPI
    64→    let context: UserContext;
    65→    try {
    66→      context = await fetchContext(session_id ?? null, message, sessionCookie);
    67→    } catch (error) {
    68→      console.error('[chat] Failed to fetch context:', error);
    69→      return new Response(JSON.stringify({ error: 'context_fetch_failed' }), {
    70→        status: 502,
    71→        headers: { 'Content-Type': 'application/json' },
    72→      });
    73→    }
    74→
    75→    // 4. Start run (record user message)
    76→    let runData: RunStartResponse;
    77→    try {
    78→      const startRes = await fetch(`${FASTAPI_URL}/internal/chat/run/start`, {
    79→        method: 'POST',
    80→        headers: {
    81→          'Content-Type': 'application/json',
    82→          Cookie: `fortune_session=${sessionCookie}`,
    83→        },
    84→        body: JSON.stringify({
    85→          session_id: session_id ?? null,
    86→          message,
    87→          correlation_id: correlationId,
    88→        }),
    89→      });
    90→
    91→      if (!startRes.ok) {
    92→        throw new Error(`run/start failed: ${startRes.status}`);
    93→      }
    94→
    95→      runData = await startRes.json();
    96→    } catch (error) {
    97→      console.error('[chat] Failed to start run:', error);
    98→      return new Response(JSON.stringify({ error: 'run_start_failed' }), {
    99→        status: 502,
   100→        headers: { 'Content-Type': 'application/json' },
   101→      });
   102→    }
   103→
   104→    // 5. Build system prompt and messages
   105→    const systemPrompt = buildSystemPrompt(context);
   106→    const messages = buildMessages(context, message);
   107→
   108→    // 6. Select tools based on command
   109→    const tools = getToolsForCommand(command);
   110→
   111→    // 7. Stream response with Vercel AI SDK
   112→    const result = streamText({
   113→      model: selectModel(),
   114→      system: systemPrompt,
   115→      messages,
   116→      tools,
   117→      maxSteps: 5, // Allow up to 5 tool calls per request
   118→
   119→      // Finalize run when streaming completes
   120→      onFinish: async ({ text, steps, usage }) => {
   121→        try {
   122→          // Collect tool calls and A2UI cards from steps
   123→          const allToolCalls: Array<{ toolName: string; args: unknown }> = [];
   124→          const a2uiCards: Array<Record<string, unknown>> = [];
   125→
   126→          // Type-safe iteration over steps
   127→          const stepsArray = steps as Array<{
   128→            toolCalls?: Array<{ toolName: string; args: unknown }>;
   129→            toolResults?: Array<{ result: unknown }>;
   130→          }> | undefined;
   131→
   132→          for (const step of stepsArray || []) {
   133→            if (step.toolCalls) {
   134→              for (const tc of step.toolCalls) {
   135→                allToolCalls.push({
   136→                  toolName: tc.toolName,
   137→                  args: tc.args,
   138→                });
   139→              }
   140→            }
   141→            if (step.toolResults) {
   142→              for (const tr of step.toolResults) {
   143→                if (
   144→                  tr.result &&
   145→                  typeof tr.result === 'object' &&
   146→                  'type' in tr.result &&
   147→                  (tr.result as Record<string, unknown>).type === 'a2ui_card'
   148→                ) {
   149→                  a2uiCards.push(tr.result as Record<string, unknown>);
   150→                }
   151→              }
   152→            }
   153→          }
   154→
   155→          // Finalize run
   156→          await fetch(`${FASTAPI_URL}/internal/chat/run/finalize`, {
   157→            method: 'POST',
   158→            headers: {
   159→              'Content-Type': 'application/json',
   160→              Cookie: `fortune_session=${sessionCookie}`,
   161→            },
   162→            body: JSON.stringify({
   163→              run_id: runData.run_id,
   164→              session_id: runData.session_id,
   165→              assistant_content: text,
   166→              tool_calls: allToolCalls.length > 0 ? allToolCalls : undefined,
   167→              a2ui_cards: a2uiCards.length > 0 ? a2uiCards : undefined,
   168→              prompt_tokens: usage?.promptTokens ?? 0,
   169→              completion_tokens: usage?.completionTokens ?? 0,
   170→            }),
   171→          });
   172→        } catch (error) {
   173→          console.error('[chat] Failed to finalize run:', error);
   174→          // Don't throw - the response has already been sent
   175→        }
   176→      },
   177→    });
   178→
   179→    // 8. Return streaming response
   180→    // Add session_id to response headers for client to track
   181→    const response = result.toDataStreamResponse();
   182→
   183→    // Clone response to add custom headers
   184→    const headers = new Headers(response.headers);
   185→    headers.set('X-Session-Id', runData.session_id);
   186→    headers.set('X-Run-Id', runData.run_id);
   187→    headers.set('X-Correlation-Id', correlationId);
   188→
   189→    return new Response(response.body, {
   190→      status: response.status,
   191→      headers,
   192→    });
   193→  } catch (error) {
   194→    console.error('[chat] Unexpected error:', error);
   195→    return new Response(
   196→      JSON.stringify({
   197→        error: 'internal_error',
   198→        correlation_id: correlationId,
   199→      }),
   200→      {
   201→        status: 500,
   202→        headers: { 'Content-Type': 'application/json' },
   203→      }
   204→    );
   205→  }
   206→}
   207→
   208→// Health check for the chat endpoint
   209→export async function GET() {
   210→  return new Response(JSON.stringify({ status: 'ok', service: 'agent_runtime' }), {
   211→    headers: { 'Content-Type': 'application/json' },
   212→  });
   213→}
   214→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
