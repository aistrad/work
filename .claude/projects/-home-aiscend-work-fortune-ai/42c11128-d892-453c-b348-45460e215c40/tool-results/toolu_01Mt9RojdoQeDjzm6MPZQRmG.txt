     1→import json
     2→import os
     3→from datetime import datetime
     4→from typing import Any, Dict, Optional
     5→
     6→
     7→BASE_DIR = os.path.join("user")
     8→JOB_INDEX_PATH = os.path.join(BASE_DIR, "job_index.json")
     9→
    10→
    11→def _ensure_user_dirs(user_id: int) -> str:
    12→    user_dir = os.path.join(BASE_DIR, str(user_id))
    13→    conv_dir = os.path.join(user_dir, "conversations")
    14→    os.makedirs(conv_dir, exist_ok=True)
    15→    return conv_dir
    16→
    17→
    18→def _read_json(path: str) -> Any:
    19→    try:
    20→        with open(path, "r", encoding="utf-8") as f:
    21→            return json.load(f)
    22→    except Exception:
    23→        return None
    24→
    25→
    26→def _write_json(path: str, data: Any) -> None:
    27→    tmp = path + ".tmp"
    28→    with open(tmp, "w", encoding="utf-8") as f:
    29→        json.dump(data, f, ensure_ascii=False, indent=2)
    30→    os.replace(tmp, path)
    31→
    32→
    33→def save_job_index(job_id: int, user_id: int) -> None:
    34→    idx = _read_json(JOB_INDEX_PATH) or {}
    35→    idx[str(job_id)] = {"user_id": user_id, "saved_at": datetime.utcnow().isoformat()}
    36→    os.makedirs(BASE_DIR, exist_ok=True)
    37→    _write_json(JOB_INDEX_PATH, idx)
    38→
    39→
    40→def find_user_by_job(job_id: int) -> Optional[int]:
    41→    idx = _read_json(JOB_INDEX_PATH) or {}
    42→    entry = idx.get(str(job_id))
    43→    if isinstance(entry, dict):
    44→        uid = entry.get("user_id")
    45→        try:
    46→            return int(uid) if uid is not None else None
    47→        except Exception:
    48→            return None
    49→    if isinstance(entry, int):
    50→        return entry
    51→    return None
    52→
    53→
    54→def append_prompt(user_id: int, job_id: int | str, prompt: str, model: str) -> None:
    55→    conv_dir = _ensure_user_dirs(user_id)
    56→    path = os.path.join(conv_dir, f"{str(job_id)}.jsonl")
    57→    rec = {
    58→        "ts": datetime.utcnow().isoformat(),
    59→        "role": "user",
    60→        "model": model,
    61→        "content": prompt,
    62→    }
    63→    with open(path, "a", encoding="utf-8") as f:
    64→        f.write(json.dumps(rec, ensure_ascii=False) + "\n")
    65→
    66→
    67→def append_output(user_id: int, job_id: int | str, text: str, url: Optional[str] = None) -> None:
    68→    conv_dir = _ensure_user_dirs(user_id)
    69→    path = os.path.join(conv_dir, f"{str(job_id)}.jsonl")
    70→    rec: Dict[str, Any] = {
    71→        "ts": datetime.utcnow().isoformat(),
    72→        "role": "assistant",
    73→        "content": text,
    74→    }
    75→    if url:
    76→        rec["doc_url"] = url
    77→    with open(path, "a", encoding="utf-8") as f:
    78→        f.write(json.dumps(rec, ensure_ascii=False) + "\n")
    79→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
