     1→/**
     2→ * API Layer - 与后端 Soul OS API 通信
     3→ *
     4→ * 后端 API 格式: { ok: boolean, data?: T, error?: { code, message, detail } }
     5→ */
     6→
     7→const API_BASE = process.env.NEXT_PUBLIC_API_BASE || ''
     8→
     9→// Cookie helper
    10→function getCookie(name: string): string {
    11→  if (typeof document === 'undefined') return ''
    12→  const match = document.cookie.match(new RegExp(`(?:^|; )${name.replace(/[-.]/g, '\\$&')}=([^;]*)`))
    13→  return match ? decodeURIComponent(match[1]) : ''
    14→}
    15→
    16→// CSRF headers
    17→function csrfHeaders(): Record<string, string> {
    18→  const csrf = getCookie('fortune_csrf')
    19→  return csrf ? { 'X-CSRF-Token': csrf } : {}
    20→}
    21→
    22→// Generic API response type
    23→interface ApiResponse<T> {
    24→  ok: boolean
    25→  data?: T
    26→  error?: {
    27→    code: string
    28→    message: string
    29→    detail?: Record<string, unknown>
    30→  }
    31→}
    32→
    33→// Fetch with auth
    34→async function fetchApi<T>(
    35→  url: string,
    36→  options: RequestInit = {}
    37→): Promise<T> {
    38→  const headers: Record<string, string> = {
    39→    'Content-Type': 'application/json',
    40→    ...csrfHeaders(),
    41→    ...(options.headers as Record<string, string> || {}),
    42→  }
    43→
    44→  const res = await fetch(`${API_BASE}${url}`, {
    45→    ...options,
    46→    headers,
    47→    credentials: 'include', // Send cookies
    48→  })
    49→
    50→  const json: ApiResponse<T> = await res.json().catch(() => ({ ok: false }))
    51→
    52→  if (!res.ok || !json.ok) {
    53→    if (res.status === 401 || res.status === 403) {
    54→      // Redirect to login (with basePath)
    55→      if (typeof window !== 'undefined') {
    56→        window.location.href = '/new/login'
    57→      }
    58→      throw new Error('Unauthorized')
    59→    }
    60→    throw new Error(json.error?.message || 'Request failed')
    61→  }
    62→
    63→  return json.data as T
    64→}
    65→
    66→// =============================================================================
    67→// Dashboard API Types
    68→// =============================================================================
    69→
    70→export interface StateScore {
    71→  score: number
    72→  breakdown: {
    73→    emotion: number
    74→    action: number
    75→    streak: number
    76→  }
    77→  recovery_action: string | null
    78→}
    79→
    80→export interface PermaScore {
    81→  score: number
    82→  trend?: 'up' | 'down' | 'stable'
    83→}
    84→
    85→export interface PermaData {
    86→  positive_emotion: PermaScore
    87→  engagement: PermaScore
    88→  relationships: PermaScore
    89→  meaning: PermaScore
    90→  accomplishment: PermaScore
    91→}
    92→
    93→export interface TaskItem {
    94→  task_id: string
    95→  title: string
    96→  status: 'suggested' | 'active' | 'done' | 'skipped'
    97→  commitment_type?: 'start_task' | 'schedule_task'
    98→  minutes?: number
    99→  if_then?: string
   100→}
   101→
   102→export interface RiskAlert {
   103→  type: string
   104→  message: string
   105→}
   106→
   107→export interface OverviewData {
   108→  insight: string
   109→  state_score: StateScore
   110→  perma: PermaData
   111→  today_tasks: TaskItem[]
   112→  risk_alerts: RiskAlert[]
   113→}
   114→
   115→export interface L0Translation {
   116→  concept: string
   117→  translation: string
   118→  action: string
   119→}
   120→
   121→export interface L0Facts {
   122→  day_master: string
   123→  strength: string
   124→  translations: L0Translation[]
   125→}
   126→
   127→export interface L1Schema {
   128→  perma_snapshot: PermaData
   129→  cognitive_patterns: {
   130→    identified_schemas: string[]
   131→    reframe_count?: number
   132→  }
   133→  strengths_in_use: string[]
   134→}
   135→
   136→export interface StatusData {
   137→  l0_facts: L0Facts
   138→  l1_schema: L1Schema
   139→  state_score: StateScore
   140→}
   141→
   142→export interface TrendPoint {
   143→  date: string
   144→  score: number
   145→}
   146→
   147→export interface TrendEvent {
   148→  date: string
   149→  type: string
   150→  title: string
   151→}
   152→
   153→export interface TrendsData {
   154→  state_score_history: TrendPoint[]
   155→  events: TrendEvent[]
   156→}
   157→
   158→export interface TasksData {
   159→  active: TaskItem[]
   160→  suggested: TaskItem[]
   161→  completed_recent: TaskItem[]
   162→}
   163→
   164→export interface RelationItem {
   165→  id: string
   166→  name: string
   167→  type: string
   168→  compatibility?: number
   169→}
   170→
   171→export interface RelationsData {
   172→  relations: RelationItem[]
   173→}
   174→
   175→export interface ExploreItem {
   176→  id: string
   177→  title: string
   178→  type: 'mystic' | 'course' | 'artifact'
   179→  description?: string
   180→}
   181→
   182→export interface ExploreData {
   183→  mystic_entries: ExploreItem[]
   184→  courses: ExploreItem[]
   185→  artifacts: ExploreItem[]
   186→}
   187→
   188→export interface CheckinResponse {
   189→  insight: string
   190→  action: {
   191→    content: string
   192→    minutes: number
   193→    if_then: string
   194→  }
   195→  state_score: StateScore
   196→}
   197→
   198→// =============================================================================
   199→// Dashboard API Functions
   200→// =============================================================================
   201→
   202→export async function fetchOverview(): Promise<OverviewData> {
   203→  return fetchApi<OverviewData>('/api/dashboard/overview')
   204→}
   205→
   206→export async function fetchStatus(): Promise<StatusData> {
   207→  return fetchApi<StatusData>('/api/dashboard/status')
   208→}
   209→
   210→export async function fetchTrends(days: number = 7): Promise<TrendsData> {
   211→  return fetchApi<TrendsData>(`/api/dashboard/trends?days=${days}`)
   212→}
   213→
   214→export async function fetchTasks(): Promise<TasksData> {
   215→  return fetchApi<TasksData>('/api/dashboard/tasks')
   216→}
   217→
   218→export async function fetchRelations(): Promise<RelationsData> {
   219→  return fetchApi<RelationsData>('/api/dashboard/relations')
   220→}
   221→
   222→export async function fetchExplore(): Promise<ExploreData> {
   223→  return fetchApi<ExploreData>('/api/dashboard/explore')
   224→}
   225→
   226→// Task Actions
   227→export async function acceptTask(
   228→  taskId: string,
   229→  commitmentType: 'start_task' | 'schedule_task' = 'start_task'
   230→): Promise<{ commitment_id: string; status: string }> {
   231→  return fetchApi('/api/dashboard/task/accept', {
   232→    method: 'POST',
   233→    body: JSON.stringify({ task_id: taskId, commitment_type: commitmentType }),
   234→  })
   235→}
   236→
   237→export async function completeTask(
   238→  taskId: string,
   239→  note: string = ''
   240→): Promise<{ status: string; state_score: StateScore }> {
   241→  return fetchApi('/api/dashboard/task/done', {
   242→    method: 'POST',
   243→    body: JSON.stringify({ task_id: taskId, note }),
   244→  })
   245→}
   246→
   247→export async function skipTask(
   248→  taskId: string,
   249→  reason: string = ''
   250→): Promise<{ status: string }> {
   251→  return fetchApi('/api/dashboard/task/skip', {
   252→    method: 'POST',
   253→    body: JSON.stringify({ task_id: taskId, reason }),
   254→  })
   255→}
   256→
   257→// Checkin
   258→export async function submitCheckin(
   259→  mood: string,
   260→  intensity: number,
   261→  note: string = ''
   262→): Promise<CheckinResponse> {
   263→  return fetchApi('/api/dashboard/checkin', {
   264→    method: 'POST',
   265→    body: JSON.stringify({ mood, intensity, note }),
   266→  })
   267→}
   268→
   269→// =============================================================================
   270→// Chat API
   271→// =============================================================================
   272→
   273→export interface ChatMessage {
   274→  role: 'user' | 'assistant'
   275→  content: string
   276→  timestamp?: string
   277→}
   278→
   279→export interface SendChatRequest {
   280→  message: string
   281→  session_id?: string
   282→}
   283→
   284→export interface SendChatResponse {
   285→  session_id: string
   286→  reply: string
   287→  ui_components?: unknown[]
   288→}
   289→
   290→export async function sendChatMessage(
   291→  message: string,
   292→  sessionId?: string
   293→): Promise<SendChatResponse> {
   294→  const result = await fetchApi<{
   295→    session_id: string
   296→    assistant_message?: { role: string; a2ui?: unknown }
   297→    suggested_tasks?: unknown[]
   298→  }>('/api/chat/send', {
   299→    method: 'POST',
   300→    body: JSON.stringify({ text: message, session_id: sessionId }),
   301→  })
   302→
   303→  // Extract reply from a2ui response
   304→  const a2ui = result.assistant_message?.a2ui as { ui_components?: Array<{ type: string; data: string }> } | undefined
   305→  const markdownComponent = a2ui?.ui_components?.find(c => c.type === 'markdown_text')
   306→  const reply = markdownComponent?.data || ''
   307→
   308→  return {
   309→    session_id: result.session_id,
   310→    reply,
   311→    ui_components: a2ui?.ui_components,
   312→  }
   313→}
   314→
   315→// =============================================================================
   316→// Auth API
   317→// =============================================================================
   318→
   319→export interface LoginRequest {
   320→  email: string
   321→  password: string
   322→}
   323→
   324→export interface LoginResponse {
   325→  user_id: number
   326→  email: string
   327→}
   328→
   329→export interface RegisterRequest {
   330→  email: string
   331→  password: string
   332→  name: string
   333→  gender: string
   334→  birthday_local: string
   335→  tz_offset_hours: number
   336→  location: {
   337→    name: string
   338→    longitude: number
   339→    latitude: number
   340→  }
   341→}
   342→
   343→export interface RegisterResponse {
   344→  user_id: number
   345→  email: string
   346→  profile_summary: {
   347→    name: string
   348→    gender: string
   349→    location_name: string
   350→  }
   351→}
   352→
   353→export interface UserInfo {
   354→  user_id: number
   355→  email: string
   356→  name: string
   357→  persona_style: string
   358→}
   359→
   360→export type ChatBackend = 'agent_service' | 'fastapi'
   361→
   362→export interface UserPreferences {
   363→  persona_style: 'standard' | 'warm' | 'roast'
   364→  push_enabled: boolean
   365→  push_time: string
   366→  quiet_hours_start: string
   367→  quiet_hours_end: string
   368→  chat_backend: ChatBackend
   369→}
   370→
   371→export async function login(email: string, password: string): Promise<LoginResponse> {
   372→  const res = await fetch(`${API_BASE}/api/auth/login`, {
   373→    method: 'POST',
   374→    headers: { 'Content-Type': 'application/json' },
   375→    credentials: 'include',
   376→    body: JSON.stringify({ email, password }),
   377→  })
   378→  const json = await res.json()
   379→  if (!res.ok || !json.ok) {
   380→    throw new Error(json.error?.message || 'Login failed')
   381→  }
   382→  return json.data
   383→}
   384→
   385→export async function register(data: RegisterRequest): Promise<RegisterResponse> {
   386→  const res = await fetch(`${API_BASE}/api/auth/register`, {
   387→    method: 'POST',
   388→    headers: { 'Content-Type': 'application/json' },
   389→    credentials: 'include',
   390→    body: JSON.stringify(data),
   391→  })
   392→  const json = await res.json()
   393→  if (!res.ok || !json.ok) {
   394→    throw new Error(json.error?.message || 'Register failed')
   395→  }
   396→  return json.data
   397→}
   398→
   399→export async function logout(): Promise<void> {
   400→  await fetchApi('/api/auth/logout', { method: 'POST' })
   401→}
   402→
   403→export async function fetchMe(): Promise<UserInfo> {
   404→  return fetchApi<UserInfo>('/api/auth/me')
   405→}
   406→
   407→export async function fetchPreferences(): Promise<UserPreferences> {
   408→  return fetchApi<UserPreferences>('/api/user/preferences')
   409→}
   410→
   411→export async function updatePreferences(
   412→  patch: Partial<Pick<UserPreferences, 'persona_style' | 'push_enabled' | 'push_time' | 'quiet_hours_start' | 'quiet_hours_end' | 'chat_backend'>>
   413→): Promise<void> {
   414→  await fetchApi('/api/user/preferences', {
   415→    method: 'PUT',
   416→    body: JSON.stringify(patch),
   417→  })
   418→}
   419→
   420→// SSE Chat Stream
   421→export function streamChatMessage(
   422→  message: string,
   423→  sessionId: string | undefined,
   424→  onChunk: (chunk: string) => void,
   425→  onDone: (fullResponse: SendChatResponse) => void,
   426→  onError: (error: Error) => void
   427→): () => void {
   428→  const controller = new AbortController()
   429→
   430→  const params = new URLSearchParams({ message })
   431→  if (sessionId) params.set('session_id', sessionId)
   432→
   433→  let resolvedSessionId = sessionId || ''
   434→
   435→  fetch(`${API_BASE}/api/chat/stream?${params}`, {
   436→    method: 'GET',
   437→    credentials: 'include',
   438→    headers: csrfHeaders(),
   439→    signal: controller.signal,
   440→  })
   441→    .then(async (response) => {
   442→      if (!response.ok) {
   443→        // Backward-compatible fallback: older backends may not implement /api/chat/stream yet.
   444→        if (response.status === 404 || response.status === 405) {
   445→          const fallback = await sendChatMessage(message, sessionId)
   446→          onDone(fallback)
   447→          return
   448→        }
   449→        const errorText = await response.text().catch(() => '')
   450→        const detail = errorText ? `: ${errorText.slice(0, 200)}` : ''
   451→        throw new Error(`Stream request failed (${response.status})${detail}`)
   452→      }
   453→
   454→      const reader = response.body?.getReader()
   455→      if (!reader) throw new Error('No reader')
   456→
   457→      const decoder = new TextDecoder()
   458→      let buffer = ''
   459→      let fullContent = ''
   460→
   461→      while (true) {
   462→        const { done, value } = await reader.read()
   463→        if (done) break
   464→
   465→        buffer += decoder.decode(value, { stream: true })
   466→        const lines = buffer.split('\n')
   467→        buffer = lines.pop() || ''
   468→
   469→        for (const line of lines) {
   470→          if (line.startsWith('data: ')) {
   471→            const data = line.slice(6)
   472→            if (data === '[DONE]') {
   473→              onDone({
   474→                session_id: resolvedSessionId,
   475→                reply: fullContent,
   476→              })
   477→              return
   478→            }
   479→            try {
   480→              const json = JSON.parse(data)
   481→              if (json?.type === 'meta' && typeof json.session_id === 'string') {
   482→                resolvedSessionId = json.session_id
   483→              } else if (json?.type === 'delta' && typeof json.delta === 'string') {
   484→                fullContent += json.delta
   485→                onChunk(json.delta)
   486→              } else if (json?.type === 'final' && json.data) {
   487→                const sid = typeof json.data.session_id === 'string' ? json.data.session_id : resolvedSessionId
   488→                resolvedSessionId = sid
   489→
   490→                const a2ui = json.data?.assistant_message?.a2ui as
   491→                  | { ui_components?: Array<{ type: string; data: unknown }> }
   492→                  | undefined
   493→                const markdownComponent = a2ui?.ui_components?.find((c) => c.type === 'markdown_text')
   494→                const reply = typeof markdownComponent?.data === 'string' ? markdownComponent.data : fullContent
   495→
   496→                onDone({
   497→                  session_id: sid,
   498→                  reply,
   499→                  ui_components: a2ui?.ui_components,
   500→                })
   501→                return
   502→              } else if (json?.type === 'error' && typeof json.error === 'string') {
   503→                throw new Error(json.error)
   504→              } else if (typeof json?.content === 'string') {
   505→                // Backward-compatible: {content:"..."}
   506→                fullContent += json.content
   507→                onChunk(json.content)
   508→              }
   509→            } catch {
   510→              // Skip invalid JSON
   511→            }
   512→          }
   513→        }
   514→      }
   515→    })
   516→    .catch((err) => {
   517→      if (err.name !== 'AbortError') {
   518→        onError(err)
   519→      }
   520→    })
   521→
   522→  return () => controller.abort()
   523→}
   524→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
