     1→"""
     2→Proactive Worker - 主动推送系统 Worker
     3→
     4→运行模式:
     5→1. 单次运行: python workers/proactive_worker.py --once
     6→2. 守护进程: python workers/proactive_worker.py --daemon --interval 3600
     7→3. 测试模式: python workers/proactive_worker.py --dry-run
     8→
     9→功能:
    10→- 扫描用户并检测触发条件
    11→- 生成个性化内容
    12→- 保存通知到数据库
    13→"""
    14→
    15→import argparse
    16→import asyncio
    17→import logging
    18→import sys
    19→from datetime import datetime
    20→from pathlib import Path
    21→
    22→# 添加项目根目录到 path
    23→sys.path.insert(0, str(Path(__file__).parent.parent))
    24→
    25→from services.proactive.engine import get_proactive_engine
    26→
    27→logging.basicConfig(
    28→    level=logging.INFO,
    29→    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    30→)
    31→logger = logging.getLogger(__name__)
    32→
    33→
    34→async def run_once(dry_run: bool = False) -> int:
    35→    """执行一次扫描和处理"""
    36→    logger.info(f"Starting proactive scan at {datetime.now()}")
    37→
    38→    engine = get_proactive_engine()
    39→
    40→    # 扫描任务
    41→    tasks = await engine.run_scheduled_scan()
    42→    logger.info(f"Found {len(tasks)} tasks")
    43→
    44→    if dry_run:
    45→        logger.info("Dry run mode - not processing tasks")
    46→        for task in tasks:
    47→            logger.info(f"  - {task.skill_id}/{task.reminder_type} for user {task.user_id}")
    48→        return len(tasks)
    49→
    50→    # 处理任务
    51→    if tasks:
    52→        success_count = await engine.process_tasks(tasks)
    53→        logger.info(f"Processed {success_count}/{len(tasks)} tasks successfully")
    54→        return success_count
    55→
    56→    return 0
    57→
    58→
    59→async def run_daemon(interval: int = 3600, dry_run: bool = False):
    60→    """守护进程模式"""
    61→    logger.info(f"Starting proactive worker daemon (interval: {interval}s)")
    62→
    63→    while True:
    64→        try:
    65→            await run_once(dry_run)
    66→        except Exception as e:
    67→            logger.error(f"Error in proactive worker: {e}")
    68→
    69→        logger.info(f"Sleeping for {interval} seconds...")
    70→        await asyncio.sleep(interval)
    71→
    72→
    73→def main():
    74→    parser = argparse.ArgumentParser(description="Proactive Worker - 主动推送系统")
    75→    parser.add_argument(
    76→        "--once",
    77→        action="store_true",
    78→        help="执行一次后退出",
    79→    )
    80→    parser.add_argument(
    81→        "--daemon",
    82→        action="store_true",
    83→        help="守护进程模式",
    84→    )
    85→    parser.add_argument(
    86→        "--interval",
    87→        type=int,
    88→        default=3600,
    89→        help="守护进程模式下的扫描间隔（秒），默认 3600",
    90→    )
    91→    parser.add_argument(
    92→        "--dry-run",
    93→        action="store_true",
    94→        help="测试模式，只扫描不处理",
    95→    )
    96→
    97→    args = parser.parse_args()
    98→
    99→    if args.daemon:
   100→        asyncio.run(run_daemon(args.interval, args.dry_run))
   101→    elif args.once:
   102→        result = asyncio.run(run_once(args.dry_run))
   103→        logger.info(f"Completed with {result} tasks")
   104→    else:
   105→        # 默认执行一次
   106→        result = asyncio.run(run_once(args.dry_run))
   107→        logger.info(f"Completed with {result} tasks")
   108→
   109→
   110→if __name__ == "__main__":
   111→    main()
   112→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
