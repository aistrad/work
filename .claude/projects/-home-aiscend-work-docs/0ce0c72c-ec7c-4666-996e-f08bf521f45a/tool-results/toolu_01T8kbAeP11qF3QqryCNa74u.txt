The file /home/aiscend/work/vibelife/apps/api/workers/proactive_worker.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     1→"""
     2→Proactive Worker - 主动推送系统 Worker v3.0
     3→
     4→运行模式:
     5→1. 单次运行: python workers/proactive_worker.py --once
     6→2. 守护进程: python workers/proactive_worker.py --daemon --interval 3600
     7→3. 测试模式: python workers/proactive_worker.py --dry-run
     8→
     9→功能:
    10→- 扫描用户并检测触发条件（静态优先 + LLM 回退）
    11→- 调用 Agent 生成个性化内容
    12→- 保存通知到数据库
    13→
    14→v3.0 更新:
    15→- 使用 ProactiveOrchestrator 替代 ProactiveEngine
    16→- 静态条件优先求值，降低 LLM 调用
    17→- 幂等去重机制
    18→"""
    19→
    20→import argparse
    21→import asyncio
    22→import logging
    23→import sys
    24→from datetime import datetime
    25→from pathlib import Path
    26→
    27→# 添加项目根目录到 path
    28→sys.path.insert(0, str(Path(__file__).parent.parent))
    29→
    30→logging.basicConfig(
    31→    level=logging.INFO,
    32→    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    33→)
    34→logger = logging.getLogger(__name__)
    35→
    36→
    37→def get_orchestrator():
    38→    """获取 ProactiveOrchestrator 实例"""
    39→    from services.proactive.orchestrator import ProactiveOrchestrator
    40→    from services.proactive.trigger_evaluator import TriggerEvaluator
    41→    from services.proactive.agent_adapter import ProactiveAgentAdapter
    42→    from services.reminder.notification import NotificationService
    43→
    44→    trigger_evaluator = TriggerEvaluator()
    45→    agent_adapter = ProactiveAgentAdapter()
    46→    notification_service = NotificationService()
    47→
    48→    return ProactiveOrchestrator(
    49→        trigger_evaluator=trigger_evaluator,
    50→        agent_adapter=agent_adapter,
    51→        notification_service=notification_service,
    52→    )
    53→
    54→
    55→async def run_once(dry_run: bool = False) -> int:
    56→    """执行一次扫描和处理"""
    57→    logger.info(f"Starting proactive scan at {datetime.now()}")
    58→
    59→    orchestrator = get_orchestrator()
    60→
    61→    # 扫描并处理
    62→    results = await orchestrator.run_scheduled_scan(dry_run=dry_run)
    63→    logger.info(f"Generated {len(results)} notifications")
    64→
    65→    if dry_run:
    66→        logger.info("Dry run mode - notifications not saved")
    67→        for result in results:
    68→            logger.info(f"  - {result['skill_id']}/{result['reminder_id']} for user {result['user_id']}")
    69→
    70→    return len(results)
    71→
    72→
    73→async def run_daemon(interval: int = 3600, dry_run: bool = False):
    74→    """守护进程模式"""
    75→    logger.info(f"Starting proactive worker daemon (interval: {interval}s)")
    76→
    77→    while True:
    78→        try:
    79→            await run_once(dry_run)
    80→        except Exception as e:
    81→            logger.error(f"Error in proactive worker: {e}")
    82→
    83→        logger.info(f"Sleeping for {interval} seconds...")
    84→        await asyncio.sleep(interval)
    85→
    86→
    87→def main():
    88→    parser = argparse.ArgumentParser(description="Proactive Worker v3.0 - LLM-First 主动推送系统")
    89→    parser.add_argument(
    90→        "--once",
    91→        action="store_true",
    92→        help="执行一次后退出",
    93→    )
    94→    parser.add_argument(
    95→        "--daemon",
    96→        action="store_true",
    97→        help="守护进程模式",
    98→    )
    99→    parser.add_argument(
   100→        "--interval",
   101→        type=int,
   102→        default=3600,
   103→        help="守护进程模式下的扫描间隔（秒），默认 3600",
   104→    )
   105→    parser.add_argument(
   106→        "--dry-run",
   107→        action="store_true",
   108→        help="测试模式，只扫描不处理",
   109→    )
   110→
   111→    args = parser.parse_args()
   112→
   113→    if args.daemon:
   114→        asyncio.run(run_daemon(args.interval, args.dry_run))
   115→    elif args.once:
   116→        result = asyncio.run(run_once(args.dry_run))
   117→        logger.info(f"Completed with {result} notifications")
   118→    else:
   119→        # 默认执行一次
   120→        result = asyncio.run(run_once(args.dry_run))
   121→        logger.info(f"Completed with {result} notifications")
   122→
   123→
   124→if __name__ == "__main__":
   125→    main()
   126→