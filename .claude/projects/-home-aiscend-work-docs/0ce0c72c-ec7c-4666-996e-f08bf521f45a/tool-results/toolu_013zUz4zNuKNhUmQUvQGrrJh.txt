The file /home/aiscend/work/vibelife/apps/api/tests/services/proactive/test_trigger_evaluator.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     1→"""
     2→TriggerEvaluator Unit Tests
     3→
     4→TDD: Tests written first, then implementation.
     5→
     6→Test categories:
     7→1. Static condition evaluation (exists, !exists, ==, !=, >, <, >=, <=, contains)
     8→2. Placeholder preprocessing ({today}, {now})
     9→3. Cron matching with timezone
    10→4. Event-based detection (birthday, solar_term)
    11→5. LLM fallback for complex conditions
    12→6. Idempotent key generation
    13→"""
    14→
    15→import pytest
    16→from datetime import datetime, date, timezone
    17→from unittest.mock import AsyncMock, MagicMock, patch
    18→import time_machine
    19→
    20→
    21→class TestStaticConditionEvaluation:
    22→    """Test static condition evaluation (no LLM needed)"""
    23→
    24→    @pytest.fixture
    25→    def evaluator(self):
    26→        from services.proactive.trigger_evaluator import TriggerEvaluator
    27→        return TriggerEvaluator()
    28→
    29→    @pytest.fixture
    30→    def profile_with_birth_info(self):
    31→        return {
    32→            "vibe": {
    33→                "profile": {
    34→                    "birth_info": {
    35→                        "date": "1990-05-15",
    36→                        "time": "10:30",
    37→                        "location": "Beijing"
    38→                    }
    39→                },
    40→                "goals": [
    41→                    {"name": "Learn Python", "status": "active"}
    42→                ],
    43→                "state": {
    44→                    "emotion": "calm",
    45→                    "focus": ["career", "health"]
    46→                }
    47→            },
    48→            "lifecoach": {
    49→                "progress": {
    50→                    "last_checkin_date": "2026-01-25",
    51→                    "streak_days": 7
    52→                }
    53→            },
    54→            "skills": {
    55→                "bazi": {
    56→                    "daily_fortune": {
    57→                        "score": 75
    58→                    }
    59→                }
    60→            }
    61→        }
    62→
    63→    def test_exists_operator_returns_true_when_data_exists(self, evaluator, profile_with_birth_info):
    64→        """exists operator should return True when path has data"""
    65→        condition = {
    66→            "description": "用户已设定八字信息",
    67→            "data_path": "vibe.profile.birth_info",
    68→            "operator": "exists"
    69→        }
    70→        result = evaluator._static_eval(condition, profile_with_birth_info)
    71→        assert result is True
    72→
    73→    def test_exists_operator_returns_false_when_data_missing(self, evaluator, profile_with_birth_info):
    74→        """exists operator should return False when path has no data"""
    75→        condition = {
    76→            "description": "用户设定了X数据",
    77→            "data_path": "vibe.profile.nonexistent",
    78→            "operator": "exists"
    79→        }
    80→        result = evaluator._static_eval(condition, profile_with_birth_info)
    81→        assert result is False
    82→
    83→    def test_not_exists_operator(self, evaluator, profile_with_birth_info):
    84→        """!exists operator should return True when path has no data"""
    85→        condition = {
    86→            "data_path": "vibe.profile.nonexistent",
    87→            "operator": "!exists"
    88→        }
    89→        result = evaluator._static_eval(condition, profile_with_birth_info)
    90→        assert result is True
    91→
    92→    def test_equals_operator_string(self, evaluator, profile_with_birth_info):
    93→        """== operator should work with strings"""
    94→        condition = {
    95→            "data_path": "vibe.state.emotion",
    96→            "operator": "==",
    97→            "value": "calm"
    98→        }
    99→        result = evaluator._static_eval(condition, profile_with_birth_info)
   100→        assert result is True
   101→
   102→    def test_not_equals_operator(self, evaluator, profile_with_birth_info):
   103→        """!= operator should work correctly"""
   104→        condition = {
   105→            "data_path": "lifecoach.progress.last_checkin_date",
   106→            "operator": "!=",
   107→            "value": "2026-01-26"
   108→        }
   109→        result = evaluator._static_eval(condition, profile_with_birth_info)
   110→        assert result is True
   111→
   112→    def test_greater_than_operator(self, evaluator, profile_with_birth_info):
   113→        """< operator should work with numbers"""
   114→        condition = {
   115→            "data_path": "skills.bazi.daily_fortune.score",
   116→            "operator": "<",
   117→            "value": 80
   118→        }
   119→        result = evaluator._static_eval(condition, profile_with_birth_info)
   120→        assert result is True
   121→
   122→    def test_greater_than_or_equal_operator(self, evaluator, profile_with_birth_info):
   123→        """>= operator should work with numbers"""
   124→        condition = {
   125→            "data_path": "lifecoach.progress.streak_days",
   126→            "operator": ">=",
   127→            "value": 7
   128→        }
   129→        result = evaluator._static_eval(condition, profile_with_birth_info)
   130→        assert result is True
   131→
   132→    def test_contains_operator(self, evaluator, profile_with_birth_info):
   133→        """contains operator should check substring"""
   134→        condition = {
   135→            "data_path": "vibe.profile.birth_info.location",
   136→            "operator": "contains",
   137→            "value": "Bei"
   138→        }
   139→        result = evaluator._static_eval(condition, profile_with_birth_info)
   140→        assert result is True
   141→
   142→
   143→class TestPlaceholderPreprocessing:
   144→    """Test placeholder replacement in conditions"""
   145→
   146→    @pytest.fixture
   147→    def evaluator(self):
   148→        from services.proactive.trigger_evaluator import TriggerEvaluator
   149→        return TriggerEvaluator()
   150→
   151→    @time_machine.travel("2026-01-26 10:00:00", tick=False)
   152→    def test_today_placeholder_replaced(self, evaluator):
   153→        """{today} should be replaced with current date"""
   154→        condition = {
   155→            "data_path": "lifecoach.progress.last_checkin_date",
   156→            "operator": "!=",
   157→            "value": "{today}"
   158→        }
   159→        processed = evaluator._preprocess_condition(condition)
   160→        assert processed["value"] == "2026-01-26"
   161→
   162→    @time_machine.travel("2026-01-26 10:30:45", tick=False)
   163→    def test_now_placeholder_replaced(self, evaluator):
   164→        """{now} should be replaced with current datetime"""
   165→        condition = {
   166→            "data_path": "some.path",
   167→            "operator": "==",
   168→            "value": "{now}"
   169→        }
   170→        processed = evaluator._preprocess_condition(condition)
   171→        assert "2026-01-26" in processed["value"]
   172→
   173→
   174→class TestCronMatching:
   175→    """Test cron schedule matching with timezone"""
   176→
   177→    @pytest.fixture
   178→    def evaluator(self):
   179→        from services.proactive.trigger_evaluator import TriggerEvaluator
   180→        return TriggerEvaluator()
   181→
   182→    @time_machine.travel("2026-01-26 00:00:30+00:00", tick=False)
   183→    def test_cron_matches_at_scheduled_time(self, evaluator):
   184→        """Cron should match when current time matches schedule"""
   185→        schedule = "0 8 * * *"  # 8:00 AM every day in user timezone
   186→        matched, bucket_key = evaluator._evaluate_cron(schedule, "Asia/Shanghai")
   187→        # At 00:00 UTC = 08:00 Asia/Shanghai
   188→        assert matched is True
   189→        assert bucket_key is not None
   190→
   191→    @time_machine.travel("2026-01-26 01:00:00+00:00", tick=False)
   192→    def test_cron_does_not_match_outside_window(self, evaluator):
   193→        """Cron should not match outside the time window"""
   194→        schedule = "0 8 * * *"  # 8:00 AM every day
   195→        matched, bucket_key = evaluator._evaluate_cron(schedule, "Asia/Shanghai")
   196→        # At 01:00 UTC = 09:00 Asia/Shanghai
   197→        assert matched is False
   198→
   199→    @time_machine.travel("2026-01-26 00:00:00+00:00", tick=False)
   200→    def test_cron_returns_bucket_key_for_idempotency(self, evaluator):
   201→        """Cron should return bucket_key for idempotent deduplication"""
   202→        schedule = "0 8 * * *"
   203→        matched, bucket_key = evaluator._evaluate_cron(schedule, "Asia/Shanghai")
   204→        # At 00:00 UTC = 08:00 Asia/Shanghai
   205→        assert bucket_key == "2026-01-26T08:00"
   206→
   207→    def test_invalid_cron_returns_false(self, evaluator):
   208→        """Invalid cron expression should return False"""
   209→        matched, bucket_key = evaluator._evaluate_cron("invalid cron", "Asia/Shanghai")
   210→        assert matched is False
   211→        assert bucket_key is None
   212→
   213→
   214→class TestConditionClassification:
   215→    """Test classification of static vs complex conditions"""
   216→
   217→    @pytest.fixture
   218→    def evaluator(self):
   219→        from services.proactive.trigger_evaluator import TriggerEvaluator
   220→        return TriggerEvaluator()
   221→
   222→    def test_condition_with_data_path_and_static_operator_is_static(self, evaluator):
   223→        """Conditions with data_path and static operator are static"""
   224→        condition = {
   225→            "data_path": "vibe.profile.birth_info",
   226→            "operator": "exists"
   227→        }
   228→        assert evaluator._is_static_condition(condition) is True
   229→
   230→    def test_condition_without_data_path_is_complex(self, evaluator):
   231→        """Conditions without data_path require LLM"""
   232→        condition = {
   233→            "description": "用户连续3天情绪低落且未进行冥想"
   234→        }
   235→        assert evaluator._is_static_condition(condition) is False
   236→
   237→    def test_condition_with_non_static_operator_is_complex(self, evaluator):
   238→        """Conditions with non-static operators require LLM"""
   239→        condition = {
   240→            "data_path": "some.path",
   241→            "operator": "semantic_match"
   242→        }
   243→        assert evaluator._is_static_condition(condition) is False
   244→
   245→
   246→class TestEventBasedDetection:
   247→    """Test event-based trigger detection"""
   248→
   249→    @pytest.fixture
   250→    def evaluator(self):
   251→        from services.proactive.trigger_evaluator import TriggerEvaluator
   252→        return TriggerEvaluator()
   253→
   254→    @time_machine.travel("2026-05-08", tick=False)
   255→    def test_birthday_detected_7_days_before(self, evaluator):
   256→        """Birthday should be detected 7 days before"""
   257→        profile = {
   258→            "vibe": {
   259→                "profile": {
   260→                    "birth_info": {
   261→                        "date": "1990-05-15"
   262→                    }
   263→                }
   264→            }
   265→        }
   266→        triggered, event_info, idempotent_key = evaluator._detect_birthday(profile, [7, 0])
   267→        assert triggered is True
   268→        assert event_info["event_type"] == "birthday"
   269→        assert event_info["days_until"] == 7
   270→
   271→    @time_machine.travel("2026-05-15", tick=False)
   272→    def test_birthday_detected_on_day(self, evaluator):
   273→        """Birthday should be detected on the day"""
   274→        profile = {
   275→            "vibe": {
   276→                "profile": {
   277→                    "birth_info": {
   278→                        "date": "1990-05-15"
   279→                    }
   280→                }
   281→            }
   282→        }
   283→        triggered, event_info, idempotent_key = evaluator._detect_birthday(profile, [7, 0])
   284→        assert triggered is True
   285→        assert event_info["days_until"] == 0
   286→
   287→    @time_machine.travel("2026-05-10", tick=False)
   288→    def test_birthday_not_detected_outside_advance_days(self, evaluator):
   289→        """Birthday should not be detected outside advance_days"""
   290→        profile = {
   291→            "vibe": {
   292→                "profile": {
   293→                    "birth_info": {
   294→                        "date": "1990-05-15"
   295→                    }
   296→                }
   297→            }
   298→        }
   299→        triggered, event_info, idempotent_key = evaluator._detect_birthday(profile, [7, 0])
   300→        assert triggered is False
   301→
   302→    def test_birthday_not_detected_without_birth_info(self, evaluator):
   303→        """Birthday should not be detected without birth_info"""
   304→        profile = {"vibe": {"profile": {}}}
   305→        triggered, event_info, idempotent_key = evaluator._detect_birthday(profile, [7, 0])
   306→        assert triggered is False
   307→
   308→
   309→class TestNestedValueAccess:
   310→    """Test nested dictionary value access"""
   311→
   312→    @pytest.fixture
   313→    def evaluator(self):
   314→        from services.proactive.trigger_evaluator import TriggerEvaluator
   315→        return TriggerEvaluator()
   316→
   317→    def test_get_nested_value_success(self, evaluator):
   318→        """Should get deeply nested values"""
   319→        data = {"a": {"b": {"c": "value"}}}
   320→        result = evaluator._get_nested_value(data, "a.b.c")
   321→        assert result == "value"
   322→
   323→    def test_get_nested_value_missing_path(self, evaluator):
   324→        """Should return None for missing path"""
   325→        data = {"a": {"b": {}}}
   326→        result = evaluator._get_nested_value(data, "a.b.c")
   327→        assert result is None
   328→
   329→    def test_get_nested_value_non_dict(self, evaluator):
   330→        """Should handle non-dict intermediate values"""
   331→        data = {"a": "string"}
   332→        result = evaluator._get_nested_value(data, "a.b.c")
   333→        assert result is None
   334→
   335→
   336→class TestEvaluateConditions:
   337→    """Test the main condition evaluation flow"""
   338→
   339→    @pytest.fixture
   340→    def evaluator(self):
   341→        from services.proactive.trigger_evaluator import TriggerEvaluator
   342→        return TriggerEvaluator()
   343→
   344→    @pytest.mark.asyncio
   345→    async def test_all_static_conditions_pass(self, evaluator):
   346→        """All static conditions passing should return True"""
   347→        profile = {
   348→            "vibe": {
   349→                "profile": {
   350→                    "birth_info": {"date": "1990-05-15"}
   351→                }
   352→            }
   353→        }
   354→        conditions = [
   355→            {"data_path": "vibe.profile.birth_info", "operator": "exists"}
   356→        ]
   357→        result = await evaluator._evaluate_conditions(conditions, profile)
   358→        assert result is True
   359→
   360→    @pytest.mark.asyncio
   361→    async def test_one_static_condition_fails_short_circuits(self, evaluator):
   362→        """Failing static condition should short-circuit"""
   363→        profile = {"vibe": {"profile": {}}}
   364→        conditions = [
   365→            {"data_path": "vibe.profile.birth_info", "operator": "exists"},
   366→            {"description": "Complex condition that should not be evaluated"}
   367→        ]
   368→        result = await evaluator._evaluate_conditions(conditions, profile)
   369→        assert result is False
   370→
   371→    @pytest.mark.asyncio
   372→    async def test_empty_conditions_return_true(self, evaluator):
   373→        """Empty conditions should return True"""
   374→        result = await evaluator._evaluate_conditions([], {})
   375→        assert result is True
   376→
   377→
   378→class TestTimeBasedTrigger:
   379→    """Test time-based trigger evaluation"""
   380→
   381→    @pytest.fixture
   382→    def evaluator(self):
   383→        from services.proactive.trigger_evaluator import TriggerEvaluator
   384→        return TriggerEvaluator()
   385→
   386→    @pytest.mark.asyncio
   387→    @time_machine.travel("2026-01-26 00:00:30+00:00", tick=False)
   388→    async def test_time_based_trigger_with_matching_cron(self, evaluator):
   389→        """Time-based trigger should fire when cron matches"""
   390→        trigger_config = {
   391→            "type": "time_based",
   392→            "schedule": "0 8 * * *"
   393→        }
   394→        profile = {
   395→            "vibe": {
   396→                "profile": {
   397→                    "birth_info": {"date": "1990-05-15"}
   398→                }
   399→            }
   400→        }
   401→        conditions = [
   402→            {"data_path": "vibe.profile.birth_info", "operator": "exists"}
   403→        ]
   404→
   405→        triggered, event_info, bucket_key = await evaluator.evaluate(
   406→            trigger_config=trigger_config,
   407→            profile=profile,
   408→            conditions=conditions,
   409→            user_timezone="Asia/Shanghai"
   410→        )
   411→
   412→        assert triggered is True
   413→        assert bucket_key is not None
   414→
   415→    @pytest.mark.asyncio
   416→    @time_machine.travel("2026-01-26 00:00:30+00:00", tick=False)
   417→    async def test_time_based_trigger_fails_when_conditions_not_met(self, evaluator):
   418→        """Time-based trigger should not fire when conditions fail"""
   419→        trigger_config = {
   420→            "type": "time_based",
   421→            "schedule": "0 8 * * *"
   422→        }
   423→        profile = {"vibe": {"profile": {}}}
   424→        conditions = [
   425→            {"data_path": "vibe.profile.birth_info", "operator": "exists"}
   426→        ]
   427→
   428→        triggered, event_info, bucket_key = await evaluator.evaluate(
   429→            trigger_config=trigger_config,
   430→            profile=profile,
   431→            conditions=conditions,
   432→            user_timezone="Asia/Shanghai"
   433→        )
   434→
   435→        assert triggered is False
   436→
   437→
   438→class TestEventBasedTrigger:
   439→    """Test event-based trigger evaluation"""
   440→
   441→    @pytest.fixture
   442→    def evaluator(self):
   443→        from services.proactive.trigger_evaluator import TriggerEvaluator
   444→        return TriggerEvaluator()
   445→
   446→    @pytest.mark.asyncio
   447→    @time_machine.travel("2026-05-15", tick=False)
   448→    async def test_event_based_birthday_trigger(self, evaluator):
   449→        """Event-based birthday trigger should fire on birthday"""
   450→        trigger_config = {
   451→            "type": "event_based",
   452→            "event": "birthday",
   453→            "advance_days": [7, 0]
   454→        }
   455→        profile = {
   456→            "vibe": {
   457→                "profile": {
   458→                    "birth_info": {"date": "1990-05-15"}
   459→                }
   460→            }
   461→        }
   462→
   463→        triggered, event_info, idempotent_key = await evaluator.evaluate(
   464→            trigger_config=trigger_config,
   465→            profile=profile,
   466→            user_timezone="Asia/Shanghai"
   467→        )
   468→
   469→        assert triggered is True
   470→        assert event_info["event_type"] == "birthday"
   471→
   472→
   473→class TestDataConditionTrigger:
   474→    """Test data_condition trigger type"""
   475→
   476→    @pytest.fixture
   477→    def evaluator(self):
   478→        from services.proactive.trigger_evaluator import TriggerEvaluator
   479→        return TriggerEvaluator()
   480→
   481→    @pytest.mark.asyncio
   482→    @time_machine.travel("2026-01-26", tick=False)
   483→    async def test_data_condition_trigger(self, evaluator):
   484→        """Data condition trigger should evaluate conditions only"""
   485→        trigger_config = {
   486→            "type": "data_condition"
   487→        }
   488→        profile = {
   489→            "lifecoach": {
   490→                "north_star": {"vision": "Become a better person"},
   491→                "progress": {"last_checkin_date": "2026-01-25"}
   492→            }
   493→        }
   494→        conditions = [
   495→            {"data_path": "lifecoach.north_star.vision", "operator": "exists"},
   496→            {"data_path": "lifecoach.progress.last_checkin_date", "operator": "!=", "value": "{today}"}
   497→        ]
   498→
   499→        triggered, event_info, bucket_key = await evaluator.evaluate(
   500→            trigger_config=trigger_config,
   501→            profile=profile,
   502→            conditions=conditions,
   503→            user_timezone="Asia/Shanghai"
   504→        )
   505→
   506→        assert triggered is True
   507→