     1→"""
     2→ProactiveEngine - 主动推送系统核心引擎
     3→
     4→职责:
     5→1. 加载 Skill 级提醒定义 (reminders.yaml)
     6→2. 协调触发检测、内容生成、推送投递
     7→3. 管理数据源 (unified_profiles)
     8→
     9→设计原则:
    10→- Skill 级定义: 每个 Skill 在 reminders.yaml 定义自己的提醒类型
    11→- 数据源统一: unified_profiles 是唯一真源
    12→- 智能化: 基于 life_context 个性化内容 + 事件触发
    13→"""
    14→
    15→import logging
    16→import yaml
    17→from dataclasses import dataclass, field
    18→from datetime import datetime, date
    19→from enum import Enum
    20→from pathlib import Path
    21→from typing import List, Dict, Any, Optional
    22→from uuid import UUID
    23→
    24→import pytz
    25→
    26→from stores.db import get_connection
    27→from stores.unified_profile_repo import UnifiedProfileRepository
    28→from services.reminder.notification import NotificationService
    29→# v7.5: 使用 async 版本，从数据库优先加载
    30→from services.agent.skill_loader import load_skill_metadata_async
    31→
    32→logger = logging.getLogger(__name__)
    33→
    34→
    35→class ReminderPriority(str, Enum):
    36→    LOW = "low"
    37→    MEDIUM = "medium"
    38→    HIGH = "high"
    39→    URGENT = "urgent"
    40→
    41→
    42→@dataclass
    43→class ReminderTask:
    44→    """提醒任务"""
    45→    user_id: UUID
    46→    skill_id: str
    47→    reminder_type: str
    48→    priority: ReminderPriority = ReminderPriority.MEDIUM
    49→    trigger_event: Optional[str] = None
    50→    trigger_date: Optional[date] = None
    51→    metadata: Dict[str, Any] = field(default_factory=dict)
    52→
    53→
    54→@dataclass
    55→class ReminderContent:
    56→    """提醒内容"""
    57→    title: str
    58→    body: str
    59→    data: Dict[str, Any] = field(default_factory=dict)
    60→    card_type: Optional[str] = None
    61→    # 对话引导字段
    62→    suggested_prompt: Optional[str] = None
    63→    quick_actions: List[Dict[str, str]] = field(default_factory=list)
    64→
    65→
    66→class ProactiveEngine:
    67→    """主动推送引擎"""
    68→
    69→    # 默认推送时间 (用户本地时间) - 可被 global_config 覆盖
    70→    DEFAULT_PUSH_HOUR = 4
    71→
    72→    def __init__(self):
    73→        self._skill_configs: Dict[str, Dict] = {}
    74→        self._trigger_detector = None
    75→        self._content_generator = None
    76→        self._notification_service = NotificationService()
    77→        self._load_skill_configs()
    78→
    79→    def _get_default_push_hour(self, skill_id: Optional[str] = None) -> int:
    80→        """
    81→        获取默认推送时间（支持全局和 Skill 级别配置）
    82→
    83→        优先级: Skill global_config > 系统默认值
    84→        """
    85→        if skill_id:
    86→            skill_config = self._skill_configs.get(skill_id, {})
    87→            global_config = skill_config.get("global_config", {})
    88→            if "default_push_hour" in global_config:
    89→                return global_config["default_push_hour"]
    90→
    91→        return self.DEFAULT_PUSH_HOUR
    92→
    93→    def _load_skill_configs(self):
    94→        """加载所有 Skill 的 reminders.yaml"""
    95→        skills_dir = Path(__file__).parent.parent.parent / "skills"
    96→
    97→        for skill_dir in skills_dir.iterdir():
    98→            if skill_dir.is_dir():
    99→                reminders_file = skill_dir / "reminders.yaml"
   100→                if reminders_file.exists():
   101→                    try:
   102→                        with open(reminders_file, encoding="utf-8") as f:
   103→                            config = yaml.safe_load(f)
   104→                            if config and "skill_id" in config:
   105→                                self._skill_configs[config["skill_id"]] = config
   106→                                logger.info(f"Loaded reminders config for skill: {config['skill_id']}")
   107→                    except Exception as e:
   108→                        logger.error(f"Failed to load {reminders_file}: {e}")
   109→
   110→        logger.info(f"Loaded {len(self._skill_configs)} skill reminder configs")
   111→
   112→    @property
   113→    def trigger_detector(self):
   114→        """延迟加载 TriggerDetector"""
   115→        if self._trigger_detector is None:
   116→            from .trigger_detector import TriggerDetector
   117→            self._trigger_detector = TriggerDetector()
   118→        return self._trigger_detector
   119→
   120→    @property
   121→    def content_generator(self):
   122→        """延迟加载 ContentGenerator"""
   123→        if self._content_generator is None:
   124→            from .content_generator import ContentGenerator
   125→            self._content_generator = ContentGenerator()
   126→        return self._content_generator
   127→
   128→    async def run_scheduled_scan(self) -> List[ReminderTask]:
   129→        """
   130→        定时扫描入口 (由 Worker 调用)
   131→
   132→        流程:
   133→        1. 获取当前时段应该推送的用户
   134→        2. 检测每个用户的触发条件
   135→        3. 生成提醒任务
   136→        """
   137→        tasks = []
   138→
   139→        # 获取当前时段的用户
   140→        users = await self._get_users_for_current_hour()
   141→        logger.info(f"Found {len(users)} users for current hour")
   142→
   143→        for user in users:
   144→            try:
   145→                user_tasks = await self._detect_user_triggers(user)
   146→                tasks.extend(user_tasks)
   147→            except Exception as e:
   148→                logger.error(f"Failed to detect triggers for user {user.get('user_id')}: {e}")
   149→
   150→        logger.info(f"Generated {len(tasks)} reminder tasks")
   151→        return tasks
   152→
   153→    async def process_tasks(self, tasks: List[ReminderTask]) -> int:
   154→        """
   155→        处理提醒任务
   156→
   157→        流程:
   158→        1. 生成个性化内容
   159→        2. 投递到推送渠道
   160→        3. 记录到数据库
   161→        """
   162→        success_count = 0
   163→
   164→        for task in tasks:
   165→            try:
   166→                # 获取用户 Profile
   167→                profile = await UnifiedProfileRepository.get_profile(task.user_id)
   168→                if not profile:
   169→                    logger.warning(f"Profile not found for user {task.user_id}")
   170→                    continue
   171→
   172→                # 获取 Skill 配置
   173→                skill_config = self._skill_configs.get(task.skill_id, {})
   174→                reminder_config = self._get_reminder_config(skill_config, task.reminder_type)
   175→
   176→                # 生成内容
   177→                content = await self.content_generator.generate(
   178→                    task=task,
   179→                    profile=profile,
   180→                    config=reminder_config,
   181→                )
   182→
   183→                # 投递 (保存到数据库)
   184→                # 使用统一的 notification_type 格式: {skill_id}_{reminder_type}
   185→                notification_type = f"{task.skill_id}_{task.reminder_type}"
   186→                await self._notification_service.send_notification(
   187→                    user_id=task.user_id,
   188→                    notification_type=notification_type,
   189→                    title=content.title,
   190→                    content=content.data,
   191→                    trigger_date=task.trigger_date or date.today(),
   192→                )
   193→
   194→                success_count += 1
   195→                logger.debug(f"Processed task: {task.skill_id}/{task.reminder_type} for user {task.user_id}")
   196→
   197→            except Exception as e:
   198→                logger.error(f"Failed to process task {task}: {e}")
   199→
   200→        logger.info(f"Successfully processed {success_count}/{len(tasks)} tasks")
   201→        return success_count
   202→
   203→    async def run_once(self) -> int:
   204→        """执行一次完整的扫描和处理"""
   205→        tasks = await self.run_scheduled_scan()
   206→        if tasks:
   207→            return await self.process_tasks(tasks)
   208→        return 0
   209→
   210→    async def _get_users_for_current_hour(self) -> List[Dict[str, Any]]:
   211→        """
   212→        获取当前时段应该推送的用户
   213→
   214→        v7.6 改进: 从 unified_profiles 读取推送偏好
   215→        优先级:
   216→        1. 用户全局偏好 (preferences.push_settings.default_push_hour)
   217→        2. Skill 配置 (reminders.yaml global_config.default_push_hour)
   218→        3. 系统默认值 (DEFAULT_PUSH_HOUR)
   219→        """
   220→        now_utc = datetime.now(pytz.UTC)
   221→
   222→        # v7.6: 查询付费用户及其 Profile（推送偏好现在在 profile 内）
   223→        query = """
   224→            SELECT
   225→                u.id as user_id,
   226→                up.profile
   227→            FROM vibe_users u
   228→            JOIN unified_profiles up ON up.user_id = u.id
   229→            WHERE u.subscription_status = 'active'
   230→        """
   231→
   232→        users = []
   233→        try:
   234→            async with get_connection() as conn:
   235→                rows = await conn.fetch(query)
   236→
   237→            for row in rows:
   238→                profile = row["profile"] if isinstance(row["profile"], dict) else {}
   239→                preferences = profile.get("preferences", {})
   240→                tz_name = preferences.get("timezone", "Asia/Shanghai")
   241→
   242→                # v7.6: 从 profile.preferences.push_settings 获取推送偏好
   243→                push_settings = preferences.get("push_settings", {})
   244→                user_push_hour = push_settings.get("default_push_hour", self.DEFAULT_PUSH_HOUR)
   245→                quiet_start = push_settings.get("quiet_start_hour", 22)
   246→                quiet_end = push_settings.get("quiet_end_hour", 7)
   247→
   248→                try:
   249→                    tz = pytz.timezone(tz_name)
   250→                    user_time = now_utc.astimezone(tz)
   251→
   252→                    # 检查是否在静默时段
   253→                    is_quiet = False
   254→                    if quiet_start > quiet_end:
   255→                        is_quiet = user_time.hour >= quiet_start or user_time.hour < quiet_end
   256→                    else:
   257→                        is_quiet = quiet_start <= user_time.hour < quiet_end
   258→
   259→                    if is_quiet:
   260→                        continue  # 跳过静默时段的用户
   261→
   262→                    # 检查用户本地时间是否匹配其推送时间
   263→                    if user_time.hour == user_push_hour:
   264→                        users.append({
   265→                            "user_id": row["user_id"],
   266→                            "profile": profile,
   267→                            "timezone": tz_name,
   268→                            "local_hour": user_time.hour,
   269→                            "push_hour": user_push_hour,
   270→                        })
   271→                except Exception:
   272→                    # 默认使用 Asia/Shanghai (UTC+8)
   273→                    default_hour = (now_utc.hour + 8) % 24
   274→                    if default_hour == user_push_hour:
   275→                        users.append({
   276→                            "user_id": row["user_id"],
   277→                            "profile": profile,
   278→                            "timezone": "Asia/Shanghai",
   279→                            "local_hour": default_hour,
   280→                            "push_hour": user_push_hour,
   281→                        })
   282→        except Exception as e:
   283→            logger.error(f"Failed to get users: {e}")
   284→
   285→        return users
   286→
   287→    async def _should_send_to_user(
   288→        self,
   289→        user_id: UUID,
   290→        skill_id: str,
   291→    ) -> bool:
   292→        """
   293→        检查是否应该发送推送
   294→
   295→        基于 Skill 订阅状态决定：
   296→        - Core Skill: 始终发送
   297→        - Default Skill: 未取消订阅且 push_enabled 时发送
   298→        - Professional Skill: 已订阅且 push_enabled 时发送
   299→        """
   300→        # v7.5: 使用 async 版本，从数据库优先加载
   301→        skill_meta = await load_skill_metadata_async(skill_id)
   302→        category = skill_meta.category if skill_meta else "professional"
   303→
   304→        # Core Skill 始终发送
   305→        if category == "core":
   306→            return True
   307→
   308→        # v7.6: 使用 UnifiedProfileRepository 获取用户订阅状态
   309→        subscription = await UnifiedProfileRepository.get_skill_subscription(user_id, skill_id)
   310→
   311→        # Default Skill: 检查取消订阅和推送开关
   312→        if category == "default":
   313→            if subscription and subscription.status == "unsubscribed":
   314→                return False
   315→            if subscription and not subscription.push_enabled:
   316→                return False
   317→            return True
   318→
   319→        # Professional Skill: 需要有效订阅且开启推送
   320→        if not subscription or subscription.status != "subscribed":
   321→            return False
   322→
   323→        return subscription.push_enabled
   324→
   325→    async def _detect_user_triggers(self, user: Dict[str, Any]) -> List[ReminderTask]:
   326→        """检测用户的所有触发条件 - 集成订阅检查"""
   327→        tasks = []
   328→        user_id = user["user_id"]
   329→        profile = user["profile"]
   330→        user_local_hour = user.get("local_hour")
   331→
   332→        # 遍历所有 Skill 配置
   333→        for skill_id, config in self._skill_configs.items():
   334→            # 检查 Skill 配置的推送时间是否匹配用户本地时间
   335→            skill_push_hour = self._get_default_push_hour(skill_id)
   336→            if user_local_hour is not None and user_local_hour != skill_push_hour:
   337→                continue
   338→
   339→            # 先检查订阅状态（避免无谓的触发检测）
   340→            if not await self._should_send_to_user(user_id, skill_id):
   341→                continue
   342→
   343→            # 支持新旧配置格式: reminders (新) / reminder_types (旧)
   344→            reminders = config.get("reminders") or config.get("reminder_types", [])
   345→
   346→            # 获取 Skill 级别的 cooldown 配置
   347→            global_config = config.get("global_config", {})
   348→            default_cooldown = global_config.get("cooldown_hours", 24)
   349→
   350→            for reminder in reminders:
   351→                trigger_config = reminder.get("trigger", {})
   352→                reminder_id = reminder.get("id", "unknown")
   353→                conditions = reminder.get("conditions", [])  # 获取额外条件
   354→
   355→                try:
   356→                    # 检测触发条件 (包括 conditions)
   357→                    should_trigger, event_info = await self.trigger_detector.should_trigger(
   358→                        trigger_config=trigger_config,
   359→                        profile=profile,
   360→                        skill_id=skill_id,
   361→                        conditions=conditions,  # 传递条件
   362→                    )
   363→
   364→                    if should_trigger:
   365→                        # 检查 cooldown（支持 trigger 级别和 skill 级别配置）
   366→                        cooldown_hours = trigger_config.get("cooldown_hours", default_cooldown)
   367→                        notification_type = f"{skill_id}_{reminder_id}"
   368→
   369→                        if not await self._notification_service.check_cooldown(
   370→                            user_id=user_id,
   371→                            notification_type=notification_type,
   372→                            cooldown_hours=cooldown_hours,
   373→                        ):
   374→                            logger.debug(f"Cooldown active for {notification_type}, skipping")
   375→                            continue
   376→
   377→                        tasks.append(ReminderTask(
   378→                            user_id=user_id,
   379→                            skill_id=skill_id,
   380→                            reminder_type=reminder_id,
   381→                            priority=ReminderPriority(reminder.get("priority", "medium")),
   382→                            trigger_event=event_info.get("event_name") if event_info else None,
   383→                            trigger_date=event_info.get("event_date") if event_info else date.today(),
   384→                            metadata={"config": reminder, "event_info": event_info},
   385→                        ))
   386→                except Exception as e:
   387→                    logger.error(f"Failed to check trigger {reminder_id} for user {user_id}: {e}")
   388→
   389→        return tasks
   390→
   391→    def _get_reminder_config(self, skill_config: Dict, reminder_type: str) -> Dict:
   392→        """获取特定提醒类型的配置"""
   393→        # 支持新旧配置格式
   394→        reminders = skill_config.get("reminders") or skill_config.get("reminder_types", [])
   395→        for reminder in reminders:
   396→            if reminder["id"] == reminder_type:
   397→                return reminder
   398→        return {}
   399→
   400→    def get_skill_configs(self) -> Dict[str, Dict]:
   401→        """获取所有 Skill 配置 (用于调试)"""
   402→        return self._skill_configs
   403→
   404→
   405→# ═══════════════════════════════════════════════════════════════════════════
   406→# Singleton
   407→# ═══════════════════════════════════════════════════════════════════════════
   408→
   409→_engine: Optional[ProactiveEngine] = None
   410→
   411→
   412→def get_proactive_engine() -> ProactiveEngine:
   413→    """获取单例 ProactiveEngine"""
   414→    global _engine
   415→    if _engine is None:
   416→        _engine = ProactiveEngine()
   417→    return _engine
   418→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
