     1→# Proactive 模块 LLM-First 重构设计 v3.0
     2→
     3→> Version: 3.0 | Date: 2026-01-25
     4→> 目标：将 Proactive 系统升级为 LLM-First + Agent 驱动架构
     5→
     6→---
     7→
     8→## 概述
     9→
    10→本文档定义 Proactive 模块从 v2.0（硬编码架构）到 v3.0（LLM-First + Agent 驱动）的升级方案。核心变化是消除 TriggerDetector 和 ContentGenerator 中的硬编码逻辑，统一复用 CoreAgent 能力。
    11→
    12→### 设计原则
    13→
    14→| 原则 | v2.0 | v3.0 |
    15→|-----|------|------|
    16→| 触发检测 | 10+ 硬编码 `_detect_*` 方法 | 声明式 conditions + 静态求值优先 |
    17→| 内容生成 | 10+ 硬编码 `_generate_*` 方法 | 调用 CoreAgent Phase 2 |
    18→| 新增功能 | 需要修改 Python 代码 | 只需修改 YAML + rules/*.md |
    19→| 与 Agent 关系 | 独立系统 | 统一架构，复用 Agent |
    20→
    21→### LLM-First ≠ 什么都让 LLM 做
    22→
    23→**核心理解**：LLM-First 是指**业务逻辑配置化**，由 LLM 解读执行，而非把所有计算都交给 LLM。
    24→
    25→```python
    26→# ❌ 错误理解：所有判断都让 LLM 做
    27→conditions_result = await llm.evaluate("检查 birth_info 是否存在")
    28→
    29→# ✅ 正确理解：确定性计算由平台做，复杂语义由 LLM 做
    30→if condition.operator in STATIC_OPERATORS:
    31→    result = static_eval(condition, profile)  # 平台计算
    32→else:
    33→    result = await llm.evaluate(condition)    # LLM 推理
    34→```
    35→
    36→**分层原则**：
    37→| 层级 | 职责 | 示例 |
    38→|-----|------|------|
    39→| 平台层 | 确定性计算 | cron 匹配、exists 检查、数值比较、时区转换 |
    40→| 配置层 | 声明式规则 | conditions、rules/*.md |
    41→| LLM 层 | 语义推理 | 复杂条件组合、自然语言理解、内容生成 |
    42→
    43→---
    44→
    45→## 架构对比
    46→
    47→### v2.0 架构（当前）
    48→
    49→```
    50→┌─────────────────┐    ┌──────────────────┐    ┌────────────────────┐
    51→│ ProactiveWorker │───▶│ ProactiveEngine  │───▶│ TriggerDetector    │
    52→└─────────────────┘    │                  │    │ (643 行硬编码)     │
    53→                       │                  │    │ _detect_birthday() │
    54→                       │                  │    │ _detect_dayun()    │
    55→                       │                  │    │ _check_has_data()  │
    56→                       │                  │    │ ...10+ 方法        │
    57→                       │                  │    └────────────────────┘
    58→                       │                  │    ┌────────────────────┐
    59→                       │                  │───▶│ ContentGenerator   │
    60→                       └──────────────────┘    │ (1037 行硬编码)    │
    61→                                               │ _generate_fortune()│
    62→                                               │ _generate_dayun()  │
    63→                                               │ ...10+ 方法        │
    64→                                               └────────────────────┘
    65→```
    66→
    67→### v3.0 架构（目标）
    68→
    69→```
    70→┌─────────────────┐    ┌──────────────────────┐    ┌──────────────────┐
    71→│ ProactiveWorker │───▶│ ProactiveOrchestrator│───▶│ TriggerEvaluator │
    72→└─────────────────┘    │ (纯配置加载+分发)    │    │ (LLM 评估触发)   │
    73→                       │                      │    │ - cron 匹配      │
    74→                       │                      │    │ - LLM conditions │
    75→                       │                      │    └──────────────────┘
    76→                       │                      │    ┌──────────────────┐
    77→                       │                      │───▶│ CoreAgent.run()  │
    78→                       └──────────────────────┘    │ (复用 Phase 2)   │
    79→                                                   │ - Skill 工具     │
    80→                                                   │ - Rules 规则     │
    81→                                                   │ - 知识检索       │
    82→                                                   └──────────────────┘
    83→```
    84→
    85→---
    86→
    87→## 需要删除的硬编码
    88→
    89→### TriggerDetector（trigger_detector.py，643 行）
    90→
    91→| 方法 | 替代方案 |
    92→|------|---------|
    93→| `_detect_birthday()` | `conditions: [{event: birthday}]` + LLM 评估 |
    94→| `_detect_dayun_change()` | `conditions: [{event: dayun_change}]` + LLM 评估 |
    95→| `_detect_new_year()` | `conditions: [{event: new_year}]` + LLM 评估 |
    96→| `_detect_solar_term()` | `conditions: [{event: solar_term}]` + LLM 评估 |
    97→| `_detect_lunar_phase()` | `conditions: [{event: lunar_phase}]` + LLM 评估 |
    98→| `_detect_mercury_retrograde()` | `conditions: [{event: mercury_retrograde}]` + LLM 评估 |
    99→| `_detect_significant_transit()` | `conditions: [{event: significant_transit}]` + LLM 评估 |
   100→| `_detect_streak_broken()` | `conditions: [{event: streak_broken}]` + LLM 评估 |
   101→| `_check_has_data()` | `conditions: [{data_path: "...", operator: exists}]` |
   102→| `_check_not_checked_in_today()` | `conditions: [{data_path: "...", operator: "!=", value: "{today}"}]` |
   103→| `_check_has_pending_levers()` | `conditions: [{description: "有未完成杠杆"}]` + LLM 评估 |
   104→
   105→### ContentGenerator（content_generator.py，1037 行）
   106→
   107→| 方法 | 替代方案 |
   108→|------|---------|
   109→| `_generate_daily_fortune()` | `content.rule: rules/proactive/daily-fortune-push.md` + Agent |
   110→| `_generate_dayun_transition()` | `content.rule: rules/proactive/dayun-push.md` + Agent |
   111→| `_generate_fortune_alert()` | `content.rule: rules/proactive/fortune-alert-push.md` + Agent |
   112→| `_generate_daily_horoscope()` | `content.rule: rules/proactive/daily-horoscope-push.md` + Agent |
   113→| `_generate_transit_alert()` | `content.rule: rules/proactive/transit-alert-push.md` + Agent |
   114→| `_generate_lunar_phase()` | `content.rule: rules/proactive/lunar-phase-push.md` + Agent |
   115→| `_generate_solar_term()` | `content.rule: rules/proactive/solar-term-push.md` + Agent |
   116→| `_generate_weekly_summary()` | `content.rule: rules/proactive/weekly-summary-push.md` + Agent |
   117→| `_generate_birthday()` | `content.rule: rules/proactive/birthday-push.md` + Agent |
   118→| `_generate_daily_checkin()` | `content.rule: rules/proactive/daily-checkin-push.md` + Agent |
   119→
   120→---
   121→
   122→## 配置规范 v3.0
   123→
   124→### reminders.yaml 升级格式
   125→
   126→```yaml
   127→version: "3.0"  # 标识使用新架构
   128→skill_id: bazi
   129→enabled: true
   130→
   131→reminders:
   132→  - id: daily_fortune
   133→    name: 每日运势
   134→
   135→    # 触发配置
   136→    trigger:
   137→      type: time_based          # 时间触发保留 cron 匹配
   138→      schedule: "0 8 * * *"
   139→      cooldown_hours: 24
   140→
   141→    # 条件配置（声明式，LLM 评估）
   142→    conditions:
   143→      - description: "用户已设定八字信息"
   144→        data_path: "identity.birth_info"
   145→        operator: "exists"
   146→      - description: "今天还未收到运势推送"
   147→        data_path: "notifications.bazi.daily_fortune.last_sent"
   148→        operator: "!="
   149→        value: "{today}"
   150→
   151→    # 内容配置（Agent 驱动）
   152→    content:
   153→      rule: rules/proactive/daily-fortune-push.md  # Agent 使用此 Rule
   154→      card_type: DailyFortuneCard
   155→      suggested_prompt: "想了解今天的运势详情？"
   156→      quick_actions:
   157→        - label: "今日宜忌"
   158→          prompt: "今天适合做什么？有什么需要注意的？"
   159→        - label: "开运建议"
   160→          prompt: "今天如何提升运势？"
   161→
   162→    priority: medium
   163→
   164→# 事件触发示例
   165→  - id: birthday_reminder
   166→    name: 生日提醒
   167→
   168→    trigger:
   169→      type: event_based
   170→      event: birthday
   171→      advance_days: [7, 0]      # 提前 7 天和当天
   172→
   173→    conditions:
   174→      - description: "用户生日信息存在"
   175→        data_path: "identity.birth_info.date"
   176→        operator: "exists"
   177→
   178→    content:
   179→      rule: rules/proactive/birthday-push.md
   180→      card_type: BirthdayCard
   181→
   182→# 数据条件触发示例
   183→  - id: daily_checkin
   184→    name: 每日签到提醒
   185→
   186→    trigger:
   187→      type: data_condition
   188→      # 不再使用 type: has_data，改为声明式 conditions
   189→
   190→    conditions:
   191→      - description: "用户已设定愿景"
   192→        data_path: "lifecoach.north_star.vision"
   193→        operator: "exists"
   194→      - description: "今天还未签到"
   195→        data_path: "lifecoach.progress.last_checkin_date"
   196→        operator: "!="
   197→        value: "{today}"
   198→
   199→    content:
   200→      rule: rules/proactive/daily-checkin-push.md
   201→
   202→global_config:
   203→  default_push_hour: 8
   204→  cooldown_hours: 24
   205→  max_daily_pushes: 5
   206→  quiet_hours:
   207→    start: 22
   208→    end: 7
   209→```
   210→
   211→### conditions 声明式语法
   212→
   213→| 字段 | 类型 | 说明 |
   214→|-----|------|------|
   215→| `description` | string | 条件的自然语言描述（LLM 理解用） |
   216→| `data_path` | string | Profile 数据路径（可选） |
   217→| `operator` | string | 操作符：`exists`, `!exists`, `==`, `!=`, `>`, `<`, `>=`, `<=`, `contains` |
   218→| `value` | string/number | 比较值，支持 `{today}`, `{now}`, `{user_timezone}` 等变量 |
   219→
   220→**复杂条件示例**：
   221→
   222→```yaml
   223→conditions:
   224→  # 数据存在检查
   225→  - description: "用户已设定八字信息"
   226→    data_path: "identity.birth_info"
   227→    operator: "exists"
   228→
   229→  # 日期比较
   230→  - description: "今天还未签到"
   231→    data_path: "lifecoach.progress.last_checkin_date"
   232→    operator: "!="
   233→    value: "{today}"
   234→
   235→  # 数值阈值
   236→  - description: "运势分数低于 40"
   237→    data_path: "skills.bazi.daily_fortune.score"
   238→    operator: "<"
   239→    value: 40
   240→
   241→  # 复杂条件（纯 LLM 评估）
   242→  - description: "用户连续 3 天情绪低落且未进行冥想"
   243→    # 无 data_path，完全由 LLM 评估
   244→```
   245→
   246→---
   247→
   248→## 核心组件设计
   249→
   250→### 1. TriggerEvaluator（静态优先 + LLM 回退）
   251→
   252→**文件**: `apps/api/services/proactive/trigger_evaluator.py`
   253→
   254→**核心原则**：确定性条件由平台计算，复杂语义才回退 LLM。
   255→
   256→```python
   257→"""
   258→TriggerEvaluator - 静态求值优先 + LLM 回退
   259→
   260→设计原则:
   261→1. 静态条件（exists/==/!=/>/< 等）由平台直接求值
   262→2. 复杂条件（无 data_path、自然语言描述）才回退 LLM
   263→3. cron 匹配 + 时区处理 + 幂等键
   264→
   265→优势:
   266→- 降低延迟与成本
   267→- 降低 LLM 误判风险
   268→- 保持配置驱动的灵活性
   269→"""
   270→
   271→from typing import Dict, Any, Tuple, Optional, List
   272→from datetime import datetime, timezone
   273→import croniter
   274→import pytz
   275→
   276→
   277→# 可静态求值的操作符
   278→STATIC_OPERATORS = {"exists", "!exists", "==", "!=", ">", "<", ">=", "<=", "contains"}
   279→
   280→
   281→class TriggerEvaluator:
   282→    """静态优先 + LLM 回退的触发评估器"""
   283→
   284→    def __init__(self, llm_service=None):
   285→        self.llm_service = llm_service
   286→
   287→    async def evaluate(
   288→        self,
   289→        trigger_config: Dict[str, Any],
   290→        profile: Dict[str, Any],
   291→        conditions: Optional[List[Dict]] = None,
   292→        user_timezone: str = "Asia/Shanghai",
   293→    ) -> Tuple[bool, Optional[Dict[str, Any]], Optional[str]]:
   294→        """
   295→        评估触发条件
   296→
   297→        Returns:
   298→            (triggered: bool, event_info: Optional[Dict], idempotent_key: Optional[str])
   299→        """
   300→        trigger_type = trigger_config.get("type")
   301→
   302→        # 1. 时间触发：确定性 cron 匹配
   303→        if trigger_type == "time_based":
   304→            matched, bucket_key = self._evaluate_cron(
   305→                trigger_config.get("schedule"),
   306→                user_timezone
   307→            )
   308→            if not matched:
   309→                return False, None, None
   310→            # 继续评估 conditions
   311→            if conditions:
   312→                cond_result = await self._evaluate_conditions(conditions, profile)
   313→                return cond_result, None, bucket_key
   314→            return True, None, bucket_key
   315→
   316→        # 2. 事件触发：确定性事件检测
   317→        if trigger_type == "event_based":
   318→            return await self._evaluate_event(trigger_config, profile, conditions)
   319→
   320→        # 3. 数据条件触发
   321→        if trigger_type == "data_condition":
   322→            result = await self._evaluate_conditions(conditions, profile)
   323→            return result, None, None
   324→
   325→        return False, None, None
   326→
   327→    def _evaluate_cron(
   328→        self,
   329→        schedule: str,
   330→        user_timezone: str,
   331→    ) -> Tuple[bool, Optional[str]]:
   332→        """
   333→        确定性 cron 匹配（带时区）
   334→
   335→        Returns:
   336→            (matched: bool, bucket_key: str) - bucket_key 用于幂等去重
   337→        """
   338→        if not schedule:
   339→            return False, None
   340→
   341→        try:
   342→            tz = pytz.timezone(user_timezone)
   343→            now = datetime.now(tz)
   344→
   345→            cron = croniter.croniter(schedule, now)
   346→            prev_time = cron.get_prev(datetime)
   347→
   348→            # 计算时间桶（分钟级精度）
   349→            bucket_key = prev_time.strftime("%Y-%m-%dT%H:%M")
   350→
   351→            # 误差窗口与扫描频率对齐（假设每分钟扫描，误差 ≤60s）
   352→            matched = (now - prev_time).total_seconds() < 60
   353→
   354→            return matched, bucket_key
   355→        except Exception:
   356→            return False, None
   357→
   358→    async def _evaluate_conditions(
   359→        self,
   360→        conditions: List[Dict],
   361→        profile: Dict[str, Any],
   362→    ) -> bool:
   363→        """
   364→        条件评估：静态优先，LLM 回退
   365→
   366→        流程:
   367→        1. 预处理占位符（{today}, {now}）
   368→        2. 静态条件直接求值
   369→        3. 复杂条件回退 LLM
   370→        4. 所有条件 AND 逻辑
   371→        """
   372→        if not conditions:
   373→            return True
   374→
   375→        static_conditions = []
   376→        complex_conditions = []
   377→
   378→        # 分类条件
   379→        for cond in conditions:
   380→            cond = self._preprocess_condition(cond)  # 替换占位符
   381→            if self._is_static_condition(cond):
   382→                static_conditions.append(cond)
   383→            else:
   384→                complex_conditions.append(cond)
   385→
   386→        # 1. 先求值静态条件（短路优化）
   387→        for cond in static_conditions:
   388→            if not self._static_eval(cond, profile):
   389→                return False  # 短路：静态条件不满足，直接返回
   390→
   391→        # 2. 静态条件全部通过，再求值复杂条件
   392→        if complex_conditions and self.llm_service:
   393→            return await self._llm_eval_conditions(complex_conditions, profile)
   394→
   395→        return True
   396→
   397→    def _is_static_condition(self, cond: Dict) -> bool:
   398→        """判断是否为可静态求值的条件"""
   399→        return (
   400→            "data_path" in cond and
   401→            cond.get("operator", "exists") in STATIC_OPERATORS
   402→        )
   403→
   404→    def _preprocess_condition(self, cond: Dict) -> Dict:
   405→        """预处理占位符"""
   406→        cond = cond.copy()
   407→        if "value" in cond:
   408→            value = str(cond["value"])
   409→            if "{today}" in value:
   410→                cond["value"] = value.replace("{today}", datetime.now().strftime("%Y-%m-%d"))
   411→            if "{now}" in value:
   412→                cond["value"] = value.replace("{now}", datetime.now().isoformat())
   413→        return cond
   414→
   415→    def _static_eval(self, cond: Dict, profile: Dict) -> bool:
   416→        """静态条件求值"""
   417→        data_path = cond.get("data_path", "")
   418→        operator = cond.get("operator", "exists")
   419→        expected = cond.get("value")
   420→
   421→        # 获取数据
   422→        actual = self._get_nested_value(profile, data_path)
   423→
   424→        # 求值
   425→        if operator == "exists":
   426→            return actual is not None
   427→        if operator == "!exists":
   428→            return actual is None
   429→        if operator == "==":
   430→            return str(actual) == str(expected)
   431→        if operator == "!=":
   432→            return str(actual) != str(expected)
   433→        if operator == ">":
   434→            return float(actual or 0) > float(expected)
   435→        if operator == "<":
   436→            return float(actual or 0) < float(expected)
   437→        if operator == ">=":
   438→            return float(actual or 0) >= float(expected)
   439→        if operator == "<=":
   440→            return float(actual or 0) <= float(expected)
   441→        if operator == "contains":
   442→            return expected in str(actual or "")
   443→
   444→        return False
   445→
   446→    def _get_nested_value(self, data: Dict, path: str) -> Any:
   447→        """获取嵌套路径的值"""
   448→        keys = path.split(".")
   449→        for key in keys:
   450→            if isinstance(data, dict):
   451→                data = data.get(key)
   452→            else:
   453→                return None
   454→        return data
   455→
   456→    async def _llm_eval_conditions(
   457→        self,
   458→        conditions: List[Dict],
   459→        profile: Dict,
   460→    ) -> bool:
   461→        """LLM 评估复杂条件（仅用于无法静态求值的情况）"""
   462→        # 简化 prompt，只发送相关数据
   463→        prompt = f"""判断用户是否满足以下条件（全部满足返回 true）：
   464→
   465→条件：
   466→{chr(10).join(f"- {c.get('description', c)}" for c in conditions)}
   467→
   468→用户相关数据：
   469→{self._extract_relevant_data(profile, conditions)}
   470→
   471→返回 JSON：{{"triggered": true/false, "reason": "..."}}"""
   472→
   473→        result = await self.llm_service.evaluate(prompt=prompt)
   474→        return result.get("triggered", False)
   475→
   476→    async def _evaluate_event(
   477→        self,
   478→        trigger_config: Dict,
   479→        profile: Dict,
   480→        conditions: Optional[List[Dict]],
   481→    ) -> Tuple[bool, Optional[Dict], Optional[str]]:
   482→        """
   483→        事件触发评估
   484→
   485→        优先使用确定性计算（生日、节气等），
   486→        仅对模糊场景回退 LLM。
   487→        """
   488→        event_type = trigger_config.get("event")
   489→        advance_days = trigger_config.get("advance_days", [0])
   490→
   491→        # 确定性事件检测
   492→        if event_type == "birthday":
   493→            return self._detect_birthday(profile, advance_days)
   494→        if event_type == "solar_term":
   495→            return self._detect_solar_term(advance_days)
   496→
   497→        # 复杂事件回退 LLM
   498→        if self.llm_service:
   499→            return await self._llm_detect_event(event_type, profile, conditions)
   500→
   501→        return False, None, None
   502→
   503→    def _detect_birthday(
   504→        self,
   505→        profile: Dict,
   506→        advance_days: List[int],
   507→    ) -> Tuple[bool, Optional[Dict], Optional[str]]:
   508→        """确定性生日检测"""
   509→        birth_date_str = self._get_nested_value(profile, "vibe.profile.birth_info.date")
   510→        if not birth_date_str:
   511→            return False, None, None
   512→
   513→        try:
   514→            birth = datetime.strptime(birth_date_str, "%Y-%m-%d")
   515→            today = datetime.now()
   516→            this_year_birthday = birth.replace(year=today.year)
   517→
   518→            days_until = (this_year_birthday - today).days
   519→
   520→            if days_until in advance_days:
   521→                return True, {
   522→                    "event_type": "birthday",
   523→                    "event_date": this_year_birthday.strftime("%Y-%m-%d"),
   524→                    "days_until": days_until,
   525→                }, f"birthday-{this_year_birthday.strftime('%Y-%m-%d')}"
   526→
   527→        except Exception:
   528→            pass
   529→
   530→        return False, None, None
   531→```
   532→
   533→### 2. ProactiveOrchestrator
   534→
   535→**文件**: `apps/api/services/proactive/orchestrator.py`
   536→
   537→```python
   538→"""
   539→ProactiveOrchestrator - 主动推送编排器
   540→
   541→职责:
   542→1. 加载 Skill 级 reminders.yaml 配置
   543→2. 调度触发评估（静态优先 + LLM 回退）
   544→3. 调用 CoreAgent 生成内容
   545→4. 投递通知
   546→
   547→平台层硬约束:
   548→- 静默时段检查
   549→- 每日推送上限
   550→- 幂等去重（基于 bucket_key）
   551→- 冷却时间检查
   552→"""
   553→
   554→from typing import Dict, List, Optional, Any
   555→from uuid import UUID
   556→from datetime import datetime
   557→import logging
   558→
   559→from .trigger_evaluator import TriggerEvaluator
   560→from .agent_adapter import ProactiveAgentAdapter
   561→from .models import ReminderTask, ReminderContent
   562→from services.notification import NotificationService
   563→
   564→
   565→class ProactiveOrchestrator:
   566→    """主动推送编排器"""
   567→
   568→    def __init__(
   569→        self,
   570→        trigger_evaluator: TriggerEvaluator,
   571→        agent_adapter: ProactiveAgentAdapter,
   572→        notification_service: NotificationService,
   573→    ):
   574→        self.trigger_evaluator = trigger_evaluator
   575→        self.agent_adapter = agent_adapter
   576→        self.notification_service = notification_service
   577→        self._skill_configs: Dict[str, Dict] = {}
   578→        self._load_skill_configs()
   579→        self._idempotent_cache: Dict[str, datetime] = {}  # 幂等缓存
   580→
   581→    async def run_scheduled_scan(self, dry_run: bool = False) -> List[Dict]:
   582→        """定时扫描入口"""
   583→        results = []
   584→        users = await self._get_users_for_current_hour()
   585→
   586→        for user_id, profile in users:
   587→            user_notifications = await self._process_user(user_id, profile, dry_run)
   588→            results.extend(user_notifications)
   589→
   590→        return results
   591→
   592→    async def _process_user(
   593→        self,
   594→        user_id: UUID,
   595→        profile: Dict,
   596→        dry_run: bool = False,
   597→    ) -> List[Dict]:
   598→        """处理单个用户的所有推送"""
   599→        notifications = []
   600→        user_timezone = profile.get("vibe", {}).get("preferences", {}).get("timezone", "Asia/Shanghai")
   601→
   602→        # 0. 静默时段检查（平台硬约束）
   603→        if self._is_quiet_hours(user_timezone):
   604→            logging.debug(f"User {user_id} in quiet hours, skipping")
   605→            return []
   606→
   607→        # 0.1 每日推送上限检查
   608→        daily_count = await self._get_daily_push_count(user_id)
   609→        max_daily = self._get_global_config().get("max_daily_pushes", 5)
   610→        if daily_count >= max_daily:
   611→            logging.debug(f"User {user_id} reached daily limit ({max_daily})")
   612→            return []
   613→
   614→        for skill_id, config in self._skill_configs.items():
   615→            # 1. 订阅状态检查
   616→            if not await self._should_send_to_user(user_id, skill_id):
   617→                continue
   618→
   619→            for reminder in config.get("reminders", []):
   620→                # 2. 触发评估（静态优先 + LLM 回退）
   621→                triggered, event_info, bucket_key = await self.trigger_evaluator.evaluate(
   622→                    trigger_config=reminder.get("trigger", {}),
   623→                    profile=profile,
   624→                    conditions=reminder.get("conditions"),
   625→                    user_timezone=user_timezone,
   626→                )
   627→
   628→                if not triggered:
   629→                    continue
   630→
   631→                # 3. 幂等检查（基于 bucket_key）
   632→                idempotent_key = f"{user_id}-{skill_id}-{reminder['id']}-{bucket_key}"
   633→                if self._is_duplicate(idempotent_key):
   634→                    logging.debug(f"Duplicate: {idempotent_key}")
   635→                    continue
   636→
   637→                # 4. 冷却检查
   638→                if not await self._check_cooldown(user_id, skill_id, reminder["id"]):
   639→                    continue
   640→
   641→                # 5. 生成内容（调用 Agent）
   642→                content = await self.agent_adapter.generate_content(
   643→                    user_id=str(user_id),
   644→                    profile=profile,
   645→                    skill_id=skill_id,
   646→                    reminder=reminder,
   647→                    event_info=event_info,
   648→                )
   649→
   650→                # 6. 保存通知
   651→                if not dry_run:
   652→                    await self.notification_service.save(
   653→                        user_id=user_id,
   654→                        notification_type=f"{skill_id}_{reminder['id']}",
   655→                        title=content.title,
   656→                        content=content.to_dict(),
   657→                    )
   658→                    self._mark_sent(idempotent_key)
   659→
   660→                notifications.append({
   661→                    "user_id": str(user_id),
   662→                    "skill_id": skill_id,
   663→                    "reminder_id": reminder["id"],
   664→                    "title": content.title,
   665→                    "triggered_reason": event_info,  # 记录触发原因
   666→                })
   667→
   668→        return notifications
   669→
   670→    def _is_quiet_hours(self, user_timezone: str) -> bool:
   671→        """静默时段检查"""
   672→        import pytz
   673→        tz = pytz.timezone(user_timezone)
   674→        now = datetime.now(tz)
   675→        hour = now.hour
   676→
   677→        global_config = self._get_global_config()
   678→        quiet_start = global_config.get("quiet_hours", {}).get("start", 22)
   679→        quiet_end = global_config.get("quiet_hours", {}).get("end", 7)
   680→
   681→        if quiet_start > quiet_end:  # 跨午夜
   682→            return hour >= quiet_start or hour < quiet_end
   683→        return quiet_start <= hour < quiet_end
   684→
   685→    def _is_duplicate(self, idempotent_key: str) -> bool:
   686→        """幂等检查"""
   687→        if idempotent_key in self._idempotent_cache:
   688→            return True
   689→        return False
   690→
   691→    def _mark_sent(self, idempotent_key: str):
   692→        """标记已发送"""
   693→        self._idempotent_cache[idempotent_key] = datetime.now()
   694→```
   695→
   696→### 3. ProactiveAgentAdapter
   697→
   698→**文件**: `apps/api/services/proactive/agent_adapter.py`
   699→
   700→```python
   701→"""
   702→ProactiveAgentAdapter - Agent 适配器
   703→
   704→职责:
   705→- 封装 Proactive 调用 CoreAgent 的逻辑
   706→- 构建 Proactive 专用 Prompt
   707→- 提取 Agent 输出的结构化内容
   708→"""
   709→
   710→from typing import Dict, Any, Optional
   711→from dataclasses import dataclass
   712→import json
   713→
   714→from services.agent import create_agent, AgentContext
   715→from .models import ReminderContent
   716→
   717→
   718→@dataclass
   719→class ProactivePromptConfig:
   720→    """Proactive Prompt 配置"""
   721→    skill_id: str
   722→    reminder_id: str
   723→    rule_path: str
   724→    event_info: Optional[Dict] = None
   725→    profile_summary: Optional[str] = None
   726→
   727→
   728→class ProactiveAgentAdapter:
   729→    """Agent 适配器"""
   730→
   731→    async def generate_content(
   732→        self,
   733→        user_id: str,
   734→        profile: Dict,
   735→        skill_id: str,
   736→        reminder: Dict,
   737→        event_info: Optional[Dict] = None,
   738→    ) -> ReminderContent:
   739→        """
   740→        调用 Agent 生成推送内容
   741→
   742→        流程:
   743→        1. 构建 Agent 上下文
   744→        2. 构建 Proactive Prompt
   745→        3. 运行 Agent（非流式）
   746→        4. 提取结构化内容
   747→        """
   748→        # 1. 构建上下文
   749→        context = AgentContext(
   750→            user_id=user_id,
   751→            profile=profile,
   752→            skill=skill_id,
   753→            scenario="proactive",
   754→        )
   755→
   756→        # 2. 构建 Prompt
   757→        proactive_prompt = self._build_proactive_prompt(
   758→            reminder=reminder,
   759→            event_info=event_info,
   760→            profile=profile,
   761→        )
   762→
   763→        # 3. 运行 Agent（非流式，直接获取结果）
   764→        agent = create_agent(max_iterations=3)
   765→        content_buffer = ""
   766→
   767→        async for event in agent.run(proactive_prompt, context):
   768→            if event.type == "content":
   769→                content_buffer += event.data.get("content", "")
   770→
   771→        # 4. 提取内容
   772→        return self._extract_content(content_buffer, reminder)
   773→
   774→    def _build_proactive_prompt(
   775→        self,
   776→        reminder: Dict,
   777→        event_info: Optional[Dict],
   778→        profile: Dict,
   779→    ) -> str:
   780→        """构建 Proactive Prompt"""
   781→        rule_path = reminder.get("content", {}).get("rule", "")
   782→
   783→        prompt_parts = [
   784→            f"# 推送内容生成任务",
   785→            f"",
   786→            f"## 场景",
   787→            f"- 推送类型: {reminder.get('name', reminder['id'])}",
   788→            f"- 规则文件: {rule_path}",
   789→        ]
   790→
   791→        if event_info:
   792→            prompt_parts.extend([
   793→                f"",
   794→                f"## 触发事件",
   795→                f"```json",
   796→                json.dumps(event_info, ensure_ascii=False, indent=2),
   797→                f"```",
   798→            ])
   799→
   800→        prompt_parts.extend([
   801→            f"",
   802→            f"## 用户画像摘要",
   803→            self._build_profile_summary(profile),
   804→            f"",
   805→            f"## 任务",
   806→            f"1. 读取规则文件 `{rule_path}` 中的生成要求",
   807→            f"2. 根据用户画像和触发事件生成个性化推送内容",
   808→            f"3. 输出 JSON 格式：",
   809→            f"```json",
   810→            f'{{',
   811→            f'  "title": "推送标题（≤20字）",',
   812→            f'  "body": "推送正文（≤100字）",',
   813→            f'  "fortune_hint": "可选，运势提示",',
   814→            f'  "action_tip": "可选，行动建议"',
   815→            f'}}',
   816→            f"```",
   817→        ])
   818→
   819→        return "\n".join(prompt_parts)
   820→
   821→    def _build_profile_summary(self, profile: Dict) -> str:
   822→        """
   823→        构建用户画像摘要
   824→
   825→        统一使用 vibe.* 路径（与 VibeProfile v2.0 一致）
   826→        """
   827→        lines = []
   828→        vibe = profile.get("vibe", {})
   829→
   830→        # 身份信息 - vibe.profile.birth_info
   831→        profile_data = vibe.get("profile", {})
   832→        if birth := profile_data.get("birth_info"):
   833→            lines.append(f"- 生日: {birth.get('date')}")
   834→
   835→        # 状态 - vibe.state
   836→        state = vibe.get("state", {})
   837→        if focus := state.get("focus"):
   838→            lines.append(f"- 关注领域: {', '.join(focus)}")
   839→        if emotion := state.get("emotion"):
   840→            lines.append(f"- 当前情绪: {emotion}")
   841→
   842→        # 目标 - vibe.goals（统一路径）
   843→        goals = vibe.get("goals", [])
   844→        if goals:
   845→            goal_names = [g.get("name", str(g)) for g in goals[:3]]
   846→            lines.append(f"- 目标: {', '.join(goal_names)}")
   847→
   848→        return "\n".join(lines) if lines else "（无画像信息）"
   849→
   850→    def _extract_content(
   851→        self,
   852→        content_buffer: str,
   853→        reminder: Dict,
   854→    ) -> ReminderContent:
   855→        """
   856→        提取结构化内容
   857→
   858→        使用严格校验 + 字段截断 + 兜底模板
   859→        """
   860→        from pydantic import BaseModel, Field, ValidationError
   861→
   862→        # Pydantic 模型定义
   863→        class ContentSchema(BaseModel):
   864→            title: str = Field(max_length=20)
   865→            body: str = Field(max_length=200)
   866→            fortune_hint: Optional[str] = Field(None, max_length=50)
   867→            action_tip: Optional[str] = Field(None, max_length=50)
   868→
   869→        # 1. 尝试提取 JSON
   870→        data = None
   871→        try:
   872→            import re
   873→            json_match = re.search(r'```json\s*(.*?)\s*```', content_buffer, re.DOTALL)
   874→            if json_match:
   875→                data = json.loads(json_match.group(1))
   876→            else:
   877→                data = json.loads(content_buffer)
   878→        except json.JSONDecodeError:
   879→            logging.warning(f"Failed to parse JSON from content: {content_buffer[:100]}")
   880→
   881→        # 2. Pydantic 校验 + 字段截断
   882→        if data:
   883→            try:
   884→                validated = ContentSchema(**data)
   885→                data = validated.model_dump()
   886→            except ValidationError as e:
   887→                logging.warning(f"Content validation failed: {e}")
   888→                # 尝试截断后重试
   889→                data = {
   890→                    "title": str(data.get("title", ""))[:20],
   891→                    "body": str(data.get("body", ""))[:200],
   892→                    "fortune_hint": str(data.get("fortune_hint", ""))[:50] if data.get("fortune_hint") else None,
   893→                    "action_tip": str(data.get("action_tip", ""))[:50] if data.get("action_tip") else None,
   894→                }
   895→
   896→        # 3. 兜底模板
   897→        if not data or not data.get("title"):
   898→            data = {
   899→                "title": reminder.get("name", "推送通知"),
   900→                "body": "点击查看详情",
   901→            }
   902→            logging.warning(f"Using fallback template for reminder: {reminder.get('id')}")
   903→
   904→        # 附加对话引导
   905→        content_config = reminder.get("content", {})
   906→
   907→        return ReminderContent(
   908→            title=data.get("title"),
   909→            body=data.get("body", ""),
   910→            fortune_hint=data.get("fortune_hint"),
   911→            action_tip=data.get("action_tip"),
   912→            card_type=content_config.get("card_type"),
   913→            suggested_prompt=content_config.get("suggested_prompt"),
   914→            quick_actions=content_config.get("quick_actions", []),
   915→        )
   916→```
   917→
   918→---
   919→
   920→## Proactive Rule 模板
   921→
   922→### 模板文件
   923→
   924→**文件**: `skills/core/rules/proactive/_template.md`
   925→
   926→```markdown
   927→---
   928→id: proactive-{reminder_id}
   929→name: {reminder_name} 推送内容生成
   930→type: proactive
   931→version: 1.0.0
   932→---
   933→
   934→# {reminder_name} 推送内容生成
   935→
   936→## 场景说明
   937→{场景描述}
   938→
   939→## 触发事件
   940→- 事件类型: {event_type}
   941→- 触发条件: {conditions_description}
   942→
   943→## 用户画像读取
   944→从 profile 中读取以下信息：
   945→- `identity.birth_info` - 出生信息
   946→- `state.focus` - 关注领域
   947→- `state.emotion` - 当前情绪
   948→- `skills.{skill_id}.*` - Skill 相关数据
   949→
   950→## 生成要求
   951→
   952→### 标题
   953→- 字数: ≤20 字
   954→- 风格: {风格描述}
   955→- 包含: {必须包含的元素}
   956→
   957→### 正文
   958→- 字数: ≤100 字
   959→- 风格: 温暖、个性化
   960→- 结构: {结构要求}
   961→
   962→### 可选字段
   963→- `fortune_hint`: 运势提示（如适用）
   964→- `action_tip`: 行动建议
   965→
   966→## 语气风格
   967→根据用户 `preferences.voice_mode` 调整：
   968→- `warm`: 温暖关怀型
   969→- `sarcastic`: 毒舌激励型
   970→- `wise`: 智慧洞察型
   971→
   972→## 输出格式
   973→```json
   974→{
   975→  "title": "推送标题",
   976→  "body": "推送正文，个性化内容...",
   977→  "fortune_hint": "可选，运势提示",
   978→  "action_tip": "可选，行动建议"
   979→}
   980→```
   981→
   982→## 示例
   983→
   984→### 示例 1: 标准场景
   985→输入:
   986→- 用户关注: 事业
   987→- 当前情绪: 平静
   988→- 触发事件: {example_event}
   989→
   990→输出:
   991→```json
   992→{
   993→  "title": "{example_title}",
   994→  "body": "{example_body}",
   995→  "action_tip": "{example_action_tip}"
   996→}
   997→```
   998→```
   999→
  1000→### Bazi 每日运势 Rule
  1001→
  1002→**文件**: `skills/bazi/rules/proactive/daily-fortune-push.md`
  1003→
  1004→```markdown
  1005→---
  1006→id: proactive-daily-fortune
  1007→name: 每日运势推送内容生成
  1008→type: proactive
  1009→skill_id: bazi
  1010→---
  1011→
  1012→# 每日运势推送内容生成
  1013→
  1014→## 场景说明
  1015→每日早晨为用户推送个性化运势提醒，帮助用户了解当日运势趋势并提供行动建议。
  1016→
  1017→## 数据读取
  1018→从 profile 中读取：
  1019→- `identity.birth_info` - 八字信息
  1020→- `skills.bazi.daily_fortune` - 今日运势数据（如已计算）
  1021→- `state.focus` - 关注领域
  1022→- `preferences.voice_mode` - 语气偏好
  1023→
  1024→## 生成要求
  1025→
  1026→### 标题
  1027→- 字数: ≤15 字
  1028→- 包含: 日期感、运势关键词
  1029→- 示例: "今日运势 · 事业有突破"
  1030→
  1031→### 正文
  1032→- 字数: 60-100 字
  1033→- 结构:
  1034→  1. 今日运势概述（1句）
  1035→  2. 重点关注事项（1句）
  1036→  3. 行动建议（1句）
  1037→- 风格: 根据 voice_mode 调整
  1038→
  1039→### fortune_hint
  1040→- 今日宜/忌（简短）
  1041→
  1042→### action_tip
  1043→- 具体可执行的建议
  1044→
  1045→## 语气风格示例
  1046→
  1047→### warm（温暖型）
  1048→"今天土气旺盛，适合稳扎稳打。事业上可能遇到贵人相助，记得保持谦逊哦～"
  1049→
  1050→### sarcastic（毒舌型）
  1051→"今天运势不错，别浪费了。有贵人送机会上门，这次可别又错过了。"
  1052→
  1053→### wise（智慧型）
  1054→"戊土当令，厚德载物。今日宜守不宜攻，静待时机方为上策。"
  1055→
  1056→## 输出格式
  1057→```json
  1058→{
  1059→  "title": "今日运势 · {关键词}",
  1060→  "body": "{个性化正文}",
  1061→  "fortune_hint": "宜: {宜事} | 忌: {忌事}",
  1062→  "action_tip": "{具体建议}"
  1063→}
  1064→```
  1065→```
  1066→
  1067→### Lifecoach 每日签到 Rule
  1068→
  1069→**文件**: `skills/lifecoach/rules/proactive/daily-checkin-push.md`
  1070→
  1071→```markdown
  1072→---
  1073→id: proactive-daily-checkin
  1074→name: 每日签到推送内容生成
  1075→type: proactive
  1076→skill_id: lifecoach
  1077→---
  1078→
  1079→# 每日签到推送内容生成
  1080→
  1081→## 场景说明
  1082→每日提醒用户进行签到，以 Future Self 人格进行温暖的问候。
  1083→
  1084→## 数据读取
  1085→从 profile 中读取：
  1086→- `lifecoach.north_star.vision` - 用户愿景
  1087→- `lifecoach.progress.streak_days` - 连续签到天数
  1088→- `lifecoach.progress.last_checkin_date` - 上次签到日期
  1089→- `state.emotion` - 当前情绪
  1090→
  1091→## 场景判断
  1092→
  1093→### 场景 1: 正常签到（昨天有签到）
  1094→- 风格: 日常问候
  1095→- 提及: 连续签到天数
  1096→
  1097→### 场景 2: 久别重逢（3-7 天未签到）
  1098→- 风格: 温暖欢迎
  1099→- 提及: 没关系，重新开始
  1100→
  1101→### 场景 3: 长时间未互动（>7 天）
  1102→- 风格: 关心询问
  1103→- 不提及: 断签
  1104→
  1105→### 场景 4: 连续签到里程碑（7天/30天/100天）
  1106→- 风格: 庆祝
  1107→- 提及: 具体成就
  1108→
  1109→## 生成要求
  1110→
  1111→### 标题
  1112→- 字数: ≤12 字
  1113→- 示例: "早上好！"、"想你了～"、"恭喜连续 7 天！"
  1114→
  1115→### 正文
  1116→- 字数: 40-80 字
  1117→- 以 Future Self 口吻
  1118→- 引导用户签到
  1119→
  1120→## 输出格式
  1121→```json
  1122→{
  1123→  "title": "{场景化标题}",
  1124→  "body": "{Future Self 口吻的问候}",
  1125→  "action_tip": "点击开始今天的签到"
  1126→}
  1127→```
  1128→
  1129→## 示例
  1130→
  1131→### 正常签到
  1132→```json
  1133→{
  1134→  "title": "早上好！",
  1135→  "body": "连续签到第 15 天了，稳步前进中！今天想和我聊聊最近的进展吗？",
  1136→  "action_tip": "开始今日签到"
  1137→}
  1138→```
  1139→
  1140→### 久别重逢
  1141→```json
  1142→{
  1143→  "title": "好久不见～",
  1144→  "body": "几天没见你了，一切都好吗？没关系，每一天都是新的开始。准备好继续了吗？",
  1145→  "action_tip": "重新开始"
  1146→}
  1147→```
  1148→```
  1149→
  1150→---
  1151→
  1152→## 文件变更清单
  1153→
  1154→### 新增文件（11个）
  1155→
  1156→| 文件 | 描述 |
  1157→|------|------|
  1158→| `services/proactive/trigger_evaluator.py` | LLM 触发评估器 |
  1159→| `services/proactive/orchestrator.py` | 主动推送编排器 |
  1160→| `services/proactive/agent_adapter.py` | Agent 适配器 |
  1161→| `services/proactive/models.py` | 数据模型（提取自 engine.py） |
  1162→| `skills/core/rules/proactive/_template.md` | Proactive Rule 模板 |
  1163→| `skills/bazi/rules/proactive/daily-fortune-push.md` | Bazi 每日运势 Rule |
  1164→| `skills/bazi/rules/proactive/birthday-push.md` | Bazi 生日 Rule |
  1165→| `skills/lifecoach/rules/proactive/daily-checkin-push.md` | Lifecoach 签到 Rule |
  1166→| `skills/zodiac/rules/proactive/daily-horoscope-push.md` | Zodiac 每日星座 Rule |
  1167→| `tests/services/proactive/test_trigger_evaluator.py` | 评估器单元测试 |
  1168→| `tests/services/proactive/test_orchestrator.py` | 编排器集成测试 |
  1169→
  1170→### 修改文件（5个）
  1171→
  1172→| 文件 | 变更 |
  1173→|------|------|
  1174→| `workers/proactive_worker.py` | 使用 ProactiveOrchestrator |
  1175→| `skills/bazi/reminders.yaml` | 升级到 v3.0 格式 |
  1176→| `skills/lifecoach/reminders.yaml` | 升级到 v3.0 格式 |
  1177→| `skills/zodiac/reminders.yaml` | 升级到 v3.0 格式 |
  1178→| `services/proactive/__init__.py` | 更新导出 |
  1179→
  1180→### 删除文件（2个）
  1181→
  1182→| 文件 | 行数 | 原因 |
  1183→|------|------|------|
  1184→| `services/proactive/trigger_detector.py` | 643 | 所有检测逻辑 LLM 化 |
  1185→| `services/proactive/content_generator.py` | 1037 | 所有生成逻辑 Agent 化 |
  1186→
  1187→---
  1188→
  1189→## 迁移指南
  1190→
  1191→### 1. v2.0 → v3.0 配置迁移
  1192→
  1193→```yaml
  1194→# v2.0 (旧)
  1195→reminders:
  1196→  - id: daily_fortune
  1197→    trigger:
  1198→      type: time_based
  1199→      schedule: "0 8 * * *"
  1200→    conditions:
  1201→      - type: has_data
  1202→        path: "identity.birth_info"
  1203→    content:
  1204→      generator: rules/daily-fortune.md
  1205→
  1206→# v3.0 (新)
  1207→version: "3.0"
  1208→reminders:
  1209→  - id: daily_fortune
  1210→    trigger:
  1211→      type: time_based
  1212→      schedule: "0 8 * * *"
  1213→    conditions:
  1214→      - description: "用户已设定八字信息"
  1215→        data_path: "identity.birth_info"
  1216→        operator: "exists"
  1217→    content:
  1218→      rule: rules/proactive/daily-fortune-push.md  # 独立的 proactive rule
  1219→```
  1220→
  1221→### 2. conditions 迁移对照表
  1222→
  1223→| v2.0 type | v3.0 声明式 |
  1224→|-----------|------------|
  1225→| `has_data` | `{data_path: "...", operator: "exists"}` |
  1226→| `not_checked_in_today` | `{data_path: "...last_checkin_date", operator: "!=", value: "{today}"}` |
  1227→| `has_pending_levers` | `{description: "有未完成杠杆"}` |
  1228→| 自定义 type | `{description: "..."}` + LLM 评估 |
  1229→
  1230→### 3. generator → rule 迁移
  1231→
  1232→旧的 `content.generator` 指向的 Rule 文件需要重构为 Proactive 专用 Rule：
  1233→
  1234→```
  1235→rules/daily-fortune.md (通用 Skill Rule)
  1236→    ↓ 提取推送相关部分
  1237→rules/proactive/daily-fortune-push.md (Proactive 专用 Rule)
  1238→```
  1239→
  1240→---
  1241→
  1242→## 验证方案
  1243→
  1244→### 单元测试
  1245→
  1246→```bash
  1247→# 触发评估器测试
  1248→pytest tests/services/proactive/test_trigger_evaluator.py -v
  1249→
  1250→# 编排器测试
  1251→pytest tests/services/proactive/test_orchestrator.py -v
  1252→```
  1253→
  1254→### E2E 验证用例
  1255→
  1256→| 场景 | 预期结果 |
  1257→|------|---------|
  1258→| Bazi 每日运势 | cron 匹配 → conditions 通过 → Agent 生成 → 通知保存 |
  1259→| Lifecoach 签到 | data_condition → LLM 评估 conditions → Agent 生成 → 通知保存 |
  1260→| Bazi 生日提醒 | event_based → LLM 检测生日 → Agent 生成 → 通知保存 |
  1261→| 新增触发类型 | 只改 YAML + Rule 文件，零代码改动 ✅ |
  1262→
  1263→### 性能验收
  1264→
  1265→| 指标 | 目标 |
  1266→|------|------|
  1267→| 推送延迟增加 | ≤2 秒 |
  1268→| LLM 调用模型 | Haiku（成本优化） |
  1269→| 批量处理 | 支持 |
  1270→
  1271→---
  1272→
  1273→## 风险与缓解
  1274→
  1275→| 风险 | 描述 | 缓解措施 |
  1276→|------|------|---------|
  1277→| LLM 误判触发 | LLM 可能错误评估 conditions | 1. time_based 保留 cron 匹配<br>2. 关键条件添加 fallback |
  1278→| Agent 内容质量 | 生成内容不符合预期 | 1. Rule 文件提供详细示例<br>2. JSON Schema 校验 |
  1279→| 性能影响 | LLM 调用增加延迟 | 1. 批量处理<br>2. 使用 Haiku |
  1280→| 向后兼容 | v2.0 配置无法直接使用 | 1. 支持 version 自动检测<br>2. 渐进迁移 |
  1281→
  1282→---
  1283→
  1284→## 成功标准
  1285→
  1286→- [ ] 新增触发条件只需修改 YAML，零代码改动
  1287→- [ ] 新增推送内容只需添加 Rule 文件，零代码改动
  1288→- [ ] 删除 trigger_detector.py（643 行）
  1289→- [ ] 删除 content_generator.py（1037 行）
  1290→- [ ] 所有现有 reminders.yaml 迁移到 v3.0 格式
  1291→- [ ] 测试覆盖率 80%+
  1292→- [ ] 推送延迟增加 ≤2 秒
  1293→
  1294→---
  1295→
  1296→## 时间线
  1297→
  1298→| 周 | 阶段 | 任务 |
  1299→|----|------|------|
  1300→| 1 | 基础架构 | TriggerEvaluator + ProactiveOrchestrator + AgentAdapter |
  1301→| 2 | Rules 迁移 | Proactive Rule 文件 + reminders.yaml v3.0 |
  1302→| 3 | 清理测试 | 删除硬编码 + 单元测试 + E2E 测试 |
  1303→
  1304→---
  1305→
  1306→## 相关文档
  1307→
  1308→- [SPEC.md](./ref/SPEC.md) - v2.0 规范（当前）
  1309→- [LLM-FIRST-DESIGN.md](/docs/archive/v9/LLM-FIRST-DESIGN.md) - LLM-First 架构设计
  1310→- [ARCHITECTURE.md](/docs/archive/v8/ARCHITECTURE.md) - 系统架构
  1311→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
