     1→import { create } from "zustand"
     2→import type { Message, Artifact, Quest, DashboardTab, Relation, Block, ActionButton } from "@/types"
     3→import * as api from "@/lib/api"
     4→
     5→// Map API types to frontend types
     6→interface UserStatus {
     7→  energy: number
     8→  emotion: number
     9→  connection: number
    10→  growth: number
    11→  fortune: number
    12→}
    13→
    14→interface StateScore {
    15→  score: number
    16→  breakdown: {
    17→    emotion: number
    18→    action: number
    19→    streak: number
    20→  }
    21→  recoveryAction: string | null
    22→}
    23→
    24→interface PermaData {
    25→  positiveEmotion: { score: number; trend?: string }
    26→  engagement: { score: number; trend?: string }
    27→  relationships: { score: number; trend?: string }
    28→  meaning: { score: number; trend?: string }
    29→  accomplishment: { score: number; trend?: string }
    30→}
    31→
    32→interface L0Facts {
    33→  dayMaster: string
    34→  strength: string
    35→  translations: { concept: string; translation: string; action: string }[]
    36→}
    37→
    38→interface L1Schema {
    39→  permaSnapshot: PermaData
    40→  cognitivePatterns: { identifiedSchemas: string[]; reframeCount?: number }
    41→  strengthsInUse: string[]
    42→}
    43→
    44→interface RiskAlert {
    45→  type: string
    46→  message: string
    47→}
    48→
    49→interface TrendPoint {
    50→  date: string
    51→  score: number
    52→}
    53→
    54→interface TrendEvent {
    55→  date: string
    56→  type: string
    57→  title: string
    58→}
    59→
    60→interface AppState {
    61→  // UI State
    62→  isSidebarOpen: boolean
    63→  activeTab: DashboardTab
    64→  isMobile: boolean
    65→
    66→  // Preferences
    67→  chatBackend: api.ChatBackend
    68→
    69→  // Loading States
    70→  isLoading: boolean
    71→  loadingTab: DashboardTab | null
    72→
    73→  // Chat State
    74→  messages: Message[]
    75→  isStreaming: boolean
    76→  sessionId: string | null
    77→
    78→  // Artifacts
    79→  artifacts: Artifact[]
    80→  pinnedArtifacts: Artifact[]
    81→
    82→  // Overview Data
    83→  insight: string
    84→  stateScore: StateScore
    85→  perma: PermaData
    86→  todayTasks: api.TaskItem[]
    87→  riskAlerts: RiskAlert[]
    88→
    89→  // Status Data
    90→  l0Facts: L0Facts | null
    91→  l1Schema: L1Schema | null
    92→
    93→  // Trends Data
    94→  trendHistory: TrendPoint[]
    95→  trendEvents: TrendEvent[]
    96→
    97→  // Tasks Data
    98→  activeTasks: api.TaskItem[]
    99→  suggestedTasks: api.TaskItem[]
   100→  completedTasks: api.TaskItem[]
   101→
   102→  // Relations Data
   103→  relations: Relation[]
   104→
   105→  // Explore Data
   106→  mysticEntries: api.ExploreItem[]
   107→  courses: api.ExploreItem[]
   108→
   109→  // Legacy (for compatibility)
   110→  status: UserStatus
   111→  quests: Quest[]
   112→  todayQuests: Quest[]
   113→
   114→  // UI Actions
   115→  setSidebarOpen: (open: boolean) => void
   116→  setActiveTab: (tab: DashboardTab) => void
   117→  setIsMobile: (mobile: boolean) => void
   118→  setChatBackend: (backend: api.ChatBackend) => void
   119→
   120→  // Fetch Actions
   121→  fetchOverview: () => Promise<void>
   122→  fetchStatus: () => Promise<void>
   123→  fetchTrends: (days?: number) => Promise<void>
   124→  fetchTasks: () => Promise<void>
   125→  fetchRelations: () => Promise<void>
   126→  fetchExplore: () => Promise<void>
   127→  fetchPreferences: () => Promise<void>
   128→  updateChatBackend: (backend: api.ChatBackend) => Promise<void>
   129→
   130→  // Task Actions
   131→  acceptTask: (taskId: string, type?: 'start_task' | 'schedule_task') => Promise<void>
   132→  completeTask: (taskId: string, note?: string) => Promise<void>
   133→  skipTask: (taskId: string, reason?: string) => Promise<void>
   134→
   135→  // Checkin
   136→  submitCheckin: (mood: string, intensity: number, note?: string) => Promise<api.CheckinResponse>
   137→
   138→  // Chat Actions
   139→  sendMessage: (content: string) => Promise<void>
   140→  addMessage: (message: Message) => void
   141→  setStreaming: (streaming: boolean) => void
   142→  clearMessages: () => void
   143→
   144→  // Artifact Actions
   145→  addArtifact: (artifact: Artifact) => void
   146→  pinArtifact: (id: string) => void
   147→  unpinArtifact: (id: string) => void
   148→}
   149→
   150→// Helper to convert API perma to frontend format
   151→function convertPerma(perma: api.PermaData): PermaData {
   152→  return {
   153→    positiveEmotion: { score: perma.positive_emotion.score, trend: perma.positive_emotion.trend },
   154→    engagement: { score: perma.engagement.score, trend: perma.engagement.trend },
   155→    relationships: { score: perma.relationships.score, trend: perma.relationships.trend },
   156→    meaning: { score: perma.meaning.score, trend: perma.meaning.trend },
   157→    accomplishment: { score: perma.accomplishment.score, trend: perma.accomplishment.trend },
   158→  }
   159→}
   160→
   161→// Helper to convert PERMA to 5-dimension status
   162→function permaToStatus(perma: PermaData): UserStatus {
   163→  return {
   164→    energy: Math.round(perma.positiveEmotion.score * 10),
   165→    emotion: Math.round(perma.engagement.score * 10),
   166→    connection: Math.round(perma.relationships.score * 10),
   167→    growth: Math.round(perma.meaning.score * 10),
   168→    fortune: Math.round(perma.accomplishment.score * 10),
   169→  }
   170→}
   171→
   172→type A2UIComponent = {
   173→  type?: unknown
   174→  title?: unknown
   175→  data?: unknown
   176→}
   177→
   178→function a2uiToBlocks(uiComponents: unknown[] | undefined): Block[] | undefined {
   179→  if (!Array.isArray(uiComponents) || uiComponents.length === 0) return undefined
   180→
   181→  const now = Date.now()
   182→  const blocks: Block[] = []
   183→
   184→  uiComponents.forEach((raw, idx) => {
   185→    if (!raw || typeof raw !== 'object') return
   186→    const c = raw as A2UIComponent
   187→    const type = String(c.type || '')
   188→    const title = typeof c.title === 'string' ? c.title : undefined
   189→    const id = `${type || 'component'}-${now}-${idx}`
   190→
   191→    if (type === 'markdown_text') {
   192→      blocks.push({
   193→        id,
   194→        type: 'markdown_text',
   195→        content: typeof c.data === 'string' ? c.data : String(c.data ?? ''),
   196→        ...(title ? { title } : {}),
   197→      } as unknown as Block)
   198→      return
   199→    }
   200→
   201→    if (type === 'action_buttons') {
   202→      const data = Array.isArray(c.data) ? c.data : []
   203→      const buttons: ActionButton[] = data
   204→        .filter((b) => b && typeof b === 'object')
   205→        .map((b) => {
   206→          const btn = b as { label?: unknown; action?: unknown }
   207→          const label = typeof btn.label === 'string' ? btn.label : '下一步'
   208→          const action = (btn.action && typeof btn.action === 'object' ? btn.action : {}) as Record<string, unknown>
   209→          const actionType = typeof action.type === 'string' ? action.type : 'opt_out'
   210→          return {
   211→            label,
   212→            action: {
   213→              type: actionType as ActionButton['action']['type'],
   214→              task_id: typeof action.task_id === 'string' ? action.task_id : undefined,
   215→              panel: typeof action.panel === 'string' ? action.panel : undefined,
   216→            },
   217→          }
   218→        })
   219→
   220→      blocks.push({
   221→        id,
   222→        type: 'action_buttons',
   223→        content: '',
   224→        buttons,
   225→        ...(title ? { title } : {}),
   226→      } as unknown as Block)
   227→      return
   228→    }
   229→
   230→    // Fallback: show as a simple callout
   231→    blocks.push({
   232→      id,
   233→      type: 'callout',
   234→      content: typeof c.data === 'string' ? c.data : JSON.stringify(c.data ?? c),
   235→      ...(title ? { title } : {}),
   236→    } as unknown as Block)
   237→  })
   238→
   239→  return blocks.length > 0 ? blocks : undefined
   240→}
   241→
   242→export const useAppStore = create<AppState>((set, get) => ({
   243→  // Initial UI State
   244→  isSidebarOpen: true,
   245→  activeTab: "overview",
   246→  isMobile: false,
   247→
   248→  // Preferences
   249→  chatBackend: 'agent_service',
   250→
   251→  // Loading States
   252→  isLoading: false,
   253→  loadingTab: null,
   254→
   255→  // Initial Chat State
   256→  messages: [],
   257→  isStreaming: false,
   258→  sessionId: null,
   259→
   260→  // Initial Artifacts
   261→  artifacts: [],
   262→  pinnedArtifacts: [],
   263→
   264→  // Overview Data (defaults)
   265→  insight: "加载中...",
   266→  stateScore: { score: 0, breakdown: { emotion: 0, action: 0, streak: 0 }, recoveryAction: null },
   267→  perma: {
   268→    positiveEmotion: { score: 5 },
   269→    engagement: { score: 5 },
   270→    relationships: { score: 5 },
   271→    meaning: { score: 5 },
   272→    accomplishment: { score: 5 },
   273→  },
   274→  todayTasks: [],
   275→  riskAlerts: [],
   276→
   277→  // Status Data
   278→  l0Facts: null,
   279→  l1Schema: null,
   280→
   281→  // Trends Data
   282→  trendHistory: [],
   283→  trendEvents: [],
   284→
   285→  // Tasks Data
   286→  activeTasks: [],
   287→  suggestedTasks: [],
   288→  completedTasks: [],
   289→
   290→  // Relations Data
   291→  relations: [],
   292→
   293→  // Explore Data
   294→  mysticEntries: [],
   295→  courses: [],
   296→
   297→  // Legacy (for compatibility)
   298→  status: { energy: 50, emotion: 50, connection: 50, growth: 50, fortune: 50 },
   299→  quests: [],
   300→  todayQuests: [],
   301→
   302→  // UI Actions
   303→  setSidebarOpen: (open) => set({ isSidebarOpen: open }),
   304→  setActiveTab: (tab) => set({ activeTab: tab }),
   305→  setIsMobile: (mobile) => set({ isMobile: mobile }),
   306→  setChatBackend: (backend) => set({ chatBackend: backend }),
   307→
   308→  // Fetch Overview
   309→  fetchOverview: async () => {
   310→    set({ isLoading: true, loadingTab: 'overview' })
   311→    try {
   312→      const data = await api.fetchOverview()
   313→      const perma = convertPerma(data.perma)
   314→      set({
   315→        insight: data.insight,
   316→        stateScore: {
   317→          score: data.state_score.score,
   318→          breakdown: data.state_score.breakdown,
   319→          recoveryAction: data.state_score.recovery_action,
   320→        },
   321→        perma,
   322→        todayTasks: data.today_tasks,
   323→        riskAlerts: data.risk_alerts,
   324→        status: permaToStatus(perma),
   325→      })
   326→    } catch (err) {
   327→      console.error('Failed to fetch overview:', err)
   328→    } finally {
   329→      set({ isLoading: false, loadingTab: null })
   330→    }
   331→  },
   332→
   333→  // Fetch Status
   334→  fetchStatus: async () => {
   335→    set({ isLoading: true, loadingTab: 'status' })
   336→    try {
   337→      const data = await api.fetchStatus()
   338→      set({
   339→        l0Facts: {
   340→          dayMaster: data.l0_facts.day_master,
   341→          strength: data.l0_facts.strength,
   342→          translations: data.l0_facts.translations,
   343→        },
   344→        l1Schema: {
   345→          permaSnapshot: convertPerma(data.l1_schema.perma_snapshot),
   346→          cognitivePatterns: {
   347→            identifiedSchemas: data.l1_schema.cognitive_patterns.identified_schemas,
   348→            reframeCount: data.l1_schema.cognitive_patterns.reframe_count,
   349→          },
   350→          strengthsInUse: data.l1_schema.strengths_in_use,
   351→        },
   352→        stateScore: {
   353→          score: data.state_score.score,
   354→          breakdown: data.state_score.breakdown,
   355→          recoveryAction: data.state_score.recovery_action,
   356→        },
   357→      })
   358→    } catch (err) {
   359→      console.error('Failed to fetch status:', err)
   360→    } finally {
   361→      set({ isLoading: false, loadingTab: null })
   362→    }
   363→  },
   364→
   365→  // Fetch Trends
   366→  fetchTrends: async (days = 7) => {
   367→    set({ isLoading: true, loadingTab: 'trends' })
   368→    try {
   369→      const data = await api.fetchTrends(days)
   370→      set({
   371→        trendHistory: data.state_score_history,
   372→        trendEvents: data.events,
   373→      })
   374→    } catch (err) {
   375→      console.error('Failed to fetch trends:', err)
   376→    } finally {
   377→      set({ isLoading: false, loadingTab: null })
   378→    }
   379→  },
   380→
   381→  // Fetch Tasks
   382→  fetchTasks: async () => {
   383→    set({ isLoading: true, loadingTab: 'quests' })
   384→    try {
   385→      const data = await api.fetchTasks()
   386→      set({
   387→        activeTasks: data.active,
   388→        suggestedTasks: data.suggested,
   389→        completedTasks: data.completed_recent,
   390→      })
   391→    } catch (err) {
   392→      console.error('Failed to fetch tasks:', err)
   393→    } finally {
   394→      set({ isLoading: false, loadingTab: null })
   395→    }
   396→  },
   397→
   398→  // Fetch Relations
   399→  fetchRelations: async () => {
   400→    set({ isLoading: true, loadingTab: 'relations' })
   401→    try {
   402→      const data = await api.fetchRelations()
   403→      set({
   404→        relations: data.relations.map((r) => ({
   405→          id: r.id,
   406→          name: r.name,
   407→          type: r.type as Relation['type'],
   408→          compatibility: r.compatibility,
   409→        })),
   410→      })
   411→    } catch (err) {
   412→      console.error('Failed to fetch relations:', err)
   413→    } finally {
   414→      set({ isLoading: false, loadingTab: null })
   415→    }
   416→  },
   417→
   418→  // Fetch Explore
   419→  fetchExplore: async () => {
   420→    set({ isLoading: true, loadingTab: 'explore' })
   421→    try {
   422→      const data = await api.fetchExplore()
   423→      set({
   424→        mysticEntries: data.mystic_entries,
   425→        courses: data.courses,
   426→      })
   427→    } catch (err) {
   428→      console.error('Failed to fetch explore:', err)
   429→    } finally {
   430→      set({ isLoading: false, loadingTab: null })
   431→    }
   432→  },
   433→
   434→  // Preferences
   435→  fetchPreferences: async () => {
   436→    try {
   437→      const prefs = await api.fetchPreferences()
   438→      set({ chatBackend: prefs.chat_backend })
   439→    } catch (err) {
   440→      console.error('Failed to fetch preferences:', err)
   441→    }
   442→  },
   443→
   444→  updateChatBackend: async (backend) => {
   445→    try {
   446→      await api.updatePreferences({ chat_backend: backend })
   447→      set({ chatBackend: backend })
   448→    } catch (err) {
   449→      console.error('Failed to update chat backend:', err)
   450→    }
   451→  },
   452→
   453→  // Accept Task
   454→  acceptTask: async (taskId, type = 'start_task') => {
   455→    try {
   456→      await api.acceptTask(taskId, type)
   457→      // Refresh tasks
   458→      get().fetchTasks()
   459→      get().fetchOverview()
   460→    } catch (err) {
   461→      console.error('Failed to accept task:', err)
   462→    }
   463→  },
   464→
   465→  // Complete Task
   466→  completeTask: async (taskId, note = '') => {
   467→    try {
   468→      const result = await api.completeTask(taskId, note)
   469→      set({
   470→        stateScore: {
   471→          score: result.state_score.score,
   472→          breakdown: result.state_score.breakdown,
   473→          recoveryAction: result.state_score.recovery_action,
   474→        },
   475→      })
   476→      // Refresh tasks
   477→      get().fetchTasks()
   478→      get().fetchOverview()
   479→    } catch (err) {
   480→      console.error('Failed to complete task:', err)
   481→    }
   482→  },
   483→
   484→  // Skip Task
   485→  skipTask: async (taskId, reason = '') => {
   486→    try {
   487→      await api.skipTask(taskId, reason)
   488→      get().fetchTasks()
   489→      get().fetchOverview()
   490→    } catch (err) {
   491→      console.error('Failed to skip task:', err)
   492→    }
   493→  },
   494→
   495→  // Submit Checkin
   496→  submitCheckin: async (mood, intensity, note = '') => {
   497→    const result = await api.submitCheckin(mood, intensity, note)
   498→    set({
   499→      stateScore: {
   500→        score: result.state_score.score,
   501→        breakdown: result.state_score.breakdown,
   502→        recoveryAction: result.state_score.recovery_action,
   503→      },
   504→    })
   505→    return result
   506→  },
   507→
   508→  // Chat: Send Message
   509→  // Supports both legacy SSE and new Agent Runtime based on USE_NEW_RUNTIME env
   510→  sendMessage: async (content) => {
   511→    const { sessionId, messages } = get()
   512→
   513→    // Extract command if content starts with /
   514→    let command: string | undefined
   515→    let messageText = content
   516→    if (content.startsWith('/')) {
   517→      const parts = content.split(/\s+/)
   518→      const cmdPart = parts[0]
   519→      if (cmdPart.length > 1) {
   520→        command = cmdPart // e.g., "/bazi" or "/yunshi"
   521→        messageText = parts.slice(1).join(' ') || content // Keep original if no args
   522→      }
   523→    }
   524→
   525→    // Add user message
   526→    const userMessage: Message = {
   527→      id: `user-${Date.now()}`,
   528→      role: 'user',
   529→      content,
   530→      timestamp: new Date(),
   531→    }
   532→    const assistantId = `assistant-${Date.now()}`
   533→    const assistantMessage: Message = {
   534→      id: assistantId,
   535→      role: 'assistant',
   536→      content: '',
   537→      timestamp: new Date(),
   538→    }
   539→    set({ messages: [...messages, userMessage, assistantMessage], isStreaming: true })
   540→
   541→    try {
   542→      let streamedText = ''
   543→
   544→      // Use smart stream function that picks legacy or new runtime
   545→      api.streamChat(
   546→        content, // Send full content including command
   547→        sessionId || undefined,
   548→        {
   549→          command, // For new runtime tool selection
   550→          onChunk: (chunk) => {
   551→            streamedText += chunk
   552→            set((state) => ({
   553→              messages: state.messages.map((m) =>
   554→                m.id === assistantId
   555→                  ? { ...m, content: streamedText }
   556→                  : m
   557→              ),
   558→            }))
   559→          },
   560→          onToolCall: (toolInvocation) => {
   561→            // Handle tool call updates (new runtime only)
   562→            console.log('[chat] Tool call:', toolInvocation.toolName, toolInvocation.result ? '(completed)' : '(pending)')
   563→          },
   564→          onDone: (final) => {
   565→            set((state) => ({
   566→              messages: state.messages.map((m) =>
   567→                m.id === assistantId
   568→                  ? {
   569→                      ...m,
   570→                      content: final.reply || streamedText || '收到了，让我想想...',
   571→                      blocks: a2uiToBlocks(final.ui_components),
   572→                    }
   573→                  : m
   574→              ),
   575→              sessionId: final.session_id,
   576→              isStreaming: false,
   577→            }))
   578→          },
   579→          onError: (err) => {
   580→            console.error('Chat stream failed:', err)
   581→            const msg = err instanceof Error ? err.message : String(err || 'unknown_error')
   582→            set((state) => ({
   583→              messages: state.messages.map((m) =>
   584→                m.id === assistantId
   585→                  ? { ...m, content: streamedText || `（请求失败：${msg}）` }
   586→                  : m
   587→              ),
   588→              isStreaming: false,
   589→            }))
   590→          },
   591→        }
   592→      )
   593→    } catch (err) {
   594→      console.error('Failed to send message:', err)
   595→      set({ isStreaming: false })
   596→    }
   597→  },
   598→
   599→  // Chat: Add Message (for non-streaming)
   600→  addMessage: (message) =>
   601→    set((state) => ({
   602→      messages: [...state.messages, message],
   603→    })),
   604→
   605→  setStreaming: (streaming) => set({ isStreaming: streaming }),
   606→
   607→  clearMessages: () => set({ messages: [], sessionId: null }),
   608→
   609→  // Artifact Actions
   610→  addArtifact: (artifact) =>
   611→    set((state) => ({
   612→      artifacts: [...state.artifacts, artifact],
   613→    })),
   614→
   615→  pinArtifact: (id) =>
   616→    set((state) => {
   617→      const artifact = state.artifacts.find((a) => a.id === id)
   618→      if (!artifact) return state
   619→
   620→      const updated = { ...artifact, pinned: true }
   621→      return {
   622→        artifacts: state.artifacts.map((a) => (a.id === id ? updated : a)),
   623→        pinnedArtifacts: [...state.pinnedArtifacts, updated],
   624→      }
   625→    }),
   626→
   627→  unpinArtifact: (id) =>
   628→    set((state) => ({
   629→      artifacts: state.artifacts.map((a) =>
   630→        a.id === id ? { ...a, pinned: false } : a
   631→      ),
   632→      pinnedArtifacts: state.pinnedArtifacts.filter((a) => a.id !== id),
   633→    })),
   634→}))
   635→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
