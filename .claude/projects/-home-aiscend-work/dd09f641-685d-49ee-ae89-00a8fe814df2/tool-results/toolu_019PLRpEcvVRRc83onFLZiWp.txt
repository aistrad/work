     1→from __future__ import annotations
     2→
     3→import hashlib
     4→import json
     5→from dataclasses import dataclass
     6→from datetime import date, datetime, timedelta, timezone
     7→from typing import Any, Dict, List, Optional, Tuple
     8→
     9→import swisseph as swe
    10→from lunar_python import LunarYear, Solar
    11→
    12→from common.logging import get_logger
    13→from stores import fortune_db
    14→
    15→
    16→logger = get_logger(__name__)
    17→
    18→
    19→BAZI_FACTS_VERSION = "bazi-tts-v1"
    20→
    21→_DAY_GAN_ELEMENT = {
    22→    "甲": "木",
    23→    "乙": "木",
    24→    "丙": "火",
    25→    "丁": "火",
    26→    "戊": "土",
    27→    "己": "土",
    28→    "庚": "金",
    29→    "辛": "金",
    30→    "壬": "水",
    31→    "癸": "水",
    32→}
    33→
    34→_MONTH_BRANCH_SEASON_ELEMENT = {
    35→    "寅": "木",
    36→    "卯": "木",
    37→    "辰": "木",
    38→    "巳": "火",
    39→    "午": "火",
    40→    "未": "火",
    41→    "申": "金",
    42→    "酉": "金",
    43→    "戌": "金",
    44→    "亥": "水",
    45→    "子": "水",
    46→    "丑": "水",
    47→}
    48→
    49→_ELEMENT_REL = {
    50→    "木": {"generator": "水", "produces": "火", "controls": "土", "controlled_by": "金"},
    51→    "火": {"generator": "木", "produces": "土", "controls": "金", "controlled_by": "水"},
    52→    "土": {"generator": "火", "produces": "金", "controls": "水", "controlled_by": "木"},
    53→    "金": {"generator": "土", "produces": "水", "controls": "木", "controlled_by": "火"},
    54→    "水": {"generator": "金", "produces": "木", "controls": "火", "controlled_by": "土"},
    55→}
    56→
    57→_SHENSHA_SANHE_GROUPS = [
    58→    ("申子辰", {"taohua": "酉", "yima": "寅", "huagai": "辰"}),
    59→    ("亥卯未", {"taohua": "子", "yima": "巳", "huagai": "未"}),
    60→    ("寅午戌", {"taohua": "卯", "yima": "申", "huagai": "戌"}),
    61→    ("巳酉丑", {"taohua": "午", "yima": "亥", "huagai": "丑"}),
    62→]
    63→
    64→_TIANYI_BY_DAY_GAN = {
    65→    "甲": ["丑", "未"],
    66→    "戊": ["丑", "未"],
    67→    "庚": ["丑", "未"],
    68→    "乙": ["子", "申"],
    69→    "己": ["子", "申"],
    70→    "丙": ["亥", "酉"],
    71→    "丁": ["亥", "酉"],
    72→    "辛": ["寅", "午"],
    73→    "壬": ["卯", "巳"],
    74→    "癸": ["卯", "巳"],
    75→}
    76→
    77→_WENCHANG_BY_DAY_GAN = {
    78→    "甲": ["巳", "午"],
    79→    "乙": ["巳", "午"],
    80→    "丙": ["申", "酉"],
    81→    "丁": ["申", "酉"],
    82→    "戊": ["申", "酉"],
    83→    "己": ["申", "酉"],
    84→    "庚": ["亥", "子"],
    85→    "辛": ["亥", "子"],
    86→    "壬": ["寅", "卯"],
    87→    "癸": ["寅", "卯"],
    88→}
    89→
    90→
    91→def _dt_str(dt: datetime) -> str:
    92→    return dt.replace(tzinfo=None).strftime("%Y-%m-%d %H:%M:%S")
    93→
    94→
    95→def _canonical_json(obj: Any) -> str:
    96→    return json.dumps(obj, ensure_ascii=False, sort_keys=True, separators=(",", ":"))
    97→
    98→
    99→def _sha256_text(s: str) -> str:
   100→    return "sha256:" + hashlib.sha256(s.encode("utf-8")).hexdigest()
   101→
   102→
   103→@dataclass(frozen=True)
   104→class TrueSolarTime:
   105→    tz_meridian_deg: float
   106→    lon_corr_min: float
   107→    eot_min: float
   108→    true_solar_time_local: datetime
   109→
   110→
   111→def compute_true_solar_time(
   112→    *,
   113→    birthday_local: datetime,
   114→    tz_offset_hours: float,
   115→    longitude: float,
   116→) -> TrueSolarTime:
   117→    tz_meridian_deg = float(tz_offset_hours) * 15.0
   118→    lon_corr_min = (float(longitude) - tz_meridian_deg) * 4.0
   119→
   120→    birthday_utc = (birthday_local - timedelta(hours=float(tz_offset_hours))).replace(tzinfo=timezone.utc)
   121→    hour_decimal_utc = (
   122→        birthday_utc.hour
   123→        + birthday_utc.minute / 60.0
   124→        + birthday_utc.second / 3600.0
   125→        + birthday_utc.microsecond / 3600.0 / 1_000_000.0
   126→    )
   127→    jd_ut = swe.julday(birthday_utc.year, birthday_utc.month, birthday_utc.day, hour_decimal_utc)
   128→    eot_min = swe.time_equ(jd_ut) * 1440.0
   129→
   130→    corr_seconds = (lon_corr_min + eot_min) * 60.0
   131→    t = birthday_local + timedelta(seconds=corr_seconds)
   132→    true_solar_time_local = (t + timedelta(seconds=0.5)).replace(microsecond=0)  # round to nearest second
   133→    return TrueSolarTime(
   134→        tz_meridian_deg=tz_meridian_deg,
   135→        lon_corr_min=lon_corr_min,
   136→        eot_min=eot_min,
   137→        true_solar_time_local=true_solar_time_local,
   138→    )
   139→
   140→
   141→def _wuxing_counts(wuxing: str) -> Dict[str, int]:
   142→    out = {"金": 0, "木": 0, "水": 0, "火": 0, "土": 0}
   143→    for k in out:
   144→        out[k] = (wuxing or "").count(k)
   145→    return out
   146→
   147→
   148→def _season_bonus(
   149→    *,
   150→    month_branch: str,
   151→    day_master_element: str,
   152→) -> Tuple[str, int]:
   153→    season_element = _MONTH_BRANCH_SEASON_ELEMENT.get(month_branch, "")
   154→    if not season_element:
   155→        return "", 0
   156→    if season_element == day_master_element:
   157→        return season_element, 2
   158→    rel = _ELEMENT_REL[day_master_element]
   159→    if season_element == rel["generator"]:
   160→        return season_element, 1
   161→    if season_element == rel["controlled_by"]:
   162→        return season_element, -1
   163→    if season_element == rel["controls"]:
   164→        return season_element, -1
   165→    return season_element, 0
   166→
   167→
   168→def _compute_strength(
   169→    *,
   170→    wuxing_count: Dict[str, int],
   171→    month_branch: str,
   172→    day_master_element: str,
   173→) -> Dict[str, Any]:
   174→    rel = _ELEMENT_REL[day_master_element]
   175→    generator = rel["generator"]
   176→    produced = rel["produces"]
   177→    controlled_by = rel["controlled_by"]
   178→    controls = rel["controls"]
   179→
   180→    support = int(wuxing_count.get(day_master_element, 0)) + int(wuxing_count.get(generator, 0))
   181→    drain = int(wuxing_count.get(produced, 0)) + int(wuxing_count.get(controlled_by, 0))
   182→    season_element, season_bonus = _season_bonus(month_branch=month_branch, day_master_element=day_master_element)
   183→    score = int(support - drain + season_bonus)
   184→
   185→    if score >= 2:
   186→        status = "strong"
   187→        favorable = [produced, controls, controlled_by]
   188→    elif score <= -2:
   189→        status = "weak"
   190→        favorable = [day_master_element, generator]
   191→    else:
   192→        status = "neutral"
   193→        min_count = min(wuxing_count.values()) if wuxing_count else 0
   194→        favorable = [k for k, v in wuxing_count.items() if v == min_count]
   195→
   196→    return {
   197→        "rule_id": "RULE-STRENGTH-SCORE-V1",
   198→        "day_master_element": day_master_element,
   199→        "generator_element": generator,
   200→        "produced_element": produced,
   201→        "controls_element": controls,
   202→        "controlled_by_element": controlled_by,
   203→        "season_element": season_element,
   204→        "season_bonus": season_bonus,
   205→        "support": support,
   206→        "drain": drain,
   207→        "score": score,
   208→        "status": status,
   209→        "favorable_elements": favorable,
   210→    }
   211→
   212→
   213→def _branch_group_targets(branch: str) -> Dict[str, str]:
   214→    for group, targets in _SHENSHA_SANHE_GROUPS:
   215→        if branch in group:
   216→            return targets
   217→    return {}
   218→
   219→
   220→def _compute_shensha(
   221→    *,
   222→    pillars: Dict[str, str],
   223→    day_gan: str,
   224→) -> List[Dict[str, Any]]:
   225→    year_branch = pillars.get("year", "")[1:2]
   226→    day_branch = pillars.get("day", "")[1:2]
   227→    branches = [p[1:2] for p in pillars.values() if isinstance(p, str) and len(p) >= 2]
   228→    branch_set = set(branches)
   229→
   230→    targets: Dict[str, str] = {}
   231→    targets.update(_branch_group_targets(year_branch))
   232→    targets.update(_branch_group_targets(day_branch))
   233→
   234→    taohua = targets.get("taohua")
   235→    yima = targets.get("yima")
   236→    huagai = targets.get("huagai")
   237→
   238→    out: List[Dict[str, Any]] = [
   239→        {
   240→            "name": "桃花",
   241→            "rule_id": "RULE-SHENSHA-TAOHUA-V1",
   242→            "hit": bool(taohua and taohua in branch_set),
   243→            "note": "以日支/年支推咸池",
   244→        },
   245→        {
   246→            "name": "驿马",
   247→            "rule_id": "RULE-SHENSHA-YIMA-V1",
   248→            "hit": bool(yima and yima in branch_set),
   249→            "note": "以日支/年支推驿马",
   250→        },
   251→        {
   252→            "name": "华盖",
   253→            "rule_id": "RULE-SHENSHA-HUAGAI-V1",
   254→            "hit": bool(huagai and huagai in branch_set),
   255→            "note": "以日支/年支推华盖",
   256→        },
   257→    ]
   258→
   259→    tianyi_targets = _TIANYI_BY_DAY_GAN.get(day_gan, [])
   260→    out.append(
   261→        {
   262→            "name": "天乙贵人",
   263→            "rule_id": "RULE-SHENSHA-TIANYI-V1",
   264→            "hit": any(b in branch_set for b in tianyi_targets),
   265→            "note": "以日干推贵人",
   266→        }
   267→    )
   268→    wenchang_targets = _WENCHANG_BY_DAY_GAN.get(day_gan, [])
   269→    out.append(
   270→        {
   271→            "name": "文昌",
   272→            "rule_id": "RULE-SHENSHA-WENCHANG-V1",
   273→            "hit": any(b in branch_set for b in wenchang_targets),
   274→            "note": "以日干推文昌",
   275→        }
   276→    )
   277→    return out
   278→
   279→
   280→def _compute_luck(*, eight_char, gender: str) -> Dict[str, Any]:
   281→    gender_code = 1 if gender == "男" else 0
   282→    yun = eight_char.getYun(gender_code)
   283→    forward = bool(yun.isForward())
   284→    start_age_year = int(yun.getStartYear())
   285→
   286→    da_yun_items: List[Dict[str, Any]] = []
   287→    for dy in yun.getDaYun(10) or []:
   288→        gz = str(dy.getGanZhi() or "")
   289→        if not gz:
   290→            continue
   291→        da_yun_items.append(
   292→            {
   293→                "start_age": int(dy.getStartAge()),
   294→                "end_age": int(dy.getEndAge()),
   295→                "start_year": int(dy.getStartYear()),
   296→                "end_year": int(dy.getEndYear()),
   297→                "gan_zhi": gz,
   298→                "xun": str(dy.getXun() or ""),
   299→                "xun_kong": str(dy.getXunKong() or ""),
   300→            }
   301→        )
   302→
   303→    for idx, item in enumerate(da_yun_items, start=1):
   304→        item["index"] = idx
   305→
   306→    this_year = datetime.now().year
   307→    liu_nian_next5 = [{"year": y, "gan_zhi": LunarYear.fromYear(y).getGanZhi()} for y in range(this_year + 1, this_year + 6)]
   308→
   309→    return {
   310→        "forward": forward,
   311→        "start_age_year": start_age_year,
   312→        "da_yun": da_yun_items,
   313→        "liu_nian_next5": liu_nian_next5,
   314→    }
   315→
   316→
   317→def compute_facts(
   318→    *,
   319→    name: str,
   320→    gender: str,
   321→    birthday_local: datetime,
   322→    tz_offset_hours: float,
   323→    location: Dict[str, Any],
   324→) -> Dict[str, Any]:
   325→    if gender not in ("男", "女"):
   326→        raise ValueError("invalid_gender")
   327→    longitude = float(location["longitude"])
   328→    latitude = float(location["latitude"])
   329→
   330→    solar_time = compute_true_solar_time(birthday_local=birthday_local, tz_offset_hours=float(tz_offset_hours), longitude=longitude)
   331→    ts = solar_time.true_solar_time_local
   332→
   333→    solar = Solar.fromYmdHms(ts.year, ts.month, ts.day, ts.hour, ts.minute, ts.second)
   334→    lunar = solar.getLunar()
   335→    eight = lunar.getEightChar()
   336→
   337→    pillars = {"year": eight.getYear(), "month": eight.getMonth(), "day": eight.getDay(), "hour": eight.getTime()}
   338→    wuxing_concat = str(eight.getYearWuXing() or "") + str(eight.getMonthWuXing() or "") + str(eight.getDayWuXing() or "") + str(eight.getTimeWuXing() or "")
   339→    wuxing_count = _wuxing_counts(wuxing_concat)
   340→
   341→    day_gan = pillars["day"][0:1]
   342→    day_master_element = _DAY_GAN_ELEMENT.get(day_gan, "")
   343→    month_branch = pillars["month"][1:2]
   344→
   345→    facts_base: Dict[str, Any] = {
   346→        "profile": {
   347→            "name": str(name),
   348→            "gender": gender,
   349→            "birthday_local": _dt_str(birthday_local),
   350→            "tz_offset_hours": float(tz_offset_hours),
   351→            "location": {"name": str(location.get("name") or ""), "longitude": longitude, "latitude": latitude},
   352→        },
   353→        "solar_time": {
   354→            "tz_meridian_deg": round(float(solar_time.tz_meridian_deg), 4),
   355→            "lon_corr_min": round(float(solar_time.lon_corr_min), 4),
   356→            "eot_min": round(float(solar_time.eot_min), 4),
   357→            "true_solar_time_local": _dt_str(ts),
   358→        },
   359→        "bazi": {
   360→            "pillars": pillars,
   361→            "day_master": {"gan": day_gan, "element": day_master_element},
   362→            "wuxing_count": wuxing_count,
   363→            "shi_shen_gan": {
   364→                "year": str(eight.getYearShiShenGan() or ""),
   365→                "month": str(eight.getMonthShiShenGan() or ""),
   366→                "day": str(eight.getDayShiShenGan() or ""),
   367→                "hour": str(eight.getTimeShiShenGan() or ""),
   368→            },
   369→            "shi_shen_zhi": {
   370→                "year": list(eight.getYearShiShenZhi() or []),
   371→                "month": list(eight.getMonthShiShenZhi() or []),
   372→                "day": list(eight.getDayShiShenZhi() or []),
   373→                "hour": list(eight.getTimeShiShenZhi() or []),
   374→            },
   375→            "na_yin": {
   376→                "year": str(eight.getYearNaYin() or ""),
   377→                "month": str(eight.getMonthNaYin() or ""),
   378→                "day": str(eight.getDayNaYin() or ""),
   379→                "hour": str(eight.getTimeNaYin() or ""),
   380→            },
   381→            "di_shi": {
   382→                "year": str(eight.getYearDiShi() or ""),
   383→                "month": str(eight.getMonthDiShi() or ""),
   384→                "day": str(eight.getDayDiShi() or ""),
   385→                "hour": str(eight.getTimeDiShi() or ""),
   386→            },
   387→            "luck": _compute_luck(eight_char=eight, gender=gender),
   388→            "strength": _compute_strength(wuxing_count=wuxing_count, month_branch=month_branch, day_master_element=day_master_element),
   389→            "shensha": _compute_shensha(pillars=pillars, day_gan=day_gan),
   390→        },
   391→        "version": {"compute_version": BAZI_FACTS_VERSION},
   392→    }
   393→
   394→    facts_hash = _sha256_text(_canonical_json(facts_base))
   395→    facts_base["version"]["facts_hash"] = facts_hash
   396→    return facts_base
   397→
   398→
   399→def make_bazi_digest(facts: Dict[str, Any]) -> str:
   400→    try:
   401→        pillars = facts.get("bazi", {}).get("pillars", {})
   402→        y = str(pillars.get("year") or "")
   403→        m = str(pillars.get("month") or "")
   404→        d = str(pillars.get("day") or "")
   405→        h = str(pillars.get("hour") or "")
   406→        dm = facts.get("bazi", {}).get("day_master", {})
   407→        dm_gan = str(dm.get("gan") or "")
   408→        dm_el = str(dm.get("element") or "")
   409→        strength = facts.get("bazi", {}).get("strength", {})
   410→        status = str(strength.get("status") or "")
   411→        return f"{y}{m}{d}{h} 日主{dm_gan}{dm_el} {status}".strip()
   412→    except Exception:
   413→        return ""
   414→
   415→
   416→def ensure_snapshot_for_user(user_id: int) -> Dict[str, Any]:
   417→    user = fortune_db.fetch_one(
   418→        "SELECT name, gender, birthday_local, tz_offset_hours, location FROM fortune_user WHERE user_id=%s AND deleted_at IS NULL",
   419→        (int(user_id),),
   420→    )
   421→    if not user:
   422→        raise ValueError("user_not_found")
   423→
   424→    snap = fortune_db.fetch_one(
   425→        "SELECT facts, facts_hash, compute_version FROM fortune_bazi_snapshot WHERE user_id=%s ORDER BY created_at DESC LIMIT 1",
   426→        (int(user_id),),
   427→    )
   428→    if snap and snap.get("facts") and snap.get("facts_hash"):
   429→        return {"facts": snap.get("facts") or {}, "facts_hash": str(snap.get("facts_hash") or ""), "compute_version": str(snap.get("compute_version") or "")}
   430→
   431→    facts = compute_facts(
   432→        name=str(user.get("name") or ""),
   433→        gender=str(user.get("gender") or ""),
   434→        birthday_local=user["birthday_local"],
   435→        tz_offset_hours=float(user.get("tz_offset_hours") or 8.0),
   436→        location=user.get("location") or {},
   437→    )
   438→    digest = make_bazi_digest(facts)
   439→    facts_json = json.dumps(facts, ensure_ascii=False)
   440→    facts_hash = str(facts.get("version", {}).get("facts_hash") or "")
   441→
   442→    with fortune_db.db_cursor(dict_cursor=True) as cur:
   443→        cur.execute(
   444→            """
   445→            INSERT INTO fortune_bazi_snapshot (user_id, compute_version, facts, facts_hash)
   446→            VALUES (%s, %s, %s::jsonb, %s)
   447→            ON CONFLICT (user_id, compute_version, facts_hash) DO NOTHING
   448→            """,
   449→            (int(user_id), BAZI_FACTS_VERSION, facts_json, facts_hash),
   450→        )
   451→        if digest:
   452→            cur.execute("UPDATE fortune_user SET bazi_digest=%s, updated_at=now() WHERE user_id=%s", (digest, int(user_id)))
   453→
   454→    logger.info(
   455→        "bazi facts computed",
   456→        extra={"operation": "bazi_facts_compute", "user_id": int(user_id), "compute_version": BAZI_FACTS_VERSION, "facts_hash": facts_hash},
   457→    )
   458→    return {"facts": facts, "facts_hash": facts_hash, "compute_version": BAZI_FACTS_VERSION}
   459→
   460→
   461→def upsert_snapshot_for_profile(
   462→    *,
   463→    user_id: int,
   464→    name: str,
   465→    gender: str,
   466→    birthday_local: datetime,
   467→    tz_offset_hours: float,
   468→    location: Dict[str, Any],
   469→) -> Dict[str, Any]:
   470→    facts = compute_facts(
   471→        name=name,
   472→        gender=gender,
   473→        birthday_local=birthday_local,
   474→        tz_offset_hours=tz_offset_hours,
   475→        location=location,
   476→    )
   477→    digest = make_bazi_digest(facts)
   478→    facts_json = json.dumps(facts, ensure_ascii=False)
   479→    facts_hash = str(facts.get("version", {}).get("facts_hash") or "")
   480→
   481→    with fortune_db.db_cursor(dict_cursor=True) as cur:
   482→        cur.execute(
   483→            """
   484→            INSERT INTO fortune_bazi_snapshot (user_id, compute_version, facts, facts_hash)
   485→            VALUES (%s, %s, %s::jsonb, %s)
   486→            ON CONFLICT (user_id, compute_version, facts_hash) DO NOTHING
   487→            """,
   488→            (int(user_id), BAZI_FACTS_VERSION, facts_json, facts_hash),
   489→        )
   490→        cur.execute("UPDATE fortune_user SET bazi_digest=%s, updated_at=now() WHERE user_id=%s", (digest, int(user_id)))
   491→
   492→    logger.info(
   493→        "bazi facts computed",
   494→        extra={"operation": "bazi_facts_compute", "user_id": int(user_id), "compute_version": BAZI_FACTS_VERSION, "facts_hash": facts_hash},
   495→    )
   496→    return {"facts": facts, "facts_hash": facts_hash, "compute_version": BAZI_FACTS_VERSION}
   497→
   498→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
