     1→"""
     2→Vibe ID Authentication Routes
     3→"""
     4→from typing import Optional
     5→
     6→from fastapi import APIRouter, HTTPException, status, Depends
     7→from pydantic import BaseModel, EmailStr
     8→
     9→from services.identity import AuthService, SSOService, get_current_user, CurrentUser
    10→
    11→
    12→router = APIRouter(prefix="/auth", tags=["Authentication"])
    13→
    14→
    15→# ─────────────────────────────────────────────────────────────────
    16→# Request/Response Models
    17→# ─────────────────────────────────────────────────────────────────
    18→
    19→class RegisterRequest(BaseModel):
    20→    email: Optional[EmailStr] = None
    21→    phone: Optional[str] = None
    22→    password: str
    23→    display_name: Optional[str] = None
    24→
    25→
    26→class LoginRequest(BaseModel):
    27→    email: Optional[EmailStr] = None
    28→    phone: Optional[str] = None
    29→    password: str
    30→
    31→
    32→class RefreshRequest(BaseModel):
    33→    refresh_token: str
    34→
    35→
    36→class SSORequest(BaseModel):
    37→    target_site: str
    38→
    39→
    40→class SSOCallbackRequest(BaseModel):
    41→    token: str
    42→    site: str
    43→
    44→
    45→class TokenResponse(BaseModel):
    46→    access_token: str
    47→    refresh_token: str
    48→    token_type: str = "bearer"
    49→    expires_in: int
    50→    user: dict
    51→
    52→
    53→class UserResponse(BaseModel):
    54→    user_id: str
    55→    vibe_id: str
    56→    display_name: Optional[str] = None
    57→    avatar_url: Optional[str] = None
    58→
    59→
    60→# ─────────────────────────────────────────────────────────────────
    61→# Endpoints
    62→# ─────────────────────────────────────────────────────────────────
    63→
    64→@router.post("/register", response_model=TokenResponse)
    65→async def register(request: RegisterRequest):
    66→    """Register a new user with Vibe ID"""
    67→    try:
    68→        result = await AuthService.register(
    69→            email=request.email,
    70→            phone=request.phone,
    71→            password=request.password,
    72→            display_name=request.display_name
    73→        )
    74→        return TokenResponse(**result)
    75→    except ValueError as e:
    76→        raise HTTPException(
    77→            status_code=status.HTTP_400_BAD_REQUEST,
    78→            detail=str(e)
    79→        )
    80→
    81→
    82→@router.post("/login", response_model=TokenResponse)
    83→async def login(request: LoginRequest):
    84→    """Login with email/phone and password"""
    85→    try:
    86→        result = await AuthService.login(
    87→            email=request.email,
    88→            phone=request.phone,
    89→            password=request.password
    90→        )
    91→        return TokenResponse(**result)
    92→    except ValueError as e:
    93→        raise HTTPException(
    94→            status_code=status.HTTP_401_UNAUTHORIZED,
    95→            detail=str(e)
    96→        )
    97→
    98→
    99→@router.post("/refresh", response_model=TokenResponse)
   100→async def refresh_token(request: RefreshRequest):
   101→    """Refresh access token"""
   102→    try:
   103→        result = await AuthService.refresh_token(request.refresh_token)
   104→        return TokenResponse(**result)
   105→    except ValueError as e:
   106→        raise HTTPException(
   107→            status_code=status.HTTP_401_UNAUTHORIZED,
   108→            detail=str(e)
   109→        )
   110→
   111→
   112→@router.get("/me", response_model=UserResponse)
   113→async def get_me(current_user: CurrentUser = Depends(get_current_user)):
   114→    """Get current authenticated user"""
   115→    return UserResponse(
   116→        user_id=str(current_user.user_id),
   117→        vibe_id=current_user.vibe_id,
   118→        display_name=current_user.display_name
   119→    )
   120→
   121→
   122→# ─────────────────────────────────────────────────────────────────
   123→# SSO Endpoints
   124→# ─────────────────────────────────────────────────────────────────
   125→
   126→@router.post("/sso/generate")
   127→async def generate_sso_token(
   128→    request: SSORequest,
   129→    current_user: CurrentUser = Depends(get_current_user)
   130→):
   131→    """Generate SSO token for cross-site authentication"""
   132→    token = await SSOService.generate_sso_token(
   133→        str(current_user.user_id),
   134→        current_user.vibe_id,
   135→        request.target_site
   136→    )
   137→
   138→    if not token:
   139→        raise HTTPException(
   140→            status_code=status.HTTP_400_BAD_REQUEST,
   141→            detail="Invalid target site"
   142→        )
   143→
   144→    redirect_url = SSOService.get_sso_redirect_url(request.target_site, token)
   145→
   146→    return {
   147→        "sso_token": token,
   148→        "redirect_url": redirect_url,
   149→        "expires_in": 300  # 5 minutes
   150→    }
   151→
   152→
   153→@router.post("/sso/callback", response_model=TokenResponse)
   154→async def sso_callback(request: SSOCallbackRequest):
   155→    """Exchange SSO token for access tokens"""
   156→    result = await SSOService.exchange_sso_for_tokens(
   157→        request.token,
   158→        request.site
   159→    )
   160→
   161→    if not result:
   162→        raise HTTPException(
   163→            status_code=status.HTTP_401_UNAUTHORIZED,
   164→            detail="Invalid or expired SSO token"
   165→        )
   166→
   167→    return TokenResponse(**result)
   168→
   169→
   170→@router.post("/logout")
   171→async def logout(current_user: CurrentUser = Depends(get_current_user)):
   172→    """Logout user (client should discard tokens)"""
   173→    # In a more complete implementation, you might:
   174→    # - Add token to a blacklist
   175→    # - Clear any server-side session
   176→    return {"message": "Logged out successfully"}
   177→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
