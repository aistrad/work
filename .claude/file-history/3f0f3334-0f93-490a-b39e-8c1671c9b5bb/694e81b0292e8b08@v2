"""
CoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索的智能体

v6 架构特性：
- Scenario 路由：根据用户消息匹配最佳场景
- PostgreSQL 知识检索：RAG + 案例匹配
- 7 阶段 SOP：P1-P2 强制，P3-P7 LLM 自由发挥
- 工具-卡片映射：标准化工具元数据
"""
import json
import logging
from typing import Optional, List, Dict, Any, AsyncGenerator
from dataclasses import dataclass
from enum import Enum

from services.llm import LLMClient, get_llm_client
from services.llm.client import LLMMessage
from services.knowledge.repository import get_knowledge_repository, KnowledgeRepository
from .skill_loader import (
    load_skill, load_scenario, get_skill_triggers,
    build_system_prompt, SkillConfig, ScenarioConfig,
    route_scenario as memory_route_scenario,
    get_available_skills, get_skill_scenarios
)
from .sop_engine import SOPEngine, SOPAction, SOPPhase, check_sop_requirements
from .tool_registry import ToolRegistry, ToolContext

logger = logging.getLogger(__name__)


class AgentState(str, Enum):
    """Agent 执行状态"""
    IDLE = "idle"
    THINKING = "thinking"
    TOOL_CALLING = "tool_calling"
    COMPLETED = "completed"
    ERROR = "error"


@dataclass
class AgentEvent:
    """Agent 执行事件"""
    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase
    data: Any = None


@dataclass
class AgentContext:
    """Agent 执行上下文"""
    user_id: str
    user_tier: str = "free"
    profile: Optional[Dict[str, Any]] = None
    skill_data: Optional[Dict[str, Any]] = None
    history: Optional[List[Dict[str, str]]] = None
    skill: Optional[str] = None
    scenario: Optional[str] = None
    portrait: Optional[str] = None
    conversation_id: Optional[str] = None
    voice_mode: Optional[str] = "warm"
    recent_insights: Optional[List[Any]] = None


def build_use_skill_tool() -> Dict[str, Any]:
    """
    动态构建 use_skill 工具定义

    从 SKILL.md 自动读取：
    - 可用的 Skills 列表
    - 每个 Skill 的触发词
    - 每个 Skill 的场景列表
    """
    # 获取所有可用 Skills 和触发词
    triggers = get_skill_triggers()
    available_skills = [s for s in get_available_skills() if s != "core"]

    # 构建 Skill 路由说明
    skill_routing = "## Skill 路由\n"
    for skill_id in available_skills:
        skill = load_skill(skill_id)
        if skill and skill.triggers:
            trigger_str = "、".join(skill.triggers[:5])  # 最多显示5个触发词
            skill_routing += f"- {trigger_str} → skill: \"{skill_id}\"\n"

    # 构建场景目录（只列出主要场景，避免 description 过长）
    scenario_catalog = "\n## 场景目录（常用）\n"
    for skill_id in available_skills:
        scenarios = get_skill_scenarios(skill_id)
        if scenarios:
            # 只列出前5个场景
            top_scenarios = scenarios[:5]
            scenario_catalog += f"\n### {skill_id}\n"
            for s in top_scenarios:
                scenario_catalog += f"- {s}\n"
            if len(scenarios) > 5:
                scenario_catalog += f"- ... (共 {len(scenarios)} 个场景)\n"

    description = f"""激活专业技能来回答用户问题。一次决定 skill、scenario 和 confidence。

{skill_routing}
{scenario_catalog}

## Confidence 说明
- high: 用户意图明确，直接执行
- medium: 基本确定，可能需要追问细节
- low: 不确定，需要向用户确认

重要：如果用户消息中已经包含了出生信息，设置 birth_info_provided=true。"""

    return {
        "type": "function",
        "function": {
            "name": "use_skill",
            "description": description,
            "parameters": {
                "type": "object",
                "properties": {
                    "skill": {
                        "type": "string",
                        "enum": available_skills,
                        "description": "要使用的技能"
                    },
                    "scenario": {
                        "type": "string",
                        "description": "场景 ID，参考上方场景目录"
                    },
                    "confidence": {
                        "type": "string",
                        "enum": ["high", "medium", "low"],
                        "description": "路由置信度"
                    },
                    "topic": {
                        "type": "string",
                        "enum": ["career", "relationship", "fortune", "health", "self", "general"],
                        "description": "用户关注的话题类型"
                    },
                    "birth_info_provided": {
                        "type": "boolean",
                        "description": "用户消息中是否已包含出生信息"
                    }
                },
                "required": ["skill", "scenario", "confidence"]
            }
        }
    }


# 缓存动态生成的工具定义
_USE_SKILL_TOOL_CACHE: Optional[Dict[str, Any]] = None


def get_use_skill_tool() -> Dict[str, Any]:
    """获取 use_skill 工具定义（带缓存）"""
    global _USE_SKILL_TOOL_CACHE
    if _USE_SKILL_TOOL_CACHE is None:
        _USE_SKILL_TOOL_CACHE = build_use_skill_tool()
    return _USE_SKILL_TOOL_CACHE


class CoreAgent:
    """
    CoreAgent v6 - 支持 Scenario 路由和 PostgreSQL 知识检索

    Features:
    - Scenario routing via PostgreSQL
    - Knowledge retrieval (RAG + cases)
    - 7-phase SOP execution
    - Tool-card mapping
    """

    def __init__(
        self,
        llm: Optional[LLMClient] = None,
        max_iterations: int = 10,
        knowledge_repo: Optional[KnowledgeRepository] = None
    ):
        self.llm = llm or get_llm_client()
        self.max_iterations = max_iterations
        self.knowledge_repo = knowledge_repo or get_knowledge_repository()
        self.state = AgentState.IDLE
        self._active_skill: Optional[str] = None
        self._active_scenario: Optional[str] = None
        self._topic: Optional[str] = None
        self._current_message: str = ""

    @property
    def usage(self) -> Dict[str, int]:
        """获取 LLM 使用统计"""
        return self.llm.usage

    async def run(
        self,
        message: str,
        context: AgentContext
    ) -> AsyncGenerator[AgentEvent, None]:
        """执行 Agent 循环"""
        self.state = AgentState.IDLE
        self._current_message = message

        # 使用前端指定的 skill/scenario，或让 LLM 决定
        if context.skill:
            self._active_skill = context.skill
            self._active_scenario = context.scenario or await self._route_scenario(context.skill, message)
        else:
            self._active_skill = None
            self._active_scenario = None

        # 检查 SOP 要求
        if self._active_skill:
            action, sop_context = check_sop_requirements(
                skill_id=self._active_skill,
                scenario_id=self._active_scenario,
                profile=context.profile,
                skill_data=context.skill_data,
                message=message
            )

            yield AgentEvent(type="sop_phase", data={
                "skill": self._active_skill,
                "scenario": self._active_scenario,
                "action": action.value,
                "phase": sop_context.get("phase", SOPPhase.ANALYZE).value,
                "context": sop_context
            })

        # 构建初始消息
        messages = await self._build_initial_messages(message, context)

        for iteration in range(self.max_iterations):
            self.state = AgentState.THINKING
            yield AgentEvent(type="thinking", data={"iteration": iteration})

            tools = self._get_current_tools(context)

            try:
                content_buffer = ""
                tool_calls = []

                async for chunk in self.llm.stream(
                    messages=messages,
                    tools=tools,
                    tool_choice=None,
                    user_tier=context.user_tier
                ):
                    if chunk["type"] == "content":
                        content_buffer += chunk["content"]
                        yield AgentEvent(type="content", data={"content": chunk["content"]})
                    elif chunk["type"] == "tool_call":
                        tool_calls.append(chunk)

                if tool_calls:
                    self.state = AgentState.TOOL_CALLING

                    assistant_tool_calls = []
                    for tc in tool_calls:
                        assistant_tool_calls.append({
                            "id": tc["tool_call_id"],
                            "function": {
                                "name": tc["tool_name"],
                                "arguments": tc["tool_args"]
                            }
                        })
                    messages.append(LLMMessage(
                        role="assistant",
                        content=content_buffer or "",
                        tool_calls=assistant_tool_calls
                    ))
                    content_buffer = ""

                    tool_results = []
                    for tc in tool_calls:
                        tool_name = tc["tool_name"]
                        tool_args = tc["tool_args"]
                        tool_call_id = tc["tool_call_id"]

                        yield AgentEvent(type="tool_call", data={
                            "id": tool_call_id,
                            "name": tool_name,
                            "arguments": tool_args
                        })

                        result = await self._execute_tool(tool_name, tool_args, context)
                        tool_results.append({
                            "tool_call_id": tool_call_id,
                            "result": result
                        })

                        yield AgentEvent(type="tool_result", data={
                            "id": tool_call_id,
                            "name": tool_name,
                            "result": result
                        })

                    for tr in tool_results:
                        result_content = tr["result"]
                        if isinstance(result_content, dict):
                            result_content = json.dumps(result_content, ensure_ascii=False)
                        messages.append(LLMMessage(
                            role="tool",
                            content=str(result_content),
                            tool_call_id=tr["tool_call_id"]
                        ))
                else:
                    self.state = AgentState.COMPLETED
                    yield AgentEvent(type="done", data={"content": content_buffer})
                    return

            except Exception as e:
                self.state = AgentState.ERROR
                logger.error(f"Agent error: {e}")
                yield AgentEvent(type="error", data={"error": str(e)})
                return

        self.state = AgentState.COMPLETED
        yield AgentEvent(type="done", data={"max_iterations_reached": True})

    def _filter_valid_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        过滤历史消息，确保 tool 消息配对完整。

        Anthropic API 要求每个 tool_result 必须有对应的 tool_use。
        如果历史消息不完整（如只有 tool 消息没有对应的 assistant tool_calls），
        需要过滤掉这些孤立的消息。
        """
        if not history:
            return []

        # 收集所有有效的 tool_call_ids（来自 assistant 的 tool_calls）
        valid_tool_ids = set()
        for msg in history:
            if msg.get("role") == "assistant" and msg.get("tool_calls"):
                for tc in msg["tool_calls"]:
                    tc_id = tc.get("id")
                    if tc_id:
                        valid_tool_ids.add(tc_id)

        # 过滤消息
        filtered = []
        for msg in history:
            role = msg.get("role", "user")

            # tool 消息需要检查是否有对应的 tool_use
            if role == "tool":
                tool_call_id = msg.get("tool_call_id")
                if tool_call_id and tool_call_id in valid_tool_ids:
                    filtered.append(msg)
                else:
                    # 孤立的 tool 消息，跳过
                    logger.warning(f"Skipping orphan tool message: {tool_call_id}")
            else:
                # user/assistant 消息直接保留
                filtered.append(msg)

        return filtered

    async def _route_scenario(self, skill_id: str, message: str) -> Optional[str]:
        """场景路由 - 根据消息匹配最佳场景"""
        try:
            matches = await self.knowledge_repo.route_scenario(skill_id, message)
            if matches:
                return matches[0].scenario_id
        except Exception as e:
            logger.warning(f"Scenario routing failed: {e}")

        # 回退到默认场景
        skill = load_skill(skill_id)
        return skill.default_scenario if skill else "basic_reading"

    async def _build_initial_messages(
        self,
        message: str,
        context: AgentContext
    ) -> List[LLMMessage]:
        """构建初始消息列表"""
        system_prompt = await self._build_system_prompt(message, context)

        messages = [LLMMessage(role="system", content=system_prompt)]

        if context.history:
            # 过滤并验证历史消息，确保 tool 消息配对完整
            filtered_history = self._filter_valid_history(context.history[-10:])
            for msg in filtered_history:
                messages.append(LLMMessage(
                    role=msg.get("role", "user"),
                    content=msg.get("content", ""),
                    tool_call_id=msg.get("tool_call_id"),
                    tool_calls=msg.get("tool_calls")
                ))

        messages.append(LLMMessage(role="user", content=message))
        return messages

    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:
        """构建 System Prompt"""
        parts = []

        # 基础 prompt
        if self._active_skill:
            # 传递完整 profile，让 skill_loader 自动处理所有字段
            user_ctx = dict(context.profile) if context.profile else {}
            user_ctx["portrait"] = context.portrait
            base_prompt = build_system_prompt(
                self._active_skill,
                self._active_scenario,
                user_ctx
            )
            parts.append(base_prompt)

            # 知识检索
            try:
                knowledge = await self.knowledge_repo.search_knowledge(
                    self._active_skill, message, top_k=5
                )
                if knowledge:
                    knowledge_text = "\n## 相关知识\n\n"
                    for chunk in knowledge:
                        knowledge_text += f"**{chunk.book_name}** ({chunk.chapter or ''})\n{chunk.chunk_text[:500]}...\n\n"
                    parts.append(knowledge_text)
            except Exception as e:
                logger.warning(f"Knowledge retrieval failed: {e}")

            # 案例匹配 - 使用智能匹配器
            try:
                from .case_matcher import match_cases_smart
                cases = await match_cases_smart(
                    self.knowledge_repo,
                    skill_id=self._active_skill,
                    scenario_id=self._active_scenario,
                    skill_data=context.skill_data,
                    top_k=2
                )
                if cases:
                    cases_text = "\n## 相关案例\n\n"
                    for case in cases:
                        cases_text += f"**{case.name}**\n{json.dumps(case.conclusion, ensure_ascii=False)}\n\n"
                    parts.append(cases_text)
            except Exception as e:
                logger.warning(f"Case matching failed: {e}")
        else:
            # 无 skill 时，添加触发规则
            triggers = get_skill_triggers()
            if triggers:
                trigger_rules = "## 技能触发规则\n\n当用户消息包含以下关键词时，调用 `use_skill` 工具：\n"
                for skill_name, keywords in triggers.items():
                    trigger_rules += f"- **{skill_name}**: {', '.join(keywords)}\n"
                parts.append(trigger_rules)

        # 用户命盘数据
        if context.skill_data and self._active_skill:
            skill_data = context.skill_data.get(self._active_skill, {})
            if skill_data:
                parts.append(f"\n## 用户命盘数据\n{json.dumps(skill_data, ensure_ascii=False, indent=2)}")

        return "\n".join(parts)

    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:
        """获取当前可用工具 - V6: 从统一注册表获取"""
        if not context.skill and not self._active_skill:
            return [get_use_skill_tool()]

        skill_id = self._active_skill or context.skill

        # 从统一注册表获取工具（YAML 为数据源）
        tools = ToolRegistry.get_tools_for_skill(skill_id)
        return tools if tools else [get_use_skill_tool()]

    async def _execute_tool(
        self,
        tool_name: str,
        tool_args: str,
        context: AgentContext
    ) -> Dict[str, Any]:
        """执行工具调用 - V6.1: 完全使用统一注册表"""
        try:
            args = json.loads(tool_args) if tool_args else {}
        except json.JSONDecodeError:
            args = {}

        # 特殊处理 use_skill（路由工具）
        if tool_name == "use_skill":
            return await self._handle_use_skill(args, context)

        # 创建工具上下文
        tool_context = ToolContext(
            user_id=context.user_id,
            user_tier=context.user_tier,
            profile=context.profile or {},
            skill_data=context.skill_data or {},
            skill_id=self._active_skill,
            scenario_id=self._active_scenario,
            conversation_id=context.conversation_id
        )

        # 使用统一注册表执行工具
        if ToolRegistry.has_handler(tool_name):
            return await ToolRegistry.execute(tool_name, args, tool_context)

        # 未找到处理器
        logger.warning(f"No handler found for tool: {tool_name}")
        return {"status": "unknown_tool", "tool": tool_name, "message": f"工具 {tool_name} 暂未实现"}

    async def _handle_search_db(
        self,
        args: Dict[str, Any],
        context: AgentContext
    ) -> Dict[str, Any]:
        """处理 search_db 工具调用"""
        table = args.get("table", "knowledge_chunks")
        query = args.get("query", "")
        filters = args.get("filters", {})
        top_k = args.get("top_k", 5)

        # 自动添加当前 skill_id 到 filters
        if self._active_skill and "skill_id" not in filters:
            filters["skill_id"] = self._active_skill
        if self._active_scenario and "scenario_id" not in filters:
            filters["scenario_id"] = self._active_scenario

        results = await self.knowledge_repo.search_db(
            table=table,
            query=query,
            filters=filters,
            top_k=top_k
        )

        return {
            "status": "success",
            "table": table,
            "query": query,
            "count": len(results),
            "results": results
        }

    async def _handle_use_skill(
        self,
        args: Dict[str, Any],
        context: AgentContext
    ) -> Dict[str, Any]:
        """处理 skill 选择 - V6: 一次决定 skill + scenario + confidence"""
        skill = args.get("skill")
        scenario = args.get("scenario", "basic_reading")
        confidence = args.get("confidence", "high")
        topic = args.get("topic", "general")

        if not skill:
            return {"status": "error", "message": "No skill specified"}

        self._active_skill = skill
        self._active_scenario = scenario
        self._topic = topic

        # 低置信度时，返回确认请求
        if confidence == "low":
            return {
                "status": "need_confirm",
                "skill": skill,
                "scenario": scenario,
                "confidence": confidence,
                "message": f"我理解您可能想使用 {skill} 的 {scenario} 服务，请确认是否正确？"
            }

        # 检查是否需要出生信息
        needs_birth = skill in ["bazi", "zodiac"]
        has_birth = context.profile and context.profile.get("birth_info")
        birth_provided = args.get("birth_info_provided", False)

        if needs_birth and not has_birth and not birth_provided:
            return {
                "status": "need_info",
                "skill": skill,
                "scenario": scenario,
                "confidence": confidence,
                "topic": topic,
                "info_type": "birth",
                "message": "技能已激活。请调用 request_info 工具收集出生信息。"
            }

        return {
            "status": "activated",
            "skill": skill,
            "scenario": scenario,
            "confidence": confidence,
            "topic": topic,
            "message": f"已激活 {skill} 技能，场景: {scenario}"
        }


def create_agent(
    llm: Optional[LLMClient] = None,
    max_iterations: int = 10
) -> CoreAgent:
    """创建 CoreAgent 实例"""
    return CoreAgent(llm=llm, max_iterations=max_iterations)
