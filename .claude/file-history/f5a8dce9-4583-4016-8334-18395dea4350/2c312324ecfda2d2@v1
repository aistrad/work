"""
TriggerDetector - 触发条件检测器

支持三种触发类型:
1. time_based - 基于时间 (cron 表达式)
2. event_based - 基于事件 (节气、月相、生日、大运交接等)
3. threshold_based - 基于阈值 (运势分数等)

设计原则:
- 从 unified_profiles 读取数据
- 支持 Skill 级自定义事件
- 智能化: 事件触发 + 阈值触发
"""

import logging
from datetime import datetime, date, timedelta
from typing import Dict, Any, Optional, Tuple, List

import pytz

from skills.zodiac.services.events import ZodiacEvents

logger = logging.getLogger(__name__)


class TriggerDetector:
    """触发条件检测器"""

    def __init__(self):
        self._event_detectors = {
            "birthday": self._detect_birthday,
            "dayun_change": self._detect_dayun_change,
            "new_year": self._detect_new_year,
            "solar_term": self._detect_solar_term,
            "lunar_phase": self._detect_lunar_phase,
            "mercury_retrograde": self._detect_mercury_retrograde,
            "significant_transit": self._detect_significant_transit,
            # Lifecoach 事件
            "streak_broken": self._detect_streak_broken,
        }

        # Lifecoach 条件检查器 (用于 reminders.yaml conditions)
        self._condition_checkers = {
            "has_data": self._check_has_data,
            "not_checked_in_today": self._check_not_checked_in_today,
            "checked_in_today": self._check_checked_in_today,
            "has_weekly_data": self._check_has_weekly_data,
            "not_reviewed_this_week": self._check_not_reviewed_this_week,
            "not_planned_this_week": self._check_not_planned_this_week,
            "has_pending_levers": self._check_has_pending_levers,
            "had_streak": self._check_had_streak,
        }

    async def should_trigger(
        self,
        trigger_config: Dict[str, Any],
        profile: Dict[str, Any],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """
        检测是否应该触发

        Returns:
            (should_trigger, event_info)
            - should_trigger: 是否触发
            - event_info: 事件信息 (event_name, event_date 等)
        """
        trigger_type = trigger_config.get("type")

        if trigger_type == "time_based":
            return self._check_time_based(trigger_config, profile), None
        elif trigger_type == "event_based":
            return await self._check_event_based(trigger_config, profile, skill_id)
        elif trigger_type == "threshold_based":
            return await self._check_threshold_based(trigger_config, profile, skill_id)

        return False, None

    def _check_time_based(self, config: Dict, profile: Dict) -> bool:
        """
        检查时间触发条件

        支持简化的 cron 格式: "0 4 * * *" (分 时 日 月 周)
        """
        schedule = config.get("schedule", "")
        timezone_aware = config.get("timezone_aware", True)

        if not schedule:
            return False

        # 获取用户时区
        if timezone_aware:
            user_tz = profile.get("preferences", {}).get("timezone", "Asia/Shanghai")
            try:
                now = datetime.now(pytz.timezone(user_tz))
            except Exception:
                now = datetime.now(pytz.timezone("Asia/Shanghai"))
        else:
            now = datetime.now(pytz.UTC)

        # 解析 cron 表达式
        return self._match_cron(schedule, now)

    def _match_cron(self, schedule: str, now: datetime) -> bool:
        """匹配简化的 cron 表达式"""
        try:
            parts = schedule.split()
            if len(parts) != 5:
                return False

            minute, hour, day, month, weekday = parts

            # 检查各字段
            if minute != "*" and int(minute) != now.minute:
                return False
            if hour != "*" and int(hour) != now.hour:
                return False
            if day != "*" and int(day) != now.day:
                return False
            if month != "*" and int(month) != now.month:
                return False
            if weekday != "*" and int(weekday) != now.weekday():
                return False

            return True
        except Exception as e:
            logger.error(f"Failed to parse cron schedule '{schedule}': {e}")
            return False

    async def _check_event_based(
        self,
        config: Dict,
        profile: Dict,
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检查事件触发条件"""
        event = config.get("event")
        advance_days = config.get("advance_days", [0])

        # 确保 advance_days 是列表
        if isinstance(advance_days, int):
            advance_days = [advance_days]

        detector = self._event_detectors.get(event)
        if not detector:
            logger.warning(f"Unknown event type: {event}")
            return False, None

        return await detector(profile, advance_days, skill_id)

    async def _check_threshold_based(
        self,
        config: Dict,
        profile: Dict,
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检查阈值触发条件"""
        metric = config.get("metric")
        condition = config.get("condition")
        threshold = config.get("threshold")
        cooldown = config.get("cooldown", 0)

        # 获取指标值
        value = await self._get_metric_value(metric, profile, skill_id)
        if value is None:
            return False, None

        # TODO: 检查冷却期 (需要记录上次触发时间)

        # 检查条件
        triggered = False
        if condition == "<":
            triggered = value < threshold
        elif condition == ">":
            triggered = value > threshold
        elif condition == "<=":
            triggered = value <= threshold
        elif condition == ">=":
            triggered = value >= threshold
        elif condition == "==":
            triggered = value == threshold

        if triggered:
            return True, {"metric": metric, "value": value, "threshold": threshold}

        return False, None

    async def _get_metric_value(
        self,
        metric: str,
        profile: Dict,
        skill_id: str,
    ) -> Optional[float]:
        """获取指标值"""
        if metric == "daily_fortune_score":
            # 计算今日运势分数
            from skills.bazi.services import BaziComputer
            computer = BaziComputer()
            return await computer.get_daily_fortune_score(profile)

        # 可扩展其他指标
        return None

    # ═════════════════���═════════════════════════════════════════════════════════
    # 事件检测器
    # ═══════════════════════════════════════════════════════════════════════════

    async def _detect_birthday(
        self,
        profile: Dict,
        advance_days: List[int],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检测生日"""
        birth_info = profile.get("birth_info", {})
        birth_date_str = birth_info.get("date")

        if not birth_date_str:
            return False, None

        try:
            birth = datetime.strptime(birth_date_str, "%Y-%m-%d").date()
        except ValueError:
            return False, None

        today = date.today()
        birthday_this_year = date(today.year, birth.month, birth.day)

        # 如果今年生日已过，检查明年
        if birthday_this_year < today:
            birthday_this_year = date(today.year + 1, birth.month, birth.day)

        days_until = (birthday_this_year - today).days

        if days_until in advance_days:
            event_name = "birthday" if days_until == 0 else f"birthday_{days_until}days"
            return True, {
                "event_name": event_name,
                "event_date": birthday_this_year,
                "days_until": days_until,
            }

        return False, None

    async def _detect_dayun_change(
        self,
        profile: Dict,
        advance_days: List[int],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检测大运交接"""
        from skills.bazi.services import BaziComputer

        computer = BaziComputer()
        inflection_points = await computer.get_inflection_points(profile)

        today = date.today()

        for point in inflection_points:
            if point.get("type") == "major_cycle_change":
                point_year = point.get("year")
                if point_year:
                    # 大运交接通常在年初
                    point_date = date(point_year, 1, 1)
                    days_until = (point_date - today).days

                    if days_until in advance_days:
                        return True, {
                            "event_name": point.get("title", "大运交接"),
                            "event_date": point_date,
                            "days_until": days_until,
                            "point": point,
                        }

        return False, None

    async def _detect_new_year(
        self,
        profile: Dict,
        advance_days: List[int],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检测新年"""
        today = date.today()
        next_new_year = date(today.year + 1, 1, 1)

        # 如果今天是元旦
        if today.month == 1 and today.day == 1:
            if 0 in advance_days:
                return True, {
                    "event_name": "new_year",
                    "event_date": today,
                    "days_until": 0,
                }

        days_until = (next_new_year - today).days

        if days_until in advance_days:
            return True, {
                "event_name": "new_year",
                "event_date": next_new_year,
                "days_until": days_until,
            }

        return False, None

    async def _detect_solar_term(
        self,
        profile: Dict,
        advance_days: List[int],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检测节气"""
        # 使用 ZodiacEvents 获取节气信息
        today = date.today()

        try:
            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)

            for event in events:
                if event.event_type == "solar_term":
                    days_until = (event.start_date - today).days
                    if days_until in advance_days:
                        return True, {
                            "event_name": event.name,
                            "event_date": event.start_date,
                            "days_until": days_until,
                            "description": event.description,
                        }
        except Exception as e:
            logger.error(f"Failed to detect solar term: {e}")

        return False, None

    async def _detect_lunar_phase(
        self,
        profile: Dict,
        advance_days: List[int],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检测月相 (新月/满月)"""
        today = date.today()

        try:
            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)

            for event in events:
                if event.event_type in ("new_moon", "full_moon"):
                    days_until = (event.start_date - today).days
                    if days_until in advance_days:
                        return True, {
                            "event_name": event.name,
                            "event_date": event.start_date,
                            "days_until": days_until,
                            "phase": event.event_type,
                        }
        except Exception as e:
            logger.error(f"Failed to detect lunar phase: {e}")

        return False, None

    async def _detect_mercury_retrograde(
        self,
        profile: Dict,
        advance_days: List[int],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检测水逆"""
        today = date.today()

        try:
            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)

            for event in events:
                if event.event_type == "mercury_retrograde":
                    days_until = (event.start_date - today).days
                    if days_until in advance_days:
                        return True, {
                            "event_name": event.name,
                            "event_date": event.start_date,
                            "days_until": days_until,
                            "end_date": event.end_date,
                        }
        except Exception as e:
            logger.error(f"Failed to detect mercury retrograde: {e}")

        return False, None

    async def _detect_significant_transit(
        self,
        profile: Dict,
        advance_days: List[int],
        skill_id: str,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """检测重要行星过境"""
        today = date.today()

        try:
            events = ZodiacEvents.get_upcoming_events(today, days=max(advance_days) + 1)

            significant_types = ("saturn_return", "jupiter_transit", "eclipse")

            for event in events:
                if event.event_type in significant_types:
                    days_until = (event.start_date - today).days
                    if days_until in advance_days:
                        return True, {
                            "event_name": event.name,
                            "event_date": event.start_date,
                            "days_until": days_until,
                            "transit_type": event.event_type,
                        }
        except Exception as e:
            logger.error(f"Failed to detect significant transit: {e}")

        return False, None
