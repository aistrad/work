#!/usr/bin/env python3
"""
End-to-End Tool Test - éªŒè¯å®Œæ•´å·¥å…·è°ƒç”¨æµç¨‹

æµ‹è¯• CoreAgent ä½¿ç”¨ ToolRegistry çš„å®Œæ•´æµç¨‹ï¼š
1. å·¥å…·è·å– (ä» YAML)
2. å·¥å…·æ‰§è¡Œ (ä» ToolRegistry)
3. ç»“æœè¿”å›
"""
import asyncio
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

from services.agent import CoreAgent, AgentContext, ToolRegistry


async def test_core_agent_tools():
    """æµ‹è¯• CoreAgent å·¥å…·è·å–å’Œæ‰§è¡Œ"""
    print("\n=== Test: CoreAgent Tool Flow ===")

    # åˆå§‹åŒ– ToolRegistry
    import services.agent.global_handlers  # noqa: F401
    ToolRegistry.initialize()

    # åˆ›å»º Agent
    agent = CoreAgent(max_iterations=3)

    # åˆ›å»ºä¸Šä¸‹æ–‡
    context = AgentContext(
        user_id="test-user",
        user_tier="free",
        profile={"basic": {"birth_date": "1990-01-01"}},
        skill_data={"bazi": {"chart": {}}},
        skill="bazi"
    )

    # æµ‹è¯• _get_current_tools
    agent._active_skill = "bazi"
    tools = agent._get_current_tools(context)

    print(f"Tools returned: {len(tools)}")
    tool_names = [t.get("function", {}).get("name") for t in tools]
    print(f"Tool names: {tool_names[:10]}...")

    # éªŒè¯åŒ…å«é¢„æœŸå·¥å…·
    assert "show_bazi_chart" in tool_names, "Should have show_bazi_chart"
    assert "search_db" in tool_names, "Should have search_db"

    print("âœ… CoreAgent tool retrieval test passed")


async def test_tool_execution_via_agent():
    """æµ‹è¯•é€šè¿‡ Agent æ‰§è¡Œå·¥å…·"""
    print("\n=== Test: Tool Execution via Agent ===")

    # åˆå§‹åŒ–
    import services.agent.global_handlers  # noqa: F401
    ToolRegistry.initialize()

    # åˆ›å»º Agent
    agent = CoreAgent(max_iterations=3)
    agent._active_skill = "bazi"

    # åˆ›å»ºä¸Šä¸‹æ–‡
    context = AgentContext(
        user_id="test-user",
        user_tier="free",
        profile={"basic": {}},
        skill_data={"bazi": {"chart": {"day_master": {"element": "wood"}}}},
        skill="bazi"
    )

    # æµ‹è¯•æ‰§è¡Œ show_insight
    result = await agent._execute_tool(
        "show_insight",
        '{"insight_type": "fortune", "title": "è¿åŠ¿æç¤º", "content": "ä»Šå¹´è¿åŠ¿ä¸é”™"}',
        context
    )

    print(f"show_insight result: {result}")
    assert result.get("status") == "success", "Should succeed"
    assert result.get("cardType") == "insight_card", "Should return insight_card"

    # æµ‹è¯•æ‰§è¡Œ show_bazi_chart
    result = await agent._execute_tool(
        "show_bazi_chart",
        '{}',
        context
    )

    print(f"show_bazi_chart result status: {result.get('status')}")
    assert result.get("status") == "success", "Should succeed"
    assert result.get("cardType") == "bazi_chart", "Should return bazi_chart"

    print("âœ… Tool execution via Agent test passed")


async def test_no_hardcoded_fallback():
    """éªŒè¯ä¸å†ä½¿ç”¨ç¡¬ç¼–ç çš„ tool_executor"""
    print("\n=== Test: No Hardcoded Fallback ===")

    # åˆå§‹åŒ–
    import services.agent.global_handlers  # noqa: F401
    ToolRegistry.initialize()

    # æ£€æŸ¥æ‰€æœ‰ UI_TOOLS éƒ½æœ‰å¯¹åº”çš„ handler
    from services.vibe_engine.tool_executor import UI_TOOLS

    missing_handlers = []
    for tool_name in UI_TOOLS:
        if not ToolRegistry.has_handler(tool_name):
            missing_handlers.append(tool_name)

    if missing_handlers:
        print(f"âš ï¸ Missing handlers (will fallback to tool_executor): {missing_handlers}")
    else:
        print("âœ… All UI_TOOLS have registered handlers")

    # è¿™ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œå› ä¸ºæœ‰å›é€€æœºåˆ¶
    print("âœ… Fallback check completed")


async def main():
    """è¿è¡Œæ‰€æœ‰ E2E æµ‹è¯•"""
    print("=" * 60)
    print("End-to-End Tool Test Suite")
    print("=" * 60)

    try:
        await test_core_agent_tools()
        await test_tool_execution_via_agent()
        await test_no_hardcoded_fallback()

        print("\n" + "=" * 60)
        print("ğŸ‰ All E2E tests passed!")
        print("=" * 60)
        return 0

    except AssertionError as e:
        print(f"\nâŒ Test failed: {e}")
        import traceback
        traceback.print_exc()
        return 1
    except Exception as e:
        print(f"\nâŒ Error: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
