"""
Context Build API - 方案 A: AI SDK 主导 + Python Context
为前端 AI SDK streamText 提供 context 构建服务
"""
import logging
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field

from services.identity import get_optional_user, CurrentUser
from services.vibe_engine.context import (
    ContextBuilder, get_context_builder,
    Skill, VoiceMode
)
from services.vibe_engine.profile_cache import get_cached_profile_with_skill
from services.llm.config import ModelConfig
from services.agent import QuotaTracker
from stores import message_repo, conversation_repo

router = APIRouter(prefix="/context", tags=["Context"])
logger = logging.getLogger(__name__)


class ContextBuildRequest(BaseModel):
    """Context 构建请求"""
    skill: str = Field(default="bazi", description="技能类型: bazi/zodiac")
    voice_mode: str = Field(default="warm", description="语气模式: warm/sarcastic/wise")
    message: str = Field(..., description="当前用户消息")
    conversation_id: Optional[UUID] = Field(None, description="对话 ID")


class MessageItem(BaseModel):
    """消息项"""
    role: str
    content: str


class LLMConfig(BaseModel):
    """LLM 配置"""
    provider: str
    model: str
    base_url: Optional[str] = None
    api_key: str  # 从后端配置获取，前端无需从 process.env 读取


class ContextBuildResponse(BaseModel):
    """Context 构建响应"""
    system_prompt: str
    messages: List[MessageItem]
    llm_config: LLMConfig
    conversation_id: str  # 新增：返回 conversation_id
    metadata: Dict[str, Any]


@router.post("/build", response_model=ContextBuildResponse)
async def build_context(
    request: ContextBuildRequest,
    current_user: Optional[CurrentUser] = Depends(get_optional_user)
):
    """
    构建 LLM context，返回给前端 AI SDK streamText 使用。

    返回:
    - system_prompt: 系统提示词 (Persona + Skill + Profile)
    - messages: 消息列表 (历史 + 当前消息)
    - llm_config: LLM 配置 { provider, model, base_url? }
    - conversation_id: 对话 ID (新会话时自动生成)
    - metadata: 元数据 (topic, has_birth_info 等)
    """
    user_id = current_user.user_id if current_user else None

    # 生成或使用现有的 conversation_id
    conversation_id = request.conversation_id
    if not conversation_id:
        # 创建新对话记录
        try:
            conv = await conversation_repo.create_conversation(
                skill=request.skill,
                user_id=user_id,
                voice_mode=request.voice_mode,
            )
            conversation_id = conv.id
        except Exception as e:
            logger.warning(f"Failed to create conversation: {e}")
            conversation_id = uuid4()  # fallback

    # 解析参数
    try:
        skill = Skill(request.skill.lower())
    except ValueError:
        skill = Skill.BAZI

    try:
        voice_mode = VoiceMode(request.voice_mode.lower())
    except ValueError:
        voice_mode = VoiceMode.WARM

    # 获取用户 profile 和 skill_data
    profile = {}
    skill_data = {}
    if user_id:
        try:
            result = await get_cached_profile_with_skill(user_id, request.skill)
            profile = result.get("profile", {})
            skill_data = result.get("skill_data", {})
        except Exception as e:
            logger.warning(f"Failed to get user profile: {e}")

    # 获取对话历史
    history = []
    if request.conversation_id:
        try:
            history = await message_repo.get_messages_for_context(
                request.conversation_id, limit=10
            )
        except Exception as e:
            logger.warning(f"Failed to get history: {e}")

    # 构建 context
    builder = get_context_builder()
    system_prompt, llm_messages = await builder.build(
        skill=skill,
        voice_mode=voice_mode,
        current_message=request.message,
        profile=profile,
        skill_data=skill_data,
        history=history,
    )

    # 转换消息格式
    messages = []
    for msg in llm_messages:
        if msg.role != "system":  # system prompt 单独返回
            messages.append(MessageItem(role=msg.role, content=msg.content))

    # 检测话题和出生信息
    has_birth_info = bool(profile.get("birth_info") or profile.get("basic", {}).get("birth_datetime"))
    topic = builder._detect_topic(request.message, skill)

    # 获取 LLM 配置 (从 models.yaml)
    user_tier = "free"
    if current_user:
        from services.entitlement import EntitlementService
        try:
            entitlements = await EntitlementService.get_entitlements(current_user.user_id)
            user_tier = entitlements.get("tier", "free")
        except Exception:
            pass

    model_selection = ModelConfig.resolve(user_tier=user_tier, task="chat")
    # 构建 llm_config，为需要的 provider 提供 base_url
    base_url = None
    if model_selection.provider in ('deepseek', 'glm', 'openai-compatible'):
        base_url = ModelConfig.get_base_url(model_selection.provider)

    llm_config = LLMConfig(
        provider=model_selection.provider,
        model=model_selection.model,
        base_url=base_url,
        api_key=ModelConfig.get_api_key(model_selection.provider),
    )

    return ContextBuildResponse(
        system_prompt=system_prompt,
        messages=messages,
        llm_config=llm_config,
        conversation_id=str(conversation_id),
        metadata={
            "topic": topic,
            "has_birth_info": has_birth_info,
            "active_skills": [request.skill],
            "user_id": str(user_id) if user_id else None,
        }
    )


# ============================================================
# 消息保存和配额记录端点 (供前端 AI SDK 流式完成后调用)
# ============================================================

class SaveMessageRequest(BaseModel):
    """消息保存请求"""
    conversation_id: Optional[UUID] = None
    role: str = Field(..., description="消息角色: user/assistant")
    content: str = Field(..., description="消息内容")


class RecordQuotaRequest(BaseModel):
    """配额记录请求"""
    conversation_id: Optional[UUID] = None
    prompt_tokens: int = Field(default=0)
    completion_tokens: int = Field(default=0)


@router.post("/messages/save")
async def save_message(
    request: SaveMessageRequest,
    current_user: Optional[CurrentUser] = Depends(get_optional_user)
):
    """保存消息到数据库"""
    if not request.conversation_id:
        return {"success": False, "error": "conversation_id required"}

    try:
        await message_repo.create_message(
            conversation_id=request.conversation_id,
            role=request.role,
            content=request.content
        )
        return {"success": True}
    except Exception as e:
        logger.error(f"Failed to save message: {e}")
        return {"success": False, "error": str(e)}


@router.post("/quota/record")
async def record_quota(
    request: RecordQuotaRequest,
    current_user: Optional[CurrentUser] = Depends(get_optional_user)
):
    """记录配额使用"""
    user_id = current_user.user_id if current_user else None

    try:
        await QuotaTracker.record(
            user_id=str(user_id) if user_id else "guest",
            usage={
                "calls": 1,
                "tokens": request.prompt_tokens + request.completion_tokens,
            }
        )
        return {"success": True}
    except Exception as e:
        logger.error(f"Failed to record quota: {e}")
        return {"success": False, "error": str(e)}


@router.get("/quota/check")
async def check_quota(
    current_user: Optional[CurrentUser] = Depends(get_optional_user)
):
    """入口配额检查 - 前端在调用 LLM 前先检查"""
    user_id = current_user.user_id if current_user else None
    user_tier = "free"

    if current_user:
        from services.entitlement import EntitlementService
        try:
            entitlements = await EntitlementService.get_entitlements(current_user.user_id)
            user_tier = entitlements.get("tier", "free")
        except Exception:
            pass

    allowed, message = await QuotaTracker.check(
        user_id=str(user_id) if user_id else "guest",
        tier=user_tier
    )

    return {
        "allowed": allowed,
        "message": message,
        "tier": user_tier
    }
