# 用量计费系统分析报告
> 2026-01-15 | Ultra Deep Analysis

---

## 一、现有系统分析

### 当前有 4 套重叠的用量追踪

```
┌─────────────────────────────────────────────────────────────────┐
│  1. UsageService          → user_usage 表 (简单计数)            │
│  2. QuotaTracker          → usage_records 表 (calls + tokens)   │
│  3. UsageTracker          → 内存中 (不持久化!)                  │
│  4. QuotaManager          → quota_usage 表 (最完整)             │
└─────────────────────────────────────────────────────────────────┘
```

### 各组件能力对比

| 组件 | Tokens | Cost | Skill | Tool | 持久化 | 位置 |
|------|--------|------|-------|------|--------|------|
| UsageService | ❌ | ❌ | ✅ metadata | ❌ | ✅ user_usage | services/usage/ |
| QuotaTracker | ✅ | ❌ | ❌ | ❌ | ✅ usage_records | services/agent/quota.py |
| UsageTracker | ✅ | ✅ | ❌ | ✅ | ❌ 内存 | services/agent/usage_tracker.py |
| QuotaManager | ✅ | ✅ | ❌ | ❌ | ✅ quota_usage | services/model_router/quota.py |

### 当前数据库表

```sql
-- 1. user_usage (简单)
user_id, usage_type, count, metadata, created_at

-- 2. usage_records (中等)
user_id, calls, tokens, created_at

-- 3. quota_usage (复杂)
rule_id, user_id, period_start, period_end, call_count,
input_tokens, output_tokens, estimated_cost
```

---

## 二、问题诊断

### 核心问题：UsageTracker 不持久化

```python
# services/agent/usage_tracker.py
class UsageTracker:
    def record_llm_call(self, response):
        # 记录到 self.summary (内存)
        # 计算 cost
        # 但从未写入数据库!
```

### 调用链断裂

```
chat.py:396-398
  ↓
await EntitlementService.consume_conversation(user_id)  # 只 +1
await UsageService.record_usage(user_id, "conversation") # 简单记录
await UsageService.record_usage(user_id, "llm_call")     # 无 tokens/cost
  ↓
UsageTracker 的精确数据丢失
```

---

## 三、计费需求 vs 现状

### 你需要的计费数据

| 维度 | 需求 | 现状 |
|------|------|------|
| LLM 调用量 | model + input_tokens + output_tokens + cost | ❌ 不持久化 |
| Skill 使用 | skill_id + 调用次数 | ⚠️ 仅 metadata |
| Tool 使用 | tool_name + 调用次数 | ❌ 完全没有 |
| 用户维度 | user_id + 时间段汇总 | ⚠️ 分散在多表 |

### 缺失功能

1. **LLM 成本追踪** - UsageTracker 算了但没存
2. **Skill 使用明细** - 只存在 metadata 里
3. **Tool 调用记录** - 完全没有持久化
4. **计费聚合查询** - 没有统一的账单表

---

## 四、建议方案

### 方案：统一用量表 + 持久化 UsageTracker

#### 1. 新建统一用量表

```sql
CREATE TABLE usage_events (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL,

    -- 事件类型
    event_type VARCHAR(20) NOT NULL,  -- llm_call, skill_use, tool_call

    -- LLM 维度
    model VARCHAR(50),
    input_tokens INT DEFAULT 0,
    output_tokens INT DEFAULT 0,
    estimated_cost DECIMAL(10,6) DEFAULT 0,

    -- Skill 维度
    skill_id VARCHAR(30),

    -- Tool 维度
    tool_name VARCHAR(50),

    -- 通用
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_usage_events_user_date ON usage_events(user_id, created_at);
CREATE INDEX idx_usage_events_type ON usage_events(event_type, created_at);
CREATE INDEX idx_usage_events_skill ON usage_events(skill_id, created_at);
CREATE INDEX idx_usage_events_billing ON usage_events(user_id, event_type, created_at);
```

#### 2. 统一 UsageService

```python
# services/usage/service.py (重写)

class UsageService:
    """统一用量服务 - 支持计费"""

    @staticmethod
    async def record_llm_call(
        user_id: UUID,
        model: str,
        input_tokens: int,
        output_tokens: int,
        skill_id: str = None
    ) -> None:
        """记录 LLM 调用 (带成本)"""
        cost = UsageService._estimate_cost(model, input_tokens, output_tokens)

        pool = await get_db_pool()
        await pool.execute("""
            INSERT INTO usage_events
            (user_id, event_type, model, input_tokens, output_tokens,
             estimated_cost, skill_id)
            VALUES ($1, 'llm_call', $2, $3, $4, $5, $6)
        """, user_id, model, input_tokens, output_tokens, cost, skill_id)

    @staticmethod
    async def record_skill_use(user_id: UUID, skill_id: str) -> None:
        """记录 Skill 使用"""
        pool = await get_db_pool()
        await pool.execute("""
            INSERT INTO usage_events (user_id, event_type, skill_id)
            VALUES ($1, 'skill_use', $2)
        """, user_id, skill_id)

    @staticmethod
    async def record_tool_call(
        user_id: UUID,
        tool_name: str,
        skill_id: str = None
    ) -> None:
        """记录 Tool 调用"""
        pool = await get_db_pool()
        await pool.execute("""
            INSERT INTO usage_events (user_id, event_type, tool_name, skill_id)
            VALUES ($1, 'tool_call', $2, $3)
        """, user_id, tool_name, skill_id)

    @staticmethod
    async def get_billing_summary(
        user_id: UUID,
        start_date: date,
        end_date: date
    ) -> dict:
        """获取计费汇总"""
        pool = await get_db_pool()

        result = await pool.fetchrow("""
            SELECT
                COUNT(*) FILTER (WHERE event_type = 'llm_call') as llm_calls,
                COALESCE(SUM(input_tokens), 0) as total_input_tokens,
                COALESCE(SUM(output_tokens), 0) as total_output_tokens,
                COALESCE(SUM(estimated_cost), 0) as total_cost,
                COUNT(*) FILTER (WHERE event_type = 'skill_use') as skill_uses,
                COUNT(*) FILTER (WHERE event_type = 'tool_call') as tool_calls
            FROM usage_events
            WHERE user_id = $1
              AND created_at >= $2
              AND created_at < $3
        """, user_id, start_date, end_date)

        return dict(result)

    @staticmethod
    async def get_usage_by_skill(user_id: UUID, month: date) -> list:
        """按 Skill 统计用量"""
        pool = await get_db_pool()

        rows = await pool.fetch("""
            SELECT
                skill_id,
                COUNT(*) as call_count,
                COALESCE(SUM(input_tokens + output_tokens), 0) as tokens,
                COALESCE(SUM(estimated_cost), 0) as cost
            FROM usage_events
            WHERE user_id = $1
              AND created_at >= DATE_TRUNC('month', $2::date)
              AND created_at < DATE_TRUNC('month', $2::date) + INTERVAL '1 month'
              AND skill_id IS NOT NULL
            GROUP BY skill_id
        """, user_id, month)

        return [dict(r) for r in rows]

    @staticmethod
    def _estimate_cost(model: str, input_tokens: int, output_tokens: int) -> float:
        """成本估算 (复用 UsageTracker 的定价表)"""
        from services.agent.usage_tracker import MODEL_PRICING

        pricing = MODEL_PRICING.get("default")
        for key, p in MODEL_PRICING.items():
            if key in model.lower():
                pricing = p
                break

        return (input_tokens / 1_000_000) * pricing["input"] + \
               (output_tokens / 1_000_000) * pricing["output"]
```

#### 3. 修改调用点

```python
# chat.py / chat_v5.py - LLM 调用后

# 从 agent.usage 获取精确数据
usage = agent.usage  # UsageTracker 的数据

await UsageService.record_llm_call(
    user_id=user_id,
    model=usage.get("model", "unknown"),
    input_tokens=usage.get("input_tokens", 0),
    output_tokens=usage.get("output_tokens", 0),
    skill_id=skill.value
)

# Tool 调用时
await UsageService.record_tool_call(
    user_id=user_id,
    tool_name=tool_name,
    skill_id=skill.value
)
```

---

## 五、迁移计划整合

### 完整变更清单

| 步骤 | 文件 | 变更 |
|------|------|------|
| 1 | `migrations/018_usage_events.sql` | 新建 usage_events 表 |
| 2 | `services/usage/service.py` | 重写为统一服务 |
| 3 | `routes/chat.py` | 添加 LLM/Tool 记录 |
| 4 | `routes/chat_v5.py` | 添加 LLM/Tool 记录 |
| 5 | `routes/payment.py` | 修复 webhook (原计划) |
| 6 | `services/billing/subscription.py` | 添加 entitlement 方法 (原计划) |
| 7 | 删除 | `services/agent/quota.py` (重复) |
| 8 | 删除 | `services/identity/usage_limits.py` (重复) |
| 9 | 废弃 | `user_usage` 表, `usage_records` 表 |

### 数据结构对比

```
Before:
├── user_usage (简单)
├── usage_records (中等)
├── quota_usage (复杂)
└── quota_rules

After:
├── usage_events (统一，支持计费)
└── quota_rules (保留，用于限额规则)
```

---

## 六、账单 API 设计

```python
# routes/billing.py

@router.get("/usage/summary")
async def get_usage_summary(
    month: str = Query(...),  # 2026-01
    current_user: CurrentUser = Depends(get_current_user)
):
    """获取月度用量汇总"""
    start = datetime.strptime(month + "-01", "%Y-%m-%d")
    end = start + timedelta(days=32)
    end = end.replace(day=1)

    return await UsageService.get_billing_summary(
        current_user.user_id, start, end
    )

@router.get("/usage/by-skill")
async def get_usage_by_skill(
    month: str = Query(...),
    current_user: CurrentUser = Depends(get_current_user)
):
    """按 Skill 统计用量"""
    month_date = datetime.strptime(month + "-01", "%Y-%m-%d").date()
    return await UsageService.get_usage_by_skill(
        current_user.user_id, month_date
    )

@router.get("/usage/details")
async def get_usage_details(
    start: date = Query(...),
    end: date = Query(...),
    event_type: str = Query(None),
    current_user: CurrentUser = Depends(get_current_user)
):
    """获取用量明细"""
    return await UsageService.get_usage_details(
        current_user.user_id, start, end, event_type
    )
```

---

## 七、结论

**当前设计缺失计费支持**，需要：

1. ✅ 新建 `usage_events` 统一表
2. ✅ 重写 `UsageService` 支持计费
3. ✅ 修改 chat 路由记录精确用量
4. ✅ 添加账单 API

**与订阅迁移可并行执行**：
- 订阅迁移 → 解决支付断联
- 用量迁移 → 解决计费追踪

需要我继续执行完整迁移吗？
