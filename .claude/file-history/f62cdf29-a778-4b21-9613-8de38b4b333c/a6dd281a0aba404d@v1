"""
Embedding Service - Vector embeddings using Google Gemini (google-genai SDK)

Uses text-embedding-004 model for high-quality embeddings.
"""
import os
import time
import asyncio
from typing import List, Optional
import numpy as np
from loguru import logger

from google import genai
from google.genai import types
from google.genai.errors import ClientError


class EmbeddingService:
    """
    Embedding service using Google Gemini (google-genai SDK).

    Model: text-embedding-004
    Default Dimension: 768 (configurable)
    Rate Limit: ~150 requests/min
    """

    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")
    GEMINI_MODEL = os.getenv("GEMINI_EMBEDDING_MODEL", "text-embedding-004")

    # Default dimension for text-embedding-004
    DEFAULT_DIMENSION = int(os.getenv("GEMINI_EMBEDDING_DIMENSION", "768"))
    DIMENSION = DEFAULT_DIMENSION

    # Rate limiting
    RETRY_WAIT = 60  # seconds to wait on rate limit
    RUN_WAIT = 0.4   # seconds between requests (~150/min)
    MAX_RETRIES = 3

    _client = None

    @classmethod
    def _get_client(cls):
        """Get or create Gemini client"""
        if cls._client is None:
            api_key = cls.GEMINI_API_KEY or os.getenv("GEMINI_API_KEY", "")
            if not api_key:
                raise ValueError("GEMINI_API_KEY not configured")
            cls._client = genai.Client(api_key=api_key)
        return cls._client

    @classmethod
    async def embed_text(
        cls,
        text: str,
        output_dimensionality: Optional[int] = None
    ) -> List[float]:
        """
        Generate embedding for single text (for documents/storage).

        Args:
            text: Text to embed
            output_dimensionality: Output dimension, defaults to 768

        Returns:
            Embedding vector
        """
        dim = output_dimensionality or cls.DEFAULT_DIMENSION
        client = cls._get_client()

        for attempt in range(cls.MAX_RETRIES):
            try:
                # Rate limiting
                await asyncio.sleep(cls.RUN_WAIT)

                result = client.models.embed_content(
                    model=cls.GEMINI_MODEL,
                    contents=text,
                    config=types.EmbedContentConfig(
                        task_type="RETRIEVAL_DOCUMENT",
                        output_dimensionality=dim
                    )
                )

                embedding = result.embeddings[0].values
                return list(embedding)

            except ClientError as e:
                if "429" in str(e) or "RESOURCE_EXHAUSTED" in str(e):
                    logger.warning(f"Rate limited, waiting {cls.RETRY_WAIT}s...")
                    await asyncio.sleep(cls.RETRY_WAIT)
                else:
                    raise
            except Exception as e:
                if attempt < cls.MAX_RETRIES - 1:
                    logger.warning(f"Embed attempt {attempt + 1} failed: {e}")
                    await asyncio.sleep(cls.RETRY_WAIT)
                else:
                    raise

        raise RuntimeError("Max retries exceeded for embedding")

    @classmethod
    async def embed_query(
        cls,
        query: str,
        output_dimensionality: Optional[int] = None
    ) -> List[float]:
        """
        Generate embedding for search query.

        Args:
            query: Query text
            output_dimensionality: Output dimension, defaults to 768

        Returns:
            Embedding vector
        """
        dim = output_dimensionality or cls.DEFAULT_DIMENSION
        client = cls._get_client()

        for attempt in range(cls.MAX_RETRIES):
            try:
                await asyncio.sleep(cls.RUN_WAIT)

                result = client.models.embed_content(
                    model=cls.GEMINI_MODEL,
                    contents=query,
                    config=types.EmbedContentConfig(
                        task_type="RETRIEVAL_QUERY",
                        output_dimensionality=dim
                    )
                )

                embedding = result.embeddings[0].values
                return list(embedding)

            except ClientError as e:
                if "429" in str(e) or "RESOURCE_EXHAUSTED" in str(e):
                    logger.warning(f"Rate limited, waiting {cls.RETRY_WAIT}s...")
                    await asyncio.sleep(cls.RETRY_WAIT)
                else:
                    raise
            except Exception as e:
                if attempt < cls.MAX_RETRIES - 1:
                    logger.warning(f"Embed query attempt {attempt + 1} failed: {e}")
                    await asyncio.sleep(cls.RETRY_WAIT)
                else:
                    raise

        raise RuntimeError("Max retries exceeded for query embedding")

    @classmethod
    async def embed_batch(
        cls,
        texts: List[str],
        output_dimensionality: Optional[int] = None
    ) -> List[List[float]]:
        """Generate embeddings for multiple texts"""
        embeddings = []
        for text in texts:
            embedding = await cls.embed_text(text, output_dimensionality)
            embeddings.append(embedding)
        return embeddings

    @classmethod
    def get_dimension(cls) -> int:
        """Return current embedding dimension"""
        return cls.DEFAULT_DIMENSION

    @staticmethod
    def _normalize(embedding: List[float]) -> List[float]:
        """L2 normalize embedding vector."""
        arr = np.array(embedding)
        norm = np.linalg.norm(arr)
        if norm > 0:
            arr = arr / norm
        return arr.tolist()
