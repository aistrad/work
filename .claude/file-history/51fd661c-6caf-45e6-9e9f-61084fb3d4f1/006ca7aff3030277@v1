"""
VibeLife Skill Builder - Tool Handlers (v10.3)
文件位置: .claude/skills/vibelife-skill/tools/handlers.py

使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。
"""
import logging
from typing import Dict, Any, List, Optional
from dataclasses import dataclass

from services.agent.tool_registry import tool_handler, ToolContext, ToolRegistry

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════════
# 收集工具 (Collect Tools)
# ═══════════════════════════════════════════════════════════════════════════════

@tool_handler("request_skill_info")
async def execute_request_skill_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """
    收集构建 Skill 所需的基本信息

    Args:
        args: 工具参数
            - missing_fields: 缺失的字段列表
        context: 工具上下文

    Returns:
        收集表单卡片
    """
    missing_fields = args.get("missing_fields", ["skill_id", "domain", "source_path"])

    fields = []

    if "skill_id" in missing_fields:
        fields.append({
            "id": "skill_id",
            "label": "Skill ID",
            "type": "text",
            "required": True,
            "placeholder": "例如: zodiac, bazi, tarot",
            "description": "Skill 的唯一标识符，使用 kebab-case 格式"
        })

    if "domain" in missing_fields:
        fields.append({
            "id": "domain",
            "label": "领域描述",
            "type": "textarea",
            "required": True,
            "placeholder": "描述这个 Skill 的专业领域...",
            "description": "简要描述 Skill 的专业领域和核心能力"
        })

    if "source_path" in missing_fields:
        fields.append({
            "id": "source_path",
            "label": "源文件路径",
            "type": "text",
            "required": True,
            "placeholder": "/path/to/knowledge/files",
            "description": "知识源文件或目录的路径"
        })

    if "knowledge_type" in missing_fields:
        fields.append({
            "id": "knowledge_type",
            "label": "知识类型",
            "type": "select",
            "required": True,
            "options": [
                {"value": "case", "label": "案例型知识"},
                {"value": "rule", "label": "规则型知识"},
                {"value": "encyclopedia", "label": "百科型知识"},
                {"value": "mixed", "label": "混合型知识"}
            ],
            "description": "选择主要的知识类型"
        })

    return {
        "status": "collecting",
        "cardType": "collect_form",
        "formType": "skill_info",
        "title": "Skill 构建信息",
        "description": "请提供以下信息以开始构建 Skill",
        "fields": fields,
    }


# ═══════════════════════════════════════════════════════════════════════════════
# 计算工具 (Compute Tools)
# ═══════════════════════════════════════════════════════════════════════════════

@tool_handler("run_pipeline")
async def execute_run_pipeline(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """
    执行知识入库流水线

    Args:
        args: 工具参数
            - skill_id: 目标 Skill 标识符
            - source_path: 源文件路径
            - stages: 要执行的阶段列表
            - options: 流水线选项
        context: 工具上下文

    Returns:
        流水线执行结果
    """
    skill_id = args.get("skill_id")
    source_path = args.get("source_path")
    stages = args.get("stages", [0, 1, 2, 3, 6])
    options = args.get("options", {})

    if not skill_id:
        return {
            "status": "error",
            "error": "缺少 skill_id 参数",
            "action": "request_skill_info"
        }

    if not source_path:
        return {
            "status": "error",
            "error": "缺少 source_path 参数",
            "action": "request_skill_info"
        }

    try:
        # 执行流水线
        # TODO: 实现实际的流水线执行逻辑
        # from services.knowledge import KnowledgePipeline
        # pipeline = KnowledgePipeline(skill_id, source_path, options)
        # result = await pipeline.run(stages)

        # 模拟执行结果
        result = {
            "skill_id": skill_id,
            "source_path": source_path,
            "stages_completed": stages,
            "stats": {
                "documents_processed": 0,
                "chunks_created": 0,
                "vectors_generated": 0,
                "errors": 0
            }
        }

        logger.info(f"Pipeline completed for skill: {skill_id}")

        # 展示进度卡片
        return await ToolRegistry.execute(
            "show_card",
            {
                "card_type": "custom",
                "data_source": {"type": "inline", "data": {
                    "skill_id": skill_id,
                    "stage": "completed",
                    "progress": 100,
                    "message": "流水线执行完成",
                    "details": result["stats"]
                }},
                "options": {"componentId": "vibelife_skill_progress"}
            },
            context
        )

    except Exception as e:
        logger.error(f"Pipeline failed for skill {skill_id}: {e}")
        return {
            "status": "error",
            "error": f"流水线执行失败: {str(e)}",
        }


@tool_handler("run_extractor")
async def execute_run_extractor(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """
    执行 Case/Rule 抽取

    Args:
        args: 工具参数
            - skill_id: 目标 Skill 标识符
            - extract_type: 抽取类型 (case/rule/both)
            - source_ids: 要处理的源文档 ID 列表
        context: 工具上下文

    Returns:
        抽取执行结果
    """
    skill_id = args.get("skill_id")
    extract_type = args.get("extract_type", "both")
    source_ids = args.get("source_ids")

    if not skill_id:
        return {
            "status": "error",
            "error": "缺少 skill_id 参数",
            "action": "request_skill_info"
        }

    try:
        # 执行抽取
        # TODO: 实现实际的抽取逻辑
        # from services.extraction import Extractor
        # extractor = Extractor(skill_id)
        # result = await extractor.run(extract_type, source_ids)

        # 模拟执行结果
        result = {
            "skill_id": skill_id,
            "extract_type": extract_type,
            "stats": {
                "cases_extracted": 0 if extract_type == "rule" else 0,
                "rules_extracted": 0 if extract_type == "case" else 0,
                "errors": 0
            }
        }

        logger.info(f"Extraction completed for skill: {skill_id}, type: {extract_type}")

        return await ToolRegistry.execute(
            "show_card",
            {
                "card_type": "custom",
                "data_source": {"type": "inline", "data": {
                    "skill_id": skill_id,
                    "stage": "extracting",
                    "progress": 100,
                    "message": f"{extract_type} 抽取完成",
                    "details": result["stats"]
                }},
                "options": {"componentId": "vibelife_skill_progress"}
            },
            context
        )

    except Exception as e:
        logger.error(f"Extraction failed for skill {skill_id}: {e}")
        return {
            "status": "error",
            "error": f"抽取执行失败: {str(e)}",
        }


# ═══════════════════════════════════════════════════════════════════════════════
# 展示工具 (Display Tools)
# ═══════════════════════════════════════════════════════════════════════════════

@tool_handler("show_build_progress")
async def execute_show_build_progress(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """
    展示 Skill 构建进度卡片

    Args:
        args: 工具参数
            - skill_id: 目标 Skill 标识符
            - stage: 当前阶段
            - progress: 进度百分比
            - message: 状态消息
            - details: 详细信息
        context: 工具上下文

    Returns:
        进度卡片
    """
    skill_id = args.get("skill_id")
    stage = args.get("stage", "unknown")
    progress = args.get("progress", 0)
    message = args.get("message", "")
    details = args.get("details", {})

    if not skill_id:
        return {
            "status": "error",
            "error": "缺少 skill_id 参数",
        }

    # 阶段名称映射
    stage_names = {
        "preprocessing": "预处理",
        "chunking": "文本切块",
        "vectorizing": "向量化",
        "indexing": "索引构建",
        "extracting": "知识抽取",
        "quality_check": "质量检查",
        "completed": "已完成"
    }

    card_data = {
        "skill_id": skill_id,
        "stage": stage,
        "stage_name": stage_names.get(stage, stage),
        "progress": progress,
        "message": message,
        "details": details,
    }

    return await ToolRegistry.execute(
        "show_card",
        {
            "card_type": "custom",
            "data_source": {"type": "inline", "data": card_data},
            "options": {"componentId": "vibelife_skill_progress"}
        },
        context
    )


@tool_handler("show_quality_report")
async def execute_show_quality_report(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """
    展示 Skill 知识库质量报告

    Args:
        args: 工具参数
            - skill_id: 目标 Skill 标识符
            - metrics: 质量指标
            - distribution: 知识分布
            - issues: 发现的问题
            - recommendations: 改进建议
        context: 工具上下文

    Returns:
        质量报告卡片
    """
    skill_id = args.get("skill_id")
    metrics = args.get("metrics", {})
    distribution = args.get("distribution", {})
    issues = args.get("issues", [])
    recommendations = args.get("recommendations", [])

    if not skill_id:
        return {
            "status": "error",
            "error": "缺少 skill_id 参数",
        }

    # 计算总体评分
    coverage = metrics.get("coverage", 0)
    accuracy = metrics.get("accuracy", 0)
    completeness = metrics.get("completeness", 0)
    overall_score = (coverage + accuracy + completeness) / 3

    # 评级
    if overall_score >= 0.9:
        rating = "优秀"
        rating_color = "green"
    elif overall_score >= 0.7:
        rating = "良好"
        rating_color = "blue"
    elif overall_score >= 0.5:
        rating = "一般"
        rating_color = "yellow"
    else:
        rating = "需改进"
        rating_color = "red"

    card_data = {
        "skill_id": skill_id,
        "metrics": {
            "coverage": coverage,
            "accuracy": accuracy,
            "completeness": completeness,
            "overall_score": overall_score,
        },
        "rating": rating,
        "rating_color": rating_color,
        "distribution": distribution,
        "issues": issues,
        "recommendations": recommendations,
    }

    return await ToolRegistry.execute(
        "show_card",
        {
            "card_type": "custom",
            "data_source": {"type": "inline", "data": card_data},
            "options": {"componentId": "vibelife_skill_quality"}
        },
        context
    )


# ═══════════════════════════════════════════════════════════════════════════════
# 工具执行器编写指南
# ═══════════════════════════════════════════════════════════════════════════════
#
# 1. 装饰器注册
#    使用 @tool_handler("tool_name") 装饰器注册执行器
#    tool_name 必须与 tools.yaml 中定义的 name 一致
#
# 2. 函数签名
#    async def execute_xxx(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]
#    - args: 从 LLM 传入的工具参数
#    - context: 包含用户信息、Skill 数据等上下文
#
# 3. 返回格式
#    成功（展示卡片）:
#    return await ToolRegistry.execute("show_card", {...}, context)
#
#    错误情况:
#    return {"status": "error", "error": "错误描述", "action": "suggested_tool"}
#
#    收集信息:
#    return {"status": "collecting", "cardType": "collect_form", ...}
#
# 4. ToolContext 属性
#    - user_id: str          用户ID
#    - user_tier: str        用户等级 (free/premium/vip)
#    - profile: Dict         用户档案数据
#    - skill_data: Dict      Skill 相关数据
#    - skill_id: str         当前 Skill ID
