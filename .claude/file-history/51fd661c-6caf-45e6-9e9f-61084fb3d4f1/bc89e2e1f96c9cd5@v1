---
id: skill-spec
name: Skill 完整规范
impact: CRITICAL
tags: 架构, Phase, SKILL.md, 工具定义, 规范
---

# VibeLife Skill 完整规范 v10.3

本文档合并了架构设计、SKILL.md 规范和工具定义三个核心内容。

---

## 1. 核心架构：Phase 1/2 机制

### 1.1 流程图

```
用户消息
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Phase 1: 路由阶段                                        │
│ ─────────────────                                       │
│ System Prompt: routing.yaml (~1000 字符)                │
│ 工具: activate_skill, recommend_skills, ask_user_question│
│                                                         │
│ LLM 决策:                                               │
│   - 用户意图明确 → activate_skill(skill="xxx")          │
│   - 用户意图不明确 → recommend_skills()                 │
│   - 需要更多信息 → ask_user_question()                  │
└─────────────────────────────────────────────────────────┘
    │
    │ activate_skill 被调用
    ▼
┌─────────────────────────────────────────────────────────┐
│ Phase 2: 执行阶段                                        │
│ ─────────────────                                       │
│ System Prompt: SKILL.md 全文 + User Context (~4000 字符) │
│ 工具: Skill 专属工具 + 全局工具                          │
│                                                         │
│ LLM 执行:                                               │
│   - 按 SKILL.md 中的规则分析                            │
│   - 调用计算工具获取数据                                 │
│   - 调用展示工具渲染卡片                                 │
└─────────────────────────────────────────────────────────┘
```

### 1.2 关键代码位置

| 功能 | 文件 | 关键函数/位置 |
|-----|------|-------------|
| Phase 1 Prompt | `apps/api/skills/core/config/routing.yaml` | `phase1_prompt` |
| Phase 2 Prompt | `apps/api/services/agent/skill_loader.py` | `build_system_prompt()` |
| Skill 激活 | `apps/api/services/agent/core.py:444` | `result.should_reload_context` |
| 工具执行 | `apps/api/services/agent/tool_executor.py` | `_handle_activate_skill()` |

### 1.3 SKILL.md 全文加载

**关键原则**：SKILL.md 全文（去掉 frontmatter）会被加载到 Phase 2 的 System Prompt。

```python
# skill_loader.py
@lru_cache(maxsize=32)
def _load_skill_md_content(skill_id: str) -> str:
    text = skill_path.read_text(encoding='utf-8')
    _, content = parse_frontmatter(text)  # 去掉 frontmatter
    return content  # 全文返回
```

---

## 2. SKILL.md 编写规范

### 2.1 完整模板

```markdown
---
name: {skill-id}
description: {一句话描述}。触发词：{词1}、{词2}、{词3}。
category: {类别}
requires_birth_info: true/false
requires_compute: true/false
compute_tool: {计算工具名}
collect_tool: {收集工具名}
external_tools: [tool1, tool2]
---

# {Skill 中文名} Skill

## 专家身份

{专家角色描述，2-3 段}

**强制工具调用规则（必须遵守）**：
- **禁止编造数据**！必须调用 `{compute_tool}` 工具计算
- 用户提供信息后，**必须**先调用 `{compute_tool}(参数...)`
- 计算完成后，**必须**调用 `{display_tool}` 展示卡片
- **禁止**在文本中直接写分析结果而不调用工具
- **禁止**在用户已提供信息时调用 `{collect_tool}`

---

## 核心能力索引

| 能力 | 优先级 | 规则文件 | 触发场景 |
|-----|-------|---------|---------|
| {能力 1} | CRITICAL | `rules/{file}.md` | {触发场景} |

---

## 工具快速参考

### 收集工具
| 工具 | 用途 | 何时调用 |
|-----|------|---------|
| `{collect_tool}` | 收集用户信息 | 用户**未**提供信息时 |

### 计算工具
| 工具 | 用途 | 何时调用 |
|-----|------|---------|
| `{compute_tool}` | 计算数据 | 用户提供信息后**必须**调用 |

### 展示工具
| 工具 | 用途 | 何时调用 |
|-----|------|---------|
| `{display_tool}` | 展示结果卡片 | 计算完成后**必须**调用 |

---

## 服务原则

1. **框架完整**：按分析规则覆盖关键要点
2. **知识支撑**：结论必须有知识库检索支撑
3. **工具优先**：用工具展示结果，不要纯文字
4. **引导深入**：分析后引导用户探索更多

---

## 伦理边界

### 绝对禁止
- {禁止事项}

### 敏感话题处理
| 话题 | 处理方式 |
|-----|---------|
| {话题} | {处理方式} |
```

### 2.2 Frontmatter 字段说明

| 字段 | 必须 | 说明 |
|-----|------|------|
| `name` | 是 | Skill ID，kebab-case |
| `description` | 是 | 一句话描述 + 触发词 |
| `category` | 否 | 类别 |
| `requires_birth_info` | 否 | 是否需要出生信息 |
| `requires_compute` | 否 | 是否需要计算 |
| `compute_tool` | 否 | 计算工具名称 |
| `collect_tool` | 否 | 收集工具名称 |
| `external_tools` | 否 | 从其他 skill 导入的工具 |

### 2.3 强制工具调用规则（关键）

**位置**：必须在 `## 专家身份` 章节内

**作用**：防止 LLM 编造数据、明确工具调用顺序

**缺失后果**：LLM 会直接编造数据，不调用工具

---

## 3. 工具定义规范

### 3.1 工具分类

| 类别 | 前缀 | 说明 | 示例 |
|-----|------|------|------|
| 收集 | `collect_` | 收集用户信息 | `collect_zodiac_info` |
| 计算 | `calculate_` | 内部计算 | `calculate_zodiac` |
| 展示 | `show_` | 展示卡片 | `show_zodiac_chart` |
| 检索 | `search_` | 检索知识库 | `search_db` |
| 请求 | `request_` | 请求补充信息 | `request_info` |
| 保存 | `save_` | 保存用户数据 | `save_birth_info` |

### 3.2 tools.yaml 结构

```yaml
version: "1.0"
skill_id: {skill_id}

compute:
  - name: calculate_xxx
    description: 计算描述
    card_type: xxx_chart
    when_to_call: 用户提供信息后
    parameters:
      - name: param1
        type: string
        required: true
        description: 参数描述

collect:
  - name: collect_xxx_info
    description: 收集用户信息
    card_type: collect_form
    when_to_call: 用户未提供信息时
    parameters: [...]

display:
  - name: show_xxx_chart
    description: 展示图表卡片
    card_type: xxx_chart
    when_to_call: 用户想看图表时
    parameters: [...]
```

### 3.3 handlers.py 结构

```python
"""
{Skill Name} Tool Handlers
使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。
"""
from typing import Dict, Any
from services.agent.tool_registry import tool_handler, ToolContext

@tool_handler("calculate_xxx")
async def execute_calculate_xxx(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """计算工具"""
    # 从 args 或 profile 获取参数
    param1 = args.get("param1") or context.profile.get("identity", {}).get("param1")

    if not param1:
        return {"status": "error", "error": "需要参数", "action": "collect_xxx_info"}

    # 执行计算
    result = calculate_xxx(param1=param1)

    # 返回卡片
    return await ToolRegistry.execute("show_card", {
        "card_type": "custom",
        "data_source": {"type": "inline", "data": result},
        "options": {"componentId": "xxx_chart"}
    }, context)

@tool_handler("collect_xxx_info")
async def execute_collect_xxx_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """收集用户信息"""
    return {
        "status": "collecting",
        "cardType": "collect_form",
        "formType": "xxx_info",
        "title": "请填写信息",
        "fields": [
            {"id": "field1", "label": "字段1", "type": "text", "required": True},
        ],
    }
```

### 3.4 ToolContext 说明

```python
@dataclass
class ToolContext:
    user_id: str              # 用户 ID
    conversation_id: str      # 会话 ID
    skill_id: str             # 当前 Skill ID
    profile: Optional[Dict]   # 用户 Profile
    skill_data: Optional[Dict] # Skill 专属数据
```

### 3.5 全局工具

| 工具 | 用途 |
|-----|------|
| `search_db` | 检索知识库 |
| `show_card` | 通用卡片展示 |
| `show_insight` | 洞察卡片 |
| `request_info` | 请求信息 |
| `save_birth_info` | 保存出生信息 |
| `activate_skill` | 激活 Skill（Phase 1） |
| `recommend_skills` | 推荐 Skills |
| `ask_user_question` | 问用户问题 |

---

## 4. 目录结构

```
apps/api/skills/{skill_id}/
├── SKILL.md                 # 核心定义（全文加载到 prompt）
├── rules/                   # 分析规则（按需加载）
│   ├── _index.md            # 规则索引
│   └── {capability}.md      # 各能力规则
├── tools/
│   ├── tools.yaml           # 工具定义
│   └── handlers.py          # 工具执行器
└── services/                # 服务实现（可选）
    └── api.py               # 计算服务
```

---

## 5. 检查清单

### SKILL.md 检查

- [ ] Frontmatter 包含 name 和 description
- [ ] description 包含触发词
- [ ] 包含"强制工具调用规则"
- [ ] 强制规则位于"专家身份"章节内
- [ ] 核心能力索引表格完整
- [ ] 工具快速参考按类别分组

### 工具检查

- [ ] tools.yaml 定义完整（name, description, parameters, when_to_call）
- [ ] handlers.py 使用 `@tool_handler` 装饰器
- [ ] 函数签名为 `async def xxx(args: Dict, context: ToolContext)`
- [ ] 错误返回 `{status: "error", error: "...", action: "..."}`
- [ ] 展示工具使用 `ToolRegistry.execute("show_card", ...)` 委托

---

## 6. 常见问题

### Q1: LLM 仍然编造数据？

检查点：
1. SKILL.md 中是否有"强制工具调用规则"
2. 规则是否在 `## 专家身份` 章节内
3. 日志中 `system_prompt_len` 是否足够大

### Q2: 工具调用了但卡片没显示？

检查点：
1. 工具返回的 `cardType` 是否正确
2. 前端是否注册了对应的卡片组件
3. `ChatMessage.tsx` 是否正确处理该 cardType
