"""
Synastry Skill å·¥å…·æ‰§è¡Œå™¨

å®ç°åˆç›˜åŠŸèƒ½çš„æ ¸å¿ƒå·¥å…·ï¼š
- collect_synastry_info: æ”¶é›†å¯¹æ–¹ä¿¡æ¯
- select_relationship: é€‰æ‹©å·²ä¿å­˜çš„å…³ç³»å¯¹è±¡
- calculate_synastry: è®¡ç®—åˆç›˜
- show_synastry_overview: å±•ç¤ºåˆç›˜æ€»è§ˆ
- save_relationship: ä¿å­˜å…³ç³»å¯¹è±¡
- save_synastry_insight: ä¿å­˜åˆç›˜æ´å¯Ÿ
"""

import logging
from typing import Dict, Any
from datetime import datetime, timezone

from services.tool_registry import tool_handler, ToolContext, ToolRegistry
from stores.unified_profile_repo import UnifiedProfileRepository

logger = logging.getLogger(__name__)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Collect Tools
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@tool_handler("collect_synastry_info")
async def execute_collect_synastry_info(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    æ”¶é›†åˆç›˜å¯¹è±¡çš„å‡ºç”Ÿä¿¡æ¯

    å±•ç¤º CollectSynastryInfoCard è¡¨å•
    """
    return await ToolRegistry.execute("show_card", {
        "cardType": "collect_synastry_info",
        "title": "å‘Šè¯‰æˆ‘ TA çš„ä¿¡æ¯",
        "fields": [
            {
                "name": "relationship_type",
                "type": "select",
                "label": "TA æ˜¯ä½ çš„...",
                "required": True,
                "options": [
                    {"value": "romantic", "label": "æ‹äºº/çº¦ä¼šå¯¹è±¡", "icon": "ğŸ’•"},
                    {"value": "spouse", "label": "é…å¶/ä¼´ä¾£", "icon": "ğŸ’"},
                    {"value": "parent_child", "label": "äº²å­", "icon": "ğŸ‘¨â€ğŸ‘§"},
                    {"value": "sibling", "label": "å…„å¼Ÿå§å¦¹", "icon": "ğŸ‘«"},
                    {"value": "business", "label": "åˆä¼™äºº/åŒäº‹", "icon": "ğŸ¤"},
                    {"value": "friend", "label": "æœ‹å‹", "icon": "ğŸ‘¥"},
                ]
            },
            {
                "name": "person_name",
                "type": "text",
                "label": "TA å«ä»€ä¹ˆï¼Ÿ",
                "placeholder": "å§“åæˆ–æ˜µç§°",
                "required": True
            },
            {
                "name": "birth_date",
                "type": "date",
                "label": "TA ä»€ä¹ˆæ—¶å€™å‡ºç”Ÿï¼Ÿ",
                "required": True
            },
            {
                "name": "birth_time",
                "type": "time",
                "label": "å‡ºç”Ÿæ—¶é—´ï¼ˆå¯é€‰ï¼‰",
                "required": False,
                "placeholder": "ä¸ç¡®å®šå¯ä»¥ä¸å¡«"
            },
            {
                "name": "birth_place",
                "type": "location",
                "label": "TA åœ¨å“ªé‡Œå‡ºç”Ÿï¼Ÿ",
                "placeholder": "æœç´¢åŸå¸‚...",
                "required": True
            },
            {
                "name": "save_relationship",
                "type": "checkbox",
                "label": "ä¿å­˜ TAï¼Œæ–¹ä¾¿ä¸‹æ¬¡æŸ¥çœ‹",
                "default": True
            }
        ],
        "submitLabel": "å¼€å§‹åˆ†æ"
    }, context)


@tool_handler("select_relationship")
async def execute_select_relationship(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    å±•ç¤ºå·²ä¿å­˜çš„å…³ç³»å¯¹è±¡åˆ—è¡¨

    è®©ç”¨æˆ·é€‰æ‹©å·²æœ‰å¯¹è±¡æˆ–æ·»åŠ æ–°çš„
    """
    # ä» VibeRelationship è·å–å…³ç³»åˆ—è¡¨
    user_id = context.user_id
    relationships = await UnifiedProfileRepository.get_vibe_relationships(user_id)

    # æ ¼å¼åŒ–å…³ç³»åˆ—è¡¨
    formatted_relationships = []
    for rel in relationships:
        formatted_relationships.append({
            "id": rel.get("id"),
            "name": rel.get("name"),
            "type": rel.get("type"),
            "typeLabel": _get_relationship_type_label(rel.get("type")),
            "typeIcon": _get_relationship_type_icon(rel.get("type")),
            "lastSynastryAt": rel.get("last_synastry_at"),
            "hasSynastry": bool(rel.get("synastry"))
        })

    return await ToolRegistry.execute("show_card", {
        "cardType": "select_relationship",
        "title": "ä½ æƒ³çœ‹å’Œè°çš„åˆç›˜ï¼Ÿ",
        "relationships": formatted_relationships,
        "allowAddNew": True,
        "addNewLabel": "æ·»åŠ æ–°çš„äºº"
    }, context)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Compute Tools
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@tool_handler("calculate_synastry")
async def execute_calculate_synastry(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    è®¡ç®—åˆç›˜åˆ†æ

    æ ¹æ®ç”¨æˆ·å·²è®¢é˜…çš„ Skill è‡ªåŠ¨è®¡ç®—å¯¹åº”ç»´åº¦
    """
    from skills.synastry.services.synastry_engine import SynastryEngine

    user_id = context.user_id
    profile = context.profile

    # è§£æå‚æ•°
    person2_birth_info = args.get("person2_birth_info", {})
    relationship_type = args.get("relationship_type", "romantic")
    relationship_id = args.get("relationship_id")
    person_name = args.get("person_name", "TA")
    save_relationship = args.get("save_relationship", True)

    # è·å–ç”¨æˆ·å‡ºç”Ÿä¿¡æ¯
    identity = profile.get("identity", {})
    user_birth_info = identity.get("birth_info", {})

    if not user_birth_info.get("date"):
        return {
            "success": False,
            "error": "è¯·å…ˆå®Œå–„ä½ çš„å‡ºç”Ÿä¿¡æ¯",
            "_hint": {"action": "collect_birth_info"}
        }

    if not person2_birth_info.get("date"):
        return {
            "success": False,
            "error": "éœ€è¦å¯¹æ–¹çš„å‡ºç”Ÿæ—¥æœŸæ‰èƒ½è®¡ç®—åˆç›˜"
        }

    # è·å–ç”¨æˆ·å·²è®¢é˜…çš„ Skillï¼ˆMVP åªéœ€è¦ zodiacï¼‰
    subscribed_skills = await UnifiedProfileRepository.get_subscribed_skill_ids(user_id)

    # ç¡®ä¿ zodiac åœ¨è®¢é˜…åˆ—è¡¨ä¸­ï¼ˆåˆç›˜åŸºç¡€åŠŸèƒ½ï¼‰
    if "zodiac" not in subscribed_skills:
        subscribed_skills.append("zodiac")

    # è®¡ç®—åˆç›˜
    engine = SynastryEngine()
    result = await engine.calculate(
        user_birth_info=user_birth_info,
        partner_birth_info=person2_birth_info,
        relationship_type=relationship_type,
        subscribed_skills=subscribed_skills
    )

    # å¦‚æœéœ€è¦ä¿å­˜å…³ç³»å¯¹è±¡
    if save_relationship and not relationship_id:
        relationship_id = await UnifiedProfileRepository.add_vibe_relationship(
            user_id,
            {
                "name": person_name,
                "type": relationship_type,
                "birth_info": person2_birth_info
            }
        )

    # ä¿å­˜åˆç›˜æ´å¯Ÿåˆ°å…³ç³»å¯¹è±¡
    if relationship_id and result.dimensions:
        for dim in result.dimensions:
            await UnifiedProfileRepository.save_synastry_insight(
                user_id,
                relationship_id,
                dim.skill_id,
                {
                    "overall_score": dim.score,
                    "summary": dim.summary,
                    "categories": dim.data.get("categories", []),
                    "aspects": dim.data.get("aspects", []),
                    "strengths": dim.data.get("strengths", []),
                    "challenges": dim.data.get("challenges", []),
                    "advice": dim.data.get("advice", "")
                }
            )

    # æ„å»ºè¿”å›æ•°æ®
    user_name = profile.get("identity", {}).get("display_name") or "ä½ "

    return {
        "success": True,
        "result": {
            "person1": {
                "name": user_name,
            },
            "person2": {
                "name": person_name,
                "birthInfo": person2_birth_info
            },
            "relationshipType": relationship_type,
            "overallScore": result.overall_score,
            "overallLabel": engine.get_score_label(result.overall_score),
            "dimensions": [
                {
                    "skill": dim.skill_id,
                    "name": _get_skill_display_name(dim.skill_id),
                    "icon": _get_skill_icon(dim.skill_id),
                    "score": dim.score,
                    "summary": dim.summary,
                    "data": dim.data
                }
                for dim in result.dimensions
            ],
            "strengths": result.strengths,
            "challenges": result.challenges,
            "advice": result.advice,
            "relationshipId": relationship_id
        },
        "_hint": {
            "action": "show_synastry_results",
            "message": "åˆç›˜è®¡ç®—å®Œæˆï¼Œè¯·å±•ç¤º SynastryOverviewCard"
        }
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Display Tools
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@tool_handler("show_synastry_overview")
async def execute_show_synastry_overview(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    å±•ç¤ºåˆç›˜æ€»è§ˆå¡ç‰‡
    """
    return await ToolRegistry.execute("show_card", {
        "cardType": "synastry_overview",
        "person1": args.get("person1"),
        "person2": args.get("person2"),
        "relationshipType": args.get("relationship_type"),
        "overallScore": args.get("overall_score"),
        "overallLabel": args.get("overall_label") or _get_score_label(args.get("overall_score", 0)),
        "dimensions": args.get("dimensions", []),
        "strengths": args.get("strengths", []),
        "challenges": args.get("challenges", []),
        "advice": args.get("advice", [])
    }, context)


@tool_handler("show_zodiac_synastry")
async def execute_show_zodiac_synastry(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    å±•ç¤ºæ˜Ÿåº§åˆç›˜è¯¦æƒ…
    """
    return await ToolRegistry.execute("show_card", {
        "cardType": "zodiac_synastry_detail",
        **args.get("synastry_data", {})
    }, context)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Action Tools
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@tool_handler("save_relationship")
async def execute_save_relationship(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    ä¿å­˜å…³ç³»å¯¹è±¡åˆ° VibeRelationship
    """
    user_id = context.user_id

    relationship_data = {
        "name": args.get("name"),
        "type": args.get("relationship_type"),
        "birth_info": args.get("birth_info")
    }

    relationship_id = await UnifiedProfileRepository.add_vibe_relationship(
        user_id, relationship_data
    )

    return {
        "success": True,
        "relationshipId": relationship_id,
        "message": f"å·²ä¿å­˜ {args.get('name')} çš„ä¿¡æ¯"
    }


@tool_handler("save_synastry_insight")
async def execute_save_synastry_insight(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    ä¿å­˜åˆç›˜æ´å¯Ÿåˆ° VibeRelationship
    """
    user_id = context.user_id
    relationship_id = args.get("relationship_id")
    skill_id = args.get("skill_id", "zodiac")
    insight = args.get("insight", {})

    if not relationship_id:
        return {"success": False, "error": "relationship_id æ˜¯å¿…éœ€çš„"}

    success = await UnifiedProfileRepository.save_synastry_insight(
        user_id, relationship_id, skill_id, insight
    )

    if not success:
        return {"success": False, "error": "å…³ç³»å¯¹è±¡ä¸å­˜åœ¨"}

    return {
        "success": True,
        "message": "åˆç›˜æ´å¯Ÿå·²ä¿å­˜"
    }


@tool_handler("get_synastry_history")
async def execute_get_synastry_history(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    è·å–ä¸æŸäººçš„åˆç›˜å†å²
    """
    user_id = context.user_id
    relationship_id = args.get("relationship_id")

    if not relationship_id:
        return {"success": False, "error": "relationship_id æ˜¯å¿…éœ€çš„"}

    relationship = await UnifiedProfileRepository.get_vibe_relationship_by_id(
        user_id, relationship_id
    )

    if not relationship:
        return {"success": False, "error": "å…³ç³»å¯¹è±¡ä¸å­˜åœ¨"}

    synastry = relationship.get("synastry", {})

    return {
        "success": True,
        "relationship": {
            "id": relationship.get("id"),
            "name": relationship.get("name"),
            "type": relationship.get("type"),
            "typeLabel": _get_relationship_type_label(relationship.get("type")),
            "lastSynastryAt": relationship.get("last_synastry_at")
        },
        "synastry": synastry
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Helper Functions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _get_relationship_type_label(rel_type: str) -> str:
    """è·å–å…³ç³»ç±»å‹çš„æ˜¾ç¤ºæ ‡ç­¾"""
    labels = {
        "romantic": "æ‹äºº",
        "spouse": "ä¼´ä¾£",
        "parent_child": "äº²å­",
        "sibling": "å…„å¼Ÿå§å¦¹",
        "business": "åˆä¼™äºº",
        "friend": "æœ‹å‹"
    }
    return labels.get(rel_type, rel_type)


def _get_relationship_type_icon(rel_type: str) -> str:
    """è·å–å…³ç³»ç±»å‹çš„å›¾æ ‡"""
    icons = {
        "romantic": "ğŸ’•",
        "spouse": "ğŸ’",
        "parent_child": "ğŸ‘¨â€ğŸ‘§",
        "sibling": "ğŸ‘«",
        "business": "ğŸ¤",
        "friend": "ğŸ‘¥"
    }
    return icons.get(rel_type, "ğŸ‘¤")


def _get_skill_display_name(skill_id: str) -> str:
    """è·å– Skill çš„æ˜¾ç¤ºåç§°"""
    names = {
        "zodiac": "æ˜Ÿåº§å¥‘åˆ",
        "bazi": "å…«å­—é…å¯¹",
        "jungastro": "å¿ƒç†å¥‘åˆ"
    }
    return names.get(skill_id, skill_id)


def _get_skill_icon(skill_id: str) -> str:
    """è·å– Skill çš„å›¾æ ‡"""
    icons = {
        "zodiac": "â™ˆ",
        "bazi": "â˜¯",
        "jungastro": "ğŸ§ "
    }
    return icons.get(skill_id, "âœ¨")


def _get_score_label(score: int) -> str:
    """æ ¹æ®åˆ†æ•°è·å–è¯„ä»·æ ‡ç­¾"""
    if score >= 85:
        return "å¤©ä½œä¹‹åˆ"
    elif score >= 70:
        return "é»˜å¥‘ç»„åˆ"
    elif score >= 55:
        return "éœ€è¦ç£¨åˆ"
    elif score >= 40:
        return "äº’è¡¥æˆé•¿"
    else:
        return "æŒ‘æˆ˜è¾ƒå¤š"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Privacy Pairing Tools
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@tool_handler("show_pairing_code")
async def execute_show_pairing_code(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    æ˜¾ç¤ºç”¨æˆ·çš„ Vibe é…å¯¹ç 

    å±•ç¤º PairingCodeCard
    """
    from services.pairing import PairingService

    user_id = context.user_id
    vibe_id = await PairingService.get_user_vibe_id(user_id)

    if not vibe_id:
        return {
            "success": False,
            "error": "æ— æ³•è·å–é…å¯¹ç "
        }

    return await ToolRegistry.execute("show_card", {
        "cardType": "pairing_code",
        "vibeId": vibe_id,
        "hint": "åˆ†äº«æ­¤é…å¯¹ç ç»™å¯¹æ–¹ï¼ŒTA å¯ä»¥å‘ä½ å‘èµ·åˆç›˜è¯·æ±‚"
    }, context)


@tool_handler("show_pairing_requests")
async def execute_show_pairing_requests(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    æ˜¾ç¤ºå¾…å¤„ç†çš„é…å¯¹è¯·æ±‚åˆ—è¡¨

    å±•ç¤º PairingRequestCard
    """
    from services.pairing import PairingService

    user_id = context.user_id
    requests = await PairingService.get_pending_requests(user_id)

    return await ToolRegistry.execute("show_card", {
        "cardType": "pairing_request_list",
        "requests": requests,
        "count": len(requests)
    }, context)


@tool_handler("request_pairing")
async def execute_request_pairing(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    å‘å¦ä¸€ç”¨æˆ·å‘èµ·é…å¯¹è¯·æ±‚
    """
    from services.pairing import PairingService

    user_id = context.user_id
    target_vibe_id = args.get("target_vibe_id")
    relationship_type = args.get("relationship_type", "romantic")
    message = args.get("message")

    if not target_vibe_id:
        return {
            "success": False,
            "error": "è¯·æä¾›å¯¹æ–¹çš„é…å¯¹ç  (Vibe ID)"
        }

    try:
        result = await PairingService.request_pairing(
            requester_id=user_id,
            target_vibe_id=target_vibe_id,
            relationship_type=relationship_type,
            message=message,
        )
        return result
    except ValueError as e:
        return {
            "success": False,
            "error": str(e)
        }


@tool_handler("accept_pairing_request")
async def execute_accept_pairing_request(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    æ¥å—é…å¯¹è¯·æ±‚å¹¶è®¡ç®—åˆç›˜
    """
    from services.pairing import PairingService
    from uuid import UUID

    user_id = context.user_id
    request_id = args.get("request_id")

    if not request_id:
        return {
            "success": False,
            "error": "è¯·æä¾›é…å¯¹è¯·æ±‚ ID"
        }

    try:
        result = await PairingService.accept_pairing(
            request_id=UUID(request_id),
            user_id=user_id,
        )

        # å±•ç¤ºéšç§å®‰å…¨çš„åˆç›˜ç»“æœå¡ç‰‡
        if result.get("success"):
            await ToolRegistry.execute("show_card", {
                "cardType": "privacy_synastry_result",
                **result
            }, context)

        return result
    except ValueError as e:
        return {
            "success": False,
            "error": str(e)
        }


@tool_handler("reject_pairing_request")
async def execute_reject_pairing_request(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    æ‹’ç»é…å¯¹è¯·æ±‚
    """
    from services.pairing import PairingService
    from uuid import UUID

    user_id = context.user_id
    request_id = args.get("request_id")

    if not request_id:
        return {
            "success": False,
            "error": "è¯·æä¾›é…å¯¹è¯·æ±‚ ID"
        }

    try:
        result = await PairingService.reject_pairing(
            request_id=UUID(request_id),
            user_id=user_id,
        )
        return result
    except ValueError as e:
        return {
            "success": False,
            "error": str(e)
        }


@tool_handler("generate_invite_link")
async def execute_generate_invite_link(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    ç”Ÿæˆä¸€æ¬¡æ€§é‚€è¯·é“¾æ¥
    """
    from services.pairing import PairingService
    import os

    user_id = context.user_id
    relationship_type = args.get("relationship_type", "romantic")
    message = args.get("message")
    base_url = os.getenv("VIBELIFE_BASE_URL", "https://vibelife.app")

    try:
        result = await PairingService.generate_invite_link(
            creator_id=user_id,
            relationship_type=relationship_type,
            message=message,
            base_url=base_url,
        )

        # å±•ç¤ºé‚€è¯·é“¾æ¥å¡ç‰‡
        if result.get("success"):
            await ToolRegistry.execute("show_card", {
                "cardType": "pairing_invite",
                "url": result["url"],
                "token": result["token"],
                "relationshipType": result["relationshipType"],
                "relationshipLabel": result["relationshipLabel"],
                "expiresAt": result.get("expiresAt"),
            }, context)

        return result
    except ValueError as e:
        return {
            "success": False,
            "error": str(e)
        }


@tool_handler("show_privacy_synastry_result")
async def execute_show_privacy_synastry_result(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    æ˜¾ç¤ºéšç§å®‰å…¨çš„åˆç›˜ç»“æœ

    ç»“æœä¸åŒ…å«ä»»ä½•åŸå§‹å‡ºç”Ÿæ•°æ®
    """
    return await ToolRegistry.execute("show_card", {
        "cardType": "privacy_synastry_result",
        "person1": args.get("person1"),
        "person2": args.get("person2"),
        "overallScore": args.get("overall_score"),
        "overallLabel": args.get("overall_label") or _get_score_label(args.get("overall_score", 0)),
        "dimensions": args.get("dimensions", []),
        "strengths": args.get("strengths", []),
        "challenges": args.get("challenges", []),
        "advice": args.get("advice", [])
    }, context)


@tool_handler("delete_synastry_result")
async def execute_delete_synastry_result(
    args: Dict[str, Any],
    context: ToolContext
) -> Dict[str, Any]:
    """
    åˆ é™¤è‡ªå·±çš„åˆç›˜è®°å½•
    """
    from services.pairing import PairingService
    from uuid import UUID

    user_id = context.user_id
    partner_id = args.get("partner_id")

    if not partner_id:
        return {
            "success": False,
            "error": "è¯·æä¾›å¯¹æ–¹çš„ç”¨æˆ· ID"
        }

    try:
        result = await PairingService.delete_synastry_result(
            user_id=user_id,
            partner_id=UUID(partner_id),
        )
        return result
    except ValueError as e:
        return {
            "success": False,
            "error": str(e)
        }
