"""
Relationship API Routes
Based on: vibelife spec v3.0, section 2.2.4

Endpoints:
- POST /api/v1/relationship/analyze - Single-user analysis
- POST /api/v1/relationship/vibe-link - Create Vibe Link
- GET /api/v1/relationship/vibe-link/{code} - Get Vibe Link info
- POST /api/v1/relationship/vibe-link/{code}/accept - Accept invitation
- POST /api/v1/relationship/vibe-link/{code}/complete - Complete analysis
- POST /api/v1/relationship/card - Generate shareable card
"""

import logging
from typing import Optional
from uuid import UUID
from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

from services.relationship import (
    get_relationship_service,
    VibeLinkService,
    RelationshipCardGenerator,
    DisclosureLevel,
)
from services.relationship.vibe_link import get_vibe_link_service

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/relationship", tags=["relationship"])


# ═══════════════════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════════════════

class AnalyzeRequest(BaseModel):
    """Request for relationship analysis"""
    user_id: str
    user_profile: dict
    partner_info: dict  # Can be full profile or minimal (zodiac/chinese_zodiac)
    relationship_type: str = Field(default="general")


class AnalyzeResponse(BaseModel):
    """Response for relationship analysis"""
    success: bool
    analysis: Optional[dict] = None
    error: Optional[str] = None


class CreateVibeLinkRequest(BaseModel):
    """Request to create a Vibe Link"""
    creator_id: str
    creator_nickname: str
    creator_profile: dict
    disclosure_level: str = Field(default="minimal")
    relationship_type: str = Field(default="general")


class VibeLinkResponse(BaseModel):
    """Response for Vibe Link operations"""
    success: bool
    session: Optional[dict] = None
    invite_url: Optional[str] = None
    error: Optional[str] = None


class AcceptVibeLinkRequest(BaseModel):
    """Request to accept a Vibe Link"""
    acceptor_id: str
    acceptor_nickname: str
    acceptor_profile: dict
    disclosure_level: str = Field(default="minimal")


class GenerateCardRequest(BaseModel):
    """Request to generate relationship card"""
    analysis_id: str
    analysis: dict
    tier: str = Field(default="basic")
    creator_nickname: str = ""
    partner_nickname: str = ""
    include_type_info: bool = False
    type_info: Optional[dict] = None


class CardResponse(BaseModel):
    """Response for card generation"""
    success: bool
    card: Optional[dict] = None
    error: Optional[str] = None


# ═══════════════════════════════════════════════════════════════════════════
# Routes
# ═══════════════════════════════════════════════════════════════════════════

@router.post("/analyze", response_model=AnalyzeResponse)
async def analyze_relationship(request: AnalyzeRequest):
    """
    Analyze relationship between user and partner.

    Single-user mode: User enters partner's info directly.
    Partner info can be:
    - Full profile (if known)
    - Minimal: {"zodiac": "leo"} or {"chinese_zodiac": "tiger"}
    """
    try:
        service = get_relationship_service()

        # Check if minimal info mode
        partner_profile = request.partner_info
        if "basic" not in partner_profile:
            # Minimal info - wrap it
            partner_profile = {"basic": request.partner_info, "life_context": {}}

        analysis = await service.analyze(
            user1_id=UUID(request.user_id),
            user1_profile=request.user_profile,
            user2_profile=partner_profile,
            relationship_type=request.relationship_type,
        )

        return AnalyzeResponse(
            success=True,
            analysis=analysis.to_dict(),
        )

    except Exception as e:
        logger.error(f"Relationship analysis failed: {e}")
        return AnalyzeResponse(
            success=False,
            error=str(e),
        )


@router.post("/vibe-link", response_model=VibeLinkResponse)
async def create_vibe_link(request: CreateVibeLinkRequest):
    """
    Create a new Vibe Link for privacy-preserving relationship analysis.

    Returns an invite URL that can be shared with the partner.
    """
    try:
        service = get_vibe_link_service()

        session = service.create_link(
            creator_id=UUID(request.creator_id),
            creator_nickname=request.creator_nickname,
            creator_profile=request.creator_profile,
            disclosure_level=request.disclosure_level,
            relationship_type=request.relationship_type,
        )

        return VibeLinkResponse(
            success=True,
            session=session.to_dict(),
            invite_url=session.get_invite_url(),
        )

    except Exception as e:
        logger.error(f"Create Vibe Link failed: {e}")
        return VibeLinkResponse(
            success=False,
            error=str(e),
        )


@router.get("/vibe-link/{code}", response_model=VibeLinkResponse)
async def get_vibe_link(code: str):
    """
    Get Vibe Link information by code.

    Use this to check link status and show invitation info.
    """
    try:
        service = get_vibe_link_service()
        session = service.get_session(code)

        if not session:
            return VibeLinkResponse(
                success=False,
                error="Link not found or expired",
            )

        return VibeLinkResponse(
            success=True,
            session=session.to_dict(),
        )

    except Exception as e:
        logger.error(f"Get Vibe Link failed: {e}")
        return VibeLinkResponse(
            success=False,
            error=str(e),
        )


@router.post("/vibe-link/{code}/accept", response_model=VibeLinkResponse)
async def accept_vibe_link(code: str, request: AcceptVibeLinkRequest):
    """
    Accept a Vibe Link invitation.

    The acceptor chooses their disclosure level.
    """
    try:
        service = get_vibe_link_service()

        session = service.accept_link(
            code=code,
            acceptor_id=UUID(request.acceptor_id),
            acceptor_nickname=request.acceptor_nickname,
            acceptor_profile=request.acceptor_profile,
            disclosure_level=request.disclosure_level,
        )

        if not session:
            return VibeLinkResponse(
                success=False,
                error="Cannot accept link. It may be expired, already accepted, or invalid.",
            )

        return VibeLinkResponse(
            success=True,
            session=session.to_dict(),
        )

    except Exception as e:
        logger.error(f"Accept Vibe Link failed: {e}")
        return VibeLinkResponse(
            success=False,
            error=str(e),
        )


@router.post("/vibe-link/{code}/complete", response_model=VibeLinkResponse)
async def complete_vibe_link(
    code: str,
    creator_profile: dict = None,
    acceptor_profile: dict = None,
):
    """
    Complete the Vibe Link analysis after both users have joined.

    This generates personalized advice for each user.
    """
    try:
        service = get_vibe_link_service()

        session = await service.complete_analysis(
            code=code,
            creator_profile=creator_profile or {},
            acceptor_profile=acceptor_profile or {},
        )

        if not session:
            return VibeLinkResponse(
                success=False,
                error="Cannot complete analysis. Session may not be ready.",
            )

        return VibeLinkResponse(
            success=True,
            session={
                **session.to_dict(),
                "creator_analysis": session.creator_analysis,
                "acceptor_analysis": session.acceptor_analysis,
            },
        )

    except Exception as e:
        logger.error(f"Complete Vibe Link failed: {e}")
        return VibeLinkResponse(
            success=False,
            error=str(e),
        )


@router.delete("/vibe-link/{code}")
async def cancel_vibe_link(code: str, user_id: str = Query(...)):
    """Cancel a pending Vibe Link (creator only)"""
    try:
        service = get_vibe_link_service()
        success = service.cancel_link(code, UUID(user_id))

        return {
            "success": success,
            "message": "Link cancelled" if success else "Cannot cancel link",
        }

    except Exception as e:
        logger.error(f"Cancel Vibe Link failed: {e}")
        return {"success": False, "error": str(e)}


@router.post("/card", response_model=CardResponse)
async def generate_card(request: GenerateCardRequest):
    """
    Generate a shareable relationship card.

    Basic cards are free and contain limited info.
    Premium cards include scores, type info, and AI image.
    """
    try:
        generator = RelationshipCardGenerator()

        card = await generator.generate(
            analysis=request.analysis,
            tier=request.tier,
            creator_nickname=request.creator_nickname,
            partner_nickname=request.partner_nickname,
            include_type_info=request.include_type_info,
            type_info=request.type_info,
        )

        return CardResponse(
            success=True,
            card=card.to_dict(),
        )

    except Exception as e:
        logger.error(f"Generate card failed: {e}")
        return CardResponse(
            success=False,
            error=str(e),
        )


@router.get("/card/{share_code}")
async def get_shared_card(share_code: str):
    """Get a shared relationship card by its share code"""
    # TODO: Load from database
    return {
        "success": False,
        "error": "Card not found. Cards are generated on-demand.",
    }
