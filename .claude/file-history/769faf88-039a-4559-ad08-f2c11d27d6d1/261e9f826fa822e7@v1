"""
Payment API Routes
Based on: vibelife spec v3.0

Endpoints:
- POST /api/v1/payment/create-checkout - Create checkout session
- POST /api/v1/payment/verify - Verify payment completion
- GET /api/v1/payment/products - Get available products
- POST /api/v1/payment/unlock-report - Unlock a report after payment
- GET /api/v1/payment/subscription - Get user's subscription status
"""

import os
import logging
from typing import Optional
from uuid import UUID
from fastapi import APIRouter, HTTPException, Query, Request
from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/payment", tags=["payment"])


# ═══════════════════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════════════════

class Product(BaseModel):
    """Product for purchase"""
    id: str
    name: str
    description: str
    price: float
    currency: str = "CNY"
    type: str  # "report", "subscription", "relationship_card"


class CreateCheckoutRequest(BaseModel):
    """Request to create checkout session"""
    user_id: str
    product_id: str
    metadata: dict = Field(default_factory=dict)
    success_url: Optional[str] = None
    cancel_url: Optional[str] = None


class CheckoutResponse(BaseModel):
    """Response with checkout info"""
    success: bool
    checkout_url: Optional[str] = None
    session_id: Optional[str] = None
    error: Optional[str] = None


class VerifyPaymentRequest(BaseModel):
    """Request to verify payment"""
    session_id: str
    user_id: str


class PaymentVerifyResponse(BaseModel):
    """Response for payment verification"""
    success: bool
    paid: bool = False
    product_id: Optional[str] = None
    metadata: dict = Field(default_factory=dict)
    error: Optional[str] = None


class UnlockReportRequest(BaseModel):
    """Request to unlock a report"""
    user_id: str
    report_id: str
    payment_session_id: str


class UnlockResponse(BaseModel):
    """Response for unlock operation"""
    success: bool
    unlocked: bool = False
    report_url: Optional[str] = None
    error: Optional[str] = None


class SubscriptionResponse(BaseModel):
    """Response for subscription status"""
    success: bool
    has_subscription: bool = False
    subscription: Optional[dict] = None
    error: Optional[str] = None


# ═══════════════════════════════════════════════════════════════════════════
# Products Definition
# ═══════════════════════════════════════════════════════════════════════════

# Based on spec: 19.9 = 完整报告 + 高清海报 + 首月订阅权益
PRODUCTS = [
    Product(
        id="report_full",
        name="完整报告 + 高清海报",
        description="完整深度分析报告、高清AI海报、永久保存、首月订阅权益",
        price=19.9,
        type="report",
    ),
    Product(
        id="relationship_card_premium",
        name="高级关系卡",
        description="完整关系分析、匹配度可视化、AI关系海报",
        price=9.9,
        type="relationship_card",
    ),
    Product(
        id="subscription_monthly",
        name="月度订阅",
        description="无限对话、深度分析、专属功能",
        price=19.9,
        type="subscription",
    ),
    Product(
        id="subscription_yearly",
        name="年度订阅",
        description="无限对话、深度分析、专属功能、年度特惠",
        price=159.0,
        type="subscription",
    ),
]

PRODUCTS_MAP = {p.id: p for p in PRODUCTS}


# ═══════════════════════════════════════════════════════════════════════════
# Database-backed payment tracking
# ═══════════════════════════════════════════════════════════════════════════

from stores import payment_repo


# ═══════════════════════════════════════════════════════════════════════════
# Routes
# ═══════════════════════════════════════════════════════════════════════════

@router.get("/products")
async def get_products():
    """Get list of available products"""
    return {
        "success": True,
        "products": [p.dict() for p in PRODUCTS],
    }


@router.post("/create-checkout", response_model=CheckoutResponse)
async def create_checkout(request: CreateCheckoutRequest):
    """
    Create a checkout session.

    In production, this would integrate with Stripe or other payment provider.
    For now, we create a mock session for development.
    """
    try:
        # Validate product
        product = PRODUCTS_MAP.get(request.product_id)
        if not product:
            raise HTTPException(status_code=400, detail="Invalid product ID")

        # Check for Stripe integration
        stripe_key = os.getenv("STRIPE_SECRET_KEY")

        if stripe_key:
            # Real Stripe integration would go here
            # import stripe
            # stripe.api_key = stripe_key
            # session = stripe.checkout.Session.create(...)
            pass

        # Mock session for development
        import uuid
        session_id = f"cs_mock_{uuid.uuid4().hex[:16]}"

        _payment_sessions[session_id] = {
            "user_id": request.user_id,
            "product_id": request.product_id,
            "product": product.dict(),
            "paid": False,
            "metadata": request.metadata,
        }

        # In development, return a mock checkout URL
        base_url = os.getenv("APP_BASE_URL", "http://localhost:3000")
        checkout_url = f"{base_url}/checkout/{session_id}"

        return CheckoutResponse(
            success=True,
            checkout_url=checkout_url,
            session_id=session_id,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Create checkout failed: {e}")
        return CheckoutResponse(
            success=False,
            error=str(e),
        )


@router.post("/verify", response_model=PaymentVerifyResponse)
async def verify_payment(request: VerifyPaymentRequest):
    """
    Verify payment completion.

    In production, this would check with the payment provider.
    """
    try:
        session = _payment_sessions.get(request.session_id)

        if not session:
            return PaymentVerifyResponse(
                success=False,
                error="Session not found",
            )

        if session["user_id"] != request.user_id:
            return PaymentVerifyResponse(
                success=False,
                error="User mismatch",
            )

        return PaymentVerifyResponse(
            success=True,
            paid=session["paid"],
            product_id=session["product_id"],
            metadata=session["metadata"],
        )

    except Exception as e:
        logger.error(f"Verify payment failed: {e}")
        return PaymentVerifyResponse(
            success=False,
            error=str(e),
        )


@router.post("/mock-pay/{session_id}")
async def mock_pay(session_id: str):
    """
    Mock payment completion for development.

    This endpoint simulates successful payment.
    Remove in production!
    """
    if session_id not in _payment_sessions:
        raise HTTPException(status_code=404, detail="Session not found")

    _payment_sessions[session_id]["paid"] = True

    return {
        "success": True,
        "message": "Payment simulated successfully",
        "session_id": session_id,
    }


@router.post("/unlock-report", response_model=UnlockResponse)
async def unlock_report(request: UnlockReportRequest):
    """
    Unlock a full report after payment verification.

    This endpoint:
    1. Verifies the payment session
    2. Marks the report as unlocked for the user
    3. Returns the full report URL
    """
    try:
        # Verify payment
        session = _payment_sessions.get(request.payment_session_id)

        if not session:
            return UnlockResponse(
                success=False,
                error="Payment session not found",
            )

        if not session["paid"]:
            return UnlockResponse(
                success=False,
                error="Payment not completed",
            )

        if session["user_id"] != request.user_id:
            return UnlockResponse(
                success=False,
                error="User mismatch",
            )

        # TODO: Update report in database to mark as unlocked
        # TODO: Grant subscription if included in product

        base_url = os.getenv("APP_BASE_URL", "http://localhost:3000")
        report_url = f"{base_url}/report/{request.report_id}?full=true"

        return UnlockResponse(
            success=True,
            unlocked=True,
            report_url=report_url,
        )

    except Exception as e:
        logger.error(f"Unlock report failed: {e}")
        return UnlockResponse(
            success=False,
            error=str(e),
        )


@router.get("/subscription", response_model=SubscriptionResponse)
async def get_subscription(user_id: str = Query(...)):
    """
    Get user's current subscription status.
    """
    try:
        # TODO: Load from database via SubscriptionService
        # For now, return mock data

        return SubscriptionResponse(
            success=True,
            has_subscription=False,
            subscription=None,
        )

    except Exception as e:
        logger.error(f"Get subscription failed: {e}")
        return SubscriptionResponse(
            success=False,
            error=str(e),
        )


@router.post("/webhook")
async def payment_webhook(request: Request):
    """
    Handle payment provider webhooks.

    In production, this would:
    1. Verify webhook signature
    2. Process payment events (payment_intent.succeeded, etc.)
    3. Update database accordingly
    """
    try:
        payload = await request.body()
        # sig_header = request.headers.get("Stripe-Signature")

        # TODO: Verify and process webhook
        logger.info(f"Received webhook: {len(payload)} bytes")

        return {"received": True}

    except Exception as e:
        logger.error(f"Webhook processing failed: {e}")
        raise HTTPException(status_code=400, detail=str(e))
