"""
Social Network API Routes.

REQ: REQ-SOCIAL-001 ~ REQ-SOCIAL-005
Design: §3.4.1 ~ §3.4.2
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, Field

from api.deps import require_auth, require_csrf
from models.social import (
    BuffType,
    CardType,
    CreateChainRequest,
    CreateShareCardRequest,
    EnergyBuffRequest,
    JoinChainRequest,
    RelationshipStatus,
    RelationshipType,
    RitualType,
)
from services import social_service

router = APIRouter(prefix="/api/social", tags=["Social Network"])


# =============================================================================
# Friend Management (REQ-SOCIAL-001)
# =============================================================================

class FriendRequestBody(BaseModel):
    peer_user_id: int
    relationship_type: str = "friend"
    message: Optional[str] = None


@router.post("/friends/request")
async def send_friend_request(
    request: Request,
    body: FriendRequestBody,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """Send a friend request."""
    require_csrf(request, auth)
    user_id = auth["user_id"]

    try:
        rel_type = RelationshipType(body.relationship_type)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid relationship type")

    try:
        edge = social_service.send_friend_request(
            user_id=user_id,
            peer_user_id=body.peer_user_id,
            relationship_type=rel_type,
        )
        return {
            "success": True,
            "status": edge.status.value,
            "message": "Friend request sent",
        }
    except social_service.SocialServiceError as e:
        raise HTTPException(status_code=400, detail=str(e))


class AcceptRequestBody(BaseModel):
    peer_user_id: int


@router.post("/friends/accept")
async def accept_friend_request(
    request: Request,
    body: AcceptRequestBody,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """Accept a friend request."""
    require_csrf(request, auth)
    user_id = auth["user_id"]

    try:
        edge = social_service.accept_friend_request(
            user_id=user_id,
            peer_user_id=body.peer_user_id,
        )
        return {
            "success": True,
            "status": edge.status.value,
            "message": "Friend request accepted",
        }
    except social_service.SocialServiceError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.get("/friends")
async def get_friends(
    request: Request,
    status: Optional[str] = Query(default=None, description="Filter by status"),
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """Get user's friends list."""
    user_id = auth["user_id"]

    status_filter = None
    if status:
        try:
            status_filter = RelationshipStatus(status)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid status")

    friends = social_service.get_friends(user_id, status=status_filter)

    return {
        "friends": [
            {
                "peer_user_id": f.peer_user_id,
                "relationship_type": f.relationship_type.value,
                "status": f.status.value,
                "compatibility_score": f.compatibility_score,
                "created_at": f.created_at.isoformat() if f.created_at else None,
            }
            for f in friends
        ],
        "total_count": len(friends),
    }


# =============================================================================
# Energy Buff (REQ-SOCIAL-002)
# =============================================================================

class BuffRequestBody(BaseModel):
    to_user_id: int
    buff_type: str
    amount: int = Field(..., gt=0, le=1000)
    message: Optional[str] = None


@router.post("/buff")
async def send_energy_buff(
    request: Request,
    body: BuffRequestBody,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """
    Send energy buff to a friend.

    REQ: REQ-SOCIAL-002
    Design: §3.4.1
    """
    require_csrf(request, auth)
    user_id = auth["user_id"]

    try:
        buff_type = BuffType(body.buff_type)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid buff type")

    try:
        buff = social_service.send_energy_buff(
            from_user_id=user_id,
            to_user_id=body.to_user_id,
            buff_type=buff_type,
            amount=body.amount,
            message=body.message,
        )

        # Get new balance
        from stores import fortune_db
        balance = fortune_db.fetch_one(
            "SELECT coins FROM fortune_user_balance WHERE user_id = %s",
            [user_id],
        )

        return {
            "buff_id": buff.buff_id,
            "success": True,
            "new_balance": balance["coins"] if balance else 0,
            "message": f"成功发送 {body.amount} {buff_type.value} 能量",
        }

    except social_service.NotFriendsError:
        raise HTTPException(status_code=403, detail="Not friends")
    except social_service.InsufficientBalanceError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except social_service.SocialServiceError as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/buff/received")
async def get_received_buffs(
    request: Request,
    limit: int = Query(default=20, ge=1, le=100),
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """Get buffs received by current user."""
    user_id = auth["user_id"]

    buffs = social_service.get_received_buffs(user_id, limit=limit)

    return {
        "buffs": [
            {
                "buff_id": b.buff_id,
                "from_user_id": b.from_user_id,
                "buff_type": b.buff_type.value,
                "amount": b.amount,
                "message": b.message,
                "created_at": b.created_at.isoformat() if b.created_at else None,
            }
            for b in buffs
        ],
    }


# =============================================================================
# Luck Chain (REQ-SOCIAL-004)
# =============================================================================

class CreateChainBody(BaseModel):
    title: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    ritual_type: str
    base_reward: int = Field(default=10, ge=1, le=100)
    expires_hours: int = Field(default=24, ge=1, le=168)


@router.post("/chain/create")
async def create_chain(
    request: Request,
    body: CreateChainBody,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """Create a new luck chain."""
    require_csrf(request, auth)
    user_id = auth["user_id"]

    try:
        ritual_type = RitualType(body.ritual_type)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid ritual type")

    chain = social_service.create_luck_chain(
        creator_user_id=user_id,
        title=body.title,
        description=body.description,
        ritual_type=ritual_type,
        base_reward=body.base_reward,
        expires_hours=body.expires_hours,
    )

    return {
        "chain_id": chain.chain_id,
        "title": chain.title,
        "status": chain.status.value,
        "expires_at": chain.expires_at.isoformat() if chain.expires_at else None,
    }


class JoinChainBody(BaseModel):
    chain_id: int
    contribution: Optional[str] = None


@router.post("/chain/join")
async def join_chain(
    request: Request,
    body: JoinChainBody,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """
    Join a luck chain.

    REQ: REQ-SOCIAL-004
    Design: §3.4.2
    """
    require_csrf(request, auth)
    user_id = auth["user_id"]

    try:
        result = social_service.join_luck_chain(
            chain_id=body.chain_id,
            user_id=user_id,
            contribution=body.contribution,
        )
        return result

    except social_service.ChainNotActiveError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except social_service.AlreadyJoinedError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except social_service.SocialServiceError as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/chain/{chain_id}")
async def get_chain(
    chain_id: int,
    request: Request,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """Get chain details."""
    user_id = auth["user_id"]

    try:
        detail = social_service.get_chain_detail(chain_id, user_id=user_id)

        return {
            "chain": {
                "chain_id": detail["chain"].chain_id,
                "creator_user_id": detail["chain"].creator_user_id,
                "title": detail["chain"].title,
                "description": detail["chain"].description,
                "ritual_type": detail["chain"].ritual_type.value,
                "base_reward": detail["chain"].base_reward,
                "participant_count": detail["chain"].participant_count,
                "status": detail["chain"].status.value,
                "expires_at": detail["chain"].expires_at.isoformat() if detail["chain"].expires_at else None,
            },
            "participants": [
                {
                    "user_id": p.user_id,
                    "position": p.position,
                    "contribution": p.contribution,
                    "reward_earned": p.reward_earned,
                }
                for p in detail["participants"]
            ],
            "my_participation": {
                "position": detail["my_participation"].position,
                "reward_earned": detail["my_participation"].reward_earned,
            } if detail["my_participation"] else None,
        }

    except social_service.SocialServiceError as e:
        raise HTTPException(status_code=404, detail=str(e))


# =============================================================================
# Share Card (REQ-SOCIAL-005)
# =============================================================================

class CreateShareBody(BaseModel):
    card_type: str
    content: Dict[str, Any]
    expires_hours: int = Field(default=168, ge=1, le=720)


@router.post("/share")
async def create_share_card(
    request: Request,
    body: CreateShareBody,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """
    Create a shareable card.

    REQ: REQ-SOCIAL-005
    """
    require_csrf(request, auth)
    user_id = auth["user_id"]

    valid_types = ["daily_guidance", "insight", "achievement", "chain_invite"]
    if body.card_type not in valid_types:
        raise HTTPException(status_code=400, detail="Invalid card type")

    card = social_service.create_share_card(
        user_id=user_id,
        card_type=body.card_type,
        content=body.content,
        expires_hours=body.expires_hours,
    )

    # Generate QR data (base64 encoded URL)
    import base64
    qr_data = base64.b64encode(card.share_url.encode()).decode() if card.share_url else None

    return {
        "card_id": str(card.card_id),
        "share_url": card.share_url,
        "qr_data": qr_data,
    }


@router.get("/share/{card_id}")
async def get_share_card(
    card_id: str,
    request: Request,
) -> Dict[str, Any]:
    """Get a share card (public endpoint)."""
    card = social_service.get_share_card(card_id)

    if not card:
        raise HTTPException(status_code=404, detail="Card not found")

    # Check expiration
    from datetime import datetime, timezone
    if card.expires_at and card.expires_at < datetime.now(timezone.utc):
        raise HTTPException(status_code=410, detail="Card has expired")

    return {
        "card_id": str(card.card_id),
        "card_type": card.card_type,
        "content": card.content,
        "view_count": card.view_count,
        "created_at": card.created_at.isoformat() if card.created_at else None,
    }


# =============================================================================
# Compatibility Analysis (REQ-SOCIAL-003)
# =============================================================================

class CompatibilityRequestBody(BaseModel):
    peer_user_id: int = Field(..., description="对方用户ID")
    analysis_type: str = Field(default="basic", description="basic|detailed")
    use_cache: bool = Field(default=True, description="是否使用缓存结果")


@router.post("/compatibility")
async def analyze_compatibility(
    request: Request,
    body: CompatibilityRequestBody,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """
    Analyze compatibility between current user and another user.

    REQ: REQ-SOCIAL-003
    Design: §3.4.1 合盘分析

    Based on bazi data, calculates:
    - wuxing_harmony: 五行和谐度
    - daymaster_relation: 日主关系
    - shishen_synergy: 十神互补
    - overall: 综合评分

    Returns insights and recommendations for the relationship.
    """
    require_csrf(request, auth)
    user_id = auth["user_id"]

    if body.analysis_type not in ("basic", "detailed"):
        raise HTTPException(status_code=400, detail="Invalid analysis type")

    if user_id == body.peer_user_id:
        raise HTTPException(status_code=400, detail="Cannot analyze compatibility with yourself")

    try:
        # Check for cached result if requested
        if body.use_cache:
            cached = social_service.get_cached_compatibility(user_id, body.peer_user_id)
            if cached:
                from datetime import datetime, timezone
                return {
                    "user_id": user_id,
                    "peer_user_id": body.peer_user_id,
                    "result": cached,
                    "analyzed_at": cached.get("cached_at").isoformat() if cached.get("cached_at") else datetime.now(timezone.utc).isoformat(),
                }

        # Calculate fresh compatibility
        result = social_service.calculate_compatibility(
            user_id=user_id,
            peer_user_id=body.peer_user_id,
            analysis_type=body.analysis_type,
        )

        from datetime import datetime, timezone
        return {
            "user_id": user_id,
            "peer_user_id": body.peer_user_id,
            "result": result,
            "analyzed_at": datetime.now(timezone.utc).isoformat(),
        }

    except social_service.SocialServiceError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.get("/compatibility/{peer_user_id}")
async def get_compatibility(
    peer_user_id: int,
    request: Request,
    auth: Dict[str, Any] = Depends(require_auth),
) -> Dict[str, Any]:
    """
    Get cached compatibility result with a specific user.

    Returns 404 if no cached result exists.
    """
    user_id = auth["user_id"]

    if user_id == peer_user_id:
        raise HTTPException(status_code=400, detail="Cannot get compatibility with yourself")

    cached = social_service.get_cached_compatibility(user_id, peer_user_id)
    if not cached:
        raise HTTPException(status_code=404, detail="No compatibility analysis found. Use POST /api/social/compatibility to analyze.")

    from datetime import datetime, timezone
    return {
        "user_id": user_id,
        "peer_user_id": peer_user_id,
        "result": cached,
        "analyzed_at": cached.get("cached_at").isoformat() if cached.get("cached_at") else None,
    }
