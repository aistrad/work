# Mentis: 软件架构设计
## 完整系统架构规范

---

## 1. 架构概述

### 1.1 系统愿景

Mentis 是一个 **以 Stream 为核心的智能体个人操作系统** —— 一个 AI 原生平台，融合：
- 具有持久记忆的实时对话 AI
- 多维度生命状态追踪（Vibe 分数）
- 可插拔洞察模块框架
- 主动智能体能力

### 1.2 架构目标

| 目标 | 优先级 | 描述 |
|------|--------|------|
| **可扩展性** | P0 | 支持 100 万+ 并发用户 |
| **低延迟** | P0 | 聊天响应 <500ms，UI <100ms |
| **隐私安全** | P0 | 敏感数据端到端加密 |
| **可扩展性** | P1 | 可插拔模块无需修改核心 |
| **可靠性** | P1 | 99.9% 可用性 SLA |
| **成本效率** | P1 | 规模化后优化 LLM 成本 |

### 1.3 架构原则

1. **事件驱动核心**：所有状态变更通过事件流动
2. **API 优先设计**：每个能力都通过 API 暴露
3. **多元持久化**：为每种数据类型选择合适的数据库
4. **边缘就绪**：为全球部署优化
5. **AI 原生**：LLM 操作作为一等公民

---

## 2. 系统架构

### 2.1 高层架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              客户端层                                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  Web 应用   │  │ 移动端应用  │  │   小组件    │  │  可穿戴设备 │        │
│  │  (Next.js)  │  │  (React     │  │  (iOS/      │  │  (WatchOS/  │        │
│  │             │  │   Native)   │  │   Android)  │  │   WearOS)   │        │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘        │
│         │                │                │                │               │
└─────────┼────────────────┼────────────────┼────────────────┼───────────────┘
          │                │                │                │
          └────────────────┴────────────────┴────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              网关层                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      API 网关 (Kong/AWS API Gateway)                 │   │
│  │  • 限流  • 认证  • 请求路由  • SSL/TLS                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌──────────────┐  ┌──────────────┐│┌──────────────┐  ┌──────────────┐     │
│  │  REST API    │  │  GraphQL     │││  WebSocket   │  │  gRPC        │     │
│  │  端点        │  │  网关        │││  网关        │  │  内部通信    │     │
│  └──────────────┘  └──────────────┘│└──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            应用层                                           │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     伴侣层 (AI 人格)                                 │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │   │
│  │  │ 人格引擎     │  │ 交互引擎     │  │ 主动智能体   │               │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   MENTIS 智能引擎                                    │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │   │
│  │  │ Stream       │  │ 情绪引擎     │  │ 记忆系统     │               │   │
│  │  │ 处理器       │  │              │  │              │               │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘               │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │   │
│  │  │ 模式检测器   │  │ 模块编排器   │  │ Vibe 分数    │               │   │
│  │  │              │  │              │  │ 引擎         │               │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌───────────────── 洞察模块（可插拔） ────────────────────────────────┐   │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐  │   │
│  │  │  CBT   │ │  ACT   │ │  八字  │ │  紫微  │ │  健康  │ │  财务  │  │   │
│  │  └────────┘ └────────┘ └────────┘ └────────┘ └────────┘ └────────┘  │   │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────────────────────────────┐│   │
│  │  │  职业  │ │  投资  │ │  自定义 │ │       模块 SDK                 ││   │
│  │  └────────┘ └────────┘ └────────┘ └────────────────────────────────┘│   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     领域服务                                         │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │   │
│  │  │ 认证服务 │ │ Stream   │ │ 日报服务 │ │ 分享服务 │ │ 媒体服务 │   │   │
│  │  │          │ │ 服务     │ │          │ │          │ │          │   │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘   │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐               │   │
│  │  │ 实体服务 │ │ 进化服务 │ │ 实时服务 │ │ 解码服务 │               │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           数据与知识层                                      │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  PostgreSQL  │  │   Pinecone   │  │    Redis     │  │   S3/GCS     │    │
│  │  (主数据库)  │  │  (向量库)    │  │   (缓存)     │  │  (对象存储)  │    │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                      │
│  │    Neo4j     │  │  TimescaleDB │  │  ClickHouse  │                      │
│  │ (知识图谱)   │  │  (时序数据)  │  │ (分析引擎)   │                      │
│  └──────────────┘  └──────────────┘  └──────────────┘                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          基础设施层                                         │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │   LLM        │  │   推送服务   │  │   CDN        │  │   消息队列   │    │
│  │  提供商      │  │ (FCM/APNs)   │  │  (Cloud-     │  │  (Kafka/     │    │
│  │(Claude/GPT/  │  │              │  │   flare)     │  │   RabbitMQ)  │    │
│  │   Gemini)    │  │              │  │              │  │              │    │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                      │
│  │  Kubernetes  │  │  Terraform   │  │  监控系统    │                      │
│  │  (容器编排)  │  │  (IaC)       │  │  (Datadog/   │                      │
│  │              │  │              │  │   Grafana)   │                      │
│  └──────────────┘  └──────────────┘  └──────────────┘                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 层级职责

| 层级 | 职责 | 技术 |
|------|------|------|
| **客户端** | 用户界面、本地状态 | Next.js, React Native, Zustand |
| **网关** | 认证、限流、路由 | Kong, AWS API Gateway |
| **应用** | 业务逻辑、AI 编排 | FastAPI, Python |
| **数据** | 持久化、缓存、搜索 | PostgreSQL, Redis, Pinecone |
| **基础设施** | 计算、网络、可观测性 | K8s, Terraform, Datadog |

---

## 3. 核心组件

### 3.1 Stream 处理器

用户交互处理的核心。

```python
# 概念流程
class StreamProcessor:
    async def process_input(self, user_id: str, input: StreamInput) -> StreamOutput:
        """
        所有用户输入的主处理管道
        """
        # 1. 上下文组装
        context = await self.build_context(user_id, input)

        # 2. 情绪感知
        emotion = await self.emotion_engine.analyze(input, context)

        # 3. 记忆检索
        memories = await self.memory_system.retrieve_relevant(
            user_id, input, limit=10
        )

        # 4. 模块选择 & 洞察生成
        active_modules = await self.module_orchestrator.select_modules(
            context, emotion
        )
        insights = await self.gather_insights(active_modules, context)

        # 5. 响应策略
        strategy = await self.response_strategist.determine(
            emotion, insights, context
        )

        # 6. 响应生成
        response = await self.generate_response(
            input, context, emotion, insights, strategy
        )

        # 7. 后处理
        await self.update_vibe_score(user_id, input, response)
        await self.store_to_memory(user_id, input, response)
        await self.check_proactive_triggers(user_id)

        return response
```

#### 数据流图

```
用户输入
    │
    ▼
┌─────────────────┐
│ 输入解析        │ ← 文字/语音/图片标准化
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 上下文构建器    │ ← 用户画像 + 最近历史 + 活跃模块
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 情绪引擎        │ ← 主/次情绪 + 强度 + 需求
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 记忆系统        │ ← 相关历史对话 + 模式
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 模块选择器      │ ← CBT? 八字? 健康? 基于上下文
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 洞察收集        │ ← 并行模块执行
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 响应策略师      │ ← 镜像? 挑战? 建议? 基于需求
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ LLM 生成        │ ← 提示词组装 + 生成 + 人格风格化
└────────┬────────┘
         │
         ▼
响应输出
```

### 3.2 记忆系统

持久化、上下文感知的记忆架构。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           记忆系统                                          │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     短期记忆 (Redis)                                 │   │
│  │  • 当前会话上下文                                                   │   │
│  │  • 最近 N 条消息（滑动窗口）                                        │   │
│  │  • 当前情绪状态                                                     │   │
│  │  • 待处理行动卡片                                                   │   │
│  │  TTL: 24 小时                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     工作记忆 (PostgreSQL + 向量)                     │   │
│  │  • 近期对话（7-30 天）                                              │   │
│  │  • 提取的实体和话题                                                 │   │
│  │  • 情绪标签和模式                                                   │   │
│  │  • 用于语义搜索的向量嵌入                                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     长期记忆 (知识图谱)                              │   │
│  │  • 用户人格模型                                                     │   │
│  │  • 关系图谱（提到的人）                                             │   │
│  │  • 核心信念和价值观                                                 │   │
│  │  • 人生事件时间线                                                   │   │
│  │  • 模式历史                                                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     归档记忆 (冷存储)                                │   │
│  │  • 完整对话历史                                                     │   │
│  │  • 媒体文件（图片、语音）                                           │   │
│  │  • 压缩的旧数据                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 记忆检索策略

```python
class MemoryRetriever:
    async def retrieve(
        self,
        user_id: str,
        query: str,
        limit: int = 10
    ) -> List[Memory]:
        """
        多策略记忆检索
        """
        results = []

        # 1. 时效性 - 最近的消息
        recent = await self.get_recent(user_id, limit=5)

        # 2. 语义相似度 - 向量搜索
        similar = await self.vector_search(
            user_id, query, limit=5
        )

        # 3. 实体关联 - 提到的人/话题
        entities = extract_entities(query)
        related = await self.graph_query(user_id, entities)

        # 4. 模式匹配 - 相似情绪上下文
        emotion = await self.emotion_engine.quick_classify(query)
        emotional = await self.find_similar_emotions(
            user_id, emotion, limit=3
        )

        # 合并排序
        return self.merge_and_rank(recent, similar, related, emotional)
```

### 3.3 情绪引擎

LLM 驱动的情绪分析，带缓存。

```python
class EmotionEngine:
    """
    分析用户输入的情绪内容
    """

    async def analyze(
        self,
        input: StreamInput,
        context: ConversationContext
    ) -> EmotionAnalysis:
        # 检查缓存
        cache_key = self.compute_cache_key(input.text)
        if cached := await self.cache.get(cache_key):
            return cached

        # 基于 LLM 的分析
        prompt = self.build_emotion_prompt(input, context)
        result = await self.llm.complete(prompt)

        analysis = EmotionAnalysis(
            primary_emotion=result.primary,      # 如 "frustrated"
            secondary_emotions=result.secondary,  # 如 ["hurt", "angry"]
            intensity=result.intensity,          # 0.0 - 1.0
            valence=result.valence,              # -1.0 到 1.0
            arousal=result.arousal,              # 0.0 到 1.0
            user_needs=result.needs,             # 如 ["validation", "advice"]
        )

        # 缓存 1 小时
        await self.cache.set(cache_key, analysis, ttl=3600)

        return analysis

    def build_emotion_prompt(self, input, context):
        return f"""
        分析这条消息的情绪内容。

        用户画像: {context.user_profile}
        最近对话: {context.recent_messages[-5:]}
        当前消息: {input.text}

        请返回:
        - primary_emotion: 主导情绪
        - secondary_emotions: 最多 3 个次要情绪
        - intensity: 强度（0.0-1.0）
        - valence: 正负向（-1.0 到 1.0）
        - arousal: 唤起度（0.0 到 1.0）
        - user_needs: 用户此刻可能的需求
        """
```

### 3.4 模块编排器

管理可插拔洞察模块。

```python
class ModuleOrchestrator:
    """
    基于上下文协调洞察模块
    """

    def __init__(self):
        self.registry: Dict[str, InsightModule] = {}
        self.load_core_modules()

    async def select_modules(
        self,
        context: ConversationContext,
        emotion: EmotionAnalysis
    ) -> List[InsightModule]:
        """
        确定此次交互应激活哪些模块
        """
        active = []

        for module in self.registry.values():
            # 检查模块是否为用户启用
            if not self.is_enabled(context.user_id, module.id):
                continue

            # 检查模块激活条件
            activation = await module.should_activate(context, emotion)

            if activation.activate and activation.confidence > 0.5:
                active.append({
                    "module": module,
                    "confidence": activation.confidence,
                    "reason": activation.reason
                })

        # 按置信度排序，限制前 3 个
        active.sort(key=lambda x: x["confidence"], reverse=True)
        return [a["module"] for a in active[:3]]

    async def gather_insights(
        self,
        modules: List[InsightModule],
        context: ConversationContext
    ) -> List[Insight]:
        """
        从活跃模块并行生成洞察
        """
        tasks = [
            module.generate_insight(context)
            for module in modules
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        return [
            r for r in results
            if isinstance(r, Insight) and r.confidence > 0.6
        ]
```

### 3.5 洞察模块接口

所有模块的标准接口。

```python
from abc import ABC, abstractmethod
from typing import Optional

class InsightModule(ABC):
    """
    所有洞察模块的基础接口
    """

    @property
    @abstractmethod
    def metadata(self) -> ModuleMetadata:
        """
        返回模块元数据
        """
        pass

    @abstractmethod
    async def initialize_profile(
        self,
        user_data: UserData
    ) -> ModuleProfile:
        """
        初始化用户特定的模块画像
        """
        pass

    @abstractmethod
    async def should_activate(
        self,
        context: ConversationContext,
        emotion: EmotionAnalysis
    ) -> ActivationDecision:
        """
        确定模块是否应在此上下文中激活
        """
        pass

    @abstractmethod
    async def generate_insight(
        self,
        context: ConversationContext
    ) -> Optional[Insight]:
        """
        基于当前上下文生成洞察
        """
        pass

    @abstractmethod
    async def generate_proactive_push(
        self,
        user_state: UserState
    ) -> Optional[ProactivePush]:
        """
        在适当时生成主动推送内容
        """
        pass


# 示例：八字模块实现
class BaZiModule(InsightModule):

    @property
    def metadata(self) -> ModuleMetadata:
        return ModuleMetadata(
            id="bazi",
            name="东方人格框架",
            description="八字性格分析与时机洞察",
            category="eastern_wisdom",
            required_inputs=["birth_datetime"],
        )

    async def should_activate(
        self,
        context: ConversationContext,
        emotion: EmotionAnalysis
    ) -> ActivationDecision:
        # 在人生方向、时机、性格话题时激活
        topic_keywords = ["方向", "选择", "时机", "适合", "为什么"]
        text = context.current_input.text

        is_relevant = any(kw in text for kw in topic_keywords)
        user_receptive = context.user_profile.module_preferences.get(
            "bazi_receptivity", 0.5
        ) > 0.4

        return ActivationDecision(
            activate=is_relevant and user_receptive,
            confidence=0.75 if is_relevant else 0.0,
            reason="话题与人生方向和时机相关"
        )
```

### 3.6 Vibe 分数引擎

多维度健康追踪。

```python
class VibeScoreEngine:
    """
    计算并追踪多维度 Vibe 分数
    """

    DIMENSIONS = ["emotional", "productive", "physical", "social", "growth"]

    async def calculate(
        self,
        user_id: str,
        time_window: timedelta = timedelta(hours=24)
    ) -> VibeScore:
        """
        计算所有维度的当前 Vibe 分数
        """
        scores = {}

        for dim in self.DIMENSIONS:
            scores[dim] = await self.calculate_dimension(
                user_id, dim, time_window
            )

        # 基于用户人生阶段的加权聚合
        weights = await self.get_user_weights(user_id)
        total = sum(
            scores[d] * weights.get(d, 1.0)
            for d in self.DIMENSIONS
        ) / sum(weights.values())

        return VibeScore(
            total=round(total),
            dimensions=scores,
            label=self.get_label(total),
            trend=await self.calculate_trend(user_id)
        )

    async def calculate_dimension(
        self,
        user_id: str,
        dimension: str,
        time_window: timedelta
    ) -> int:
        """
        计算单个维度的分数
        """
        # 获取相关数据点
        entries = await self.get_entries(user_id, dimension, time_window)

        if not entries:
            return 50  # 默认基线

        # 基于维度类型进行聚合
        if dimension == "emotional":
            return self.aggregate_emotional(entries)
        elif dimension == "productive":
            return self.aggregate_productive(entries)
        # ... 等等

    def get_label(self, score: int) -> str:
        """
        分数的人类可读标签
        """
        labels = [
            (90, "蓬勃向上"),
            (75, "精力充沛"),
            (60, "稳定"),
            (45, "调整中"),
            (30, "挣扎"),
            (0, "低谷"),
        ]
        for threshold, label in labels:
            if score >= threshold:
                return label
        return "未知"
```

### 3.7 主动智能体

用于主动参与的自主智能体。

```python
class ProactiveAgent:
    """
    管理主动推送的调度和生成
    """

    PUSH_TYPES = [
        "morning_checkin",      # 早安问候
        "evening_reflection",   # 晚间反思
        "pattern_insight",      # 模式洞察
        "caring_intervention",  # 关怀干预
        "interest_content",     # 兴趣内容
        "event_reminder",       # 事件提醒
    ]

    async def run_scheduler(self):
        """
        主调度循环 - 持续运行
        """
        while True:
            users = await self.get_eligible_users()

            for user in users:
                push = await self.determine_push(user)
                if push:
                    await self.send_push(user.id, push)

            await asyncio.sleep(60)  # 每分钟检查

    async def determine_push(
        self,
        user: User
    ) -> Optional[ProactivePush]:
        """
        确定是否以及推送什么给用户
        """
        # 检查每日限制
        today_count = await self.get_push_count_today(user.id)
        if today_count >= user.settings.max_daily_pushes:
            return None

        # 检查勿扰时段
        if self.in_quiet_hours(user):
            return None

        # 按优先级检查推送类型
        for push_type in self.PUSH_TYPES:
            if await self.should_push(user, push_type):
                return await self.generate_push(user, push_type)

        return None

    async def should_push_caring_intervention(
        self,
        user: User
    ) -> bool:
        """
        检查用户是否需要关怀干预
        """
        # 检查令人担忧的模式
        recent_vibe = await self.vibe_engine.get_recent(
            user.id, days=3
        )

        # 连续低情绪分数
        if all(v.emotional < 40 for v in recent_vibe[-3:]):
            return True

        # 高活跃后突然沉默
        last_message = await self.get_last_message_time(user.id)
        usual_frequency = user.stats.avg_messages_per_day

        if (
            usual_frequency > 3 and
            last_message < datetime.now() - timedelta(days=2)
        ):
            return True

        return False
```

---

## 4. 数据架构

### 4.1 数据库选型依据

| 数据类型 | 数据库 | 选择理由 |
|----------|--------|----------|
| 用户画像、设置 | PostgreSQL | ACID，关系完整性 |
| Stream 条目 | PostgreSQL + 向量 | 结构化 + 语义搜索 |
| 嵌入向量 | Pinecone | 优化的向量操作 |
| 用户知识图谱 | Neo4j | 关系遍历 |
| 会话缓存 | Redis | 亚毫秒延迟 |
| 时序数据（Vibe） | TimescaleDB | 高效时间查询 |
| 分析数据 | ClickHouse | OLAP 负载 |
| 媒体文件 | S3/GCS | 经济的对象存储 |

### 4.2 核心表结构（PostgreSQL）

```sql
-- 用户与认证
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT UNIQUE NOT NULL,
    phone TEXT UNIQUE,
    name TEXT,
    avatar_url TEXT,
    birth_datetime TIMESTAMPTZ,
    birth_location TEXT,
    timezone TEXT DEFAULT 'UTC',
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Stream 条目（核心内容）
CREATE TABLE stream_entries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    type TEXT NOT NULL CHECK (type IN (
        'user_message', 'ai_response', 'proactive_push',
        'pattern_insight', 'action_card', 'for_you'
    )),
    content TEXT NOT NULL,
    content_embedding VECTOR(1536),  -- 用于语义搜索
    emotion_data JSONB,
    metadata JSONB DEFAULT '{}',
    parent_id UUID REFERENCES stream_entries(id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Vibe 分数（时序）
CREATE TABLE vibe_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    total_score INTEGER CHECK (total_score BETWEEN 0 AND 100),
    emotional INTEGER CHECK (emotional BETWEEN 0 AND 100),
    productive INTEGER CHECK (productive BETWEEN 0 AND 100),
    physical INTEGER CHECK (physical BETWEEN 0 AND 100),
    social INTEGER CHECK (social BETWEEN 0 AND 100),
    growth INTEGER CHECK (growth BETWEEN 0 AND 100),
    label TEXT
);

-- 模块画像（用户特定模块数据）
CREATE TABLE module_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    module_id TEXT NOT NULL,
    enabled BOOLEAN DEFAULT true,
    profile_data JSONB DEFAULT '{}',
    last_insight_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, module_id)
);

-- 主动推送日志
CREATE TABLE proactive_pushes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    push_type TEXT NOT NULL,
    content TEXT NOT NULL,
    delivered_at TIMESTAMPTZ DEFAULT NOW(),
    read_at TIMESTAMPTZ,
    response TEXT,
    response_at TIMESTAMPTZ
);

-- 索引
CREATE INDEX idx_stream_user_time ON stream_entries(user_id, created_at DESC);
CREATE INDEX idx_stream_embedding ON stream_entries
    USING ivfflat (content_embedding vector_cosine_ops);
CREATE INDEX idx_vibe_user_time ON vibe_scores(user_id, timestamp DESC);
```

### 4.3 知识图谱结构（Neo4j）

```cypher
// 用户节点
(:User {
    id: string,
    name: string
})

// 用户提到的人
(:Person {
    id: string,
    name: string,
    relationship: string,  // "friend", "family", "colleague"
    first_mention: datetime,
    mention_count: int
})

// 话题/兴趣
(:Topic {
    id: string,
    name: string,
    category: string
})

// 人生事件
(:LifeEvent {
    id: string,
    type: string,
    description: string,
    date: date,
    emotional_impact: float
})

// 发现的模式
(:Pattern {
    id: string,
    type: string,
    description: string,
    confidence: float,
    first_detected: datetime
})

// 关系
(u:User)-[:KNOWS]->(p:Person)
(u:User)-[:INTERESTED_IN]->(t:Topic)
(u:User)-[:EXPERIENCED]->(e:LifeEvent)
(u:User)-[:HAS_PATTERN]->(pat:Pattern)
(p:Person)-[:MENTIONED_WITH]->(t:Topic)
(e:LifeEvent)-[:RELATED_TO]->(p:Person)
```

### 4.4 向量索引设计（Pinecone）

```python
# 索引配置
index_config = {
    "name": "mentis-memory",
    "dimension": 1536,  # OpenAI/Anthropic 嵌入尺寸
    "metric": "cosine",
    "pods": 1,
    "pod_type": "p1.x1",  # 性能层级
}

# 向量结构
vector = {
    "id": f"{user_id}:{entry_id}",
    "values": embedding,
    "metadata": {
        "user_id": user_id,
        "entry_type": "user_message",
        "emotion": "frustrated",
        "topics": ["work", "boss"],
        "timestamp": "2026-01-04T10:00:00Z",
    }
}

# 带元数据过滤的查询
results = index.query(
    vector=query_embedding,
    filter={
        "user_id": {"$eq": user_id},
        "timestamp": {"$gte": "2025-12-01T00:00:00Z"}
    },
    top_k=10,
    include_metadata=True
)
```

---

## 5. API 设计

### 5.1 REST API 端点

```yaml
# 认证
POST /api/auth/register          # 注册
POST /api/auth/login             # 登录
POST /api/auth/refresh           # 刷新令牌
POST /api/auth/logout            # 登出

# Stream
GET  /api/stream                 # 获取 stream 条目
POST /api/stream/input           # 发送用户输入
POST /api/stream/input/voice     # 语音输入（multipart）
POST /api/stream/input/image     # 图片输入（multipart）

# Vibe 分数
GET  /api/vibe/current           # 当前 Vibe 分数
GET  /api/vibe/history           # 历史分数
GET  /api/vibe/dimension/{dim}   # 单维度详情

# 模块
GET  /api/modules                # 列出可用模块
GET  /api/modules/{id}           # 模块详情
POST /api/modules/{id}/enable    # 启用模块
POST /api/modules/{id}/disable   # 禁用模块
GET  /api/modules/{id}/profile   # 获取模块画像

# 目标与任务
GET  /api/goals                  # 列出目标
POST /api/goals                  # 创建目标
PUT  /api/goals/{id}             # 更新目标
GET  /api/tasks                  # 列出任务
POST /api/tasks/{id}/complete    # 完成任务

# 周度 Mirror
GET  /api/mirror/weekly          # 当周 mirror
GET  /api/mirror/weekly/{week}   # 特定周
GET  /api/mirror/weekly/share    # 可分享图片

# 用户画像
GET  /api/me                     # 当前用户画像
PUT  /api/me                     # 更新画像
PUT  /api/me/settings            # 更新设置
DELETE /api/me                   # 删除账户
```

### 5.2 WebSocket 协议

```typescript
// 连接
ws://api.mentis.app/realtime?token={jwt}

// 消息类型
interface RealtimeMessage {
  type: 'stream_entry' | 'vibe_update' | 'typing' | 'error';
  payload: any;
  timestamp: string;
}

// 客户端 -> 服务端
interface ClientMessage {
  type: 'subscribe' | 'unsubscribe' | 'ping';
  channel?: string;
}

// 服务端 -> 客户端（Stream 条目）
{
  "type": "stream_entry",
  "payload": {
    "id": "uuid",
    "type": "ai_response",
    "content": "紧张说明你在乎...",
    "emotion_data": { ... }
  },
  "timestamp": "2026-01-04T10:00:00Z"
}

// 服务端 -> 客户端（Vibe 更新）
{
  "type": "vibe_update",
  "payload": {
    "total": 67,
    "emotional": 72,
    "label": "稳定但疲惫"
  },
  "timestamp": "2026-01-04T10:00:00Z"
}
```

### 5.3 响应格式

```json
{
  "success": true,
  "data": { ... },
  "meta": {
    "request_id": "uuid",
    "timestamp": "2026-01-04T10:00:00Z",
    "took_ms": 234
  }
}

// 错误响应
{
  "success": false,
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "请求过于频繁",
    "details": {
      "retry_after": 60
    }
  },
  "meta": { ... }
}
```

---

## 6. LLM 集成

### 6.1 提供商策略

```python
class LLMRouter:
    """
    基于任务路由请求到合适的 LLM 提供商
    """

    PROVIDERS = {
        "claude": ClaudeProvider(),
        "openai": OpenAIProvider(),
        "gemini": GeminiProvider(),
        "glm": GLMProvider(),  # 中国市场
    }

    TASK_ROUTING = {
        "emotion_analysis": ["claude", "openai"],
        "response_generation": ["claude"],
        "pattern_detection": ["claude", "gemini"],
        "embedding": ["openai"],
        "vision": ["claude", "gemini"],
        "chinese_content": ["glm", "claude"],
    }

    async def complete(
        self,
        task: str,
        prompt: str,
        **kwargs
    ) -> LLMResponse:
        providers = self.TASK_ROUTING.get(task, ["claude"])

        for provider_name in providers:
            provider = self.PROVIDERS[provider_name]
            try:
                return await provider.complete(prompt, **kwargs)
            except RateLimitError:
                continue
            except ProviderError:
                continue

        raise AllProvidersFailedError()
```

### 6.2 成本优化

| 策略 | 实现方式 | 节省比例 |
|------|----------|----------|
| **缓存** | Redis 缓存相似查询 | 30-40% |
| **分层** | 简单用 Haiku，复杂用 Opus | 50% |
| **批处理** | 分组相似请求 | 20% |
| **提示词压缩** | 移除冗余上下文 | 15% |
| **本地模型** | 边缘处理简单任务 | 可变 |

### 6.3 提示词工程

```python
class PromptBuilder:
    """
    构建结构一致的提示词
    """

    def build_response_prompt(
        self,
        input: StreamInput,
        context: ConversationContext,
        emotion: EmotionAnalysis,
        insights: List[Insight],
        strategy: ResponseStrategy
    ) -> str:
        return f"""
        <system>
        你是 Vibe，一个温暖且富有洞察力的 AI 伴侣，服务于 {context.user.name}。

        人格特质：
        - 温暖度：{context.persona.warmth}/10
        - 直接度：{context.persona.directness}/10
        - 幽默感：{context.persona.humor}/10

        沟通风格：{context.user.preferred_style}
        当前情绪状态：{emotion.primary_emotion}（强度：{emotion.intensity}）
        用户需求：{', '.join(emotion.user_needs)}
        </system>

        <context>
        用户画像：{context.user_profile_summary}
        最近对话：
        {self.format_recent_messages(context.recent_messages)}

        相关记忆：
        {self.format_memories(context.memories)}

        活跃洞察：
        {self.format_insights(insights)}
        </context>

        <strategy>
        响应方式：{strategy.approach}
        响应长度：{strategy.length}
        应包含：{strategy.include}
        应避免：{strategy.avoid}
        </strategy>

        <user_message>
        {input.text}
        </user_message>

        以 Vibe 的身份回应。保持真实，不要做作。
        """
```

---

## 7. 安全与隐私

### 7.1 数据保护

| 数据类型 | 保护措施 | 访问权限 |
|----------|----------|----------|
| 认证凭据 | Argon2 哈希 | 仅认证服务 |
| 个人数据 | 静态 AES-256 加密 | 用户 + 管理员 |
| 对话内容 | 可选端到端加密 | 仅用户 |
| 嵌入向量 | 假名化 | AI 服务 |
| 分析数据 | 聚合、匿名化 | 分析团队 |

### 7.2 认证流程

```
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│  客户端  │────▶│  认证    │────▶│  用户    │────▶│  令牌    │
│          │     │  网关    │     │  服务    │     │  服务    │
└──────────┘     └──────────┘     └──────────┘     └──────────┘
      │                                                   │
      │              JWT（访问 + 刷新）                   │
      │◀──────────────────────────────────────────────────│
      │
      │         受保护 API 请求
      ▼         Authorization: Bearer {jwt}
┌──────────┐     ┌──────────┐
│  客户端  │────▶│  API     │ ─── JWT 验证 ───▶ 允许/拒绝
│          │     │  网关    │
└──────────┘     └──────────┘
```

### 7.3 隐私控制

```python
class PrivacyManager:
    """
    用户可控的隐私设置
    """

    async def export_data(self, user_id: str) -> DataExport:
        """
        GDPR 合规数据导出
        """
        return DataExport(
            profile=await self.get_profile(user_id),
            conversations=await self.get_conversations(user_id),
            vibe_history=await self.get_vibe_history(user_id),
            module_data=await self.get_module_data(user_id),
        )

    async def delete_account(self, user_id: str):
        """
        完整账户删除
        """
        # 1. 从所有数据库删除
        await self.postgres.delete_user(user_id)
        await self.neo4j.delete_user_graph(user_id)
        await self.pinecone.delete_vectors(user_id)
        await self.redis.delete_user_cache(user_id)
        await self.s3.delete_user_media(user_id)

        # 2. 撤销所有会话
        await self.auth.revoke_all_tokens(user_id)

        # 3. 审计日志
        await self.audit.log("account_deleted", user_id)
```

---

## 8. 可扩展性与性能

### 8.1 扩展策略

| 组件 | 扩展方式 | 目标 |
|------|----------|------|
| Web 服务器 | 水平扩展（K8s HPA） | 每 Pod 10K req/s |
| WebSocket | 粘性会话 + Redis pub/sub | 每 Pod 50K 连接 |
| PostgreSQL | 读副本 + Citus | 100K QPS |
| Redis | 集群模式 | 100 万 ops/s |
| Pinecone | 托管自动扩展 | 自动 |
| LLM 调用 | 队列 + 限流 | 提供商限制 |

### 8.2 缓存策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           缓存层级                                          │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  L1: 内存（应用层）                                                 │   │
│  │  • 热用户会话                                                       │   │
│  │  • 频繁访问的配置                                                   │   │
│  │  TTL: 请求生命周期                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  L2: Redis 集群                                                     │   │
│  │  • 用户画像                                                         │   │
│  │  • 最近对话                                                         │   │
│  │  • 情绪分析结果                                                     │   │
│  │  • LLM 响应缓存                                                     │   │
│  │  TTL: 1 小时 - 24 小时                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  L3: CDN (Cloudflare)                                               │   │
│  │  • 静态资源                                                         │   │
│  │  • 公开内容                                                         │   │
│  │  • 分享卡片图片                                                     │   │
│  │  TTL: 1 天 - 1 年                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.3 性能目标

| 指标 | 目标 | 当前 |
|------|------|------|
| API 延迟（p50） | <100ms | 待测 |
| API 延迟（p99） | <500ms | 待测 |
| 聊天响应 | <2s | 待测 |
| WebSocket 传输 | <50ms | 待测 |
| 页面加载（LCP） | <2.5s | 待测 |
| 可用性 | 99.9% | 待测 |

---

## 9. 可观测性

### 9.1 监控栈

| 工具 | 用途 |
|------|------|
| **Datadog** | APM、指标、日志 |
| **Sentry** | 错误追踪 |
| **Grafana** | 仪表盘 |
| **PagerDuty** | 告警 |
| **PostHog** | 产品分析 |

### 9.2 关键指标

```python
# 业务指标
- daily_active_users           # 日活用户
- messages_per_user_per_day    # 每用户日均消息数
- proactive_push_engagement    # 主动推送参与率
- module_activation_rate       # 模块激活率
- vibe_score_trend             # Vibe 分数趋势

# 技术指标
- api_request_rate             # API 请求率
- api_error_rate               # API 错误率
- api_latency_percentiles      # API 延迟分位
- llm_token_usage              # LLM Token 使用量
- llm_cost_per_user            # 每用户 LLM 成本
- cache_hit_rate               # 缓存命中率
- db_query_latency             # 数据库查询延迟
- websocket_connections        # WebSocket 连接数
```

### 9.3 告警规则

```yaml
alerts:
  - name: high_error_rate
    condition: error_rate > 1%
    duration: 5m
    severity: critical
    message: "错误率过高"

  - name: high_latency
    condition: p99_latency > 2s
    duration: 5m
    severity: warning
    message: "响应延迟过高"

  - name: llm_cost_spike
    condition: daily_llm_cost > $1000
    severity: warning
    message: "LLM 成本飙升"

  - name: low_cache_hit
    condition: cache_hit_rate < 70%
    duration: 15m
    severity: warning
    message: "缓存命中率过低"
```

---

## 10. 部署架构

### 10.1 环境策略

| 环境 | 用途 | 配置 |
|------|------|------|
| **本地** | 开发 | Docker Compose |
| **开发** | 集成测试 | K8s（单节点） |
| **预发布** | 生产前验证 | K8s（完整副本） |
| **生产** | 正式用户 | K8s（多区域） |

### 10.2 CI/CD 管道

```yaml
# GitHub Actions 工作流
name: Deploy

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: 运行测试
        run: pnpm test

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: 构建 Docker 镜像
        run: docker build -t mentis-api .
      - name: 推送到仓库
        run: docker push gcr.io/mentis/api:${{ github.sha }}

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: 部署到预发布环境
        run: kubectl apply -f k8s/staging/

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: 部署到生产环境
        run: kubectl apply -f k8s/production/
```

### 10.3 基础设施即代码

```hcl
# Terraform 示例
resource "google_container_cluster" "mentis" {
  name     = "mentis-production"
  location = "us-central1"

  node_pool {
    name       = "default-pool"
    node_count = 3

    node_config {
      machine_type = "n2-standard-4"
    }

    autoscaling {
      min_node_count = 3
      max_node_count = 20
    }
  }
}

resource "google_sql_database_instance" "mentis" {
  name             = "mentis-postgres"
  database_version = "POSTGRES_15"
  region           = "us-central1"

  settings {
    tier = "db-custom-4-16384"

    backup_configuration {
      enabled = true
    }
  }
}
```

---

## 11. 技术栈总结

### 11.1 前端

| 组件 | 技术 | 选择理由 |
|------|------|----------|
| Web 框架 | Next.js 14 | SSR、App Router、RSC |
| UI 库 | React 18 | 生态、Hooks |
| 样式 | Tailwind CSS | 原子化、快速 |
| 状态管理 | Zustand | 轻量、简单 |
| 动画 | Framer Motion | 声明式、强大 |
| 表单 | React Hook Form + Zod | 验证、性能 |

### 11.2 后端

| 组件 | 技术 | 选择理由 |
|------|------|----------|
| API 框架 | FastAPI | 异步、类型提示 |
| 语言 | Python 3.11+ | AI/ML 生态 |
| 任务队列 | Celery + Redis | 可靠、可扩展 |
| WebSocket | FastAPI + Redis Pub/Sub | 实时 |
| ORM | SQLAlchemy 2.0 | 异步、强大 |

### 11.3 AI/ML

| 组件 | 技术 | 选择理由 |
|------|------|----------|
| 主 LLM | Claude (Anthropic) | 质量、安全 |
| 备用 LLM | GPT-4 (OpenAI) | 可用性 |
| 中文 LLM | GLM-4 (智谱) | 中国市场 |
| 嵌入 | text-embedding-3 | 质量、成本 |
| 向量库 | Pinecone | 托管、快速 |

### 11.4 基础设施

| 组件 | 技术 | 选择理由 |
|------|------|----------|
| 容器编排 | Kubernetes (GKE) | 可扩展性 |
| IaC | Terraform | 声明式 |
| CI/CD | GitHub Actions | 集成 |
| CDN | Cloudflare | 性能 |
| 密钥管理 | Google Secret Manager | 安全 |

---

## 12. 未来架构考量

### 12.1 多区域部署

- 主要：美国中部
- 次要：欧洲（GDPR 合规）
- 第三：亚太（中国市场）

### 12.2 离线能力

- Web 端 Service Worker
- 移动端 SQLite 本地存储
- 重连时同步协议

### 12.3 边缘计算

- 边缘情绪检测
- 本地嵌入生成
- 减少常见操作延迟

### 12.4 多模态扩展

- 实时语音对话
- 视频情绪分析
- 可穿戴设备生物指标集成

---

## 版本历史

| 版本 | 日期 | 作者 | 变更 |
|------|------|------|------|
| 1.0 | 2026年1月 | 架构团队 | 初始规范 |

---

*Mentis 架构团队*
*解码命运 · 重塑认知 · 进化人生*
