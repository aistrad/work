"""
Message Repository - Database operations for chat messages
Based on: vibelife spec v3.0 schema (001_v3_schema.sql)
"""
import json
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4
from datetime import datetime
import logging

from .db import get_connection, fetchrow, fetch, execute

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# Data Models
# ═══════════════════════════════════════════════════════════════════════════

class MessageRecord:
    """Message database record"""

    def __init__(
        self,
        id: UUID,
        conversation_id: UUID,
        role: str,
        content: str,
        metadata: Optional[Dict[str, Any]],
        created_at: datetime
    ):
        self.id = id
        self.conversation_id = conversation_id
        self.role = role
        self.content = content
        self.metadata = metadata or {}
        self.created_at = created_at

    def to_dict(self) -> dict:
        return {
            "id": str(self.id),
            "conversation_id": str(self.conversation_id),
            "role": self.role,
            "content": self.content,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }

    def to_chat_format(self) -> dict:
        """Convert to format used by LLM context builder"""
        return {
            "role": self.role,
            "content": self.content,
        }

    @classmethod
    def from_row(cls, row: dict) -> "MessageRecord":
        metadata = row.get("metadata")
        if isinstance(metadata, str):
            metadata = json.loads(metadata)

        return cls(
            id=row["id"],
            conversation_id=row["conversation_id"],
            role=row["role"],
            content=row["content"],
            metadata=metadata,
            created_at=row.get("created_at"),
        )


# ═══════════════════════════════════════════════════════════════════════════
# Repository Functions
# ═══════════════════════════════════════════════════════════════════════════

async def create_message(
    conversation_id: UUID,
    role: str,
    content: str,
    metadata: Optional[Dict[str, Any]] = None
) -> MessageRecord:
    """
    Create a new message.

    Args:
        conversation_id: Conversation ID
        role: user | assistant | system
        content: Message content
        metadata: Optional metadata (tool calls, extracted info, etc.)

    Returns:
        Created MessageRecord
    """
    message_id = uuid4()

    query = """
        INSERT INTO messages (id, conversation_id, role, content, metadata)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *
    """

    metadata_json = json.dumps(metadata) if metadata else "{}"

    try:
        async with get_connection() as conn:
            row = await conn.fetchrow(
                query,
                message_id,
                conversation_id,
                role,
                content,
                metadata_json
            )
            return MessageRecord.from_row(dict(row))
    except Exception as e:
        logger.error(f"Failed to create message: {e}")
        raise


async def get_message(message_id: UUID) -> Optional[MessageRecord]:
    """Get a message by ID"""
    query = "SELECT * FROM messages WHERE id = $1"

    try:
        row = await fetchrow(query, message_id)
        if row:
            return MessageRecord.from_row(dict(row))
        return None
    except Exception as e:
        logger.error(f"Failed to get message: {e}")
        raise


async def list_messages(
    conversation_id: UUID,
    limit: int = 50,
    offset: int = 0,
    order: str = "asc"
) -> List[MessageRecord]:
    """
    List messages in a conversation.

    Args:
        conversation_id: Conversation ID
        limit: Max results
        offset: Pagination offset
        order: asc or desc by created_at

    Returns:
        List of MessageRecord
    """
    order_dir = "ASC" if order.lower() == "asc" else "DESC"

    query = f"""
        SELECT * FROM messages
        WHERE conversation_id = $1
        ORDER BY created_at {order_dir}
        LIMIT $2 OFFSET $3
    """

    try:
        rows = await fetch(query, conversation_id, limit, offset)
        return [MessageRecord.from_row(dict(row)) for row in rows]
    except Exception as e:
        logger.error(f"Failed to list messages: {e}")
        raise


async def get_recent_messages(
    conversation_id: UUID,
    limit: int = 20
) -> List[MessageRecord]:
    """
    Get recent messages for context building.
    Returns messages in chronological order (oldest first).
    """
    # Get latest N messages, then reverse
    query = """
        SELECT * FROM (
            SELECT * FROM messages
            WHERE conversation_id = $1
            ORDER BY created_at DESC
            LIMIT $2
        ) sub
        ORDER BY created_at ASC
    """

    try:
        rows = await fetch(query, conversation_id, limit)
        return [MessageRecord.from_row(dict(row)) for row in rows]
    except Exception as e:
        logger.error(f"Failed to get recent messages: {e}")
        raise


async def get_messages_for_context(
    conversation_id: UUID,
    limit: int = 20
) -> List[Dict[str, str]]:
    """
    Get messages formatted for LLM context.
    Returns list of {role, content} dicts.
    """
    messages = await get_recent_messages(conversation_id, limit)
    return [msg.to_chat_format() for msg in messages]


async def count_messages(conversation_id: UUID) -> int:
    """Count messages in a conversation"""
    query = "SELECT COUNT(*) FROM messages WHERE conversation_id = $1"

    try:
        async with get_connection() as conn:
            return await conn.fetchval(query, conversation_id)
    except Exception as e:
        logger.error(f"Failed to count messages: {e}")
        raise


async def delete_message(message_id: UUID) -> bool:
    """Delete a single message"""
    query = "DELETE FROM messages WHERE id = $1"

    try:
        result = await execute(query, message_id)
        return "DELETE 1" in result
    except Exception as e:
        logger.error(f"Failed to delete message: {e}")
        raise


async def delete_conversation_messages(conversation_id: UUID) -> int:
    """Delete all messages in a conversation"""
    query = "DELETE FROM messages WHERE conversation_id = $1"

    try:
        result = await execute(query, conversation_id)
        # Parse "DELETE N" to get count
        if "DELETE" in result:
            return int(result.split(" ")[1])
        return 0
    except Exception as e:
        logger.error(f"Failed to delete conversation messages: {e}")
        raise


async def update_message_metadata(
    message_id: UUID,
    metadata: Dict[str, Any]
) -> Optional[MessageRecord]:
    """Update message metadata (merge with existing)"""
    query = """
        UPDATE messages
        SET metadata = COALESCE(metadata, '{}'::jsonb) || $2::jsonb
        WHERE id = $1
        RETURNING *
    """

    try:
        row = await fetchrow(query, message_id, json.dumps(metadata))
        if row:
            return MessageRecord.from_row(dict(row))
        return None
    except Exception as e:
        logger.error(f"Failed to update message metadata: {e}")
        raise


async def search_messages(
    user_id: UUID,
    query_text: str,
    limit: int = 20
) -> List[MessageRecord]:
    """
    Search messages by content (full-text search).
    Only searches within user's conversations.
    """
    query = """
        SELECT m.* FROM messages m
        JOIN conversations c ON m.conversation_id = c.id
        WHERE c.user_id = $1
        AND m.content ILIKE $2
        ORDER BY m.created_at DESC
        LIMIT $3
    """

    try:
        rows = await fetch(query, user_id, f"%{query_text}%", limit)
        return [MessageRecord.from_row(dict(row)) for row in rows]
    except Exception as e:
        logger.error(f"Failed to search messages: {e}")
        raise


# ═══════════════════════════════════════════════════════════════════════════
# Goal-Anchored History (v10.1)
# 借鉴 Planning-with-Files 的 Attention Manipulation 原则
# 第一条消息（用户原始意图）永远保留在 context 中
# ═══════════════════════════════════════════════════════════════════════════

async def get_messages_anchored(
    conversation_id: UUID,
    limit: int = 14
) -> List[Dict[str, str]]:
    """
    Goal-Anchored History：第一条消息 + 最近 N 条

    解决问题：长对话（50+ 条）后，原始目标被挤出注意力窗口

    原理（来自 Manus/PWF）：
    - Context Window = RAM（易失、有限）
    - 第一条消息 = 用户原始意图 = Goal
    - 通过保留第一条消息实现 Attention Manipulation

    Args:
        conversation_id: 会话 ID
        limit: 最近消息数量（默认 14，加第一条共 15 条）

    Returns:
        [第一条消息] + [最近 N 条消息]，按时间顺序排列
    """
    # 使用 UNION 合并第一条和最近 N 条，避免重复
    query = """
        WITH first_msg AS (
            SELECT * FROM messages
            WHERE conversation_id = $1
            ORDER BY created_at ASC
            LIMIT 1
        ),
        recent_msgs AS (
            SELECT * FROM messages
            WHERE conversation_id = $1
            ORDER BY created_at DESC
            LIMIT $2
        ),
        combined AS (
            SELECT * FROM first_msg
            UNION
            SELECT * FROM recent_msgs
        )
        SELECT * FROM combined ORDER BY created_at ASC
    """

    try:
        rows = await fetch(query, conversation_id, limit)
        return [{"role": row["role"], "content": row["content"]} for row in rows]
    except Exception as e:
        logger.error(f"Failed to get anchored messages: {e}")
        raise


async def get_first_message(conversation_id: UUID) -> Optional[Dict[str, str]]:
    """获取会话的第一条消息（用户原始意图）"""
    query = """
        SELECT role, content FROM messages
        WHERE conversation_id = $1
        ORDER BY created_at ASC
        LIMIT 1
    """

    try:
        row = await fetchrow(query, conversation_id)
        if row:
            return {"role": row["role"], "content": row["content"]}
        return None
    except Exception as e:
        logger.error(f"Failed to get first message: {e}")
        raise
