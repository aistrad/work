"use client";

/**
 * ChatContainer - v5.2 æ€§èƒ½ä¼˜åŒ–ç‰ˆ
 *
 * ä¼˜åŒ–ç‚¹:
 * 1. ä½¿ç”¨ content-visibility ä¼˜åŒ–é•¿æ¶ˆæ¯åˆ—è¡¨ (Vercel rule: rendering-content-visibility)
 * 2. Memoize ChatEmptyState ç»„ä»¶ (Vercel rule: rerender-extract-component)
 * 3. ä½¿ç”¨ç¼“å­˜çš„ localStorage å·¥å…· (Vercel rule: js-cache-storage)
 */

import { useRef, useEffect, useMemo, useCallback, useState, memo } from "react";
import type { Message } from "ai/react";
import { toast } from "sonner";
import { ChatMessage } from "./ChatMessage";
import { ChatInput } from "./ChatInput";
import { InsightCard, InsightType } from "@/components/insight/InsightCard";
import { VibeGlyph, BreathAura, type SkillType } from "@/components/core";
import { DailyGreeting } from "@/components/greeting/DailyGreeting";
import { ChatWelcomeMessage } from "./ChatWelcomeMessage";
import { useVibeChat, type SkillId } from "@/hooks/useVibeChat";
import { getLocalStorageJSON, getLocalStorage, setLocalStorage } from "@/utils/storage";
import { useDashboardWelcomeData } from "@/hooks/useDashboardWelcomeData";
import type { DashboardDTO } from "@/types/dashboard";

interface InsightData {
  id: string;
  insight_type: InsightType;
  title: string;
  content: string;
}

/**
 * Extract text content from AI SDK Message
 */
function getMessageContent(message: Message): string {
  return message.content || '';
}

/**
 * UUID ç”Ÿæˆå‡½æ•°ï¼ˆå…¼å®¹ SSR å’Œä¸æ”¯æŒ crypto.randomUUID çš„ç¯å¢ƒï¼‰
 */
function generateUUID(): string {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  // Fallback: ä½¿ç”¨ crypto.getRandomValues
  if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function") {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = (crypto.getRandomValues(new Uint8Array(1))[0] & 15) >> (c === "x" ? 0 : 3);
      return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
    });
  }
  // Fallback: Math.random
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
  });
}

export type VoiceMode = "warm" | "sarcastic" | "wise";

export interface ChatContainerProps {
  /**
   * Skill ID - å¯é€‰
   * - ä¼ å…¥æ—¶ï¼šåç«¯ç›´æ¥ä½¿ç”¨è¯¥ skill
   * - ä¸ä¼ æ—¶ï¼šåç«¯ CoreAgent é€šè¿‡ LLM è‡ªåŠ¨è·¯ç”±
   */
  skillId?: string;
  /**
   * Scenario/Rule ID - å¯é€‰
   * - ä¼ å…¥æ—¶ï¼šåç«¯ç›´æ¥åŠ è½½å¯¹åº”çš„ Rule æ–‡ä»¶
   * - ä¸ä¼ æ—¶ï¼šåç«¯æ ¹æ® tags åŒ¹é…æˆ–ä½¿ç”¨é»˜è®¤ scenario
   */
  scenario?: string;
  /**
   * ç”¨äº UI å±•ç¤ºçš„ skillï¼ˆä¸»é¢˜ã€ç©ºçŠ¶æ€ç­‰ï¼‰
   * å½“ skillId ä¸ä¼ æ—¶ï¼Œæ­¤å­—æ®µä»å¯ç”¨äº UI å±•ç¤º
   */
  skill?: SkillType;
  conversationId?: string;
  voiceMode?: VoiceMode;
  onConversationStart?: (id: string) => void;
  /**
   * ä» URL ä¼ å…¥çš„åˆå§‹æ¶ˆæ¯ï¼ˆå¦‚ä»é€šçŸ¥è·³è½¬ï¼‰
   */
  initialPrompt?: string | null;
  /**
   * åˆå§‹æ¶ˆæ¯å‘é€åçš„å›è°ƒ
   */
  onInitialPromptSent?: () => void;
  /**
   * Dashboard æ•°æ®ï¼ˆç”¨äºç©ºçŠ¶æ€ï¼‰
   */
  dashboardData?: DashboardDTO | null;
  /**
   * Dashboard æ•°æ®åŠ è½½çŠ¶æ€
   */
  isDashboardLoading?: boolean;
  /**
   * ç­¾åˆ°å›è°ƒ
   */
  onCheckIn?: () => Promise<void>;
  /**
   * æ æ†æ‰“å‹¾å›è°ƒ
   */
  onToggleLever?: (leverId: string) => Promise<void>;
  /**
   * å¤§çŸ³å¤´æ‰“å‹¾å›è°ƒ
   */
  onToggleRock?: (rockId: string) => Promise<void>;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ChatEmptyState - LUMINOUS PAPER Design System
// ç©ºçŠ¶æ€ï¼šå±…ä¸­ VibeGlyph + æŠ€èƒ½æ„ŸçŸ¥æ–‡æ¡ˆ + å‘¼å¸å…‰æ™•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const SKILL_EMPTY_STATE: Record<SkillType, { title: string; subtitle: string }> = {
  bazi: {
    title: "æ¢ç´¢ä½ çš„å‘½ç†",
    subtitle: "åˆ†äº«ä½ çš„ç”Ÿè¾°ï¼Œå¼€å¯å…«å­—è§£è¯»ä¹‹æ—…",
  },
  zodiac: {
    title: "å€¾å¬æ˜Ÿè¾°çš„å£°éŸ³",
    subtitle: "è®©æ˜Ÿç›˜ä¸ºä½ æ­ç¤ºå®‡å®™çš„å¯†è¯­",
  },
  mbti: {
    title: "å‘ç°çœŸå®çš„è‡ªå·±",
    subtitle: "é€šè¿‡å¯¹è¯ï¼Œæ¢ç´¢ä½ çš„äººæ ¼ç‰¹è´¨",
  },
  attach: {
    title: "ç†è§£ä½ çš„ä¾æ‹æ¨¡å¼",
    subtitle: "æ¢ç´¢äº²å¯†å…³ç³»ä¸­çš„è‡ªæˆ‘",
  },
  career: {
    title: "è§„åˆ’ä½ çš„èŒä¸šè“å›¾",
    subtitle: "è®©æˆ‘ä»¬ä¸€èµ·æ¢ç´¢ä½ çš„èŒä¸šå‘å±•æ–¹å‘",
  },
  lifecoach: {
    title: "å¼€å¯äººç”Ÿæ•™ç»ƒä¹‹æ—…",
    subtitle: "ç§‘å­¦æ–¹æ³•ï¼ŒåŠ©ä½ çªç ´ç“¶é¢ˆï¼Œé‡å¡‘äººç”Ÿ",
  },
};

// Quick prompts for each skill with icons and categories
interface QuickPromptItem {
  icon: string;
  category: string;
  question: string;
  gradient: string;
}

const SKILL_QUICK_PROMPTS: Record<SkillType, QuickPromptItem[]> = {
  bazi: [
    { icon: "ğŸ‚", category: "ç”Ÿè¾°ä¿¡æ¯", question: "æˆ‘æ˜¯1990å¹´5æœˆ15æ—¥æ—©ä¸Š8ç‚¹å‡ºç”Ÿçš„", gradient: "from-blue-500/10 to-cyan-500/10" },
    { icon: "ğŸ“ˆ", category: "è¿åŠ¿åˆ†æ", question: "å¸®æˆ‘åˆ†æä»Šå¹´çš„è¿åŠ¿", gradient: "from-purple-500/10 to-pink-500/10" },
    { icon: "ğŸ’¼", category: "äº‹ä¸šå‘å±•", question: "æˆ‘çš„äº‹ä¸šè¿å¦‚ä½•ï¼Ÿ", gradient: "from-orange-500/10 to-red-500/10" },
    { icon: "â°", category: "æ—¶æœºé€‰æ‹©", question: "ä»€ä¹ˆæ—¶å€™é€‚åˆåšé‡å¤§å†³å®šï¼Ÿ", gradient: "from-green-500/10 to-teal-500/10" },
  ],
  zodiac: [
    { icon: "â­", category: "è¿åŠ¿æŸ¥è¯¢", question: "æˆ‘æ˜¯åŒå­åº§ï¼Œå¸®æˆ‘çœ‹çœ‹æœ¬å‘¨è¿åŠ¿", gradient: "from-purple-500/10 to-pink-500/10" },
    { icon: "ğŸŒ™", category: "æ˜Ÿç›˜è§£è¯»", question: "æˆ‘çš„å¤ªé˜³æ˜Ÿåº§å’Œä¸Šå‡æ˜Ÿåº§æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ", gradient: "from-indigo-500/10 to-purple-500/10" },
    { icon: "ğŸ’•", category: "å…³ç³»åŒ¹é…", question: "åŒå­åº§å’Œä»€ä¹ˆæ˜Ÿåº§æœ€é…ï¼Ÿ", gradient: "from-rose-500/10 to-pink-500/10" },
    { icon: "ğŸŒ€", category: "æ˜Ÿè±¡å½±å“", question: "æ°´é€†å¯¹æˆ‘æœ‰ä»€ä¹ˆå½±å“ï¼Ÿ", gradient: "from-blue-500/10 to-cyan-500/10" },
  ],
  mbti: [
    { icon: "ğŸ”", category: "ç±»å‹æµ‹è¯•", question: "å¸®æˆ‘æµ‹æµ‹æˆ‘çš„MBTIç±»å‹", gradient: "from-blue-500/10 to-cyan-500/10" },
    { icon: "ğŸ’¼", category: "èŒä¸šå»ºè®®", question: "INFPé€‚åˆä»€ä¹ˆèŒä¸šï¼Ÿ", gradient: "from-orange-500/10 to-amber-500/10" },
    { icon: "ğŸ‘¥", category: "äººé™…å…³ç³»", question: "æˆ‘æ˜¯INTJï¼Œå¦‚ä½•æ”¹å–„äººé™…å…³ç³»ï¼Ÿ", gradient: "from-green-500/10 to-teal-500/10" },
    { icon: "âš¡", category: "ç±»å‹å¯¹æ¯”", question: "Eäººå’ŒIäººæœ‰ä»€ä¹ˆæœ¬è´¨åŒºåˆ«ï¼Ÿ", gradient: "from-purple-500/10 to-pink-500/10" },
  ],
  attach: [
    { icon: "ğŸ”", category: "ç±»å‹åˆ†æ", question: "å¸®æˆ‘åˆ†ææˆ‘çš„ä¾æ‹ç±»å‹", gradient: "from-blue-500/10 to-cyan-500/10" },
    { icon: "ğŸ’‘", category: "å…³ç³»å»ºè®¾", question: "å›é¿å‹ä¾æ‹å¦‚ä½•å»ºç«‹äº²å¯†å…³ç³»ï¼Ÿ", gradient: "from-rose-500/10 to-pink-500/10" },
    { icon: "ğŸ›¡ï¸", category: "å†…å¿ƒæ¢ç´¢", question: "ä¸ºä»€ä¹ˆæˆ‘æ€»æ˜¯å®³æ€•è¢«æŠ›å¼ƒï¼Ÿ", gradient: "from-amber-500/10 to-orange-500/10" },
    { icon: "ğŸ’š", category: "è‡ªæˆ‘ç–—æ„ˆ", question: "å¦‚ä½•æ²»æ„ˆç«¥å¹´çš„æƒ…æ„Ÿåˆ›ä¼¤ï¼Ÿ", gradient: "from-green-500/10 to-teal-500/10" },
  ],
  career: [
    { icon: "ğŸ¯", category: "èŒä¸šè§„åˆ’", question: "æˆ‘è¯¥å¦‚ä½•è§„åˆ’èŒä¸šå‘å±•ï¼Ÿ", gradient: "from-blue-500/10 to-cyan-500/10" },
    { icon: "ğŸš€", category: "æ–¹å‘é€‰æ‹©", question: "æˆ‘é€‚åˆåˆ›ä¸šè¿˜æ˜¯æ‰“å·¥ï¼Ÿ", gradient: "from-orange-500/10 to-red-500/10" },
    { icon: "ğŸ’ª", category: "é¢è¯•æŠ€å·§", question: "å¦‚ä½•åœ¨é¢è¯•ä¸­å±•ç°è‡ªå·±ï¼Ÿ", gradient: "from-green-500/10 to-teal-500/10" },
    { icon: "ğŸ”„", category: "èŒä¸šè½¬å‹", question: "è½¬è¡Œéœ€è¦è€ƒè™‘ä»€ä¹ˆï¼Ÿ", gradient: "from-purple-500/10 to-pink-500/10" },
  ],
  lifecoach: [
    { icon: "ğŸ¯", category: "ç›®æ ‡è®¾å®š", question: "æˆ‘æƒ³æ‰¾åˆ°äººç”Ÿæ–¹å‘ï¼Œä½†ä¸çŸ¥é“ä»å“ªå¼€å§‹", gradient: "from-red-500/10 to-pink-500/10" },
    { icon: "ğŸ”„", category: "çªç ´ç“¶é¢ˆ", question: "æˆ‘æ„Ÿè§‰å¡ä½äº†ï¼Œæƒ³è¦çªç ´ç°çŠ¶", gradient: "from-purple-500/10 to-indigo-500/10" },
    { icon: "âš¡", category: "ä¹ æƒ¯å…»æˆ", question: "å¦‚ä½•å»ºç«‹é«˜æ•ˆçš„æ—¥å¸¸ä¹ æƒ¯ï¼Ÿ", gradient: "from-orange-500/10 to-amber-500/10" },
    { icon: "ğŸ’¡", category: "ä»·å€¼åˆ›é€ ", question: "å¦‚ä½•æŠŠå…´è¶£å˜æˆäº‹ä¸šï¼Ÿ", gradient: "from-green-500/10 to-teal-500/10" },
  ],
};

// API calls now go through Next.js API routes

// æœ¬åœ° fallback æ•°æ®ç”Ÿæˆ
function getLocalGreetingData(skill: SkillType) {
  const now = new Date();
  const hour = now.getHours();
  const month = now.getMonth();
  const day = now.getDate();
  const isoDate = now.toISOString().slice(0, 10);

  // ç¡®å®šæ—¶æ®µ
  type TimeOfDay = "dawn" | "morning" | "afternoon" | "evening" | "night";
  let timeOfDay: TimeOfDay = "morning";
  let greeting = "æ–°çš„ä¸€å¤©å¼€å§‹äº†";

  if (hour >= 5 && hour < 7) {
    timeOfDay = "dawn";
    greeting = "æ™¨å…‰ç†¹å¾®";
  } else if (hour >= 7 && hour < 12) {
    timeOfDay = "morning";
    greeting = "æ„¿ä½ èƒ½é‡æ»¡æ»¡";
  } else if (hour >= 12 && hour < 18) {
    timeOfDay = "afternoon";
    greeting = "ä¿æŒä¸“æ³¨";
  } else if (hour >= 18 && hour < 21) {
    timeOfDay = "evening";
    greeting = "è¾›è‹¦ä¸€å¤©äº†";
  } else {
    timeOfDay = "night";
    greeting = "å¤œæ·±äº†ï¼Œæ—©ç‚¹ä¼‘æ¯";
  }

  const solarTerms = [
    "å°å¯’", "å¤§å¯’", "ç«‹æ˜¥", "é›¨æ°´", "æƒŠè›°", "æ˜¥åˆ†",
    "æ¸…æ˜", "è°·é›¨", "ç«‹å¤", "å°æ»¡", "èŠ’ç§", "å¤è‡³",
    "å°æš‘", "å¤§æš‘", "ç«‹ç§‹", "å¤„æš‘", "ç™½éœ²", "ç§‹åˆ†",
    "å¯’éœ²", "éœœé™", "ç«‹å†¬", "å°é›ª", "å¤§é›ª", "å†¬è‡³",
  ];
  const termIdx = month * 2 + (day >= 15 ? 1 : 0);
  const solarTerm = solarTerms[termIdx % 24];

  const seasonTips: Record<string, string> = {
    å°å¯’: "å†¬è—æ—¶èŠ‚ï¼Œåˆ©äºå›é¡¾ä¸è§„åˆ’", å¤§å¯’: "ä¸¥å¯’ä¹‹é™…ï¼Œè“„åŠ›å¾…å‘",
    ç«‹æ˜¥: "ä¸‡ç‰©å¤è‹ï¼Œé€‚åˆå¯åŠ¨æ–°è®¡åˆ’", é›¨æ°´: "æ¶¦ç‰©æ— å£°ï¼Œé™å¿ƒæ»‹å…»",
    æƒŠè›°: "æ˜¥é›·æƒŠé†’ï¼Œè¡ŒåŠ¨èµ·æ¥", æ˜¥åˆ†: "æ˜¼å¤œå¹³åˆ†ï¼Œè°ƒå’Œèº«å¿ƒ",
    æ¸…æ˜: "å¤©æ¸…åœ°æ˜ï¼Œæ•´ç†æ€ç»ª", è°·é›¨: "é›¨ç”Ÿç™¾è°·ï¼Œæ’­ç§å¸Œæœ›",
    ç«‹å¤: "å¤æ°”æ¸ç››ï¼Œä¿æŒæ´»åŠ›", å°æ»¡: "å°æœ‰æ‰€æˆï¼Œç»§ç»­åŠªåŠ›",
    èŠ’ç§: "æ’­ç§æ”¶è·ï¼Œå‹¤å‹‰ä¸æ‡ˆ", å¤è‡³: "é˜³æ°”é¼ç››ï¼Œé€‚åº¦ä¼‘æ¯",
    å°æš‘: "æš‘æ°”åˆå‡ï¼Œæ¸…å¿ƒå®ç¥", å¤§æš‘: "é…·æš‘éš¾è€ï¼Œé™ä»¥å…»å¿ƒ",
    ç«‹ç§‹: "ç§‹æ„æ¸èµ·ï¼Œæ”¶è·æ—¶èŠ‚", å¤„æš‘: "æš‘æ°”æ¸æ¶ˆï¼Œè°ƒæ•´èŠ‚å¥",
    ç™½éœ²: "ç§‹å‡‰æ¸æµ“ï¼Œæ”¶æ•›å¿ƒç¥", ç§‹åˆ†: "ç§‹é«˜æ°”çˆ½ï¼Œå¹³è¡¡å·¥ä½œä¸ç”Ÿæ´»",
    å¯’éœ²: "éœ²æ°´æ¸å¯’ï¼Œæ³¨æ„ä¿å…»", éœœé™: "éœœé™æ°´æ³½ï¼Œæ²‰æ·€ç§¯ç´¯",
    ç«‹å†¬: "å†¬å­£æ¥ä¸´ï¼Œå‚¨å¤‡èƒ½é‡", å°é›ª: "é›ªèŠ±åˆé™ï¼Œå†…çœæ—¶åˆ»",
    å¤§é›ª: "ç‘é›ªå…†ä¸°ï¼Œé™å¾…æ¥å¹´", å†¬è‡³: "ä¸€é˜³åˆç”Ÿï¼Œå¦ææ³°æ¥",
  };

  const baziHints: Record<string, string> = {
    å°å¯’: "æ°´æ—ºä¹‹å­£ï¼Œåˆ©äºæ€è€ƒä¸è§„åˆ’", å¤§å¯’: "æ°´æ°”æœ€ç››ï¼Œé€‚åˆå†…çœæ²‰æ·€",
    ç«‹æ˜¥: "æœ¨æ°”åˆç”Ÿï¼Œå®œå¼€å¯æ–°äº‹ä¸š", æ˜¥åˆ†: "æœ¨æ°”æ—ºç››ï¼Œé€‚åˆæ‹“å±•äººè„‰",
    ç«‹å¤: "ç«æ°”æ¸å‡ï¼Œåˆ©äºè¡¨è¾¾å±•ç°", å¤è‡³: "ç«æ°”æ­£ç››ï¼Œæ³¨æ„å¹³è¡¡",
    ç«‹ç§‹: "é‡‘æ°”åˆç”Ÿï¼Œé€‚åˆå†³æ–­å–èˆ", ç§‹åˆ†: "é‡‘æ°”æ—ºç››ï¼Œåˆ©äºæ”¶è·æˆæœ",
    ç«‹å†¬: "æ°´æ°”åˆç”Ÿï¼Œå®œä¼‘å…»ç”Ÿæ¯", å†¬è‡³: "ä¸€é˜³å¤å§‹ï¼Œåšç§¯è–„å‘",
  };

  const dateStr = `${month + 1}æœˆ${day}æ—¥`;
  const seedStr = `${isoDate}:${skill}:${solarTerm}:${timeOfDay}`;
  let hash = 0;
  for (let i = 0; i < seedStr.length; i += 1) {
    hash = (hash * 31 + seedStr.charCodeAt(i)) % 100000;
  }
  const fortuneScore = Math.max(32, Math.min(92, 42 + (hash % 51)));
  const fortuneHint = skill === "bazi"
    ? (baziHints[solarTerm] || "ä»Šå¤©é€‚åˆç¨³ä½èŠ‚å¥ï¼ŒæŠŠåŠ›æ°”ç”¨åœ¨å…³é”®å¤„ã€‚")
    : (seasonTips[solarTerm] || "ä»Šå¤©é€‚åˆæŠŠæ³¨æ„åŠ›æ”¶å›åˆ°è‡ªå·±èº«ä¸Šã€‚");

  const actionText =
    timeOfDay === "dawn" || timeOfDay === "morning"
      ? "å†™ä¸‹ä»Šå¤©æœ€é‡è¦çš„ä¸€ä»¶äº‹ï¼Œå¹¶ç”¨ 25 åˆ†é’Ÿå¯åŠ¨å®ƒ"
      : timeOfDay === "afternoon"
        ? "æŠŠä¸€ä»¶æ‚¬è€Œæœªå†³çš„å°äº‹æ”¶å°¾ï¼Œç»™è‡ªå·±ä¸€ä¸ªç¡®å®šæ„Ÿ"
        : timeOfDay === "evening"
          ? "ç”¨ 10 åˆ†é’Ÿå¤ç›˜ä»Šå¤©ï¼šåšå¯¹äº†ä»€ä¹ˆã€ä¸‹ä¸€æ­¥æ˜¯ä»€ä¹ˆ"
          : "å…³æœºå‰å†™ä¸€å¥æ„Ÿè°¢ï¼Œç»™å¤§è„‘ä¸€ä¸ªæŸ”è½¯çš„ç»“å°¾";

  return {
    greeting, solarTerm, timeOfDay, date: dateStr, isoDate,
    todayTip: seasonTips[solarTerm] || "ä¸“æ³¨å½“ä¸‹ï¼Œç¨³æ­¥å‰è¡Œ",
    baziHint: skill === "bazi" ? (baziHints[solarTerm] || null) : null,
    fortuneScore, fortuneHint, actionText, isFromApi: false,
  };
}

// ç”Ÿæˆå½“æ—¥é—®å€™æ•°æ® - ä½¿ç”¨æœ¬åœ°ç®—æ³•ç”Ÿæˆ
// NOTE: åŸ API è°ƒç”¨å·²ç§»é™¤ï¼Œå› åç«¯ /api/v1/fortune/greeting æœªå®ç°
// æœ¬åœ°ç®—æ³•å·²æä¾›å®Œæ•´åŠŸèƒ½ï¼šèŠ‚æ°”ã€æ—¶è¾°ã€è¿åŠ¿è¯„åˆ†ç­‰
function useDailyGreeting(skill: SkillType) {
  // åˆå§‹çŠ¶æ€ä½¿ç”¨é»˜è®¤å€¼ï¼Œé¿å… hydration mismatch
  const [data, setData] = useState(() => ({
    greeting: "æ–°çš„ä¸€å¤©å¼€å§‹äº†",
    timeOfDay: "morning" as "dawn" | "morning" | "afternoon" | "evening" | "night",
    solarTerm: "ç«‹æ˜¥",
    isoDate: new Date().toISOString().slice(0, 10),
    todayTip: "ä¸“æ³¨å½“ä¸‹ï¼Œç¨³æ­¥å‰è¡Œ",
    baziHint: null as string | null,
    fortuneScore: 75,
    fortuneHint: "è¿åŠ¿å¹³ç¨³",
    actionText: "ä»Šæ—¥å®œ",
    isFromApi: false,
  }));
  const [loading] = useState(false);

  // åœ¨å®¢æˆ·ç«¯è®¡ç®—å®é™…çš„é—®å€™æ•°æ®
  useEffect(() => {
    setData(getLocalGreetingData(skill));
  }, [skill]);

  return { ...data, loading };
}

// Memoized ChatEmptyState (Vercel rule: rerender-extract-component)
const ChatEmptyState = memo(function ChatEmptyState({ skill, onQuickPrompt }: { skill: SkillType; onQuickPrompt?: (prompt: string) => void }) {
  const config = SKILL_EMPTY_STATE[skill] || SKILL_EMPTY_STATE.bazi;
  const quickPrompts = SKILL_QUICK_PROMPTS[skill] || SKILL_QUICK_PROMPTS.bazi;
  const dailyData = useDailyGreeting(skill);
  const actionKey = useMemo(
    () => `vibelife-daily-action:${skill}:${dailyData.isoDate}`,
    [skill, dailyData.isoDate]
  );
  const [actionCompleted, setActionCompleted] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined") return;
    // Use cached localStorage (Vercel rule: js-cache-storage)
    setActionCompleted(getLocalStorage(actionKey) === "1");
  }, [actionKey]);

  const toggleAction = useCallback(() => {
    setActionCompleted((prev) => {
      const next = !prev;
      // Use cached localStorage (Vercel rule: js-cache-storage)
      setLocalStorage(actionKey, next ? "1" : "0");
      return next;
    });
  }, [actionKey]);

  const shareText = useMemo(() => {
    const term = dailyData.solarTerm ? ` Â· ${dailyData.solarTerm}` : "";
    return [
      `VibeLife${term} Â· ${dailyData.isoDate}`,
      dailyData.greeting,
      `è¿åŠ¿æŒ‡æ•°ï¼š${dailyData.fortuneScore}/100`,
      `ä»Šæ—¥ä¸€æ­¥ï¼š${dailyData.actionText}`,
      "#VibeLife",
    ].join("\n");
  }, [dailyData]);

  return (
    <div className="flex flex-col items-center justify-center w-full md:max-w-xl mx-auto px-4 py-6">
      {/* Daily Greeting æ¯æ—¥é—®å€™ */}
      <DailyGreeting
        greeting={dailyData.greeting}
        solarTerm={dailyData.solarTerm}
        timeOfDay={dailyData.timeOfDay}
        date={dailyData.isoDate}
        todayTip={dailyData.todayTip}
        baziHint={dailyData.baziHint || undefined}
        fortuneScore={dailyData.fortuneScore}
        fortuneHint={dailyData.fortuneHint}
        actionItem={{ text: dailyData.actionText, completed: actionCompleted }}
        onActionToggle={toggleAction}
        shareText={shareText}
        className="mb-6 w-full"
      />

      {/* Animated glyph with enhanced aura */}
      <div className="relative flex items-center justify-center mb-4">
        {/* Outer pulsing ring */}
        <div className="absolute w-16 h-16 rounded-full border border-skill-primary/20 animate-pulse-slow" />
        <div className="absolute w-24 h-24 rounded-full border border-skill-primary/10 animate-pulse-slower" />

        {/* Breath aura */}
        <BreathAura
          skill={skill}
          size="sm"
          position="center"
          intensity="medium"
          className="opacity-40"
        />

        {/* Central glyph */}
        <VibeGlyph
          size="sm"
          skill={skill}
          showAura={true}
          animate={true}
          className="relative z-10"
        />
      </div>

      {/* Title */}
      <h3 className="text-base md:text-lg font-serif font-semibold text-foreground mb-1 text-center">
        {config.title}
      </h3>

      {/* Subtitle */}
      <p className="text-sm text-muted-foreground max-w-sm text-center mb-4">
        {config.subtitle}
      </p>

      {/* Quick prompt suggestions */}
      <div className="w-full space-y-3">
        <p className="text-xs text-muted-foreground/60 text-center">
          è¯•è¯•è¿™æ ·é—®
        </p>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
          {quickPrompts.slice(0, 4).map((prompt, index) => (
            <button
              key={index}
              onClick={() => onQuickPrompt?.(prompt.question)}
              className={`
                group relative px-3 py-3 text-left
                bg-gradient-to-br ${prompt.gradient}
                border border-border/50 hover:border-skill-primary/30
                rounded-xl transition-all duration-200
                hover:shadow-md hover:-translate-y-0.5
              `}
            >
              <div className="flex items-start gap-2.5">
                <span className="text-lg flex-shrink-0">{prompt.icon}</span>
                <div className="flex-1 min-w-0">
                  <span className="text-[10px] font-medium text-muted-foreground/70 uppercase tracking-wide">
                    {prompt.category}
                  </span>
                  <p className="text-sm text-foreground line-clamp-2 mt-0.5">
                    {prompt.question}
                  </p>
                </div>
              </div>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
});

export function ChatContainer({
  skillId,
  scenario,
  skill = "bazi",
  conversationId: externalConversationId,
  voiceMode = "warm",
  onConversationStart,
  initialPrompt,
  onInitialPromptSent,
  dashboardData,
  isDashboardLoading,
  onCheckIn,
  onToggleLever,
  onToggleRock,
}: ChatContainerProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const initialPromptSentRef = useRef(false);

  // ç”Ÿæˆç¨³å®šçš„ conversationIdï¼ˆå¦‚æœå¤–éƒ¨æ²¡ä¼ å…¥ï¼‰
  // ä½¿ç”¨ useRef ç¡®ä¿åœ¨ç»„ä»¶ç”Ÿå‘½å‘¨æœŸå†…ä¿æŒä¸å˜
  const generatedIdRef = useRef<string | null>(null);
  if (!generatedIdRef.current) {
    generatedIdRef.current = generateUUID();
  }
  const conversationId = externalConversationId || generatedIdRef.current;

  // UI å±•ç¤ºç”¨çš„ skillï¼ˆä¸»é¢˜ã€ç©ºçŠ¶æ€ç­‰ï¼‰
  const displaySkill: SkillType = skill || (skillId as SkillType) || "bazi";

  // Use AI SDK powered chat hook
  // skillId å¯é€‰ï¼šä¸ä¼ æ—¶åç«¯ LLM è‡ªåŠ¨è·¯ç”±
  const {
    messages,
    isLoading,
    sendMessage,
    sendQuickPrompt,
    error,
  } = useVibeChat({
    skillId: skillId as SkillId | undefined,
    scenario,
    voiceMode,
    conversationId,
    onConversationStart,
    onError: (err) => {
      console.error("Chat error:", err);
      // Show user-friendly toast notification with retry option
      const errorMessage = err instanceof Error ? err.message : "æœªçŸ¥é”™è¯¯";
      const isNetworkError = errorMessage.includes("network") || errorMessage.includes("fetch");
      const isTimeoutError = errorMessage.includes("timeout") || errorMessage.includes("è¶…æ—¶");

      toast.error(
        isNetworkError ? "ç½‘ç»œè¿æ¥å¤±è´¥" : isTimeoutError ? "è¯·æ±‚è¶…æ—¶" : "å‘é€å¤±è´¥",
        {
          description: isNetworkError
            ? "è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥åé‡è¯•"
            : isTimeoutError
              ? "æœåŠ¡å™¨å“åº”æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¨åé‡è¯•"
              : "è¯·ç¨åé‡è¯•ï¼Œæˆ–åˆ·æ–°é¡µé¢",
          duration: 5000,
        }
      );
    },
  });

  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages, scrollToBottom]);

  // å¤„ç†ä» URL ä¼ å…¥çš„åˆå§‹æ¶ˆæ¯ï¼ˆå¦‚ä»é€šçŸ¥è·³è½¬ï¼‰
  useEffect(() => {
    if (initialPrompt && !initialPromptSentRef.current && !isLoading) {
      initialPromptSentRef.current = true;
      sendMessage(initialPrompt).then(() => {
        onInitialPromptSent?.();
      });
    }
  }, [initialPrompt, isLoading, sendMessage, onInitialPromptSent]);

  // é‡ç½®æ ‡è®°å½“ initialPrompt å˜åŒ–æ—¶
  useEffect(() => {
    if (!initialPrompt) {
      initialPromptSentRef.current = false;
    }
  }, [initialPrompt]);

  // Handle send from ChatInput
  const handleSend = useCallback(
    async (content: string) => {
      await sendMessage(content);
    },
    [sendMessage]
  );

  // Handle quick prompt from empty state
  const handleQuickPrompt = useCallback(
    async (content: string) => {
      await sendQuickPrompt(content);
    },
    [sendQuickPrompt]
  );

  const hasMessages = messages.length > 0;

  // DailyGreeting æ•°æ®
  const dailyData = useDailyGreeting(displaySkill);
  const actionKey = useMemo(
    () => `vibelife-daily-action:${displaySkill}:${dailyData.isoDate}`,
    [displaySkill, dailyData.isoDate]
  );
  const [actionCompleted, setActionCompleted] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined") return;
    setActionCompleted(getLocalStorage(actionKey) === "1");
  }, [actionKey]);

  const toggleAction = useCallback(() => {
    setActionCompleted((prev) => {
      const next = !prev;
      setLocalStorage(actionKey, next ? "1" : "0");
      return next;
    });
  }, [actionKey]);

  const shareText = useMemo(() => {
    const term = dailyData.solarTerm ? ` Â· ${dailyData.solarTerm}` : "";
    return [
      `VibeLife${term} Â· ${dailyData.isoDate}`,
      dailyData.greeting,
      `è¿åŠ¿æŒ‡æ•°ï¼š${dailyData.fortuneScore}/100`,
      `ä»Šæ—¥ä¸€æ­¥ï¼š${dailyData.actionText}`,
      "#VibeLife",
    ].join("\n");
  }, [dailyData]);

  // é»˜è®¤å›è°ƒï¼ˆå¦‚æœæ²¡æœ‰ä¼ å…¥ï¼‰
  const handleCheckIn = useCallback(async () => {
    if (onCheckIn) {
      await onCheckIn();
    } else {
      toast.success("ç­¾åˆ°æˆåŠŸï¼");
    }
  }, [onCheckIn]);

  const handleToggleLever = useCallback(async (leverId: string) => {
    if (onToggleLever) {
      await onToggleLever(leverId);
    }
  }, [onToggleLever]);

  const handleToggleRock = useCallback(async (rockId: string) => {
    if (onToggleRock) {
      await onToggleRock(rockId);
    }
  }, [onToggleRock]);

  // è½¬æ¢ Dashboard æ•°æ®ä¸ºæ¬¢è¿æ¶ˆæ¯æ ¼å¼
  const welcomeData = useDashboardWelcomeData(dashboardData);

  return (
    <div className="flex flex-col h-full" data-skill={displaySkill}>
      {/* Messages area - always flex-1 to push input to bottom */}
      <main
        id="main-content"
        className="flex-1 overflow-y-auto relative min-h-0"
        role="log"
        aria-label="å¯¹è¯æ¶ˆæ¯"
        aria-live="polite"
      >
        {!hasMessages ? (
          /* Empty state with Welcome Message */
          <div className="flex flex-col items-center justify-end h-full pb-4">
            {isDashboardLoading ? (
              <div className="flex items-center justify-center">
                <div className="text-sm text-muted-foreground">åŠ è½½ä¸­...</div>
              </div>
            ) : welcomeData ? (
              <ChatWelcomeMessage
                data={welcomeData}
                onCheckIn={handleCheckIn}
                onSendPrompt={handleQuickPrompt}
                className="w-full max-w-3xl"
              />
            ) : (
              <div className="flex items-center justify-center">
                <div className="text-sm text-muted-foreground">æ¬¢è¿å›æ¥</div>
              </div>
            )}
          </div>
        ) : (
          /* Messages list - æ‰€æœ‰è®¾å¤‡å±…ä¸­ */
          <div className="px-4 pt-4 pb-2 max-w-3xl mx-auto">
            {messages.map((message) => (
              // Use chat-message-item class for content-visibility optimization (Vercel rule: rendering-content-visibility)
              <div key={message.id} className="chat-message-item">
                <ChatMessage
                  role={message.role as "user" | "assistant"}
                  content={getMessageContent(message)}
                  skill={displaySkill}
                  isStreaming={isLoading && message.role === "assistant" && message === messages[messages.length - 1]}
                  onSendMessage={sendMessage}
                />
              </div>
            ))}
            {/* Show loading indicator when waiting for first response chunk */}
            {isLoading && messages.length > 0 && messages[messages.length - 1].role === "user" && (
              <ChatMessage
                role="assistant"
                content=""
                skill={displaySkill}
                isStreaming
              />
            )}
            {/* Error is now handled via toast notification in onError callback */}
            <div ref={messagesEndRef} />
          </div>
        )}
      </main>

      {/* Input - fixed at bottom */}
      <div className="flex-shrink-0">
        <ChatInput onSend={handleSend} disabled={isLoading} />
      </div>
    </div>
  );
}
