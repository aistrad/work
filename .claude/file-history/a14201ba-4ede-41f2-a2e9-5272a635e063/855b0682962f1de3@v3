/**
 * API Layer - 与后端 Soul OS API 通信
 *
 * 后端 API 格式: { ok: boolean, data?: T, error?: { code, message, detail } }
 */

const API_BASE = process.env.NEXT_PUBLIC_API_BASE || ''

// Cookie helper
function getCookie(name: string): string {
  if (typeof document === 'undefined') return ''
  const match = document.cookie.match(new RegExp(`(?:^|; )${name.replace(/[-.]/g, '\\$&')}=([^;]*)`))
  return match ? decodeURIComponent(match[1]) : ''
}

// CSRF headers
function csrfHeaders(): Record<string, string> {
  const csrf = getCookie('fortune_csrf')
  return csrf ? { 'X-CSRF-Token': csrf } : {}
}

// Generic API response type
interface ApiResponse<T> {
  ok: boolean
  data?: T
  error?: {
    code: string
    message: string
    detail?: Record<string, unknown>
  }
}

// Fetch with auth
async function fetchApi<T>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...csrfHeaders(),
    ...(options.headers as Record<string, string> || {}),
  }

  const res = await fetch(`${API_BASE}${url}`, {
    ...options,
    headers,
    credentials: 'include', // Send cookies
  })

  const json: ApiResponse<T> = await res.json().catch(() => ({ ok: false }))

  if (!res.ok || !json.ok) {
    if (res.status === 401 || res.status === 403) {
      // Redirect to login (with basePath)
      if (typeof window !== 'undefined') {
        window.location.href = '/new/login'
      }
      throw new Error('Unauthorized')
    }
    throw new Error(json.error?.message || 'Request failed')
  }

  return json.data as T
}

// =============================================================================
// Dashboard API Types
// =============================================================================

export interface StateScore {
  score: number
  breakdown: {
    emotion: number
    action: number
    streak: number
  }
  recovery_action: string | null
}

export interface PermaScore {
  score: number
  trend?: 'up' | 'down' | 'stable'
}

export interface PermaData {
  positive_emotion: PermaScore
  engagement: PermaScore
  relationships: PermaScore
  meaning: PermaScore
  accomplishment: PermaScore
}

export interface TaskItem {
  task_id: string
  title: string
  status: 'suggested' | 'active' | 'done' | 'skipped'
  commitment_type?: 'start_task' | 'schedule_task'
  minutes?: number
  if_then?: string
}

export interface RiskAlert {
  type: string
  message: string
}

export interface OverviewData {
  insight: string
  state_score: StateScore
  perma: PermaData
  today_tasks: TaskItem[]
  risk_alerts: RiskAlert[]
}

export interface L0Translation {
  concept: string
  translation: string
  action: string
}

export interface L0Facts {
  day_master: string
  strength: string
  translations: L0Translation[]
}

export interface L1Schema {
  perma_snapshot: PermaData
  cognitive_patterns: {
    identified_schemas: string[]
    reframe_count?: number
  }
  strengths_in_use: string[]
}

export interface StatusData {
  l0_facts: L0Facts
  l1_schema: L1Schema
  state_score: StateScore
}

export interface TrendPoint {
  date: string
  score: number
}

export interface TrendEvent {
  date: string
  type: string
  title: string
}

export interface TrendsData {
  state_score_history: TrendPoint[]
  events: TrendEvent[]
}

export interface TasksData {
  active: TaskItem[]
  suggested: TaskItem[]
  completed_recent: TaskItem[]
}

export interface RelationItem {
  id: string
  name: string
  type: string
  compatibility?: number
}

export interface RelationsData {
  relations: RelationItem[]
}

export interface ExploreItem {
  id: string
  title: string
  type: 'mystic' | 'course' | 'artifact'
  description?: string
}

export interface ExploreData {
  mystic_entries: ExploreItem[]
  courses: ExploreItem[]
  artifacts: ExploreItem[]
}

export interface CheckinResponse {
  insight: string
  action: {
    content: string
    minutes: number
    if_then: string
  }
  state_score: StateScore
}

// =============================================================================
// Dashboard API Functions
// =============================================================================

export async function fetchOverview(): Promise<OverviewData> {
  return fetchApi<OverviewData>('/api/dashboard/overview')
}

export async function fetchStatus(): Promise<StatusData> {
  return fetchApi<StatusData>('/api/dashboard/status')
}

export async function fetchTrends(days: number = 7): Promise<TrendsData> {
  return fetchApi<TrendsData>(`/api/dashboard/trends?days=${days}`)
}

export async function fetchTasks(): Promise<TasksData> {
  return fetchApi<TasksData>('/api/dashboard/tasks')
}

export async function fetchRelations(): Promise<RelationsData> {
  return fetchApi<RelationsData>('/api/dashboard/relations')
}

export async function fetchExplore(): Promise<ExploreData> {
  return fetchApi<ExploreData>('/api/dashboard/explore')
}

// Task Actions
export async function acceptTask(
  taskId: string,
  commitmentType: 'start_task' | 'schedule_task' = 'start_task'
): Promise<{ commitment_id: string; status: string }> {
  return fetchApi('/api/dashboard/task/accept', {
    method: 'POST',
    body: JSON.stringify({ task_id: taskId, commitment_type: commitmentType }),
  })
}

export async function completeTask(
  taskId: string,
  note: string = ''
): Promise<{ status: string; state_score: StateScore }> {
  return fetchApi('/api/dashboard/task/done', {
    method: 'POST',
    body: JSON.stringify({ task_id: taskId, note }),
  })
}

export async function skipTask(
  taskId: string,
  reason: string = ''
): Promise<{ status: string }> {
  return fetchApi('/api/dashboard/task/skip', {
    method: 'POST',
    body: JSON.stringify({ task_id: taskId, reason }),
  })
}

// Checkin
export async function submitCheckin(
  mood: string,
  intensity: number,
  note: string = ''
): Promise<CheckinResponse> {
  return fetchApi('/api/dashboard/checkin', {
    method: 'POST',
    body: JSON.stringify({ mood, intensity, note }),
  })
}

// =============================================================================
// Chat API
// =============================================================================

export interface ChatMessage {
  role: 'user' | 'assistant'
  content: string
  timestamp?: string
}

export interface SendChatRequest {
  message: string
  session_id?: string
}

export interface SendChatResponse {
  session_id: string
  reply: string
  ui_components?: unknown[]
}

export async function sendChatMessage(
  message: string,
  sessionId?: string
): Promise<SendChatResponse> {
  const result = await fetchApi<{
    session_id: string
    assistant_message?: { role: string; a2ui?: unknown }
    suggested_tasks?: unknown[]
  }>('/api/chat/send', {
    method: 'POST',
    body: JSON.stringify({ text: message, session_id: sessionId }),
  })

  // Extract reply from a2ui response
  const a2ui = result.assistant_message?.a2ui as { ui_components?: Array<{ type: string; data: string }> } | undefined
  const markdownComponent = a2ui?.ui_components?.find(c => c.type === 'markdown_text')
  const reply = markdownComponent?.data || ''

  return {
    session_id: result.session_id,
    reply,
    ui_components: a2ui?.ui_components,
  }
}

// =============================================================================
// Auth API
// =============================================================================

export interface LoginRequest {
  email: string
  password: string
}

export interface LoginResponse {
  user_id: number
  email: string
}

export interface RegisterRequest {
  email: string
  password: string
  name: string
  gender: string
  birthday_local: string
  tz_offset_hours: number
  location: {
    name: string
    longitude: number
    latitude: number
  }
}

export interface RegisterResponse {
  user_id: number
  email: string
  profile_summary: {
    name: string
    gender: string
    location_name: string
  }
}

export interface UserInfo {
  user_id: number
  email: string
  name: string
  persona_style: string
}

export async function login(email: string, password: string): Promise<LoginResponse> {
  const res = await fetch(`${API_BASE}/api/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({ email, password }),
  })
  const json = await res.json()
  if (!res.ok || !json.ok) {
    throw new Error(json.error?.message || 'Login failed')
  }
  return json.data
}

export async function register(data: RegisterRequest): Promise<RegisterResponse> {
  const res = await fetch(`${API_BASE}/api/auth/register`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify(data),
  })
  const json = await res.json()
  if (!res.ok || !json.ok) {
    throw new Error(json.error?.message || 'Register failed')
  }
  return json.data
}

export async function logout(): Promise<void> {
  await fetchApi('/api/auth/logout', { method: 'POST' })
}

export async function fetchMe(): Promise<UserInfo> {
  return fetchApi<UserInfo>('/api/auth/me')
}

// SSE Chat Stream
export function streamChatMessage(
  message: string,
  sessionId: string | undefined,
  onChunk: (chunk: string) => void,
  onDone: (fullResponse: SendChatResponse) => void,
  onError: (error: Error) => void
): () => void {
  const controller = new AbortController()

  const params = new URLSearchParams({ message })
  if (sessionId) params.set('session_id', sessionId)

  fetch(`${API_BASE}/api/chat/stream?${params}`, {
    method: 'GET',
    credentials: 'include',
    headers: csrfHeaders(),
    signal: controller.signal,
  })
    .then(async (response) => {
      if (!response.ok) {
        throw new Error('Stream request failed')
      }

      const reader = response.body?.getReader()
      if (!reader) throw new Error('No reader')

      const decoder = new TextDecoder()
      let buffer = ''
      let fullContent = ''

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        buffer += decoder.decode(value, { stream: true })
        const lines = buffer.split('\n')
        buffer = lines.pop() || ''

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6)
            if (data === '[DONE]') {
              onDone({
                session_id: sessionId || '',
                reply: fullContent,
              })
              return
            }
            try {
              const json = JSON.parse(data)
              if (json.content) {
                fullContent += json.content
                onChunk(json.content)
              }
            } catch {
              // Skip invalid JSON
            }
          }
        }
      }
    })
    .catch((err) => {
      if (err.name !== 'AbortError') {
        onError(err)
      }
    })

  return () => controller.abort()
}
