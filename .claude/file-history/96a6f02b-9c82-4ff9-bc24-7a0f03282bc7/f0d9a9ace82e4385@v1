"""
Skill Repository - Data access layer for skills
"""
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID

from .db import get_connection


class SkillRepository:
    """Repository for skill operations"""

    # ─────────────────────────────────────────────────────────────────
    # Skill Profile
    # ─────────────────────────────────────────────────────────────────

    @staticmethod
    async def get_or_create_profile(
        user_id: UUID,
        skill_id: str,
        profile_data: Optional[Dict[str, Any]] = None
    ) -> dict:
        """Get or create skill profile for user"""
        async with get_connection() as conn:
            # Try to get existing
            row = await conn.fetchrow(
                """
                SELECT * FROM skill_profiles
                WHERE user_id = $1 AND skill_id = $2
                """,
                user_id, skill_id
            )

            if row:
                return dict(row)

            # Create new
            row = await conn.fetchrow(
                """
                INSERT INTO skill_profiles (user_id, skill_id, profile_data)
                VALUES ($1, $2, $3)
                RETURNING *
                """,
                user_id, skill_id, profile_data or {}
            )
            return dict(row)

    @staticmethod
    async def update_profile(
        user_id: UUID,
        skill_id: str,
        profile_data: Dict[str, Any]
    ) -> Optional[dict]:
        """Update skill profile data"""
        async with get_connection() as conn:
            row = await conn.fetchrow(
                """
                UPDATE skill_profiles
                SET profile_data = profile_data || $3::jsonb,
                    last_use_at = NOW()
                WHERE user_id = $1 AND skill_id = $2
                RETURNING *
                """,
                user_id, skill_id, profile_data
            )
            return dict(row) if row else None

    @staticmethod
    async def get_user_profiles(user_id: UUID) -> List[dict]:
        """Get all skill profiles for user"""
        async with get_connection() as conn:
            rows = await conn.fetch(
                "SELECT * FROM skill_profiles WHERE user_id = $1",
                user_id
            )
            return [dict(row) for row in rows]

    # ─────────────────────────────────────────────────────────────────
    # Conversations
    # ─────────────────────────────────────────────────────────────────

    @staticmethod
    async def create_conversation(
        user_id: UUID,
        skill_id: str,
        entry_point: Optional[str] = None,
        referrer: Optional[str] = None
    ) -> dict:
        """Create a new conversation"""
        async with get_connection() as conn:
            # Create conversation
            row = await conn.fetchrow(
                """
                INSERT INTO skill_conversations (
                    user_id, skill_id, entry_point, referrer
                )
                VALUES ($1, $2, $3, $4)
                RETURNING *
                """,
                user_id, skill_id, entry_point, referrer
            )

            # Update profile session count
            await conn.execute(
                """
                UPDATE skill_profiles
                SET total_sessions = total_sessions + 1, last_use_at = NOW()
                WHERE user_id = $1 AND skill_id = $2
                """,
                user_id, skill_id
            )

            return dict(row)

    @staticmethod
    async def get_conversation(conversation_id: UUID) -> Optional[dict]:
        """Get conversation by ID"""
        async with get_connection() as conn:
            row = await conn.fetchrow(
                "SELECT * FROM skill_conversations WHERE id = $1",
                conversation_id
            )
            return dict(row) if row else None

    @staticmethod
    async def get_user_conversations(
        user_id: UUID,
        skill_id: Optional[str] = None,
        limit: int = 20
    ) -> List[dict]:
        """Get user's conversations"""
        async with get_connection() as conn:
            if skill_id:
                rows = await conn.fetch(
                    """
                    SELECT * FROM skill_conversations
                    WHERE user_id = $1 AND skill_id = $2
                    ORDER BY started_at DESC
                    LIMIT $3
                    """,
                    user_id, skill_id, limit
                )
            else:
                rows = await conn.fetch(
                    """
                    SELECT * FROM skill_conversations
                    WHERE user_id = $1
                    ORDER BY started_at DESC
                    LIMIT $2
                    """,
                    user_id, limit
                )
            return [dict(row) for row in rows]

    @staticmethod
    async def end_conversation(conversation_id: UUID) -> Optional[dict]:
        """End a conversation"""
        async with get_connection() as conn:
            row = await conn.fetchrow(
                """
                UPDATE skill_conversations
                SET ended_at = NOW(), status = 'ended'
                WHERE id = $1
                RETURNING *
                """,
                conversation_id
            )
            return dict(row) if row else None

    # ─────────────────────────────────────────────────────────────────
    # Messages
    # ─────────────────────────────────────────────────────────────────

    @staticmethod
    async def add_message(
        conversation_id: UUID,
        role: str,
        content: str,
        intent: Optional[str] = None,
        tools_used: Optional[List[str]] = None,
        knowledge_used: Optional[List[str]] = None
    ) -> dict:
        """Add message to conversation"""
        async with get_connection() as conn:
            # Insert message
            row = await conn.fetchrow(
                """
                INSERT INTO skill_messages (
                    conversation_id, role, content, intent,
                    tools_used, knowledge_used
                )
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING *
                """,
                conversation_id, role, content, intent,
                tools_used, knowledge_used
            )

            # Update conversation message count
            await conn.execute(
                """
                UPDATE skill_conversations
                SET message_count = message_count + 1
                WHERE id = $1
                """,
                conversation_id
            )

            return dict(row)

    @staticmethod
    async def get_messages(
        conversation_id: UUID,
        limit: int = 50
    ) -> List[dict]:
        """Get messages in conversation"""
        async with get_connection() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM skill_messages
                WHERE conversation_id = $1
                ORDER BY created_at ASC
                LIMIT $2
                """,
                conversation_id, limit
            )
            return [dict(row) for row in rows]

    @staticmethod
    async def get_recent_messages(
        user_id: UUID,
        skill_id: str,
        limit: int = 10
    ) -> List[dict]:
        """Get recent messages for user in skill"""
        async with get_connection() as conn:
            rows = await conn.fetch(
                """
                SELECT m.* FROM skill_messages m
                JOIN skill_conversations c ON m.conversation_id = c.id
                WHERE c.user_id = $1 AND c.skill_id = $2
                ORDER BY m.created_at DESC
                LIMIT $3
                """,
                user_id, skill_id, limit
            )
            return [dict(row) for row in reversed(rows)]

    # ─────────────────────────────────────────────────────────────────
    # Insights
    # ─────────────────────────────────────────────────────────────────

    @staticmethod
    async def create_insight(
        user_id: UUID,
        skill_id: str,
        insight_type: str,
        content: str,
        title: Optional[str] = None,
        evidence: Optional[Dict[str, Any]] = None,
        confidence: Optional[float] = None,
        conversation_id: Optional[UUID] = None
    ) -> dict:
        """Create an insight"""
        async with get_connection() as conn:
            row = await conn.fetchrow(
                """
                INSERT INTO skill_insights (
                    user_id, skill_id, conversation_id, insight_type,
                    title, content, evidence, confidence
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING *
                """,
                user_id, skill_id, conversation_id, insight_type,
                title, content, evidence, confidence
            )
            return dict(row)

    @staticmethod
    async def get_user_insights(
        user_id: UUID,
        skill_id: Optional[str] = None,
        insight_type: Optional[str] = None,
        limit: int = 20
    ) -> List[dict]:
        """Get user's insights"""
        async with get_connection() as conn:
            conditions = ["user_id = $1"]
            params = [user_id]
            idx = 2

            if skill_id:
                conditions.append(f"skill_id = ${idx}")
                params.append(skill_id)
                idx += 1

            if insight_type:
                conditions.append(f"insight_type = ${idx}")
                params.append(insight_type)
                idx += 1

            params.append(limit)

            query = f"""
                SELECT * FROM skill_insights
                WHERE {' AND '.join(conditions)}
                ORDER BY created_at DESC
                LIMIT ${idx}
            """

            rows = await conn.fetch(query, *params)
            return [dict(row) for row in rows]

    @staticmethod
    async def get_insight(insight_id: UUID) -> Optional[dict]:
        """Get a single insight by ID"""
        async with get_connection() as conn:
            row = await conn.fetchrow(
                "SELECT * FROM skill_insights WHERE id = $1",
                insight_id
            )
            return dict(row) if row else None

    @staticmethod
    async def update_insight_reaction(
        insight_id: UUID,
        user_reaction: str
    ) -> Optional[dict]:
        """Update user reaction to insight"""
        async with get_connection() as conn:
            row = await conn.fetchrow(
                """
                UPDATE skill_insights
                SET user_reaction = $2
                WHERE id = $1
                RETURNING *
                """,
                insight_id, user_reaction
            )
            return dict(row) if row else None

    @staticmethod
    async def link_insight_to_message(
        message_id: UUID,
        insight_id: UUID
    ) -> bool:
        """Link insight to message"""
        async with get_connection() as conn:
            result = await conn.execute(
                """
                UPDATE skill_messages
                SET insight_generated = true, insight_id = $2
                WHERE id = $1
                """,
                message_id, insight_id
            )
            return "UPDATE 1" in result

    # ─────────────────────────────────────────────────────────────────
    # Insights with Embedding (Cold Memory)
    # ─────────────────────────────────────────────────────────────────

    @staticmethod
    async def create_insight_with_embedding(
        user_id: UUID,
        skill_id: str,
        insight_type: str,
        content: str,
        title: Optional[str] = None,
        evidence: Optional[Dict[str, Any]] = None,
        confidence: Optional[float] = None,
        conversation_id: Optional[UUID] = None,
        embedding: Optional[List[float]] = None
    ) -> dict:
        """Create an insight with optional embedding for vector search"""
        async with get_connection() as conn:
            if embedding:
                # Convert list to vector string format for pgvector
                embedding_str = "[" + ",".join(map(str, embedding)) + "]"
                row = await conn.fetchrow(
                    """
                    INSERT INTO skill_insights (
                        user_id, skill_id, conversation_id, insight_type,
                        title, content, evidence, confidence, embedding
                    )
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9::vector)
                    RETURNING *
                    """,
                    user_id, skill_id, conversation_id, insight_type,
                    title, content, evidence, confidence, embedding_str
                )
            else:
                row = await conn.fetchrow(
                    """
                    INSERT INTO skill_insights (
                        user_id, skill_id, conversation_id, insight_type,
                        title, content, evidence, confidence
                    )
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                    RETURNING *
                    """,
                    user_id, skill_id, conversation_id, insight_type,
                    title, content, evidence, confidence
                )
            return dict(row)

    @staticmethod
    async def search_insights_by_embedding(
        user_id: UUID,
        query_embedding: List[float],
        skill_id: Optional[str] = None,
        threshold: float = 0.75,
        limit: int = 3
    ) -> List[dict]:
        """
        Search insights by embedding similarity (cosine distance).

        Phase 1.5 Design:
        - skill_id=None: Cross-skill search (all user's insights)
        - skill_id=str: Single skill search

        Returns insights with similarity > threshold.
        """
        async with get_connection() as conn:
            # Convert embedding to vector string
            embedding_str = "[" + ",".join(map(str, query_embedding)) + "]"

            if skill_id:
                rows = await conn.fetch(
                    """
                    SELECT id, skill_id, insight_type, title, content,
                           (1 - (embedding <=> $1::vector)) as similarity
                    FROM skill_insights
                    WHERE user_id = $2 AND skill_id = $3 AND embedding IS NOT NULL
                      AND (1 - (embedding <=> $1::vector)) > $4
                    ORDER BY embedding <=> $1::vector
                    LIMIT $5
                    """,
                    embedding_str, user_id, skill_id, threshold, limit
                )
            else:
                # Cross-skill search (Phase 1.5)
                rows = await conn.fetch(
                    """
                    SELECT id, skill_id, insight_type, title, content,
                           (1 - (embedding <=> $1::vector)) as similarity
                    FROM skill_insights
                    WHERE user_id = $2 AND embedding IS NOT NULL
                      AND (1 - (embedding <=> $1::vector)) > $3
                    ORDER BY embedding <=> $1::vector
                    LIMIT $4
                    """,
                    embedding_str, user_id, threshold, limit
                )

            return [dict(row) for row in rows]

    @staticmethod
    async def update_insight_embedding(
        insight_id: UUID,
        embedding: List[float]
    ) -> bool:
        """Update embedding for existing insight (backfill)"""
        async with get_connection() as conn:
            embedding_str = "[" + ",".join(map(str, embedding)) + "]"
            result = await conn.execute(
                """
                UPDATE skill_insights
                SET embedding = $2::vector
                WHERE id = $1
                """,
                insight_id, embedding_str
            )
            return "UPDATE 1" in result
