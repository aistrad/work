"""
Tests for Digital Twin Pydantic Models.

TASK-1.1.1: 创建孪生数据模型
REQ: REQ-TWIN-001, REQ-TWIN-002
"""

import pytest
from pydantic import ValidationError

from models.twin import (
    DimensionScores,
    TwinData,
    TwinLayer,
    TwinUpdateEvent,
    TwinUpdateResult,
)


class TestDimensionScores:
    """Tests for DimensionScores model."""

    def test_default_values(self):
        """All dimensions default to 50."""
        scores = DimensionScores()
        assert scores.energy == 50.0
        assert scores.clarity == 50.0
        assert scores.connection == 50.0
        assert scores.growth == 50.0
        assert scores.balance == 50.0

    def test_clamp_to_max(self):
        """Values above 100 are clamped to 100."""
        scores = DimensionScores(energy=150, clarity=200)
        assert scores.energy == 100.0
        assert scores.clarity == 100.0

    def test_clamp_to_min(self):
        """Values below 0 are clamped to 0."""
        scores = DimensionScores(energy=-10, clarity=-50)
        assert scores.energy == 0.0
        assert scores.clarity == 0.0

    def test_valid_range(self):
        """Values in [0, 100] are preserved."""
        scores = DimensionScores(energy=75, clarity=25, connection=0, growth=100, balance=50)
        assert scores.energy == 75.0
        assert scores.clarity == 25.0
        assert scores.connection == 0.0
        assert scores.growth == 100.0
        assert scores.balance == 50.0

    def test_none_defaults_to_50(self):
        """None values default to 50."""
        scores = DimensionScores(energy=None)
        assert scores.energy == 50.0


class TestTwinData:
    """Tests for TwinData model."""

    def test_twin_model_defaults(self):
        """Test default values for TwinData."""
        twin = TwinData(user_id=1)
        assert twin.dimension_scores.energy == 50
        assert twin.aura_points >= 0
        assert twin.overall_wellbeing == 50.0
        assert twin.growth_streak == 0
        assert twin.metadata_astrology == {}
        assert twin.dynamic_emotional == {}

    def test_twin_with_custom_dimensions(self):
        """Test TwinData with custom dimension scores."""
        twin = TwinData(
            user_id=1,
            dimension_scores=DimensionScores(energy=80, clarity=70)
        )
        assert twin.dimension_scores.energy == 80.0
        assert twin.dimension_scores.clarity == 70.0

    def test_get_layer_l1(self):
        """Test getting L1 layer data."""
        twin = TwinData(
            user_id=1,
            metadata_astrology={"bazi": "甲子"},
            metadata_psychology={"mbti": "INTJ"},
        )
        l1 = twin.get_layer(TwinLayer.L1)
        assert "metadata_astrology" in l1
        assert l1["metadata_astrology"]["bazi"] == "甲子"
        assert "metadata_psychology" in l1
        assert "metadata_memory" in l1

    def test_get_layer_l2(self):
        """Test getting L2 layer data."""
        twin = TwinData(
            user_id=1,
            dynamic_emotional={"current_mood": "happy"},
        )
        l2 = twin.get_layer(TwinLayer.L2)
        assert "dynamic_emotional" in l2
        assert l2["dynamic_emotional"]["current_mood"] == "happy"
        assert "dynamic_astro" in l2
        assert "dynamic_bio" in l2
        assert "dynamic_social" in l2

    def test_get_layer_l3(self):
        """Test getting L3 layer data."""
        twin = TwinData(
            user_id=1,
            aura_points=100,
            overall_wellbeing=75.5,
        )
        l3 = twin.get_layer(TwinLayer.L3)
        assert l3["aura_points"] == 100
        assert l3["overall_wellbeing"] == 75.5
        assert "dimension_scores" in l3

    def test_get_multiple_layers(self):
        """Test getting multiple layers at once."""
        twin = TwinData(
            user_id=1,
            metadata_astrology={"bazi": "甲子"},
            dynamic_emotional={"mood": "calm"},
        )
        data = twin.get_layers([TwinLayer.L1, TwinLayer.L2])
        assert "metadata_astrology" in data
        assert "dynamic_emotional" in data
        assert "aura_points" not in data


class TestTwinUpdateEvent:
    """Tests for TwinUpdateEvent model."""

    def test_valid_update_event(self):
        """Test creating a valid update event."""
        event = TwinUpdateEvent(
            user_id=1,
            layer=TwinLayer.L2,
            path="dynamic_emotional.current_mood",
            new_value="happy",
            confidence=0.9,
        )
        assert event.user_id == 1
        assert event.layer == TwinLayer.L2
        assert event.path == "dynamic_emotional.current_mood"
        assert event.new_value == "happy"
        assert event.confidence == 0.9

    def test_confidence_validation_too_high(self):
        """Confidence > 1 should raise ValidationError."""
        with pytest.raises(ValidationError) as exc_info:
            TwinUpdateEvent(
                user_id=1,
                layer=TwinLayer.L2,
                path="dynamic_emotional.mood",
                new_value="happy",
                confidence=1.5,
            )
        assert "confidence" in str(exc_info.value)

    def test_confidence_validation_negative(self):
        """Confidence < 0 should raise ValidationError."""
        with pytest.raises(ValidationError) as exc_info:
            TwinUpdateEvent(
                user_id=1,
                layer=TwinLayer.L2,
                path="dynamic_emotional.mood",
                new_value="happy",
                confidence=-0.1,
            )
        assert "confidence" in str(exc_info.value)

    def test_confidence_default(self):
        """Default confidence should be 1.0."""
        event = TwinUpdateEvent(
            user_id=1,
            layer=TwinLayer.L2,
            path="dynamic_emotional.mood",
            new_value="happy",
        )
        assert event.confidence == 1.0

    def test_path_validation_empty(self):
        """Empty path should raise ValidationError."""
        with pytest.raises(ValidationError):
            TwinUpdateEvent(
                user_id=1,
                layer=TwinLayer.L2,
                path="",
                new_value="happy",
            )

    def test_path_validation_valid_nested(self):
        """Valid nested path should work."""
        event = TwinUpdateEvent(
            user_id=1,
            layer=TwinLayer.L2,
            path="dynamic_emotional.mood.intensity",
            new_value=8,
        )
        assert event.path == "dynamic_emotional.mood.intensity"

    def test_source_default(self):
        """Default source should be 'agent'."""
        event = TwinUpdateEvent(
            user_id=1,
            layer=TwinLayer.L2,
            path="dynamic_emotional.mood",
            new_value="happy",
        )
        assert event.source == "agent"

    def test_trigger_default(self):
        """Default trigger should be 'chat_insight'."""
        event = TwinUpdateEvent(
            user_id=1,
            layer=TwinLayer.L2,
            path="dynamic_emotional.mood",
            new_value="happy",
        )
        assert event.trigger == "chat_insight"


class TestTwinUpdateResult:
    """Tests for TwinUpdateResult model."""

    def test_successful_update_result(self):
        """Test successful update result."""
        result = TwinUpdateResult(
            updated=True,
            log_id=123,
            old_value="sad",
            new_value="happy",
            dimensions_recalculated=True,
        )
        assert result.updated is True
        assert result.log_id == 123
        assert result.old_value == "sad"
        assert result.new_value == "happy"
        assert result.dimensions_recalculated is True

    def test_failed_update_result(self):
        """Test failed update result."""
        result = TwinUpdateResult(
            updated=False,
            new_value="happy",
        )
        assert result.updated is False
        assert result.log_id is None
        assert result.dimensions_recalculated is False


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
