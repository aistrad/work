"""
Digital Twin Pydantic Models.

REQ: REQ-TWIN-001, REQ-TWIN-002
Design: §5.1.1, §4.3.1
HOS-REF: §1.2
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, Field, field_validator, model_validator


class TwinLayer(str, Enum):
    """Twin data layers."""
    L1 = "L1"  # Metadata layer (static)
    L2 = "L2"  # Dynamic state layer
    L3 = "L3"  # Aggregated metrics


class DimensionScores(BaseModel):
    """
    L3 aggregated dimension scores.
    All scores are clamped to [0, 100].
    """
    energy: float = Field(default=50.0, ge=0, le=100, description="能量维度")
    clarity: float = Field(default=50.0, ge=0, le=100, description="清晰度维度")
    connection: float = Field(default=50.0, ge=0, le=100, description="连接维度")
    growth: float = Field(default=50.0, ge=0, le=100, description="成长维度")
    balance: float = Field(default=50.0, ge=0, le=100, description="平衡维度")

    @field_validator("energy", "clarity", "connection", "growth", "balance", mode="before")
    @classmethod
    def clamp_score(cls, v: Any) -> float:
        """Clamp score to [0, 100]."""
        if v is None:
            return 50.0
        try:
            val = float(v)
            return max(0.0, min(100.0, val))
        except (TypeError, ValueError):
            return 50.0


class TwinMetadata(BaseModel):
    """L1 Metadata layer - static/semi-static data."""
    astrology: Dict[str, Any] = Field(default_factory=dict, description="八字/命盘数据")
    psychology: Dict[str, Any] = Field(default_factory=dict, description="心理测评结果")
    memory: Dict[str, Any] = Field(default_factory=dict, description="长期记忆/偏好")


class TwinDynamicState(BaseModel):
    """L2 Dynamic state layer - frequently changing data."""
    astro: Dict[str, Any] = Field(default_factory=dict, description="当前运势/流年")
    bio: Dict[str, Any] = Field(default_factory=dict, description="生理状态")
    social: Dict[str, Any] = Field(default_factory=dict, description="社交状态")
    emotional: Dict[str, Any] = Field(default_factory=dict, description="情绪状态")


class TwinAggregatedMetrics(BaseModel):
    """L3 Aggregated metrics - computed from L1 and L2."""
    aura_points: int = Field(default=0, ge=0, description="能量点数")
    overall_wellbeing: float = Field(default=50.0, ge=0, le=100, description="整体幸福指数")
    growth_streak: int = Field(default=0, ge=0, description="成长连续天数")
    dimension_scores: DimensionScores = Field(default_factory=DimensionScores)


class TwinData(BaseModel):
    """
    Complete Digital Twin data model.

    Represents the user's spiritual digital twin with three layers:
    - L1: Metadata (astrology, psychology, memory)
    - L2: Dynamic state (astro, bio, social, emotional)
    - L3: Aggregated metrics (aura, wellbeing, dimensions)
    """
    twin_id: Optional[int] = Field(default=None, description="孪生ID")
    user_id: int = Field(..., description="用户ID")

    # L1 Metadata
    metadata_astrology: Dict[str, Any] = Field(default_factory=dict)
    metadata_psychology: Dict[str, Any] = Field(default_factory=dict)
    metadata_memory: Dict[str, Any] = Field(default_factory=dict)

    # L2 Dynamic State
    dynamic_astro: Dict[str, Any] = Field(default_factory=dict)
    dynamic_bio: Dict[str, Any] = Field(default_factory=dict)
    dynamic_social: Dict[str, Any] = Field(default_factory=dict)
    dynamic_emotional: Dict[str, Any] = Field(default_factory=dict)

    # L3 Aggregated Metrics
    aura_points: int = Field(default=0, ge=0)
    overall_wellbeing: float = Field(default=50.0, ge=0, le=100)
    growth_streak: int = Field(default=0, ge=0)
    dimension_scores: DimensionScores = Field(default_factory=DimensionScores)

    # Meta
    compute_version: str = Field(default="v1.0")
    last_full_refresh: Optional[datetime] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def get_layer(self, layer: TwinLayer) -> Dict[str, Any]:
        """Get data for a specific layer."""
        if layer == TwinLayer.L1:
            return {
                "metadata_astrology": self.metadata_astrology,
                "metadata_psychology": self.metadata_psychology,
                "metadata_memory": self.metadata_memory,
            }
        elif layer == TwinLayer.L2:
            return {
                "dynamic_astro": self.dynamic_astro,
                "dynamic_bio": self.dynamic_bio,
                "dynamic_social": self.dynamic_social,
                "dynamic_emotional": self.dynamic_emotional,
            }
        else:  # L3
            return {
                "aura_points": self.aura_points,
                "overall_wellbeing": self.overall_wellbeing,
                "growth_streak": self.growth_streak,
                "dimension_scores": self.dimension_scores.model_dump(),
            }

    def get_layers(self, layers: List[TwinLayer]) -> Dict[str, Any]:
        """Get data for multiple layers."""
        result = {}
        for layer in layers:
            result.update(self.get_layer(layer))
        return result


class TwinUpdateEvent(BaseModel):
    """
    Event for updating twin data.

    Used by Agent Service to update twin state via Tool API.
    """
    user_id: int = Field(..., description="用户ID")
    layer: TwinLayer = Field(..., description="更新的层级")
    path: str = Field(..., description="JSON路径，如 'dynamic_emotional.current_mood'")
    new_value: Any = Field(..., description="新值")
    confidence: float = Field(
        default=1.0,
        ge=0.0,
        le=1.0,
        description="置信度 [0, 1]"
    )
    source: Literal["user", "agent", "system"] = Field(
        default="agent",
        description="更新来源"
    )
    trigger: str = Field(
        default="chat_insight",
        description="触发类型: chat_insight, checkin, commitment_done, social_event, cron"
    )

    @field_validator("confidence", mode="before")
    @classmethod
    def validate_confidence(cls, v: Any) -> float:
        """Validate confidence is in [0, 1]."""
        if v is None:
            return 1.0
        try:
            val = float(v)
            if val < 0 or val > 1:
                raise ValueError(f"confidence must be in [0, 1], got {val}")
            return val
        except (TypeError, ValueError) as e:
            raise ValueError(f"Invalid confidence value: {v}") from e

    @field_validator("path", mode="before")
    @classmethod
    def validate_path(cls, v: str) -> str:
        """Validate path format."""
        if not v or not isinstance(v, str):
            raise ValueError("path must be a non-empty string")
        # Basic validation: should be dot-separated identifiers
        parts = v.split(".")
        if not all(part.isidentifier() or part.isdigit() for part in parts):
            raise ValueError(f"Invalid path format: {v}")
        return v


class TwinUpdateResult(BaseModel):
    """Result of a twin update operation."""
    updated: bool = Field(..., description="是否更新成功")
    log_id: Optional[int] = Field(default=None, description="更新日志ID")
    old_value: Optional[Any] = Field(default=None, description="旧值")
    new_value: Any = Field(..., description="新值")
    dimensions_recalculated: bool = Field(
        default=False,
        description="是否触发了维度重算"
    )


class TwinHistoryEntry(BaseModel):
    """A single entry in twin update history."""
    log_id: int
    trigger_type: str
    layer: TwinLayer
    path: str
    old_value: Optional[Any]
    new_value: Any
    confidence: float
    source: str
    created_at: datetime


class TwinHistoryResponse(BaseModel):
    """Response for twin history query."""
    entries: List[TwinHistoryEntry]
    total_count: int
    limit: int
    offset: int
