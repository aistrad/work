"""
Social Network Service.

REQ: REQ-SOCIAL-001 ~ REQ-SOCIAL-005
Design: §3.4.1 ~ §3.4.2
HOS-REF: §7.2
"""

from __future__ import annotations

import json
import math
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional
from uuid import uuid4

from common.logging import get_logger
from models.social import (
    BuffType,
    ChainParticipant,
    ChainStatus,
    EnergyBuff,
    LuckChain,
    RelationshipStatus,
    RelationshipType,
    RitualType,
    ShareCard,
    SocialEdge,
)
from stores import fortune_db

logger = get_logger(__name__)


class SocialServiceError(Exception):
    """Base exception for social service errors."""
    pass


class NotFriendsError(SocialServiceError):
    """Users are not friends."""
    pass


class InsufficientBalanceError(SocialServiceError):
    """Insufficient balance for operation."""
    pass


class AlreadyJoinedError(SocialServiceError):
    """User already joined the chain."""
    pass


class ChainNotActiveError(SocialServiceError):
    """Chain is not active."""
    pass


def _now_utc() -> datetime:
    return datetime.now(timezone.utc)


# =============================================================================
# Friend Management (REQ-SOCIAL-001)
# =============================================================================

def send_friend_request(
    user_id: int,
    peer_user_id: int,
    relationship_type: RelationshipType = RelationshipType.FRIEND,
) -> SocialEdge:
    """
    Send a friend request.

    REQ: REQ-SOCIAL-001
    """
    if user_id == peer_user_id:
        raise SocialServiceError("Cannot send friend request to yourself")

    # Check if relationship already exists
    existing = fortune_db.fetch_one(
        """
        SELECT * FROM fortune_social_edge
        WHERE user_id = %s AND peer_user_id = %s
        """,
        [user_id, peer_user_id],
    )

    if existing:
        if existing["status"] == "accepted":
            raise SocialServiceError("Already friends")
        elif existing["status"] == "pending":
            raise SocialServiceError("Friend request already pending")
        elif existing["status"] == "blocked":
            raise SocialServiceError("Cannot send request to blocked user")

    now = _now_utc()

    # Create the edge (one direction)
    fortune_db.execute(
        """
        INSERT INTO fortune_social_edge (
            user_id, peer_user_id, relationship_type, status, created_at, updated_at
        ) VALUES (%s, %s, %s, %s, %s, %s)
        ON CONFLICT (user_id, peer_user_id) DO UPDATE SET
            status = 'pending', updated_at = %s
        """,
        [user_id, peer_user_id, relationship_type.value, "pending", now, now, now],
    )

    logger.info("friend_request_sent from=%s to=%s", user_id, peer_user_id)

    return SocialEdge(
        user_id=user_id,
        peer_user_id=peer_user_id,
        relationship_type=relationship_type,
        status=RelationshipStatus.PENDING,
        created_at=now,
        updated_at=now,
    )


def accept_friend_request(user_id: int, peer_user_id: int) -> SocialEdge:
    """
    Accept a friend request.

    REQ: REQ-SOCIAL-001
    """
    # Check if there's a pending request from peer to user
    request = fortune_db.fetch_one(
        """
        SELECT * FROM fortune_social_edge
        WHERE user_id = %s AND peer_user_id = %s AND status = 'pending'
        """,
        [peer_user_id, user_id],
    )

    if not request:
        raise SocialServiceError("No pending friend request found")

    now = _now_utc()

    # Update the original request to accepted
    fortune_db.execute(
        """
        UPDATE fortune_social_edge
        SET status = 'accepted', updated_at = %s
        WHERE user_id = %s AND peer_user_id = %s
        """,
        [now, peer_user_id, user_id],
    )

    # Create the reverse edge (bidirectional friendship)
    fortune_db.execute(
        """
        INSERT INTO fortune_social_edge (
            user_id, peer_user_id, relationship_type, status, created_at, updated_at
        ) VALUES (%s, %s, %s, %s, %s, %s)
        ON CONFLICT (user_id, peer_user_id) DO UPDATE SET
            status = 'accepted', updated_at = %s
        """,
        [user_id, peer_user_id, request["relationship_type"], "accepted", now, now, now],
    )

    logger.info("friend_request_accepted user=%s peer=%s", user_id, peer_user_id)

    return SocialEdge(
        user_id=user_id,
        peer_user_id=peer_user_id,
        relationship_type=RelationshipType(request["relationship_type"]),
        status=RelationshipStatus.ACCEPTED,
        created_at=now,
        updated_at=now,
    )


def get_friends(user_id: int, status: Optional[RelationshipStatus] = None) -> List[SocialEdge]:
    """
    Get user's friends.

    REQ: REQ-SOCIAL-001
    """
    if status:
        rows = fortune_db.fetch_all(
            """
            SELECT * FROM fortune_social_edge
            WHERE user_id = %s AND status = %s
            ORDER BY updated_at DESC
            """,
            [user_id, status.value],
        )
    else:
        rows = fortune_db.fetch_all(
            """
            SELECT * FROM fortune_social_edge
            WHERE user_id = %s
            ORDER BY updated_at DESC
            """,
            [user_id],
        )

    return [
        SocialEdge(
            user_id=row["user_id"],
            peer_user_id=row["peer_user_id"],
            relationship_type=RelationshipType(row["relationship_type"]),
            status=RelationshipStatus(row["status"]),
            compatibility_score=float(row["compatibility_score"]) if row.get("compatibility_score") else None,
            compatibility_data=row.get("compatibility_data"),
            created_at=row.get("created_at"),
            updated_at=row.get("updated_at"),
        )
        for row in rows
    ]


def are_friends(user_id: int, peer_user_id: int) -> bool:
    """Check if two users are friends."""
    row = fortune_db.fetch_one(
        """
        SELECT 1 FROM fortune_social_edge
        WHERE user_id = %s AND peer_user_id = %s AND status = 'accepted'
        """,
        [user_id, peer_user_id],
    )
    return row is not None


# =============================================================================
# Energy Buff (REQ-SOCIAL-002)
# =============================================================================

def send_energy_buff(
    from_user_id: int,
    to_user_id: int,
    buff_type: BuffType,
    amount: int,
    message: Optional[str] = None,
) -> EnergyBuff:
    """
    Send energy buff to a friend.

    REQ: REQ-SOCIAL-002
    Design: §3.4.1

    Steps:
    1. Verify friendship
    2. Verify sender balance
    3. Execute transfer in transaction
    4. Update receiver's twin
    5. Send push notification
    """
    # 1. Verify friendship
    if not are_friends(from_user_id, to_user_id):
        raise NotFriendsError("Users are not friends")

    # 2. Verify sender balance
    balance_row = fortune_db.fetch_one(
        "SELECT coins FROM fortune_user_balance WHERE user_id = %s",
        [from_user_id],
    )

    if not balance_row:
        # Create balance record if not exists
        fortune_db.execute(
            "INSERT INTO fortune_user_balance (user_id, coins, aura) VALUES (%s, 0, 0)",
            [from_user_id],
        )
        raise InsufficientBalanceError("Insufficient balance")

    if balance_row["coins"] < amount:
        raise InsufficientBalanceError(f"Insufficient balance: have {balance_row['coins']}, need {amount}")

    now = _now_utc()

    # 3. Execute transfer in transaction
    # Deduct from sender
    fortune_db.execute(
        """
        UPDATE fortune_user_balance
        SET coins = coins - %s, updated_at = %s
        WHERE user_id = %s
        """,
        [amount, now, from_user_id],
    )

    # Record sender ledger entry
    sender_balance = fortune_db.fetch_one(
        "SELECT coins FROM fortune_user_balance WHERE user_id = %s",
        [from_user_id],
    )
    fortune_db.execute(
        """
        INSERT INTO fortune_currency_ledger (
            user_id, currency_type, amount, balance_after, category, reason, ref_type, created_at
        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """,
        [from_user_id, "coins", -amount, sender_balance["coins"], "transfer_out", "send_buff", "buff", now],
    )

    # Add to receiver (create balance if not exists)
    fortune_db.execute(
        """
        INSERT INTO fortune_user_balance (user_id, coins, aura, updated_at)
        VALUES (%s, %s, 0, %s)
        ON CONFLICT (user_id) DO UPDATE SET
            coins = fortune_user_balance.coins + %s,
            updated_at = %s
        """,
        [to_user_id, amount, now, amount, now],
    )

    # Record receiver ledger entry
    receiver_balance = fortune_db.fetch_one(
        "SELECT coins FROM fortune_user_balance WHERE user_id = %s",
        [to_user_id],
    )
    fortune_db.execute(
        """
        INSERT INTO fortune_currency_ledger (
            user_id, currency_type, amount, balance_after, category, reason, ref_type, created_at
        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """,
        [to_user_id, "coins", amount, receiver_balance["coins"], "transfer_in", "receive_buff", "buff", now],
    )

    # Record buff
    buff_row = fortune_db.execute_returning_one(
        """
        INSERT INTO fortune_energy_buff (
            from_user_id, to_user_id, buff_type, amount, message, source, created_at
        ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        RETURNING buff_id
        """,
        [from_user_id, to_user_id, buff_type.value, amount, message, "app", now],
    )

    buff_id = buff_row["buff_id"] if buff_row else 0

    # 4. Update receiver's twin (increment buffs received)
    try:
        from services import twin_service
        from models.twin import TwinLayer, TwinUpdateEvent

        twin_service.update_twin(TwinUpdateEvent(
            user_id=to_user_id,
            layer=TwinLayer.L2,
            path="dynamic_social.recent_buffs_received",
            new_value=1,  # Will be incremented
            confidence=1.0,
            source="system",
            trigger="social_event",
        ))
    except Exception as e:
        logger.warning("Failed to update twin for buff: %s", str(e))

    logger.info(
        "energy_buff_sent from=%s to=%s type=%s amount=%s",
        from_user_id, to_user_id, buff_type.value, amount
    )

    return EnergyBuff(
        buff_id=buff_id,
        from_user_id=from_user_id,
        to_user_id=to_user_id,
        buff_type=buff_type,
        amount=amount,
        message=message,
        source="app",
        created_at=now,
    )


def get_received_buffs(user_id: int, limit: int = 20) -> List[EnergyBuff]:
    """Get buffs received by user."""
    rows = fortune_db.fetch_all(
        """
        SELECT * FROM fortune_energy_buff
        WHERE to_user_id = %s
        ORDER BY created_at DESC
        LIMIT %s
        """,
        [user_id, limit],
    )

    return [
        EnergyBuff(
            buff_id=row["buff_id"],
            from_user_id=row["from_user_id"],
            to_user_id=row["to_user_id"],
            buff_type=BuffType(row["buff_type"]),
            amount=row["amount"],
            message=row.get("message"),
            source=row.get("source", "app"),
            created_at=row.get("created_at"),
        )
        for row in rows
    ]


# =============================================================================
# Luck Chain (REQ-SOCIAL-004)
# =============================================================================

def create_luck_chain(
    creator_user_id: int,
    title: str,
    ritual_type: RitualType,
    description: Optional[str] = None,
    base_reward: int = 10,
    expires_hours: int = 24,
) -> LuckChain:
    """
    Create a new luck chain.

    REQ: REQ-SOCIAL-004
    """
    now = _now_utc()
    expires_at = now + timedelta(hours=expires_hours)

    row = fortune_db.execute_returning_one(
        """
        INSERT INTO fortune_luck_chain (
            creator_user_id, title, description, ritual_type,
            base_reward, participant_count, status, expires_at, created_at
        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        RETURNING chain_id
        """,
        [creator_user_id, title, description, ritual_type.value,
         base_reward, 0, "active", expires_at, now],
    )

    chain_id = row["chain_id"] if row else 0

    logger.info("luck_chain_created chain_id=%s creator=%s", chain_id, creator_user_id)

    return LuckChain(
        chain_id=chain_id,
        creator_user_id=creator_user_id,
        title=title,
        description=description,
        ritual_type=ritual_type,
        base_reward=base_reward,
        participant_count=0,
        status=ChainStatus.ACTIVE,
        expires_at=expires_at,
        created_at=now,
    )


def join_luck_chain(
    chain_id: int,
    user_id: int,
    contribution: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Join a luck chain.

    REQ: REQ-SOCIAL-004
    Design: §3.4.2

    Reward formula: floor(base_reward * log2(count + 2))
    """
    # 1. Get chain info
    chain_row = fortune_db.fetch_one(
        "SELECT * FROM fortune_luck_chain WHERE chain_id = %s FOR UPDATE",
        [chain_id],
    )

    if not chain_row:
        raise SocialServiceError("Chain not found")

    if chain_row["status"] != "active":
        raise ChainNotActiveError("Chain is not active")

    if chain_row["expires_at"] and chain_row["expires_at"] < _now_utc():
        # Mark as expired
        fortune_db.execute(
            "UPDATE fortune_luck_chain SET status = 'expired' WHERE chain_id = %s",
            [chain_id],
        )
        raise ChainNotActiveError("Chain has expired")

    # 2. Check if already joined
    existing = fortune_db.fetch_one(
        """
        SELECT 1 FROM fortune_luck_chain_participant
        WHERE chain_id = %s AND user_id = %s
        """,
        [chain_id, user_id],
    )

    if existing:
        raise AlreadyJoinedError("Already joined this chain")

    now = _now_utc()
    current_count = chain_row["participant_count"]
    new_position = current_count + 1

    # 3. Calculate reward
    base_reward = chain_row["base_reward"]
    reward = int(base_reward * math.log2(new_position + 2))

    # 4. Add participant
    fortune_db.execute(
        """
        INSERT INTO fortune_luck_chain_participant (
            chain_id, user_id, position, contribution, reward_earned, created_at
        ) VALUES (%s, %s, %s, %s, %s, %s)
        """,
        [chain_id, user_id, new_position, contribution, reward, now],
    )

    # 5. Update chain participant count
    fortune_db.execute(
        """
        UPDATE fortune_luck_chain
        SET participant_count = participant_count + 1
        WHERE chain_id = %s
        """,
        [chain_id],
    )

    # 6. Award Aura to all participants
    participants = fortune_db.fetch_all(
        "SELECT user_id FROM fortune_luck_chain_participant WHERE chain_id = %s",
        [chain_id],
    )

    for p in participants:
        # Add aura reward
        fortune_db.execute(
            """
            INSERT INTO fortune_user_balance (user_id, coins, aura, updated_at)
            VALUES (%s, 0, %s, %s)
            ON CONFLICT (user_id) DO UPDATE SET
                aura = fortune_user_balance.aura + %s,
                updated_at = %s
            """,
            [p["user_id"], reward, now, reward, now],
        )

        # Record ledger
        balance = fortune_db.fetch_one(
            "SELECT aura FROM fortune_user_balance WHERE user_id = %s",
            [p["user_id"]],
        )
        fortune_db.execute(
            """
            INSERT INTO fortune_currency_ledger (
                user_id, currency_type, amount, balance_after, category, reason, ref_type, ref_id, created_at
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """,
            [p["user_id"], "aura", reward, balance["aura"] if balance else reward,
             "earn", "luck_chain", "chain", str(chain_id), now],
        )

    chain_strength = math.log2(new_position + 2)

    logger.info(
        "chain_join chain_id=%s user=%s position=%s reward=%s",
        chain_id, user_id, new_position, reward
    )

    return {
        "position": new_position,
        "reward": reward,
        "total_participants": new_position,
        "chain_strength": round(chain_strength, 2),
        "message": f"成功加入接龙！获得 {reward} 能量值",
    }


def get_chain_detail(chain_id: int, user_id: Optional[int] = None) -> Dict[str, Any]:
    """Get chain details with participants."""
    chain_row = fortune_db.fetch_one(
        "SELECT * FROM fortune_luck_chain WHERE chain_id = %s",
        [chain_id],
    )

    if not chain_row:
        raise SocialServiceError("Chain not found")

    participants = fortune_db.fetch_all(
        """
        SELECT * FROM fortune_luck_chain_participant
        WHERE chain_id = %s
        ORDER BY position
        """,
        [chain_id],
    )

    my_participation = None
    if user_id:
        for p in participants:
            if p["user_id"] == user_id:
                my_participation = ChainParticipant(
                    chain_id=p["chain_id"],
                    user_id=p["user_id"],
                    position=p["position"],
                    contribution=p.get("contribution"),
                    reward_earned=p.get("reward_earned"),
                    created_at=p.get("created_at"),
                )
                break

    return {
        "chain": LuckChain(
            chain_id=chain_row["chain_id"],
            creator_user_id=chain_row["creator_user_id"],
            title=chain_row["title"],
            description=chain_row.get("description"),
            ritual_type=RitualType(chain_row["ritual_type"]),
            base_reward=chain_row["base_reward"],
            participant_count=chain_row["participant_count"],
            status=ChainStatus(chain_row["status"]),
            expires_at=chain_row.get("expires_at"),
            created_at=chain_row.get("created_at"),
        ),
        "participants": [
            ChainParticipant(
                chain_id=p["chain_id"],
                user_id=p["user_id"],
                position=p["position"],
                contribution=p.get("contribution"),
                reward_earned=p.get("reward_earned"),
                created_at=p.get("created_at"),
            )
            for p in participants
        ],
        "my_participation": my_participation,
    }


# =============================================================================
# Share Card (REQ-SOCIAL-005)
# =============================================================================

def create_share_card(
    user_id: int,
    card_type: str,
    content: Dict[str, Any],
    expires_hours: int = 168,
) -> ShareCard:
    """
    Create a shareable card.

    REQ: REQ-SOCIAL-005
    """
    import os

    card_id = uuid4()
    now = _now_utc()
    expires_at = now + timedelta(hours=expires_hours)

    base_url = os.getenv("H5_BASE", "http://localhost:8230")
    share_url = f"{base_url}/share/{card_id}"

    fortune_db.execute(
        """
        INSERT INTO fortune_share_card (
            card_id, user_id, card_type, content, share_url, view_count, expires_at, created_at
        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """,
        [str(card_id), user_id, card_type, json.dumps(content), share_url, 0, expires_at, now],
    )

    logger.info("share_card_created card_id=%s user=%s type=%s", card_id, user_id, card_type)

    return ShareCard(
        card_id=card_id,
        user_id=user_id,
        card_type=card_type,
        content=content,
        share_url=share_url,
        view_count=0,
        expires_at=expires_at,
        created_at=now,
    )


def get_share_card(card_id: str) -> Optional[ShareCard]:
    """Get a share card by ID."""
    row = fortune_db.fetch_one(
        "SELECT * FROM fortune_share_card WHERE card_id = %s",
        [card_id],
    )

    if not row:
        return None

    # Increment view count
    fortune_db.execute(
        "UPDATE fortune_share_card SET view_count = view_count + 1 WHERE card_id = %s",
        [card_id],
    )

    content = row.get("content") or {}
    if isinstance(content, str):
        content = json.loads(content)

    return ShareCard(
        card_id=row["card_id"],
        user_id=row["user_id"],
        card_type=row["card_type"],
        content=content,
        share_url=row.get("share_url"),
        view_count=row.get("view_count", 0) + 1,
        expires_at=row.get("expires_at"),
        created_at=row.get("created_at"),
    )
