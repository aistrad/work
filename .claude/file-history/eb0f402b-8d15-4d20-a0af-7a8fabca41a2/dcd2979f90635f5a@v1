#!/usr/bin/env python3
"""
VibeLife Skill Creator v2 - 创建、验证、提炼专家级 Skill 的命令行工具

用法:
    python skill_creator.py create <skill-name>
    python skill_creator.py validate <skill-name>
    python skill_creator.py list
    python skill_creator.py distill <skill-name> --knowledge-dir <path>
    python skill_creator.py expert <skill-name> --knowledge-dir <path>  # 专家级提炼
    python skill_creator.py optimize <skill-name> --knowledge-dir <path>  # Prompt 自动优化
    python skill_creator.py status <skill-name>  # 查看版本和贡献
    python skill_creator.py reload [skill-name]
"""
import os
import re
import sys
import asyncio
import argparse
from pathlib import Path
from typing import Optional, Dict, List

# 项目根目录
PROJECT_ROOT = Path(__file__).parent.parent.parent.parent
SKILLS_DIR = PROJECT_ROOT / "apps" / "api" / "skills"

# 保留名称
RESERVED_NAMES = {"core", "system", "admin", "test", "debug"}

# 默认知识库目录
DEFAULT_KNOWLEDGE_DIRS = {
    "bazi": PROJECT_ROOT / "knowledge" / "bazi",
    "zodiac": PROJECT_ROOT / "knowledge" / "zodiac",
}

# 默认描述
DEFAULT_DESCRIPTIONS = {
    "bazi": "八字命理分析专家。提供命盘排盘、日主分析、十神解读、大运流年分析。",
    "zodiac": "西方占星分析专家。提供本命星盘解读、行星位置分析、行运预测。",
}


# ═══════════════════════════════════════════════════════════════════════════
# 颜色输出
# ═══════════════════════════════════════════════════════════════════════════

class Colors:
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    END = "\033[0m"


def print_success(msg: str):
    print(f"{Colors.GREEN}✓{Colors.END} {msg}")


def print_warning(msg: str):
    print(f"{Colors.YELLOW}⚠{Colors.END} {msg}")


def print_error(msg: str):
    print(f"{Colors.RED}✗{Colors.END} {msg}")


def print_info(msg: str):
    print(f"{Colors.BLUE}ℹ{Colors.END} {msg}")


def print_step(msg: str):
    print(f"{Colors.CYAN}→{Colors.END} {msg}")


# ═══════════════════════════════════════════════════════════════════════════
# 工具函数
# ═══════════════════════════════════════════════════════════════════════════

def validate_skill_name(name: str) -> tuple[bool, str]:
    """验证 Skill 名称"""
    if not name:
        return False, "名称不能为空"
    if len(name) > 32:
        return False, "名称不能超过 32 个字符"
    if not re.match(r"^[a-z][a-z0-9-]*$", name):
        return False, "名称只能包含小写字母、数字和连字符，且必须以字母开头"
    if name in RESERVED_NAMES:
        return False, f"'{name}' 是保留名称"
    return True, ""


def parse_frontmatter(content: str) -> tuple[Dict, str]:
    """解析 YAML frontmatter"""
    pattern = r"^---\s*\n(.*?)\n---\s*\n(.*)$"
    match = re.match(pattern, content, re.DOTALL)
    if not match:
        return {}, content
    frontmatter_str, body = match.groups()
    metadata = {}
    for line in frontmatter_str.strip().split("\n"):
        if ":" in line:
            key, value = line.split(":", 1)
            key = key.strip()
            value = value.strip()
            if value != "|":
                metadata[key] = value
    return metadata, body.strip()


# ═══════════════════════════��═══════════════════════════════════════════════
# 命令: create
# ═══════════════════════════════════════════════════════════════════════════

def cmd_create(args):
    """创建新 Skill"""
    name = args.name
    valid, error = validate_skill_name(name)
    if not valid:
        print_error(error)
        return False

    if (SKILLS_DIR / name).exists():
        print_error(f"Skill '{name}' 已存在")
        return False

    display_name = args.display_name or name.replace("-", " ").title()
    description = args.description or f"{display_name} 技能。"

    skill_dir = SKILLS_DIR / name
    skill_dir.mkdir(parents=True, exist_ok=True)

    skill_content = f"""---
name: {name}
description: |
  {description}
  当用户询问相关话题时使用。
---

# {display_name} Skill

## 能力范围

- 能力 1
- 能力 2
- 能力 3

## 分析原则

### 原则 1

说明...

### 原则 2

说明...

## 表达方式

- 用通俗易懂的语言解释专业概念
- 结合用户的实际情境
- 避免绝对化表述

## 禁止事项

- 不做负面恐吓式预测
- 不给出绝对化的结论

## 可用工具

- `show_report` - 展示详细报告
- `show_insight` - 展示洞察卡片
- `search_knowledge` - 检索知识库
"""

    skill_file = skill_dir / "SKILL.md"
    skill_file.write_text(skill_content, encoding="utf-8")

    print_success(f"创建 Skill: {name}")
    print_info(f"  目录: {skill_dir}")
    print_info(f"  文件: {skill_file}")
    print()
    print_info("下一步:")
    print(f"  1. 编辑 {skill_file} 完善内容")
    print(f"  2. 或使用 distill 命令从知识库自动提炼:")
    print(f"     python skill_creator.py distill {name} --knowledge-dir /path/to/knowledge")
    return True


# ═══════════════════════════════════════════════════════════════════════════
# 命令: validate
# ═══════════════════════════════════════════════════════════════════════════

def cmd_validate(args):
    """验证 Skill"""
    skill_name = args.name
    skill_dir = SKILLS_DIR / skill_name
    errors = []

    if not skill_dir.exists():
        print_error(f"Skill 目录不存在: {skill_dir}")
        return False

    skill_file = skill_dir / "SKILL.md"
    if not skill_file.exists():
        print_error(f"SKILL.md 文件不存在: {skill_file}")
        return False

    content = skill_file.read_text(encoding="utf-8")
    metadata, body = parse_frontmatter(content)

    if "name" not in metadata:
        errors.append("缺少必需字段: name")
    elif metadata["name"] != skill_name:
        errors.append(f"name 字段 '{metadata['name']}' 与目录名 '{skill_name}' 不匹配")

    if "description" not in metadata:
        errors.append("缺少必需字段: description")

    if not body:
        errors.append("SKILL.md 内容为空")

    if "## 能力范围" not in body and "## Capabilities" not in body:
        errors.append("建议添加 '## 能力范围' 章节")

    if errors:
        print_error(f"Skill '{skill_name}' 验证失败:")
        for error in errors:
            print(f"  - {error}")
        return False

    print_success(f"Skill '{skill_name}' 验证通过")
    return True


# ═══════════════════════════════════════════════════════════════════════════
# 命令: list
# ═══════════════════════════════════════════════════════════════════════════

def cmd_list(args):
    """列出所有 Skills"""
    if not SKILLS_DIR.exists():
        print_warning("Skills 目录不存在")
        return

    skills = []
    for path in sorted(SKILLS_DIR.iterdir()):
        if path.is_dir() and (path / "SKILL.md").exists():
            skill_file = path / "SKILL.md"
            content = skill_file.read_text(encoding="utf-8")
            metadata, _ = parse_frontmatter(content)
            skills.append({
                "name": path.name,
                "description": metadata.get("description", "").split("\n")[0][:50]
            })

    if not skills:
        print_warning("没有找到任何 Skill")
        return

    print(f"\n{'Name':<20} {'Description':<50}")
    print("-" * 70)
    for skill in skills:
        print(f"{skill['name']:<20} {skill['description']:<50}")
    print()


# ═══════════════════════════════════════════════════════════════════════════
# 命令: distill (知识提炼)
# ═══════════════════════════════════════════════════════════════════════════

async def cmd_distill_async(args):
    """从知识库提炼 Skill"""
    skill_name = args.name

    # 验证名称
    valid, error = validate_skill_name(skill_name)
    if not valid and skill_name not in ["bazi", "zodiac", "core"]:
        print_error(error)
        return False

    # 确定知识库目录
    knowledge_dir = Path(args.knowledge_dir) if args.knowledge_dir else DEFAULT_KNOWLEDGE_DIRS.get(skill_name)
    if not knowledge_dir or not knowledge_dir.exists():
        print_error(f"知识库目录不存在: {knowledge_dir}")
        print_info("请使用 --knowledge-dir 指定知识库目录")
        return False

    description = args.description or DEFAULT_DESCRIPTIONS.get(skill_name, f"{skill_name} 专业分析")

    print()
    print(f"{'=' * 60}")
    print(f"  Skill 知识提炼")
    print(f"{'=' * 60}")
    print_info(f"Skill: {skill_name}")
    print_info(f"知识库: {knowledge_dir}")
    print()

    try:
        # 导入提炼模块
        sys.path.insert(0, str(PROJECT_ROOT / "apps" / "api"))
        from services.skill_distill import SkillDistiller, DistillConfig

        config = DistillConfig(
            skill_name=skill_name,
            skill_description=description,
            knowledge_dir=knowledge_dir,
            output_dir=SKILLS_DIR / skill_name if not args.output_dir else Path(args.output_dir),
            file_pattern=args.pattern,
            merge_qa=not args.no_merge
        )

        distiller = SkillDistiller()

        if args.preview:
            # 预览模式
            print_step("预览模式：提取问答对...")
            qa_pairs = await distiller.preview(config)
            print()
            print(f"{'=' * 60}")
            print(f"  预览结果：共 {len(qa_pairs)} 个问答对")
            print(f"{'=' * 60}")

            from collections import defaultdict
            grouped = defaultdict(list)
            for qa in qa_pairs:
                grouped[qa.category].append(qa)

            for category, pairs in grouped.items():
                print(f"\n{Colors.CYAN}### {category} ({len(pairs)} 个){Colors.END}")
                for i, qa in enumerate(pairs[:3], 1):
                    print(f"\n{i}. Q: {qa.question}")
                    answer = qa.answer[:100] + "..." if len(qa.answer) > 100 else qa.answer
                    print(f"   A: {answer}")
                if len(pairs) > 3:
                    print(f"   ... 还有 {len(pairs) - 3} 个")
        else:
            # 完整提炼
            result = await distiller.distill(config)

            print()
            print(f"{'=' * 60}")
            print_success("提炼完成！")
            print(f"{'=' * 60}")
            print(f"  Skill 名称: {result.skill_name}")
            print(f"  处理文件数: {result.total_files}")
            print(f"  提取问答对: {result.total_qa_pairs}")
            print(f"  合并后问答对: {result.merged_qa_pairs}")
            print(f"  输出文件: {result.skill_path}")
            print(f"{'=' * 60}")

            # 自动重载
            if not args.no_reload:
                print()
                print_step("自动重载 Skill...")
                from services.agent.skill_loader import reload_skill
                reload_skill(skill_name)
                print_success(f"Skill '{skill_name}' 已重载")

        return True

    except ImportError as e:
        print_error(f"导入模块失败: {e}")
        print_info("请确保在正确的环境中运行")
        return False
    except Exception as e:
        print_error(f"提炼失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def cmd_distill(args):
    """从知识库提炼 Skill (同步包装)"""
    return asyncio.run(cmd_distill_async(args))


# ═══════════════════════════════════════════════════════════════════════════
# 命令: reload (热重载)
# ═══════════════════════════════════════════════════════════════════════════

def cmd_reload(args):
    """重载 Skill"""
    try:
        sys.path.insert(0, str(PROJECT_ROOT / "apps" / "api"))
        from services.agent.skill_loader import reload_skill, reload_all_skills

        if args.name:
            skill = reload_skill(args.name)
            if skill:
                print_success(f"Skill '{args.name}' 已重载")
            else:
                print_error(f"Skill '{args.name}' 不存在")
        else:
            reloaded = reload_all_skills()
            print_success(f"已重载 {len(reloaded)} 个 Skills: {', '.join(reloaded)}")

    except ImportError as e:
        print_error(f"导入模块失败: {e}")
        return False


# ═══════════════════════════════════════════════════════════════════════════
# 命令: expert (专家级提炼)
# ═══════════════════════════════════════════════════════════════════════════

async def cmd_expert_async(args):
    """专家级 Skill 提炼"""
    skill_name = args.name

    valid, error = validate_skill_name(skill_name)
    if not valid and skill_name not in ["bazi", "zodiac", "core"]:
        print_error(error)
        return False

    knowledge_dir = Path(args.knowledge_dir) if args.knowledge_dir else DEFAULT_KNOWLEDGE_DIRS.get(skill_name)
    if not knowledge_dir or not knowledge_dir.exists():
        print_error(f"知识库目录不存在: {knowledge_dir}")
        return False

    print()
    print(f"{'=' * 60}")
    print(f"  Expert Skill 提炼 v2")
    print(f"{'=' * 60}")
    print_info(f"Skill: {skill_name}")
    print_info(f"知识库: {knowledge_dir}")
    print_info(f"模式: {'增量' if not args.full else '全量'}")
    print()

    try:
        sys.path.insert(0, str(PROJECT_ROOT / "apps" / "api"))
        from services.skill_distill.expert_distiller import ExpertDistiller, DistillConfig

        config = DistillConfig(
            skill_name=skill_name,
            knowledge_dir=knowledge_dir,
            output_dir=SKILLS_DIR / skill_name if not args.output_dir else Path(args.output_dir),
            file_pattern=args.pattern,
            incremental=not args.full
        )

        distiller = ExpertDistiller()
        print_step("开始提炼...")
        result = await distiller.distill(config)

        print()
        print(f"{'=' * 60}")
        print_success("提炼完成！")
        print(f"{'=' * 60}")
        print(f"  版本: v{result.version}")
        print(f"  总文件数: {result.total_files}")
        print(f"  新增文件: {result.new_files}")
        print(f"  修改文件: {result.modified_files}")
        print(f"  删除文件: {result.deleted_files}")
        print(f"  知识单元总数: {result.total_knowledge}")
        print(f"  新增知识: {result.new_knowledge}")
        if result.changes:
            print(f"\n  变更记录:")
            for change in result.changes[:5]:
                print(f"    - {change}")
            if len(result.changes) > 5:
                print(f"    ... 还有 {len(result.changes) - 5} 条")
        print(f"{'=' * 60}")

        return True

    except ImportError as e:
        print_error(f"导入模块失败: {e}")
        import traceback
        traceback.print_exc()
        return False
    except Exception as e:
        print_error(f"提炼失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def cmd_expert(args):
    """专家级 Skill 提炼 (同步包装)"""
    return asyncio.run(cmd_expert_async(args))


# ═══════════════════════════════════════════════════════════════════════════
# 命令: status (查看状态)
# ═══════════════════════════════════════════════════════════════════════════

def cmd_status(args):
    """查看 Skill 状态"""
    skill_name = args.name
    skill_dir = SKILLS_DIR / skill_name

    if not skill_dir.exists():
        print_error(f"Skill '{skill_name}' 不存在")
        return False

    json_path = skill_dir / "skill.json"

    print()
    print(f"{'=' * 60}")
    print(f"  Skill 状态: {skill_name}")
    print(f"{'=' * 60}")

    # 检查是否是 Expert Skill
    if json_path.exists():
        import json
        with open(json_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        print(f"\n{Colors.CYAN}基本信息{Colors.END}")
        print(f"  版本: v{data.get('current_version', '1.0.0')}")
        print(f"  创建时间: {data.get('created_at', 'N/A')[:10]}")
        print(f"  更新时间: {data.get('updated_at', 'N/A')[:10]}")

        identity = data.get("identity", {})
        if identity:
            print(f"\n{Colors.CYAN}专家身份{Colors.END}")
            print(f"  角色: {identity.get('role', 'N/A')}")
            print(f"  目标: {identity.get('goal', 'N/A')}")

        knowledge = data.get("knowledge_units", [])
        if knowledge:
            print(f"\n{Colors.CYAN}知识统计{Colors.END}")
            print(f"  知识单元总数: {len(knowledge)}")

            # 按类型统计
            from collections import Counter
            type_counts = Counter(k.get("type", "unknown") for k in knowledge)
            for ktype, count in type_counts.most_common():
                print(f"    - {ktype}: {count}")

        contributions = data.get("source_contributions", {})
        if contributions:
            print(f"\n{Colors.CYAN}来源贡献 (Top 5){Colors.END}")
            sorted_contrib = sorted(
                contributions.items(),
                key=lambda x: x[1].get("knowledge_count", 0),
                reverse=True
            )
            for source, contrib in sorted_contrib[:5]:
                source_name = Path(source).name
                count = contrib.get("knowledge_count", 0)
                ratio = contrib.get("contribution_ratio", 0) * 100
                print(f"    - {source_name}: {count} ({ratio:.1f}%)")

        versions = data.get("version_history", [])
        if versions:
            print(f"\n{Colors.CYAN}版本历史 (最近 3 个){Colors.END}")
            for v in versions[-3:]:
                print(f"    v{v.get('version')}: {v.get('created_at', '')[:10]}")
                for change in v.get("changes", [])[:2]:
                    print(f"      - {change[:50]}...")
    else:
        # 传统 SKILL.md
        skill_file = skill_dir / "SKILL.md"
        if skill_file.exists():
            content = skill_file.read_text(encoding="utf-8")
            metadata, body = parse_frontmatter(content)
            print(f"  类型: 传统 Skill (SKILL.md)")
            print(f"  描述: {metadata.get('description', 'N/A')[:50]}")
            print(f"\n  提示: 使用 'expert' 命令升级为专家级 Skill")
        else:
            print_error("未找到 Skill 文件")
            return False

    print(f"\n{'=' * 60}")
    return True


# ═══════════════════════════════════════════════════════════════════════════
# 命令: optimize (Prompt 自动优化)
# ═══════════════════════════════════════════════════════════════════════════

# 默认目标
DEFAULT_GOALS = {
    "bazi": "成为八字命理领域的顶级专家。核心方法论：以日主为核心，通过五行平衡、十神关系、格局判断分析命盘。帮助用户理解命盘特质，把握大运流年趋势。",
    "zodiac": "成为西方占星领域的顶级专家。核心方法论：通过三重星座、行星相位、宫位系统解读星盘。帮助用户理解能量配置，把握行运周期，实现自我成长。",
}


async def cmd_optimize_async(args):
    """Prompt 自动优化"""
    skill_name = args.name

    knowledge_dir = Path(args.knowledge_dir) if args.knowledge_dir else DEFAULT_KNOWLEDGE_DIRS.get(skill_name)
    if not knowledge_dir or not knowledge_dir.exists():
        print_error(f"知识库目录不存在: {knowledge_dir}")
        return False

    goal = args.goal or DEFAULT_GOALS.get(skill_name, f"成为 {skill_name} 领域的顶级专家")
    output_dir = Path(args.output_dir) if args.output_dir else SKILLS_DIR / skill_name

    print()
    print(f"{'=' * 60}")
    print(f"  Prompt 自动优化 v2")
    print(f"{'=' * 60}")
    print_info(f"Skill: {skill_name}")
    print_info(f"知识库: {knowledge_dir}")
    print_info(f"目标: {goal[:50]}...")
    print()

    try:
        sys.path.insert(0, str(PROJECT_ROOT / "apps" / "api"))
        from services.skill_distill.prompt_optimizer import PromptOptimizer

        optimizer = PromptOptimizer()

        print_step("Step 1: 深度定义 Skill Meta...")
        result = await optimizer.optimize(skill_name, goal, knowledge_dir)

        print()
        print_success("Prompt 优化完成！")
        print()
        print(f"{Colors.CYAN}专家身份{Colors.END}")
        print(f"  角色: {result.meta.role}")
        print(f"  目标: {result.meta.goal}")
        print()
        print(f"{Colors.CYAN}核心方法论{Colors.END}")
        print(f"  {result.meta.core_methodology[:100]}...")
        print()
        print(f"{Colors.CYAN}方法论关键词{Colors.END}")
        print(f"  {', '.join(result.meta.methodology_keywords[:10])}")
        print()
        print(f"{Colors.CYAN}Knowhow 类型{Colors.END}")
        for t in result.meta.knowhow_types:
            print(f"  - {t.get('name')}: {t.get('name_cn', '')}")

        # 保存结果
        print()
        print_step("保存优化结果...")
        await optimizer.save(result, output_dir)
        print_success(f"已保存到: {output_dir}")

        print(f"\n{'=' * 60}")
        print_info("下一步: 使用优化后的 Prompt 提取知识")
        print(f"  python skill_creator.py expert {skill_name} -k {knowledge_dir} --use-optimized")
        print(f"{'=' * 60}")

        return True

    except Exception as e:
        print_error(f"优化失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def cmd_optimize(args):
    """Prompt 自动优化 (同步包装)"""
    return asyncio.run(cmd_optimize_async(args))


# ═══════════════════════════════════════════════════════════════════════════
# 命令: build (Expert Factory 一键构建)
# ═══════════════════════════════════════════════════════════════════════════

# 默认知识库目录 (build 命令，使用环境变量)
DEFAULT_KNOWLEDGE_DIR = os.getenv("VIBELIFE_KNOWLEDGE_ROOT", "/data/vibelife/knowledge")

async def cmd_build_async(args):
    """Expert Factory 一键构建"""
    skill_name = args.name

    # 确定知识库目录
    if args.knowledge_dir:
        knowledge_dir = Path(args.knowledge_dir)
    else:
        knowledge_dir = Path(DEFAULT_KNOWLEDGE_DIR) / skill_name

    if not knowledge_dir.exists():
        print_error(f"知识库目录不存在: {knowledge_dir}")
        return False

    # 确定输出目录
    output_dir = Path(args.output_dir) if args.output_dir else SKILLS_DIR / skill_name

    print()
    print(f"{'=' * 60}")
    print(f"  Expert Factory - 一键构建专家系统")
    print(f"{'=' * 60}")
    print_info(f"Skill: {skill_name}")
    print_info(f"知识库: {knowledge_dir}")
    print_info(f"输出目录: {output_dir}")
    print()

    try:
        sys.path.insert(0, str(PROJECT_ROOT / "apps" / "api"))
        from services.skill_distill.expert_factory import ExpertFactory

        factory = ExpertFactory()
        result = await factory.build(
            skill_name=skill_name,
            knowledge_dir=knowledge_dir,
            output_dir=output_dir,
            goal=args.goal
        )

        print()
        if result.success:
            print(f"{'=' * 60}")
            print_success("构建完成！")
            print(f"{'=' * 60}")
            print(f"  处理文件: {result.files_processed}")
            print(f"  Methods: {result.methods_extracted}")
            print(f"  Workflow Steps: {result.workflow_steps}")
            print(f"  Rules: {result.rules_extracted}")
            print(f"  输出目录: {result.output_dir}")
            print(f"{'=' * 60}")
        else:
            print_error(f"构建失败: {result.error}")
            return False

        return True

    except Exception as e:
        print_error(f"构建失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def cmd_build(args):
    """Expert Factory 一键构建 (同步包装)"""
    return asyncio.run(cmd_build_async(args))


# ═══════════════════════════════════════════════════════════════════════════
# 主函数
# ═══════════════════════════════════════════════════════════════════════════

def main():
    parser = argparse.ArgumentParser(
        description="VibeLife Skill Creator v2 - 创建、验证、提炼专家级 Skill",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
  # 创建新 Skill
  python skill_creator.py create tarot
  python skill_creator.py create tarot --display-name "塔罗牌"

  # 验证 Skill
  python skill_creator.py validate bazi

  # 列出所有 Skills
  python skill_creator.py list

  # 传统提炼（问答对模式）
  python skill_creator.py distill bazi --knowledge-dir /path/to/knowledge
  python skill_creator.py distill bazi --preview  # 预览模式

  # 专家级提炼（推荐）
  python skill_creator.py expert bazi --knowledge-dir /path/to/knowledge
  python skill_creator.py expert bazi --full  # 全量模式

  # 查看 Skill 状态
  python skill_creator.py status bazi

  # 热重载 Skill
  python skill_creator.py reload bazi    # 重载单个
  python skill_creator.py reload         # 重载所有
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="命令")

    # create 命令
    create_parser = subparsers.add_parser("create", help="创建新 Skill")
    create_parser.add_argument("name", help="Skill 名称")
    create_parser.add_argument("--display-name", help="显示名称")
    create_parser.add_argument("--description", help="描述")

    # validate 命令
    validate_parser = subparsers.add_parser("validate", help="验证 Skill")
    validate_parser.add_argument("name", help="Skill 名称")

    # list 命令
    subparsers.add_parser("list", help="列出所有 Skills")

    # distill 命令
    distill_parser = subparsers.add_parser("distill", help="从知识库提炼 Skill（传统模式）")
    distill_parser.add_argument("name", help="Skill 名称")
    distill_parser.add_argument("--knowledge-dir", "-k", help="知识库目录")
    distill_parser.add_argument("--output-dir", "-o", help="输出目录")
    distill_parser.add_argument("--description", "-d", help="Skill 描述")
    distill_parser.add_argument("--pattern", "-p", default="*.md", help="文件匹配模式")
    distill_parser.add_argument("--no-merge", action="store_true", help="不合并去重问答对")
    distill_parser.add_argument("--no-reload", action="store_true", help="不自动重载")
    distill_parser.add_argument("--preview", action="store_true", help="预览模式（不生成文件）")

    # expert 命令（新）
    expert_parser = subparsers.add_parser("expert", help="专家级 Skill 提炼（推荐）")
    expert_parser.add_argument("name", help="Skill 名称")
    expert_parser.add_argument("--knowledge-dir", "-k", help="知识库目录")
    expert_parser.add_argument("--output-dir", "-o", help="输出目录")
    expert_parser.add_argument("--pattern", "-p", default="*.md", help="文件匹配模式")
    expert_parser.add_argument("--full", action="store_true", help="全量模式（默认增量）")

    # status 命令（新）
    status_parser = subparsers.add_parser("status", help="查看 Skill 状态")
    status_parser.add_argument("name", help="Skill 名称")

    # optimize 命令（新）
    optimize_parser = subparsers.add_parser("optimize", help="自动优化 Prompt")
    optimize_parser.add_argument("name", help="Skill 名称")
    optimize_parser.add_argument("--knowledge-dir", "-k", help="知识库目录")
    optimize_parser.add_argument("--goal", "-g", help="Skill 目标描述")
    optimize_parser.add_argument("--output-dir", "-o", help="输出目录")

    # reload 命令
    reload_parser = subparsers.add_parser("reload", help="热重载 Skill")
    reload_parser.add_argument("name", nargs="?", help="Skill 名称（不指定则重载所有）")

    # build 命令（Expert Factory 一键构建）
    build_parser = subparsers.add_parser("build", help="Expert Factory 一键构建专家系统")
    build_parser.add_argument("name", help="Skill 名称")
    build_parser.add_argument("--knowledge-dir", "-k", help="知识库目录")
    build_parser.add_argument("--output-dir", "-o", help="输出目录")
    build_parser.add_argument("--goal", "-g", help="Skill 目标描述")

    args = parser.parse_args()

    if args.command == "create":
        cmd_create(args)
    elif args.command == "validate":
        cmd_validate(args)
    elif args.command == "list":
        cmd_list(args)
    elif args.command == "distill":
        cmd_distill(args)
    elif args.command == "expert":
        cmd_expert(args)
    elif args.command == "optimize":
        cmd_optimize(args)
    elif args.command == "status":
        cmd_status(args)
    elif args.command == "reload":
        cmd_reload(args)
    elif args.command == "build":
        cmd_build(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
