#!/usr/bin/env python3
"""
全面测试星盘(Zodiac)和八字(Bazi)计算功能
"""

import sys
import json
from datetime import date
from pathlib import Path

# 添加路径 (使用相对路径)
_script_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(_script_dir.parent))

def test_zodiac():
    """测试星盘计算"""
    print("\n" + "="*60)
    print("测试 1: Zodiac 星盘计算 (pyswisseph)")
    print("="*60)

    try:
        from skills.zodiac.services import ZodiacCalculator, calculate_zodiac, calculate_transit

        # 测试用例
        test_cases = [
            {"birth_date": "1990-05-15", "birth_time": "08:30", "birth_place": "Shanghai", "desc": "1990年5月15日 上海"},
            {"birth_date": "1985-12-25", "birth_time": "23:45", "birth_place": "Beijing", "desc": "1985年12月25日 北京"},
            {"birth_date": "2000-01-01", "birth_time": "00:00", "birth_place": "New York", "desc": "2000年1月1日 纽约"},
        ]

        for i, tc in enumerate(test_cases, 1):
            print(f"\n--- 测试用例 {i}: {tc['desc']} ---")

            chart = calculate_zodiac(
                birth_date=tc["birth_date"],
                birth_time=tc["birth_time"],
                birth_place=tc["birth_place"]
            )

            print(f"太阳星座: {chart['sun_sign_chinese']} ({chart['sun_sign']})")
            print(f"月亮星座: {chart['moon_sign_chinese']} ({chart['moon_sign']})")
            print(f"上升星座: {chart['rising_sign_chinese']} ({chart['rising_sign']})")
            print(f"主导元素: {chart['dominant_element']}")
            print(f"主导模式: {chart['dominant_modality']}")

            print(f"\n行星位置 ({len(chart['planets'])} 颗):")
            for p in chart['planets'][:5]:  # 只显示前5颗
                retro = " (逆行)" if p['retrograde'] else ""
                print(f"  {p['planet_chinese']}: {p['sign_chinese']} {p['degree']:.1f}° 第{p['house']}宫{retro}")

            print(f"\n相位 ({len(chart['aspects'])} 个):")
            for a in chart['aspects'][:5]:  # 只显示前5个
                print(f"  {a['description']} (容许度: {a['orb']}°)")

        # 测试行运
        print(f"\n--- 测试行运分析 ---")
        transits = calculate_transit(
            birth_date="1990-05-15",
            birth_time="08:30",
            birth_place="Shanghai",
            transit_date=date.today().isoformat()
        )
        print(f"今日行运 ({len(transits)} 个):")
        for t in transits[:3]:
            print(f"  {t['description']} - {t['influence']}")

        print("\n✅ Zodiac 测试通过!")
        return True

    except Exception as e:
        print(f"\n❌ Zodiac 测试失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def test_bazi():
    """测试八字计算"""
    print("\n" + "="*60)
    print("测试 2: Bazi 八字计算 (lunar-python)")
    print("="*60)

    try:
        from skills.bazi.services import BaziCalculator, calculate_bazi

        # 测试用例
        test_cases = [
            {"birth_date": "1990-05-15", "birth_time": "08:30", "gender": "male", "desc": "1990年5月15日 男"},
            {"birth_date": "1985-12-25", "birth_time": "23:45", "gender": "female", "desc": "1985年12月25日 女"},
            {"birth_date": "2000-01-01", "birth_time": "12:00", "gender": "unknown", "desc": "2000年1月1日"},
        ]

        for i, tc in enumerate(test_cases, 1):
            print(f"\n--- 测试用例 {i}: {tc['desc']} ---")

            chart = calculate_bazi(
                birth_date=tc["birth_date"],
                birth_time=tc["birth_time"],
                gender=tc["gender"]
            )

            print(f"农历: {chart['birth_info']['lunar_date']}")

            # 四柱
            pillars = chart['four_pillars']
            print(f"\n四柱八字:")
            print(f"  年柱: {pillars['year']['stem']}{pillars['year']['branch']} ({pillars['year']['stem_element']})")
            print(f"  月柱: {pillars['month']['stem']}{pillars['month']['branch']} ({pillars['month']['stem_element']})")
            print(f"  日柱: {pillars['day']['stem']}{pillars['day']['branch']} ({pillars['day']['stem_element']})")
            print(f"  时柱: {pillars['hour']['stem']}{pillars['hour']['branch']} ({pillars['hour']['stem_element']})")

            # 日主
            dm = chart['day_master']
            print(f"\n日主: {dm['stem']} ({dm['element']}, {dm['polarity']})")
            print(f"  {dm['description']}")

            # 五行
            print(f"\n五行分布:")
            for elem, count in chart['five_elements'].items():
                bar = "█" * count
                print(f"  {elem}: {bar} ({count})")

            # 十神
            if chart['ten_gods']:
                print(f"\n十神:")
                for tg in chart['ten_gods']:
                    print(f"  {tg['pillar']}柱: {tg['name']} ({tg['stem']})")

            # 格局
            print(f"\n格局: {chart['pattern']['name']}")
            print(f"  {chart['pattern']['description']}")

        print("\n✅ Bazi 测试通过!")
        return True

    except Exception as e:
        print(f"\n❌ Bazi 测试失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def test_accuracy():
    """验证计算准确性"""
    print("\n" + "="*60)
    print("测试 3: 计算准确性验证")
    print("="*60)

    try:
        from skills.zodiac.services import calculate_zodiac
        from skills.bazi.services import calculate_bazi

        # 已知数据验证
        # 1990-05-15 08:30 上海
        # 太阳应该在金牛座 (4月20日-5月20日)
        chart = calculate_zodiac("1990-05-15", "08:30", "Shanghai")

        print("\n验证 1990-05-15 08:30 上海:")
        print(f"  太阳星座: {chart['sun_sign']} (预期: taurus)")
        assert chart['sun_sign'] == 'taurus', f"太阳星座错误: {chart['sun_sign']}"
        print("  ✅ 太阳星座正确")

        # 验证八字
        bazi = calculate_bazi("1990-05-15", "08:30", "male")
        print(f"\n验证八字 1990-05-15 08:30:")
        print(f"  年柱: {bazi['four_pillars']['year']['stem']}{bazi['four_pillars']['year']['branch']}")
        # 1990年是庚午年
        assert bazi['four_pillars']['year']['stem'] == '庚', "年干错误"
        assert bazi['four_pillars']['year']['branch'] == '午', "年支错误"
        print("  ✅ 年柱正确 (庚午)")

        print("\n✅ 准确性验证通过!")
        return True

    except AssertionError as e:
        print(f"\n❌ 准确性验证失败: {e}")
        return False
    except Exception as e:
        print(f"\n❌ 准确性验证出错: {e}")
        import traceback
        traceback.print_exc()
        return False


def test_synastry():
    """测试合盘分析"""
    print("\n" + "="*60)
    print("测试 4: Synastry 合盘分析")
    print("="*60)

    try:
        from skills.zodiac.services import ZodiacCalculator

        calculator = ZodiacCalculator()

        # 计算两个人的星盘
        chart1 = calculator.calculate("1990-05-15", "08:30", "Shanghai")
        chart2 = calculator.calculate("1992-08-20", "14:00", "Beijing")

        print(f"\n人物1: 太阳{chart1.sun_sign}, 月亮{chart1.moon_sign}")
        print(f"人物2: 太阳{chart2.sun_sign}, 月亮{chart2.moon_sign}")

        # 导入合盘计算函数 (v6.8 moved to skills/zodiac/services/api.py)
        from skills.zodiac.services.api import _calculate_compatibility

        compat = _calculate_compatibility(chart1, chart2)

        print(f"\n合盘结果:")
        print(f"  总体评分: {compat['overallScore']}")
        print(f"  分类评分:")
        for cat in compat['categories']:
            print(f"    {cat['name']}: {cat['score']} - {cat['description']}")
        print(f"  优势: {', '.join(compat['strengths'])}")
        print(f"  挑战: {', '.join(compat['challenges'])}")
        print(f"  建议: {compat['advice']}")

        print("\n✅ Synastry 测试通过!")
        return True

    except Exception as e:
        print(f"\n❌ Synastry 测试失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def main():
    """运行所有测试"""
    print("="*60)
    print("VibeLife 星盘/八字 全面测试")
    print("="*60)

    results = []

    # 运行测试
    results.append(("Zodiac 星盘计算", test_zodiac()))
    results.append(("Bazi 八字计算", test_bazi()))
    results.append(("计算准确性验证", test_accuracy()))
    results.append(("Synastry 合盘分析", test_synastry()))

    # 汇总结果
    print("\n" + "="*60)
    print("测试结果汇总")
    print("="*60)

    passed = 0
    failed = 0
    for name, result in results:
        status = "✅ 通过" if result else "❌ 失败"
        print(f"  {name}: {status}")
        if result:
            passed += 1
        else:
            failed += 1

    print(f"\n总计: {passed} 通过, {failed} 失败")

    return failed == 0


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
