/**
 * useVibeChat Hook Tests
 */

import { describe, it, expect, vi, beforeEach, Mock } from "vitest";
import { renderHook, act, waitFor } from "@testing-library/react";
import { useVibeChat, type SkillId, type VoiceMode } from "@/hooks/useVibeChat";

// Mock the useChat hook from @ai-sdk/react
const mockUseChat = vi.fn();
vi.mock("@ai-sdk/react", () => ({
  useChat: (options: any) => mockUseChat(options),
}));

// Mock DefaultChatTransport
vi.mock("ai", () => ({
  DefaultChatTransport: vi.fn().mockImplementation((config) => ({
    ...config,
    type: "DefaultChatTransport",
  })),
}));

// Mock getTokens
vi.mock("@/lib/api", () => ({
  getTokens: () => ({ accessToken: "test-token" }),
}));

describe("useVibeChat", () => {
  const mockMessages: any[] = [];
  const mockSendMessage = vi.fn();
  const mockSetMessages = vi.fn();
  const mockStop = vi.fn();
  const mockClearError = vi.fn();
  const mockRegenerate = vi.fn();
  const mockAddToolResult = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();

    mockUseChat.mockReturnValue({
      messages: mockMessages,
      status: "ready",
      error: null,
      sendMessage: mockSendMessage,
      setMessages: mockSetMessages,
      stop: mockStop,
      clearError: mockClearError,
      regenerate: mockRegenerate,
      addToolResult: mockAddToolResult,
    });
  });

  describe("Initialization", () => {
    it("should initialize with correct default values", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(result.current.messages).toEqual([]);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
      expect(result.current.skillId).toBe("bazi");
      expect(result.current.voiceMode).toBe("warm");
    });

    it("should accept custom voiceMode", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "zodiac",
          voiceMode: "sarcastic",
        })
      );

      expect(result.current.voiceMode).toBe("sarcastic");
    });

    it("should accept conversationId", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
          conversationId: "test-conv-123",
        })
      );

      expect(result.current.conversationId).toBe("test-conv-123");
    });
  });

  describe("sendMessage", () => {
    it("should call sendMessage with text content", async () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      await act(async () => {
        await result.current.sendMessage("Hello, can you help me?");
      });

      expect(mockSendMessage).toHaveBeenCalledWith({ text: "Hello, can you help me?" });
    });
  });

  describe("sendQuickPrompt", () => {
    it("should clear messages before sending", async () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      await act(async () => {
        await result.current.sendQuickPrompt("帮我看看我的八字");
      });

      expect(mockSetMessages).toHaveBeenCalledWith([]);
      expect(mockSendMessage).toHaveBeenCalledWith({ text: "帮我看看我的八字" });
    });
  });

  describe("isLoading state", () => {
    it("should be true when status is submitted", () => {
      mockUseChat.mockReturnValue({
        ...mockUseChat.mock.results[0]?.value,
        status: "submitted",
      });

      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(result.current.isLoading).toBe(true);
    });

    it("should be true when status is streaming", () => {
      mockUseChat.mockReturnValue({
        ...mockUseChat.mock.results[0]?.value,
        status: "streaming",
      });

      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(result.current.isLoading).toBe(true);
    });

    it("should be false when status is ready", () => {
      mockUseChat.mockReturnValue({
        ...mockUseChat.mock.results[0]?.value,
        status: "ready",
      });

      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(result.current.isLoading).toBe(false);
    });
  });

  describe("Error handling", () => {
    it("should expose error from useChat", () => {
      const testError = new Error("Test error");
      mockUseChat.mockReturnValue({
        ...mockUseChat.mock.results[0]?.value,
        error: testError,
      });

      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(result.current.error).toBe(testError);
    });

    it("should call onError callback on error", () => {
      const onError = vi.fn();

      // Capture the onError callback passed to useChat
      mockUseChat.mockImplementation((options: any) => {
        // Simulate an error
        setTimeout(() => {
          options.onError?.(new Error("Test error"));
        }, 0);
        return {
          messages: [],
          status: "ready",
          error: null,
          sendMessage: mockSendMessage,
          setMessages: mockSetMessages,
          stop: mockStop,
          clearError: mockClearError,
          regenerate: mockRegenerate,
          addToolResult: mockAddToolResult,
        };
      });

      renderHook(() =>
        useVibeChat({
          skillId: "bazi",
          onError,
        })
      );

      // The onError would be called asynchronously
    });
  });

  describe("Tool handling", () => {
    it("should provide addToolResult function", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(typeof result.current.addToolResult).toBe("function");
    });

    it("should call addToolResult with correct params", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      act(() => {
        result.current.addToolResult("tool-123", "show_bazi_chart", { data: "test" });
      });

      expect(mockAddToolResult).toHaveBeenCalledWith({
        toolCallId: "tool-123",
        tool: "show_bazi_chart",
        output: { data: "test" },
      });
    });

    it("should provide approveToolCall function", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(typeof result.current.approveToolCall).toBe("function");
    });

    it("should approve tool call with positive result", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      act(() => {
        result.current.approveToolCall("tool-123", true, "show_bazi_chart", { approved: true });
      });

      expect(mockAddToolResult).toHaveBeenCalledWith({
        toolCallId: "tool-123",
        tool: "show_bazi_chart",
        output: { approved: true },
      });
    });

    it("should reject tool call with error", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      act(() => {
        result.current.approveToolCall("tool-123", false, "show_bazi_chart");
      });

      expect(mockAddToolResult).toHaveBeenCalledWith({
        toolCallId: "tool-123",
        tool: "show_bazi_chart",
        state: "output-error",
        errorText: "用户已取消操作",
      });
    });
  });

  describe("Control actions", () => {
    it("should provide stop function", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(typeof result.current.stop).toBe("function");

      act(() => {
        result.current.stop();
      });

      expect(mockStop).toHaveBeenCalled();
    });

    it("should provide clearError function", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(typeof result.current.clearError).toBe("function");

      act(() => {
        result.current.clearError();
      });

      expect(mockClearError).toHaveBeenCalled();
    });

    it("should provide setMessages function", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(typeof result.current.setMessages).toBe("function");

      const newMessages: any[] = [{ id: "1", role: "user", content: "test" }];
      act(() => {
        result.current.setMessages(newMessages);
      });

      expect(mockSetMessages).toHaveBeenCalledWith(newMessages);
    });

    it("should provide regenerate function", () => {
      const { result } = renderHook(() =>
        useVibeChat({
          skillId: "bazi",
        })
      );

      expect(typeof result.current.regenerate).toBe("function");

      act(() => {
        result.current.regenerate();
      });

      expect(mockRegenerate).toHaveBeenCalled();
    });
  });

  describe("Skill types", () => {
    const skills: SkillId[] = ["bazi", "zodiac", "mbti", "tarot", "attach", "career"];

    skills.forEach((skill) => {
      it(`should work with skill: ${skill}`, () => {
        const { result } = renderHook(() =>
          useVibeChat({
            skillId: skill,
          })
        );

        expect(result.current.skillId).toBe(skill);
      });
    });
  });

  describe("Voice modes", () => {
    const voiceModes: VoiceMode[] = ["warm", "sarcastic"];

    voiceModes.forEach((mode) => {
      it(`should work with voice mode: ${mode}`, () => {
        const { result } = renderHook(() =>
          useVibeChat({
            skillId: "bazi",
            voiceMode: mode,
          })
        );

        expect(result.current.voiceMode).toBe(mode);
      });
    });
  });
});
