"""
Synastry Engine - 合盘计算引擎

轻度融合架构：各 Skill 独立计算，最后 AI 综合解读

支持的维度：
- zodiac: 星座合盘
- bazi: 八字合婚
- jungastro: 荣格关系分析
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)


@dataclass
class SynastryDimensionResult:
    """单个维度的合盘结果"""
    skill_id: str
    score: int
    summary: str
    data: dict


@dataclass
class SynastryResult:
    """完整合盘结果"""
    person1: dict
    person2: dict
    relationship_type: str
    overall_score: int
    dimensions: List[SynastryDimensionResult]
    calculated_at: datetime


class SynastryEngine:
    """
    合盘计算引擎

    设计原则：
    1. 各 Skill 独立计算，互不依赖
    2. 综合评分取加权平均
    3. AI 综合解读由 LLM 在对话中生成
    """

    async def calculate(
        self,
        user_profile: dict,
        partner_birth_info: dict,
        relationship_type: str,
        subscribed_skills: List[str]
    ) -> SynastryResult:
        """
        计算合盘

        Args:
            user_profile: 用户完整 Profile（包含 skills 数据）
            partner_birth_info: 对方出生信息 {date, time, place, timezone}
            relationship_type: 关系类型
            subscribed_skills: 用户已订阅的 Skill 列表

        Returns:
            SynastryResult: 完整合盘结果
        """
        dimensions = []
        total_score = 0
        skill_count = 0

        # 1. 星座合盘
        if "zodiac" in subscribed_skills:
            user_zodiac = user_profile.get("skills", {}).get("zodiac", {})
            if user_zodiac.get("chart"):
                try:
                    result = await self._calc_zodiac_synastry(
                        user_zodiac["chart"],
                        partner_birth_info,
                        relationship_type
                    )
                    dimensions.append(result)
                    total_score += result.score
                    skill_count += 1
                except Exception as e:
                    logger.error(f"星座合盘计算失败: {e}")

        # 2. 八字合婚
        if "bazi" in subscribed_skills:
            user_bazi = user_profile.get("skills", {}).get("bazi", {})
            if user_bazi.get("chart"):
                try:
                    result = await self._calc_bazi_synastry(
                        user_bazi["chart"],
                        partner_birth_info,
                        relationship_type
                    )
                    dimensions.append(result)
                    total_score += result.score
                    skill_count += 1
                except Exception as e:
                    logger.error(f"八字合婚计算失败: {e}")

        # 3. 荣格关系分析
        if "jungastro" in subscribed_skills:
            user_jungastro = user_profile.get("skills", {}).get("jungastro", {})
            if user_jungastro:
                try:
                    result = await self._calc_jungastro_synastry(
                        user_jungastro,
                        partner_birth_info,
                        relationship_type
                    )
                    dimensions.append(result)
                    total_score += result.score
                    skill_count += 1
                except Exception as e:
                    logger.error(f"荣格关系分析失败: {e}")

        # 4. 计算综合评分
        overall_score = round(total_score / skill_count) if skill_count > 0 else 50

        return SynastryResult(
            person1=self._extract_person_summary(user_profile),
            person2={"name": "TA", "birth_info": partner_birth_info},
            relationship_type=relationship_type,
            overall_score=overall_score,
            dimensions=dimensions,
            calculated_at=datetime.utcnow()
        )

    async def _calc_zodiac_synastry(
        self,
        user_chart: dict,
        partner_birth_info: dict,
        relationship_type: str
    ) -> SynastryDimensionResult:
        """
        计算星座合盘

        TODO: 集成现有的 zodiac synastry 计算逻辑
        """
        # 暂时返回模拟数据，后续集成真实计算
        from skills.zodiac.services.api import calculate_zodiac_chart

        # 计算对方星盘
        partner_chart = await calculate_zodiac_chart(partner_birth_info)

        # 简化版合盘计算
        user_sun = user_chart.get("sun_sign", "")
        partner_sun = partner_chart.get("sun_sign", "") if partner_chart else ""

        # 基于元素的简单兼容性计算
        score = self._calc_element_compatibility(user_sun, partner_sun)

        return SynastryDimensionResult(
            skill_id="zodiac",
            score=score,
            summary=f"太阳{user_sun} × 太阳{partner_sun}",
            data={
                "person1": {
                    "sunSign": user_chart.get("sun_sign"),
                    "moonSign": user_chart.get("moon_sign"),
                    "risingSign": user_chart.get("rising_sign"),
                },
                "person2": {
                    "sunSign": partner_chart.get("sun_sign") if partner_chart else None,
                    "moonSign": partner_chart.get("moon_sign") if partner_chart else None,
                    "risingSign": partner_chart.get("rising_sign") if partner_chart else None,
                },
                "compatibility": {
                    "overall": score,
                    "emotional": score + 5 if score < 95 else 100,
                    "communication": score - 5 if score > 5 else 0,
                    "passion": score,
                    "stability": score
                }
            }
        )

    async def _calc_bazi_synastry(
        self,
        user_chart: dict,
        partner_birth_info: dict,
        relationship_type: str
    ) -> SynastryDimensionResult:
        """
        计算八字合婚

        TODO: 集成真实的八字合婚算法
        """
        from skills.bazi.services.api import calculate_bazi_chart

        # 计算对方八字
        partner_chart = await calculate_bazi_chart(partner_birth_info)

        # 获取日主
        user_day_master = user_chart.get("day_master", {})
        partner_day_master = partner_chart.get("day_master", {}) if partner_chart else {}

        # 简化版日主关系计算
        score = self._calc_day_master_compatibility(
            user_day_master.get("stem", ""),
            partner_day_master.get("stem", "")
        )

        return SynastryDimensionResult(
            skill_id="bazi",
            score=score,
            summary=f"日主{user_day_master.get('stem', '?')} × {partner_day_master.get('stem', '?')}",
            data={
                "person1": {
                    "dayMaster": user_day_master,
                    "fourPillars": user_chart.get("four_pillars", {})
                },
                "person2": {
                    "dayMaster": partner_day_master,
                    "fourPillars": partner_chart.get("four_pillars", {}) if partner_chart else {}
                },
                "compatibility": {
                    "overall": score,
                    "dayMasterHarmony": score,
                    "fiveElementBalance": score - 3 if score > 3 else 0,
                    "tenGodInteraction": score + 3 if score < 97 else 100
                }
            }
        )

    async def _calc_jungastro_synastry(
        self,
        user_jungastro: dict,
        partner_birth_info: dict,
        relationship_type: str
    ) -> SynastryDimensionResult:
        """
        计算荣格关系分析

        基于用户的心理画像推导关系动力
        """
        # 从用户的荣格画像提取依附风格
        attachment_style = user_jungastro.get("attachment_style", "secure")

        # 根据关系类型调整分析重点
        analysis_focus = self._get_jungastro_focus(relationship_type)

        # 简化版计算
        base_score = 70
        if attachment_style == "secure":
            base_score += 10
        elif attachment_style == "anxious":
            base_score -= 5
        elif attachment_style == "avoidant":
            base_score -= 5

        return SynastryDimensionResult(
            skill_id="jungastro",
            score=base_score,
            summary=f"依附风格: {self._get_attachment_label(attachment_style)}",
            data={
                "attachmentStyle": {
                    "type": attachment_style,
                    "description": self._get_attachment_description(attachment_style),
                    "strengths": self._get_attachment_strengths(attachment_style),
                    "challenges": self._get_attachment_challenges(attachment_style)
                },
                "relationshipPatterns": [],
                "growthOpportunities": analysis_focus.get("growth_opportunities", [])
            }
        )

    def _extract_person_summary(self, profile: dict) -> dict:
        """提取用户摘要信息"""
        return {
            "name": profile.get("account", {}).get("display_name", "你"),
            "birth_info": profile.get("identity", {}).get("birth_info", {})
        }

    def _calc_element_compatibility(self, sign1: str, sign2: str) -> int:
        """基于星座元素计算兼容性"""
        fire_signs = ["白羊座", "狮子座", "射手座", "Aries", "Leo", "Sagittarius"]
        earth_signs = ["金牛座", "处女座", "摩羯座", "Taurus", "Virgo", "Capricorn"]
        air_signs = ["双子座", "天秤座", "水瓶座", "Gemini", "Libra", "Aquarius"]
        water_signs = ["巨蟹座", "天蝎座", "双鱼座", "Cancer", "Scorpio", "Pisces"]

        def get_element(sign):
            if sign in fire_signs:
                return "fire"
            elif sign in earth_signs:
                return "earth"
            elif sign in air_signs:
                return "air"
            elif sign in water_signs:
                return "water"
            return "unknown"

        elem1 = get_element(sign1)
        elem2 = get_element(sign2)

        # 元素兼容性矩阵
        compatibility = {
            ("fire", "fire"): 85,
            ("fire", "air"): 90,
            ("fire", "earth"): 60,
            ("fire", "water"): 50,
            ("earth", "earth"): 80,
            ("earth", "water"): 85,
            ("earth", "air"): 55,
            ("air", "air"): 75,
            ("air", "water"): 60,
            ("water", "water"): 90,
        }

        key = (elem1, elem2) if (elem1, elem2) in compatibility else (elem2, elem1)
        return compatibility.get(key, 70)

    def _calc_day_master_compatibility(self, stem1: str, stem2: str) -> int:
        """计算日主兼容性"""
        # 简化版：基于五行生克
        element_map = {
            "甲": "木", "乙": "木",
            "丙": "火", "丁": "火",
            "戊": "土", "己": "土",
            "庚": "金", "辛": "金",
            "壬": "水", "癸": "水"
        }

        elem1 = element_map.get(stem1, "")
        elem2 = element_map.get(stem2, "")

        if not elem1 or not elem2:
            return 70

        # 相生关系
        generates = {
            "木": "火", "火": "土", "土": "金", "金": "水", "水": "木"
        }

        if generates.get(elem1) == elem2 or generates.get(elem2) == elem1:
            return 85  # 相生

        # 相克关系
        overcomes = {
            "木": "土", "土": "水", "水": "火", "火": "金", "金": "木"
        }

        if overcomes.get(elem1) == elem2 or overcomes.get(elem2) == elem1:
            return 55  # 相克

        if elem1 == elem2:
            return 75  # 比肩

        return 70  # 其他

    def _get_jungastro_focus(self, relationship_type: str) -> dict:
        """获取荣格分析的关注重点"""
        focuses = {
            "romantic": {
                "emphasis": ["passion", "emotional", "projection"],
                "growth_opportunities": [
                    "通过关系看见自己的阴影",
                    "学习在亲密中保持自我",
                    "共同成长的可能性"
                ]
            },
            "parent_child": {
                "emphasis": ["communication", "understanding", "growth"],
                "growth_opportunities": [
                    "理解彼此的心理需求",
                    "找到有效的沟通方式",
                    "支持彼此的个性化发展"
                ]
            },
            "business": {
                "emphasis": ["trust", "complementary", "decision"],
                "growth_opportunities": [
                    "利用互补的心理特质",
                    "建立有效的决策模式",
                    "在合作中相互学习"
                ]
            }
        }
        return focuses.get(relationship_type, focuses["romantic"])

    def _get_attachment_label(self, style: str) -> str:
        """获取依附风格标签"""
        labels = {
            "secure": "安全型",
            "anxious": "焦虑型",
            "avoidant": "回避型",
            "disorganized": "混乱型"
        }
        return labels.get(style, style)

    def _get_attachment_description(self, style: str) -> str:
        """获取依附风格描述"""
        descriptions = {
            "secure": "你在关系中感到舒适，能够既依赖他人也让他人依赖你",
            "anxious": "你渴望亲密关系，但有时会担心对方不够爱你",
            "avoidant": "你重视独立，有时会在关系中保持一定距离",
            "disorganized": "你对亲密关系有矛盾的感受"
        }
        return descriptions.get(style, "")

    def _get_attachment_strengths(self, style: str) -> List[str]:
        """获取依附风格优势"""
        strengths = {
            "secure": ["情绪稳定", "善于沟通", "信任他人"],
            "anxious": ["深情投入", "敏感细腻", "重视关系"],
            "avoidant": ["独立自主", "理性冷静", "不易受伤"],
            "disorganized": ["适应力强", "深度敏感", "理解复杂性"]
        }
        return strengths.get(style, [])

    def _get_attachment_challenges(self, style: str) -> List[str]:
        """获取依附风格挑战"""
        challenges = {
            "secure": ["可能忽视关系中的问题"],
            "anxious": ["容易过度担心", "需要更多安全感"],
            "avoidant": ["亲密关系中可能退缩", "表达情感困难"],
            "disorganized": ["关系模式不稳定", "需要更多自我了解"]
        }
        return challenges.get(style, [])
