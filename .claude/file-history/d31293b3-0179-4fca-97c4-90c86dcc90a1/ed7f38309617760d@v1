/**
 * DimensionRadar - 单维度 12 原型雷达图
 *
 * v7.0 新增: 用于展示单个维度 (Core/Inner/Outer/Shadow) 的 12 原型得分
 */

'use client'

import { useMemo } from 'react'
import { cn } from '@/lib/utils'
import {
  type ArchetypeType,
  type ArchetypeScores,
  type DimensionId,
  ARCHETYPE_META,
  DIMENSION_META,
  getArchetypeColor,
} from '@/types/vibe-id'

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

interface DimensionRadarProps {
  /** 维度 ID */
  dimension: DimensionId
  /** 该维度的 12 原型得分 */
  scores: ArchetypeScores
  /** 主原型（高亮显示） */
  primaryArchetype?: ArchetypeType
  /** 尺寸 */
  size?: number
  /** 是否显示标签 */
  showLabels?: boolean
  /** 是否显示得分 */
  showScores?: boolean
  /** 是否显示标题 */
  showTitle?: boolean
  /** 自定义类名 */
  className?: string
}

// ═══════════════════════════════════════════════════════════════════════════
// Constants
// ═══════════════════════════════════════════════════════════════════════════

const ARCHETYPES_ORDER: ArchetypeType[] = [
  'Hero', 'Ruler', 'Sage', 'Caregiver',
  'Creator', 'Outlaw', 'Magician', 'Lover',
  'Jester', 'Regular', 'Innocent', 'Explorer',
]

// 维度特定颜色
const DIMENSION_COLORS: Record<DimensionId, string> = {
  core: 'var(--accent)',
  inner: '#E91E63',  // 粉色 - 情感
  outer: '#FF9800',  // 橙色 - 外向
  shadow: '#9E9E9E', // 灰色 - 阴影
}

// ═══════════════════════════════════════════════════════════════════════════
// Helper Functions
// ═══════════════════════════════════════════════════════════════════════════

function polarToCartesian(
  centerX: number,
  centerY: number,
  radius: number,
  angleInDegrees: number
): { x: number; y: number } {
  const angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180
  return {
    x: Math.round((centerX + radius * Math.cos(angleInRadians)) * 100) / 100,
    y: Math.round((centerY + radius * Math.sin(angleInRadians)) * 100) / 100,
  }
}

function getPolygonPoints(
  scores: ArchetypeScores,
  center: number,
  maxRadius: number
): string {
  return ARCHETYPES_ORDER.map((archetype, index) => {
    const angle = (360 / 12) * index
    const score = scores[archetype] || 0
    const radius = (score / 100) * maxRadius
    const { x, y } = polarToCartesian(center, center, radius, angle)
    return `${x},${y}`
  }).join(' ')
}

// ═══════════════════════════════════════════════════════════════════════════
// Main Component
// ═══════════════════════════════════════════════════════════════════════════

export function DimensionRadar({
  dimension,
  scores,
  primaryArchetype,
  size = 200,
  showLabels = true,
  showScores = false,
  showTitle = true,
  className,
}: DimensionRadarProps) {
  const center = size / 2
  const maxRadius = size * 0.35
  const labelRadius = size * 0.45
  const dimensionMeta = DIMENSION_META[dimension]
  const dimensionColor = DIMENSION_COLORS[dimension]

  const polygonPoints = useMemo(
    () => getPolygonPoints(scores, center, maxRadius),
    [scores, center, maxRadius]
  )

  const gridLevels = [25, 50, 75, 100]

  return (
    <div className={cn('flex flex-col items-center', className)}>
      {/* Title */}
      {showTitle && (
        <div className="flex items-center gap-1.5 mb-2">
          <span className="text-lg">{dimensionMeta.icon}</span>
          <span className="text-sm font-medium text-ink-700">{dimensionMeta.label}</span>
          <span className="text-xs text-ink-400">/ {dimensionMeta.nameEn}</span>
        </div>
      )}

      <svg
        width={size}
        height={size}
        viewBox={`0 0 ${size} ${size}`}
        className="overflow-visible"
      >
        {/* 背景网格 */}
        <g className="grid-lines">
          {gridLevels.map((level) => {
            const radius = (level / 100) * maxRadius
            const points = ARCHETYPES_ORDER.map((_, index) => {
              const angle = (360 / 12) * index
              const { x, y } = polarToCartesian(center, center, radius, angle)
              return `${x},${y}`
            }).join(' ')

            return (
              <polygon
                key={level}
                points={points}
                fill="none"
                stroke="var(--ink-200)"
                strokeWidth="1"
                opacity={0.4}
              />
            )
          })}

          {ARCHETYPES_ORDER.map((_, index) => {
            const angle = (360 / 12) * index
            const { x, y } = polarToCartesian(center, center, maxRadius, angle)
            return (
              <line
                key={index}
                x1={center}
                y1={center}
                x2={x}
                y2={y}
                stroke="var(--ink-200)"
                strokeWidth="1"
                opacity={0.25}
              />
            )
          })}
        </g>

        {/* 数据多边形 */}
        <polygon
          points={polygonPoints}
          fill={dimensionColor}
          fillOpacity={0.15}
          stroke={dimensionColor}
          strokeWidth="2"
          className="transition-all duration-300"
        />

        {/* 数据点 */}
        {ARCHETYPES_ORDER.map((archetype, index) => {
          const angle = (360 / 12) * index
          const score = scores[archetype] || 0
          const radius = (score / 100) * maxRadius
          const { x, y } = polarToCartesian(center, center, radius, angle)
          const isHighlighted = archetype === primaryArchetype
          const color = getArchetypeColor(archetype)

          return (
            <circle
              key={archetype}
              cx={x}
              cy={y}
              r={isHighlighted ? 5 : 3}
              fill={isHighlighted ? color : dimensionColor}
              stroke="white"
              strokeWidth="1.5"
              className="transition-all duration-200"
            />
          )
        })}

        {/* 标签 */}
        {showLabels &&
          ARCHETYPES_ORDER.map((archetype, index) => {
            const angle = (360 / 12) * index
            const { x, y } = polarToCartesian(center, center, labelRadius, angle)
            const meta = ARCHETYPE_META[archetype]
            const isHighlighted = archetype === primaryArchetype
            const score = scores[archetype] || 0

            return (
              <g key={archetype}>
                <text
                  x={x}
                  y={y - 4}
                  textAnchor="middle"
                  style={{ fontSize: isHighlighted ? '14px' : '11px' }}
                >
                  {meta.emoji}
                </text>

                {showScores && (
                  <text
                    x={x}
                    y={y + 10}
                    textAnchor="middle"
                    className={cn(
                      'fill-current',
                      isHighlighted ? 'text-ink-700 font-medium' : 'text-ink-400'
                    )}
                    style={{ fontSize: '9px' }}
                  >
                    {Math.round(score)}
                  </text>
                )}
              </g>
            )
          })}
      </svg>

      {/* Primary archetype label */}
      {primaryArchetype && (
        <div className="mt-2 text-center">
          <span className="text-sm text-ink-600">
            {ARCHETYPE_META[primaryArchetype].emoji} {ARCHETYPE_META[primaryArchetype].name}
          </span>
        </div>
      )}
    </div>
  )
}

export default DimensionRadar
