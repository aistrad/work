"""
融合引擎 - VibeID v7.0 (四维12原型完整版)

变更:
- v7.0: 四维完整12原型得分 (core/inner/outer/shadow 每个维度都有12原型得分)
- 返回 Dict 而非 dataclass
- 简化接口，支持 Optional 输入
- 保持配置驱动的融合算法

核心策略 (从配置加载):
- 八字权重: 70%
- 星座权重: 30%
- 一致性奖励: +15%
- 冲突处理: 以八字为准
"""

import logging
from typing import Dict, Any, Tuple, Optional, List

from ..models import BaziAnalysis, ZodiacAnalysis, Archetype
from .config_loader import get_config, get_archetype_metadata

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════════
# 原型一致性检查
# ═══════════════════════════════════════════════════════════════════════════════

def check_archetype_consistency(arch1: str, arch2: str) -> str:
    """
    检查两个原型的一致性

    Returns:
        "perfect_match" | "similar" | "neutral" | "conflict"
    """
    if arch1 == arch2:
        return "perfect_match"

    config = get_config()

    # 检查对立
    for pair_info in config.archetypes.opposing_pairs:
        if set([arch1, arch2]) == set(pair_info.pair):
            return "conflict"

    # 检查相近
    for group in config.archetypes.similar_groups:
        if arch1 in group and arch2 in group:
            return "similar"

    return "neutral"


def get_opposing_archetype(archetype: str) -> str:
    """获取对立原型"""
    config = get_config()

    for pair_info in config.archetypes.opposing_pairs:
        if archetype == pair_info.pair[0]:
            return pair_info.pair[1]
        if archetype == pair_info.pair[1]:
            return pair_info.pair[0]

    return "Regular"  # 默认


# ═══════════════════════════════════════════════════════════════════════════════
# 融合引擎
# ═══════════════════════════════════════════════════════════════════════════════

class FusionEngine:
    """
    八字主导融合引擎 v6.0

    返回 Dict 格式:
    {
        "archetypes": {
            "core": {"primary": str, "secondary": str, "confidence": str, "source": dict},
            "inner": {...},
            "outer": {...},
            "shadow": {...}
        },
        "scores": {archetype_id: float}  # 0-100
    }
    """

    def __init__(self):
        self._config = get_config()
        self._archetype_metadata = get_archetype_metadata()

    @property
    def fusion_config(self):
        return self._config.fusion

    @property
    def archetypes_config(self):
        return self._config.archetypes

    def fuse(
        self,
        bazi_analysis: Optional[BaziAnalysis],
        zodiac_analysis: Optional[ZodiacAnalysis],
        bazi_scores: Dict[str, float],
        zodiac_scores: Dict[str, float]
    ) -> Dict[str, Any]:
        """
        融合八字和星座分析结果

        Args:
            bazi_analysis: 八字分析结果 (可选)
            zodiac_analysis: 星盘分析结果 (可选)
            bazi_scores: 八字原型得分
            zodiac_scores: 星座原型得分

        Returns:
            {
                "archetypes": {core, inner, outer, shadow},
                "scores": {archetype_id: float}
            }
        """
        # 1. 计算 Core 原型
        core = self._calculate_core(bazi_analysis, zodiac_analysis)

        # 2. 计算 Inner 原型
        inner = self._calculate_inner(zodiac_analysis)

        # 3. 计算 Outer 原型
        outer = self._calculate_outer(zodiac_analysis)

        # 4. 计算 Shadow 原型
        shadow = self._calculate_shadow(core["primary"])

        # 5. 融合12原型得分
        bazi_primary = bazi_analysis.primary_archetype if bazi_analysis else None
        zodiac_primary = zodiac_analysis.primary_archetype if zodiac_analysis else None
        fused_scores = self._fuse_scores(
            bazi_scores, zodiac_scores,
            bazi_primary, zodiac_primary
        )

        return {
            "archetypes": {
                "core": core,
                "inner": inner,
                "outer": outer,
                "shadow": shadow,
            },
            "scores": fused_scores,
        }

    def _calculate_core(
        self,
        bazi_analysis: Optional[BaziAnalysis],
        zodiac_analysis: Optional[ZodiacAnalysis]
    ) -> Dict[str, Any]:
        """计算 Core 原型"""
        # 只有八字
        if bazi_analysis and not zodiac_analysis:
            return {
                "primary": bazi_analysis.primary_archetype,
                "secondary": bazi_analysis.secondary_archetype,
                "confidence": "high",
                "source": {
                    "bazi_contribution": bazi_analysis.primary_archetype,
                    "bazi_pattern": bazi_analysis.pattern,
                    "bazi_useful_god": bazi_analysis.useful_god,
                    "zodiac_contribution": None,
                    "consistency_type": "bazi_only",
                }
            }

        # 只有星座
        if zodiac_analysis and not bazi_analysis:
            return {
                "primary": zodiac_analysis.primary_archetype,
                "secondary": None,
                "confidence": "medium",
                "source": {
                    "bazi_contribution": None,
                    "zodiac_contribution": zodiac_analysis.primary_archetype,
                    "consistency_type": "zodiac_only",
                }
            }

        # 两者都有
        bazi_primary = bazi_analysis.primary_archetype
        bazi_secondary = bazi_analysis.secondary_archetype
        zodiac_primary = zodiac_analysis.primary_archetype

        # 检查一致性
        consistency = check_archetype_consistency(bazi_primary, zodiac_primary)

        # 确定最终原型
        if consistency == "perfect_match":
            primary = bazi_primary
            secondary = bazi_secondary
            confidence = "high"
        elif consistency == "conflict":
            primary = bazi_primary
            secondary = zodiac_primary
            confidence = "medium"
        else:
            primary = bazi_primary
            secondary = bazi_secondary or zodiac_primary
            confidence = "high" if consistency == "similar" else "medium"

        return {
            "primary": primary,
            "secondary": secondary,
            "confidence": confidence,
            "source": {
                "bazi_contribution": bazi_primary,
                "bazi_pattern": bazi_analysis.pattern,
                "bazi_useful_god": bazi_analysis.useful_god,
                "zodiac_contribution": zodiac_primary,
                "consistency_type": consistency,
            }
        }

    def _calculate_inner(self, zodiac_analysis: Optional[ZodiacAnalysis]) -> Dict[str, Any]:
        """计算 Inner 原型 (月亮 + 金星)"""
        defaults = self._config.zodiac.defaults

        if not zodiac_analysis:
            return {
                "primary": defaults.inner_archetype,
                "secondary": None,
                "confidence": "low",
                "source": {"method": "default"}
            }

        inner_archetype = zodiac_analysis.inner_archetype
        has_moon = bool(zodiac_analysis.moon_sign)
        has_venus = bool(zodiac_analysis.venus_sign)

        if has_moon and has_venus:
            confidence = "high"
        elif has_moon:
            confidence = "medium"
        else:
            confidence = "low"

        return {
            "primary": inner_archetype or defaults.inner_archetype,
            "secondary": None,
            "confidence": confidence,
            "source": {
                "moon_sign": zodiac_analysis.moon_sign,
                "venus_sign": zodiac_analysis.venus_sign,
            }
        }

    def _calculate_outer(self, zodiac_analysis: Optional[ZodiacAnalysis]) -> Dict[str, Any]:
        """计算 Outer 原型 (上升 + 火星)"""
        defaults = self._config.zodiac.defaults

        if not zodiac_analysis:
            return {
                "primary": defaults.outer_archetype,
                "secondary": None,
                "confidence": "low",
                "source": {"method": "default"}
            }

        outer_archetype = zodiac_analysis.outer_archetype
        has_rising = bool(zodiac_analysis.rising_sign)
        has_mars = bool(zodiac_analysis.mars_sign)

        if has_rising and has_mars:
            confidence = "high"
        elif has_rising:
            confidence = "medium"
        else:
            confidence = "low"

        return {
            "primary": outer_archetype or defaults.outer_archetype,
            "secondary": None,
            "confidence": confidence,
            "source": {
                "rising_sign": zodiac_analysis.rising_sign,
                "mars_sign": zodiac_analysis.mars_sign,
            }
        }

    def _calculate_shadow(self, core_primary: str) -> Dict[str, Any]:
        """计算 Shadow 原型 (Core 的对立面)"""
        shadow_archetype = get_opposing_archetype(core_primary)
        shadow_info = self._archetype_metadata.get_shadow(core_primary)
        tension = shadow_info[1] if shadow_info else ""

        return {
            "primary": shadow_archetype,
            "secondary": None,
            "confidence": "low",
            "source": {
                "derived_from": core_primary,
                "method": "opposing_archetype",
                "tension": tension,
                "user_confirmed": False,
            }
        }

    def _fuse_scores(
        self,
        bazi_scores: Dict[str, float],
        zodiac_scores: Dict[str, float],
        bazi_primary: Optional[str],
        zodiac_primary: Optional[str]
    ) -> Dict[str, float]:
        """融合12原型得分"""
        fused = {}
        weights = self.fusion_config.weights
        consistency = self.fusion_config.consistency

        for archetype in Archetype:
            arch_name = archetype.value
            bazi_score = bazi_scores.get(arch_name, 0.0)
            zodiac_score = zodiac_scores.get(arch_name, 0.0)

            # 基础融合
            base_score = (
                bazi_score * weights.bazi +
                zodiac_score * weights.zodiac
            )

            # 一致性奖励
            if bazi_primary and zodiac_primary:
                if arch_name == bazi_primary and arch_name == zodiac_primary:
                    base_score += consistency.bonus

            fused[arch_name] = base_score

        # 归一化到 0-100
        max_score = max(fused.values()) if fused else 1.0
        if max_score > 0:
            for arch in fused:
                fused[arch] = round((fused[arch] / max_score) * 100, 1)

        return fused


# ════════════════════════════════════════════════��══════════════════════════════
# 原型计算器
# ═══════════════════════════════════════════════════════════════════════════════

class ArchetypeCalculator:
    """原型得分计算器"""

    def __init__(self):
        self._config = get_config()

    @property
    def fusion_config(self):
        return self._config.fusion

    @property
    def archetypes_config(self):
        return self._config.archetypes

    def calculate_bazi_scores(self, bazi_analysis: BaziAnalysis) -> Dict[str, float]:
        """计算八字原型得分"""
        scores = {arch.value: 0.0 for arch in Archetype}

        if bazi_analysis.primary_archetype:
            scores[bazi_analysis.primary_archetype] = 1.0

        if bazi_analysis.secondary_archetype:
            scores[bazi_analysis.secondary_archetype] = 0.5

        scores = self._apply_strength_modifier(
            scores,
            bazi_analysis.day_master_strength_score
        )

        return scores

    def _apply_strength_modifier(
        self,
        scores: Dict[str, float],
        strength_score: float
    ) -> Dict[str, float]:
        """日主强弱修正"""
        categories = self.archetypes_config.categories
        extrovert_archetypes = set(categories.extrovert)
        introvert_archetypes = set(categories.introvert)
        coefficient = self.fusion_config.strength_modifier.coefficient

        if strength_score > 0:  # 身旺
            modifier = 1 + strength_score * coefficient
            for archetype in extrovert_archetypes:
                if archetype in scores:
                    scores[archetype] *= modifier
        else:  # 身弱
            modifier = 1 + abs(strength_score) * coefficient
            for archetype in introvert_archetypes:
                if archetype in scores:
                    scores[archetype] *= modifier

        return scores


# ═══════════════════════════════════��═══════════════════════════════════════════
# 导出
# ═══════════════════════════════════════════════════════════════════════════════

__all__ = [
    "FusionEngine",
    "ArchetypeCalculator",
    "check_archetype_consistency",
    "get_opposing_archetype",
]
