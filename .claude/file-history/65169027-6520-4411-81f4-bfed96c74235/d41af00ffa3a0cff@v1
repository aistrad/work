"""
VibeLife Subscription Service
订阅管理服务 - 支持双轨制 (payment-design v2.0)
"""

from datetime import datetime, timedelta
from typing import Optional
from pydantic import BaseModel
from enum import Enum
try:  # optional in test mode
    import asyncpg  # type: ignore
except Exception:  # pragma: no cover
    asyncpg = None  # type: ignore
import json
import logging

from .stripe_service import StripeService

logger = logging.getLogger(__name__)


class SubscriptionTier(str, Enum):
    FREE = "free"
    PAID = "paid"


class SubscriptionStatus(str, Enum):
    ACTIVE = "active"
    TRIALING = "trialing"
    PAST_DUE = "past_due"
    CANCELED = "canceled"
    EXPIRED = "expired"
    SUSPENDED = "suspended"


class VipType(str, Enum):
    """双轨制类型"""
    PREPAID = "prepaid"      # 预付（大陆/香港）
    SUBSCRIPTION = "subscription"  # 订阅（海外）


class SubscriptionPlan(BaseModel):
    """订阅计划"""
    id: str
    name: str
    plan_type: SubscriptionTier
    skill_ids: list[str]
    price_monthly: int  # 分
    price_yearly: int   # 分
    currency: str = "CNY"
    features: list[str]
    is_active: bool = True


class UserSubscription(BaseModel):
    """用户订阅"""
    id: str
    user_id: str
    plan_id: str
    status: SubscriptionStatus
    started_at: datetime
    current_period_end: Optional[datetime] = None
    cancelled_at: Optional[datetime] = None
    payment_provider: str = "stripe"
    payment_subscription_id: Optional[str] = None
    # 双轨制字段
    vip_type: VipType = VipType.SUBSCRIPTION
    region: str = "GLOBAL"
    stripe_customer_id: Optional[str] = None
    payment_failed_count: int = 0


# 预定义订阅计划 - 两档制
SUBSCRIPTION_PLANS = [
    SubscriptionPlan(
        id="free",
        name="免费版",
        plan_type=SubscriptionTier.FREE,
        skill_ids=[],
        price_monthly=0,
        price_yearly=0,
        features=["每天3次对话", "基础功能"]
    ),
    SubscriptionPlan(
        id="paid",
        name="付费会员",
        plan_type=SubscriptionTier.PAID,
        skill_ids=["bazi", "zodiac", "mbti"],
        price_monthly=2990,  # ¥29.9
        price_yearly=29900,  # ¥299
        features=["每天30次对话", "所有功能"]
    ),
]


class SubscriptionService:
    """订阅管理服务"""

    def __init__(self, db_pool: asyncpg.Pool, stripe: StripeService = None):
        self.db = db_pool
        self.stripe = stripe or StripeService()

    async def get_all_plans(self) -> list[SubscriptionPlan]:
        """获取所有订阅计划"""
        return SUBSCRIPTION_PLANS

    async def get_plan(self, plan_id: str) -> Optional[SubscriptionPlan]:
        """获取指定订阅计划"""
        for plan in SUBSCRIPTION_PLANS:
            if plan.id == plan_id:
                return plan
        return None

    async def get_user_subscription(self, user_id: str) -> Optional[UserSubscription]:
        """获取用户当前订阅"""
        row = await self.db.fetchrow("""
            SELECT id, user_id::text, plan_id, status, started_at,
                   current_period_end, cancelled_at, payment_provider,
                   payment_subscription_id
            FROM user_subscriptions
            WHERE user_id = $1::uuid AND status IN ('active', 'trialing')
            ORDER BY started_at DESC
            LIMIT 1
        """, user_id)

        if row:
            return UserSubscription(
                id=str(row["id"]),
                user_id=row["user_id"],
                plan_id=row["plan_id"],
                status=SubscriptionStatus(row["status"]),
                started_at=row["started_at"],
                current_period_end=row["current_period_end"],
                cancelled_at=row["cancelled_at"],
                payment_provider=row["payment_provider"] or "stripe",
                payment_subscription_id=row["payment_subscription_id"]
            )
        return None

    async def get_user_subscription_history(
        self,
        user_id: str,
        limit: int = 10
    ) -> list[UserSubscription]:
        """获取用户订阅历史"""
        rows = await self.db.fetch("""
            SELECT id, user_id::text, plan_id, status, started_at,
                   current_period_end, cancelled_at, payment_provider,
                   payment_subscription_id
            FROM user_subscriptions
            WHERE user_id = $1::uuid
            ORDER BY started_at DESC
            LIMIT $2
        """, user_id, limit)

        return [
            UserSubscription(
                id=str(row["id"]),
                user_id=row["user_id"],
                plan_id=row["plan_id"],
                status=SubscriptionStatus(row["status"]),
                started_at=row["started_at"],
                current_period_end=row["current_period_end"],
                cancelled_at=row["cancelled_at"],
                payment_provider=row["payment_provider"] or "stripe",
                payment_subscription_id=row["payment_subscription_id"]
            )
            for row in rows
        ]

    async def create_subscription(
        self,
        user_id: str,
        plan_id: str,
        payment_subscription_id: str,
        current_period_end: datetime
    ) -> str:
        """创建订阅记录"""
        result = await self.db.fetchrow("""
            INSERT INTO user_subscriptions (
                id, user_id, plan_id, status, started_at,
                current_period_end, payment_provider, payment_subscription_id
            ) VALUES (
                uuid_generate_v4(), $1::uuid, $2, 'active', NOW(),
                $3, 'stripe', $4
            )
            RETURNING id
        """, user_id, plan_id, current_period_end, payment_subscription_id)

        return str(result["id"])

    async def update_subscription_status(
        self,
        payment_subscription_id: str,
        status: SubscriptionStatus,
        current_period_end: Optional[datetime] = None
    ) -> bool:
        """更新订阅状态"""
        if current_period_end:
            result = await self.db.execute("""
                UPDATE user_subscriptions
                SET status = $1, current_period_end = $2
                WHERE payment_subscription_id = $3
            """, status.value, current_period_end, payment_subscription_id)
        else:
            result = await self.db.execute("""
                UPDATE user_subscriptions
                SET status = $1
                WHERE payment_subscription_id = $2
            """, status.value, payment_subscription_id)

        return "UPDATE" in result

    async def cancel_subscription(self, user_id: str) -> bool:
        """取消用户订阅"""
        subscription = await self.get_user_subscription(user_id)
        if not subscription:
            return False

        # 在 Stripe 取消
        if subscription.payment_subscription_id:
            success = await self.stripe.cancel_subscription(
                subscription.payment_subscription_id,
                cancel_immediately=False
            )
            if not success:
                return False

        # 更新数据库
        await self.db.execute("""
            UPDATE user_subscriptions
            SET cancelled_at = NOW()
            WHERE id = $1::uuid
        """, subscription.id)

        return True

    async def check_feature_access(
        self,
        user_id: str,
        feature: str,
        skill_id: str = None
    ) -> bool:
        """检查用户是否有权访问某功能"""
        subscription = await self.get_user_subscription(user_id)

        # 检查订阅是否有效
        if not subscription or subscription.status != SubscriptionStatus.ACTIVE:
            return self._check_free_tier_access(feature)

        # 获取计划
        plan = await self.get_plan(subscription.plan_id)
        if not plan:
            return self._check_free_tier_access(feature)

        # 付费用户可访问所有功能
        if plan.plan_type == SubscriptionTier.PAID:
            return True

        return self._check_free_tier_access(feature)

    def _check_free_tier_access(self, feature: str) -> bool:
        """检查免费层是否可访问"""
        free_features = [
            "basic_chat",
            "basic_chart",
            "daily_fortune",
        ]
        return feature in free_features

    async def get_user_usage(self, user_id: str) -> dict:
        """获取用户使用量"""
        # 今日对话次数
        today_messages = await self.db.fetchval("""
            SELECT COUNT(*) FROM skill_messages sm
            JOIN skill_conversations sc ON sm.conversation_id = sc.id
            WHERE sc.user_id = $1::uuid
              AND sm.role = 'user'
              AND sm.created_at >= CURRENT_DATE
        """, user_id)

        # 本月对话次数
        month_messages = await self.db.fetchval("""
            SELECT COUNT(*) FROM skill_messages sm
            JOIN skill_conversations sc ON sm.conversation_id = sc.id
            WHERE sc.user_id = $1::uuid
              AND sm.role = 'user'
              AND sm.created_at >= DATE_TRUNC('month', CURRENT_DATE)
        """, user_id)

        return {
            "today_messages": today_messages or 0,
            "month_messages": month_messages or 0,
            "daily_limit": 3,  # 免费用户每日限制
            "remaining_today": max(0, 3 - (today_messages or 0))
        }

    async def sync_stripe_subscription(self, payment_subscription_id: str):
        """同步 Stripe 订阅状态"""
        stripe_sub = await self.stripe.get_subscription(payment_subscription_id)
        if not stripe_sub:
            return

        status_map = {
            "active": SubscriptionStatus.ACTIVE,
            "trialing": SubscriptionStatus.TRIALING,
            "past_due": SubscriptionStatus.PAST_DUE,
            "canceled": SubscriptionStatus.CANCELED,
            "unpaid": SubscriptionStatus.EXPIRED,
        }

        status = status_map.get(stripe_sub["status"], SubscriptionStatus.EXPIRED)
        current_period_end = stripe_sub.get("current_period_end")

        await self.update_subscription_status(
            payment_subscription_id,
            status,
            current_period_end
        )

    # ═══════════════════════════════════════════════════════════════════════
    # 双轨制到期检查 (payment-design v2.0)
    # ═══════════════════════════════════════════════════════════════════════

    async def check_expiring_subscriptions(self) -> dict:
        """
        检查即将到期的预付用户（定时任务调用）
        返回各时间段的用户数量
        """
        now = datetime.now()
        results = {"7d": 0, "3d": 0, "1d": 0, "expired": 0}

        # 7天内到期
        rows_7d = await self.db.fetch("""
            SELECT id, user_id::text, expires_at
            FROM subscriptions
            WHERE vip_type = 'prepaid'
              AND status = 'active'
              AND expires_at <= $1
              AND expires_at > $2
        """, now + timedelta(days=7), now + timedelta(days=3))
        results["7d"] = len(rows_7d)

        # 3天内到期
        rows_3d = await self.db.fetch("""
            SELECT id, user_id::text, expires_at
            FROM subscriptions
            WHERE vip_type = 'prepaid'
              AND status = 'active'
              AND expires_at <= $1
              AND expires_at > $2
        """, now + timedelta(days=3), now + timedelta(days=1))
        results["3d"] = len(rows_3d)

        # 1天内到期
        rows_1d = await self.db.fetch("""
            SELECT id, user_id::text, expires_at
            FROM subscriptions
            WHERE vip_type = 'prepaid'
              AND status = 'active'
              AND expires_at <= $1
              AND expires_at > $2
        """, now + timedelta(days=1), now)
        results["1d"] = len(rows_1d)

        logger.info(f"Expiring subscriptions: 7d={results['7d']}, 3d={results['3d']}, 1d={results['1d']}")
        return results

    async def expire_overdue_subscriptions(self) -> int:
        """
        将已过期的订阅标记为 expired（定时任务调用）
        返回处理的数量
        """
        result = await self.db.execute("""
            UPDATE subscriptions
            SET status = 'expired', updated_at = NOW()
            WHERE vip_type = 'prepaid'
              AND status = 'active'
              AND expires_at <= NOW()
        """)

        count = int(result.split()[-1]) if result else 0
        if count > 0:
            logger.info(f"Expired {count} overdue prepaid subscriptions")
        return count

    async def create_prepaid_subscription(
        self,
        user_id: str,
        plan_code: str,
        service_days: int,
        payment_session_id: str,
        region: str = "CN"
    ) -> str:
        """创建预付订阅（大陆/香港用户）"""
        expires_at = datetime.now() + timedelta(days=service_days)

        # 检查是否有现有活跃订阅，如果有则延长
        existing = await self.db.fetchrow("""
            SELECT id, expires_at FROM subscriptions
            WHERE user_id = $1::uuid AND status = 'active'
            ORDER BY expires_at DESC LIMIT 1
        """, user_id)

        if existing and existing["expires_at"] > datetime.now():
            # 延长现有订阅
            new_expires = existing["expires_at"] + timedelta(days=service_days)
            await self.db.execute("""
                UPDATE subscriptions
                SET expires_at = $1, updated_at = NOW()
                WHERE id = $2
            """, new_expires, existing["id"])
            logger.info(f"Extended prepaid subscription for user {user_id} to {new_expires}")
            return str(existing["id"])

        # 创建新订阅
        result = await self.db.fetchrow("""
            INSERT INTO subscriptions (
                id, user_id, plan_code, status, vip_type, region,
                started_at, expires_at, source
            ) VALUES (
                gen_random_uuid(), $1::uuid, $2, 'active', 'prepaid', $3,
                NOW(), $4, 'payment'
            )
            RETURNING id
        """, user_id, plan_code, region, expires_at)

        logger.info(f"Created prepaid subscription for user {user_id}, expires {expires_at}")
        return str(result["id"])

    async def create_stripe_subscription(
        self,
        user_id: str,
        plan_code: str,
        stripe_subscription_id: str,
        stripe_customer_id: str,
        current_period_end: datetime
    ) -> str:
        """创建 Stripe 订阅（海外用户）"""
        result = await self.db.fetchrow("""
            INSERT INTO subscriptions (
                id, user_id, plan_code, status, vip_type, region,
                started_at, expires_at, stripe_subscription_id, stripe_customer_id, source
            ) VALUES (
                gen_random_uuid(), $1::uuid, $2, 'active', 'subscription', 'GLOBAL',
                NOW(), $3, $4, $5, 'payment'
            )
            RETURNING id
        """, user_id, plan_code, current_period_end, stripe_subscription_id, stripe_customer_id)

        logger.info(f"Created Stripe subscription for user {user_id}, sub_id={stripe_subscription_id}")
        return str(result["id"])

    async def increment_payment_failed_count(self, stripe_subscription_id: str) -> int:
        """增加支付失败计数，返回新的计数"""
        result = await self.db.fetchrow("""
            UPDATE subscriptions
            SET payment_failed_count = payment_failed_count + 1, updated_at = NOW()
            WHERE stripe_subscription_id = $1
            RETURNING payment_failed_count
        """, stripe_subscription_id)

        count = result["payment_failed_count"] if result else 0

        # 如果失败次数 >= 3，暂停订阅
        if count >= 3:
            await self.db.execute("""
                UPDATE subscriptions
                SET status = 'suspended', updated_at = NOW()
                WHERE stripe_subscription_id = $1
            """, stripe_subscription_id)
            logger.warning(f"Suspended subscription {stripe_subscription_id} after {count} payment failures")

        return count

    async def reset_payment_failed_count(self, stripe_subscription_id: str):
        """重置支付失败计数（支付成功后调用）"""
        await self.db.execute("""
            UPDATE subscriptions
            SET payment_failed_count = 0, updated_at = NOW()
            WHERE stripe_subscription_id = $1
        """, stripe_subscription_id)

    # ═══════════════════════════════════════════════════════════════════════
    # Entitlement 方法 (从 EntitlementService 合并)
    # ═══════════════════════════════════════════════════════════════════════

    # 层级配置
    TIER_CONFIG = {
        "free": {"daily_limit": 3},
        "paid": {"daily_limit": 200},
    }

    async def check_can_chat(self, user_id: str) -> dict:
        """检查用户是否可以对话"""
        sub = await self.get_active_subscription(user_id)
        tier = "paid" if sub else "free"

        usage = await self.get_user_usage(user_id)
        limit = self.TIER_CONFIG[tier]["daily_limit"]
        remaining = max(0, limit - usage["today_messages"])

        return {
            "can_chat": remaining > 0,
            "remaining": remaining,
            "tier": tier
        }

    async def consume_conversation(self, user_id: str) -> bool:
        """消耗一次对话额度 (usage 通过 UsageService 自动记录)"""
        return True

    async def get_entitlements(self, user_id: str) -> dict:
        """获取用户权益"""
        sub = await self.get_active_subscription(user_id)
        tier = "paid" if sub else "free"
        usage = await self.get_user_usage(user_id)
        limit = self.TIER_CONFIG[tier]["daily_limit"]

        return {
            "tier": tier,
            "daily_limit": limit,
            "daily_used": usage["today_messages"],
            "daily_remaining": max(0, limit - usage["today_messages"]),
            "subscription_expires_at": sub.current_period_end if sub else None
        }

    async def get_active_subscription(self, user_id: str) -> Optional[UserSubscription]:
        """获取用户当前活跃订阅 (兼容两个表)"""
        # 优先查询 subscriptions 表 (新表)
        row = await self.db.fetchrow("""
            SELECT id, user_id::text, plan_code as plan_id, status, started_at,
                   expires_at as current_period_end, stripe_subscription_id as payment_subscription_id
            FROM subscriptions
            WHERE user_id = $1::uuid AND status = 'active' AND expires_at > NOW()
            ORDER BY expires_at DESC
            LIMIT 1
        """, user_id)

        if row:
            return UserSubscription(
                id=str(row["id"]),
                user_id=row["user_id"],
                plan_id=row["plan_id"],
                status=SubscriptionStatus.ACTIVE,
                started_at=row["started_at"],
                current_period_end=row["current_period_end"],
                payment_subscription_id=row["payment_subscription_id"]
            )

        # 回退到 user_subscriptions 表 (旧表)
        return await self.get_user_subscription(user_id)

    async def upgrade_to_paid(self, user_id: str, expires_at: datetime) -> bool:
        """升级到付费 (手动/测试用)"""
        days = (expires_at - datetime.now()).days
        await self.create_prepaid_subscription(
            user_id=user_id,
            plan_code="paid",
            service_days=max(1, days),
            payment_session_id="manual_upgrade",
            region="CN"
        )
        return True

    async def downgrade_to_free(self, user_id: str) -> bool:
        """降级到免费"""
        await self.db.execute("""
            UPDATE subscriptions
            SET status = 'canceled', updated_at = NOW()
            WHERE user_id = $1::uuid AND status = 'active'
        """, user_id)
        return True
