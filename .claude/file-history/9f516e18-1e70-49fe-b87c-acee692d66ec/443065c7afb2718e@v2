/**
 * useVibeChat - AI SDK useChat wrapper for VibeLife
 *
 * Provides streaming chat with skill and voice mode support
 */

'use client';

import { useChat, type UseChatOptions } from '@ai-sdk/react';
import { useCallback, useEffect, useState } from 'react';
import { getTokens } from '@/lib/api';

export type SkillId = 'bazi' | 'zodiac' | 'mbti' | 'attach' | 'career';
export type VoiceMode = 'warm' | 'sarcastic';

export interface UseVibeChatOptions {
  skillId: SkillId;
  voiceMode?: VoiceMode;
  conversationId?: string;
  onConversationStart?: (id: string) => void;
  onError?: (error: Error) => void;
}

export interface VibeChatMetadata {
  conversation_id?: string;
  skill?: string;
  voice_mode?: string;
}

export function useVibeChat({
  skillId,
  voiceMode = 'warm',
  conversationId: initialConversationId,
  onConversationStart,
  onError,
}: UseVibeChatOptions) {
  const [conversationId, setConversationId] = useState<string | undefined>(initialConversationId);
  const [metadata, setMetadata] = useState<VibeChatMetadata>({});

  // Get auth token
  const getAuthHeaders = useCallback(() => {
    const { accessToken } = getTokens();
    return accessToken ? { Authorization: `Bearer ${accessToken}` } : {};
  }, []);

  const chatOptions: UseChatOptions = {
    api: '/api/chat',
    body: {
      skill: skillId,
      voice_mode: voiceMode,
      conversation_id: conversationId,
    },
    headers: getAuthHeaders(),
    onResponse: (response) => {
      if (!response.ok) {
        onError?.(new Error(`Chat request failed: ${response.status}`));
      }
    },
    onFinish: (message, { finishReason }) => {
      // Parse metadata from the last data event if available
      // The conversation_id will be in the response metadata
    },
    onError: (error) => {
      console.error('Chat error:', error);
      onError?.(error);
    },
  };

  const chat = useChat(chatOptions);

  // Handle conversation ID from streaming response
  useEffect(() => {
    // Check for new conversation ID in the response data
    const lastMessage = chat.messages[chat.messages.length - 1];
    if (lastMessage?.id && !conversationId) {
      // In a real implementation, we'd extract conversation_id from the stream
      // For now, we use the message ID as a fallback
    }
  }, [chat.messages, conversationId, onConversationStart]);

  // Custom submit handler that includes skill and voice mode
  const sendMessage = useCallback(
    async (content: string) => {
      // Update headers before sending (in case token changed)
      return chat.append({
        role: 'user',
        content,
      }, {
        body: {
          skill: skillId,
          voice_mode: voiceMode,
          conversation_id: conversationId,
        },
        headers: getAuthHeaders(),
      });
    },
    [chat, skillId, voiceMode, conversationId, getAuthHeaders]
  );

  // Handle quick prompt - same as sendMessage but clears existing messages first
  const sendQuickPrompt = useCallback(
    async (content: string) => {
      chat.setMessages([]);
      return sendMessage(content);
    },
    [chat, sendMessage]
  );

  return {
    // Core state
    messages: chat.messages,
    input: chat.input,
    isLoading: chat.isLoading,
    error: chat.error,

    // Actions
    sendMessage,
    sendQuickPrompt,
    setInput: chat.setInput,
    handleInputChange: chat.handleInputChange,
    handleSubmit: chat.handleSubmit,
    stop: chat.stop,
    reload: chat.reload,

    // Metadata
    conversationId,
    metadata,

    // Raw chat for advanced use
    append: chat.append,
    setMessages: chat.setMessages,
  };
}

export default useVibeChat;
