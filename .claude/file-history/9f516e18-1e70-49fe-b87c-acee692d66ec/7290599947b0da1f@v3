/**
 * Next.js API Route for Chat - AI SDK 6 Compatible
 *
 * Implements Data Stream Protocol with x-vercel-ai-ui-message-stream header
 * Proxies to Python backend and converts SSE format
 */

import { NextRequest, NextResponse } from 'next/server';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE || "http://localhost:8000/api/v1";

export const runtime = 'edge';

/**
 * AI SDK 6 Data Stream Protocol format:
 * - text-start: {"type":"text-start","id":"[id]"}
 * - text-delta: {"type":"text-delta","id":"[id]","delta":"[content]"}
 * - text-end: {"type":"text-end","id":"[id]"}
 * - [DONE] to terminate
 */
export async function POST(req: NextRequest) {
  const body = await req.json();
  const { messages, skill, voice_mode, conversation_id } = body;

  // Extract the latest user message
  const lastMessage = messages?.[messages.length - 1];
  const userMessage = typeof lastMessage === 'string'
    ? lastMessage
    : lastMessage?.content || lastMessage?.parts?.[0]?.text || body.message || '';

  // Get auth token from header
  const authHeader = req.headers.get('authorization');

  // Prepare request to Python backend
  const chatRequest = {
    message: userMessage,
    skill: skill || 'bazi',
    voice_mode: voice_mode || 'warm',
    conversation_id: conversation_id,
  };

  try {
    // Call Python backend SSE endpoint
    const response = await fetch(`${API_BASE}/chat/stream`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(authHeader && { Authorization: authHeader }),
      },
      body: JSON.stringify(chatRequest),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ detail: 'Chat failed' }));
      return NextResponse.json({ error: error.detail || 'Chat failed' }, { status: response.status });
    }

    // Create ReadableStream for AI SDK 6 Data Stream Protocol
    const encoder = new TextEncoder();
    const messageId = `msg-${Date.now()}`;

    const stream = new ReadableStream({
      async start(controller) {
        const reader = response.body?.getReader();
        const decoder = new TextDecoder();

        if (!reader) {
          controller.close();
          return;
        }

        // Send message-start
        controller.enqueue(encoder.encode(`data: {"type":"message-start","id":"${messageId}"}\n\n`));

        // Send text-start
        const textId = `text-${Date.now()}`;
        controller.enqueue(encoder.encode(`data: {"type":"text-start","id":"${textId}"}\n\n`));

        let buffer = '';

        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const dataStr = line.slice(6).trim();
                if (!dataStr) continue;

                try {
                  const data = JSON.parse(dataStr);

                  if (data.type === 'chunk') {
                    // Convert to AI SDK 6 text-delta format
                    const delta = JSON.stringify(data.content).slice(1, -1); // escape for JSON
                    controller.enqueue(encoder.encode(
                      `data: {"type":"text-delta","id":"${textId}","delta":"${delta}"}\n\n`
                    ));
                  } else if (data.type === 'done') {
                    // Send text-end
                    controller.enqueue(encoder.encode(`data: {"type":"text-end","id":"${textId}"}\n\n`));

                    // Send message-end with metadata
                    const metadata = {
                      conversation_id: data.conversation_id,
                      skill: data.skill,
                      voice_mode: data.voice_mode,
                    };
                    controller.enqueue(encoder.encode(
                      `data: {"type":"message-end","id":"${messageId}","metadata":${JSON.stringify(metadata)}}\n\n`
                    ));

                    // Terminate stream
                    controller.enqueue(encoder.encode('data: [DONE]\n\n'));
                  } else if (data.type === 'error') {
                    controller.enqueue(encoder.encode(
                      `data: {"type":"error","error":"${data.message}"}\n\n`
                    ));
                  }
                } catch {
                  // Skip malformed JSON
                }
              }
            }
          }
        } catch (error) {
          controller.enqueue(encoder.encode(
            `data: {"type":"error","error":"${error instanceof Error ? error.message : 'Unknown error'}"}\n\n`
          ));
        } finally {
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'x-vercel-ai-ui-message-stream': 'v1',
      },
    });
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
