/**
 * Next.js API Route for Chat - AI SDK Compatible
 *
 * Acts as a proxy to Python backend, converting SSE format to AI SDK Data Stream Protocol
 */

import { createDataStreamResponse, createDataStream } from 'ai';
import { NextRequest } from 'next/server';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE || "http://localhost:8000/api/v1";

export const runtime = 'edge';

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { messages, skill, voice_mode, conversation_id } = body;

  // Extract the latest user message
  const lastMessage = messages?.[messages.length - 1];
  const userMessage = lastMessage?.content || body.message || '';

  // Get auth token from header
  const authHeader = req.headers.get('authorization');

  // Prepare request to Python backend
  const chatRequest = {
    message: userMessage,
    skill: skill || 'bazi',
    voice_mode: voice_mode || 'warm',
    conversation_id: conversation_id,
  };

  // Create data stream for AI SDK
  return createDataStreamResponse({
    execute: async (dataStream) => {
      try {
        // Call Python backend SSE endpoint
        const response = await fetch(`${API_BASE}/chat/stream`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(authHeader && { Authorization: authHeader }),
          },
          body: JSON.stringify(chatRequest),
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({ detail: 'Chat failed' }));
          dataStream.writeData({ error: error.detail || 'Chat failed' });
          return;
        }

        const reader = response.body?.getReader();
        const decoder = new TextDecoder();

        if (!reader) {
          dataStream.writeData({ error: 'No response body' });
          return;
        }

        let buffer = '';
        let metadata: Record<string, unknown> = {};

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const dataStr = line.slice(6).trim();
              if (!dataStr) continue;

              try {
                const data = JSON.parse(dataStr);

                if (data.type === 'chunk') {
                  // Write text chunk to AI SDK stream
                  dataStream.writeData({ type: 'text-delta', textDelta: data.content });
                } else if (data.type === 'done') {
                  // Store metadata for final response
                  metadata = {
                    conversation_id: data.conversation_id,
                    skill: data.skill,
                    voice_mode: data.voice_mode,
                  };
                  dataStream.writeData({ type: 'finish', metadata });
                } else if (data.type === 'error') {
                  dataStream.writeData({ error: data.message });
                  return;
                }
              } catch {
                // Skip malformed JSON
              }
            }
          }
        }
      } catch (error) {
        dataStream.writeData({
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    },
  });
}
