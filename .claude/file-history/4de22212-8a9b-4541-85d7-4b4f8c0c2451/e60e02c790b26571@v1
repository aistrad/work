"""
ProactiveEngine - 主动推送系统核心引擎

职责:
1. 加载 Skill 级提醒定义 (reminders.yaml)
2. 协调触发检测、内容生成、推送投递
3. 管理数据源 (unified_profiles)

设计原则:
- Skill 级定义: 每个 Skill 在 reminders.yaml 定义自己的提醒类型
- 数据源统一: unified_profiles 是唯一真源
- 智能化: 基于 life_context 个性化内容 + 事件触发
"""

import logging
import yaml
from dataclasses import dataclass, field
from datetime import datetime, date, timedelta
from enum import Enum
from pathlib import Path
from typing import List, Dict, Any, Optional
from uuid import UUID

import pytz

from stores.db import get_connection
from stores.unified_profile_repo import UnifiedProfileRepository
from stores.skill_subscription_repo import SkillSubscriptionRepository
from services.reminder.notification import NotificationService
from services.agent.skill_loader import load_skill_metadata

logger = logging.getLogger(__name__)


class ReminderPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


@dataclass
class ReminderTask:
    """提醒任务"""
    user_id: UUID
    skill_id: str
    reminder_type: str
    priority: ReminderPriority = ReminderPriority.MEDIUM
    trigger_event: Optional[str] = None
    trigger_date: Optional[date] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ReminderContent:
    """提醒内容"""
    title: str
    body: str
    data: Dict[str, Any] = field(default_factory=dict)
    card_type: Optional[str] = None


class ProactiveEngine:
    """主动推送引擎"""

    # 默认推送时间 (用户本地时间)
    DEFAULT_PUSH_HOUR = 4

    def __init__(self):
        self._skill_configs: Dict[str, Dict] = {}
        self._trigger_detector = None
        self._content_generator = None
        self._notification_service = NotificationService()
        self._load_skill_configs()

    def _load_skill_configs(self):
        """加载所有 Skill 的 reminders.yaml"""
        skills_dir = Path(__file__).parent.parent.parent / "skills"

        for skill_dir in skills_dir.iterdir():
            if skill_dir.is_dir():
                reminders_file = skill_dir / "reminders.yaml"
                if reminders_file.exists():
                    try:
                        with open(reminders_file, encoding="utf-8") as f:
                            config = yaml.safe_load(f)
                            if config and "skill_id" in config:
                                self._skill_configs[config["skill_id"]] = config
                                logger.info(f"Loaded reminders config for skill: {config['skill_id']}")
                    except Exception as e:
                        logger.error(f"Failed to load {reminders_file}: {e}")

        logger.info(f"Loaded {len(self._skill_configs)} skill reminder configs")

    @property
    def trigger_detector(self):
        """延迟加载 TriggerDetector"""
        if self._trigger_detector is None:
            from .trigger_detector import TriggerDetector
            self._trigger_detector = TriggerDetector()
        return self._trigger_detector

    @property
    def content_generator(self):
        """延迟加载 ContentGenerator"""
        if self._content_generator is None:
            from .content_generator import ContentGenerator
            self._content_generator = ContentGenerator()
        return self._content_generator

    async def run_scheduled_scan(self) -> List[ReminderTask]:
        """
        定时扫描入口 (由 Worker 调用)

        流程:
        1. 获取当前时段应该推送的用户
        2. 检测每个用户的触发条件
        3. 生成提醒任务
        """
        tasks = []

        # 获取当前时段的用户
        users = await self._get_users_for_current_hour()
        logger.info(f"Found {len(users)} users for current hour")

        for user in users:
            try:
                user_tasks = await self._detect_user_triggers(user)
                tasks.extend(user_tasks)
            except Exception as e:
                logger.error(f"Failed to detect triggers for user {user.get('user_id')}: {e}")

        logger.info(f"Generated {len(tasks)} reminder tasks")
        return tasks

    async def process_tasks(self, tasks: List[ReminderTask]) -> int:
        """
        处理提醒任务

        流程:
        1. 生成个性化内容
        2. 投递到推送渠道
        3. 记录到数据库
        """
        success_count = 0

        for task in tasks:
            try:
                # 获取用户 Profile
                profile = await UnifiedProfileRepository.get_profile(task.user_id)
                if not profile:
                    logger.warning(f"Profile not found for user {task.user_id}")
                    continue

                # 获取 Skill 配置
                skill_config = self._skill_configs.get(task.skill_id, {})
                reminder_config = self._get_reminder_config(skill_config, task.reminder_type)

                # 生成内容
                content = await self.content_generator.generate(
                    task=task,
                    profile=profile,
                    config=reminder_config,
                )

                # 投递 (保存到数据库)
                await self._notification_service.send_notification(
                    user_id=task.user_id,
                    notification_type=task.reminder_type,
                    title=content.title,
                    content=content.data,
                    trigger_date=task.trigger_date or date.today(),
                )

                success_count += 1
                logger.debug(f"Processed task: {task.skill_id}/{task.reminder_type} for user {task.user_id}")

            except Exception as e:
                logger.error(f"Failed to process task {task}: {e}")

        logger.info(f"Successfully processed {success_count}/{len(tasks)} tasks")
        return success_count

    async def run_once(self) -> int:
        """执行一次完整的扫描和处理"""
        tasks = await self.run_scheduled_scan()
        if tasks:
            return await self.process_tasks(tasks)
        return 0

    async def _get_users_for_current_hour(self) -> List[Dict[str, Any]]:
        """获取当前时段应该推送的用户"""
        now_utc = datetime.now(pytz.UTC)
        target_hour = self.DEFAULT_PUSH_HOUR

        # 找出当前时刻为目标时间的时区偏移
        valid_offsets = []
        for offset in range(-12, 15):
            tz_time = now_utc + timedelta(hours=offset)
            if tz_time.hour == target_hour:
                valid_offsets.append(offset)

        if not valid_offsets:
            return []

        # 查询付费用户 (使用 unified_profiles)
        query = """
            SELECT u.id as user_id, up.profile
            FROM vibe_users u
            JOIN unified_profiles up ON up.user_id = u.id
            WHERE u.subscription_status = 'active'
        """

        users = []
        try:
            async with get_connection() as conn:
                rows = await conn.fetch(query)

            for row in rows:
                profile = row["profile"] if isinstance(row["profile"], dict) else {}
                tz_name = profile.get("preferences", {}).get("timezone", "Asia/Shanghai")

                try:
                    tz = pytz.timezone(tz_name)
                    user_time = now_utc.astimezone(tz)
                    if user_time.hour == target_hour:
                        users.append({
                            "user_id": row["user_id"],
                            "profile": profile,
                            "timezone": tz_name,
                        })
                except Exception:
                    # 默认使用 Asia/Shanghai (UTC+8)
                    if 8 in valid_offsets:
                        users.append({
                            "user_id": row["user_id"],
                            "profile": profile,
                            "timezone": "Asia/Shanghai",
                        })
        except Exception as e:
            logger.error(f"Failed to get users: {e}")

        return users

    async def _detect_user_triggers(self, user: Dict[str, Any]) -> List[ReminderTask]:
        """检测用户的所有触发条件"""
        tasks = []
        user_id = user["user_id"]
        profile = user["profile"]

        # 遍历所有 Skill 配置
        for skill_id, config in self._skill_configs.items():
            for reminder in config.get("reminder_types", []):
                trigger_config = reminder.get("trigger", {})

                try:
                    # 检测触发条件
                    should_trigger, event_info = await self.trigger_detector.should_trigger(
                        trigger_config=trigger_config,
                        profile=profile,
                        skill_id=skill_id,
                    )

                    if should_trigger:
                        tasks.append(ReminderTask(
                            user_id=user_id,
                            skill_id=skill_id,
                            reminder_type=reminder["id"],
                            priority=ReminderPriority(reminder.get("priority", "medium")),
                            trigger_event=event_info.get("event_name") if event_info else None,
                            trigger_date=event_info.get("event_date") if event_info else date.today(),
                            metadata={"config": reminder, "event_info": event_info},
                        ))
                except Exception as e:
                    logger.error(f"Failed to check trigger {reminder.get('id')} for user {user_id}: {e}")

        return tasks

    def _get_reminder_config(self, skill_config: Dict, reminder_type: str) -> Dict:
        """获取特定提醒类型的配置"""
        for reminder in skill_config.get("reminder_types", []):
            if reminder["id"] == reminder_type:
                return reminder
        return {}

    def get_skill_configs(self) -> Dict[str, Dict]:
        """获取所有 Skill 配置 (用于调试)"""
        return self._skill_configs


# ═══════════════════════════════════════════════════════════════════════════
# Singleton
# ═══════════════════════════════════════════════════════════════════════════

_engine: Optional[ProactiveEngine] = None


def get_proactive_engine() -> ProactiveEngine:
    """获取单例 ProactiveEngine"""
    global _engine
    if _engine is None:
        _engine = ProactiveEngine()
    return _engine
