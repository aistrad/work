# Profile 注入机制设计 - 通用方案

> **目标**: 实现通用的 Profile 注入机制，让所有 Skill 都能自动获得用户上下文
> **原则**: Skill 无关、分层注入、Token 优化、声明式配置

---

## 一、核心设计

### 1.1 分层注入架构

```
┌────────────────────────────────────────────────────────┐
│                    Profile 注入层级                      │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Layer 1: ESSENTIAL (必需，所有 Skill)                  │
│  ├── display_name    - 用户称呼                         │
│  ├── voice_mode      - 语气风格                         │
│  └── tier            - 用户等级                         │
│                                                        │
│  Layer 2: SHARED (共享，大多数 Skill)                   │
│  ├── focus[]         - 当前关注领域                     │
│  ├── goals[]         - 用户目标 (extracted)             │
│  ├── concerns[]      - 关注点 (extracted)               │
│  └── patterns[]      - 行为模式 (extracted)             │
│                                                        │
│  Layer 3: SPECIFIC (按需，Skill 声明)                   │
│  ├── birth_info      - 出生信息 (bazi, zodiac)         │
│  ├── facts[]         - 个人事实 (career, lifecoach)    │
│  └── life_events[]   - 生活事件 (lifecoach)            │
│                                                        │
│  Layer 4: CONTEXTUAL (上下文，当前 Skill)               │
│  ├── _findings[]     - 历史发现                         │
│  └── _session        - 会话状态                         │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### 1.2 Skill 配置声明

每个 Skill 在 `SKILL.md` 中声明需要的 Profile 字段：

```yaml
# SKILL.md frontmatter 新增
profile_injection:
  level: balanced  # minimal | balanced | full
  specific_fields:
    - birth_info   # 仅命盘类
    - life_events  # 仅规划类
  inject_findings: true  # 是否注入历史发现
```

---

## 二、数据模型

### 2.1 ProfileInjection 配置

```python
@dataclass
class ProfileInjectionConfig:
    """Profile 注入配置"""
    level: str = "balanced"  # minimal | balanced | full
    specific_fields: List[str] = field(default_factory=list)
    inject_findings: bool = False
    max_findings: int = 5
    max_goals: int = 3
    max_concerns: int = 3
```

### 2.2 InjectedProfile 结构

```python
@dataclass
class InjectedProfile:
    """注入到 Prompt 的 Profile 数据"""
    # Layer 1: Essential
    display_name: Optional[str] = None
    voice_mode: str = "warm"
    tier: str = "free"

    # Layer 2: Shared
    focus: List[str] = field(default_factory=list)
    goals: List[str] = field(default_factory=list)
    concerns: List[str] = field(default_factory=list)
    patterns: List[str] = field(default_factory=list)

    # Layer 3: Specific (按需填充)
    birth_info: Optional[Dict] = None
    facts: List[str] = field(default_factory=list)
    life_events: List[str] = field(default_factory=list)

    # Layer 4: Contextual
    findings: List[Dict] = field(default_factory=list)

    def to_prompt_text(self) -> str:
        """转换为 Prompt 文本"""
```

---

## 三、实现方案

### 3.1 文件修改清单

| 文件 | 修改内容 |
|------|---------|
| `services/agent/profile_injector.py` | **新增**：Profile 注入核心模块 |
| `services/agent/prompt_builder.py` | 集成 ProfileInjector |
| `services/agent/skill_loader.py` | 解析 `profile_injection` 配置 |
| `skills/*/SKILL.md` | 添加 `profile_injection` 声明 |

### 3.2 ProfileInjector 模块设计

```python
# services/agent/profile_injector.py

class ProfileInjector:
    """
    通用 Profile 注入器

    职责：
    1. 根据 Skill 配置提取 Profile 数据
    2. 格式化为 Prompt 友好的文本
    3. 控制 Token 消耗
    """

    # 默认配置（未声明时使用）
    DEFAULT_CONFIG = ProfileInjectionConfig(level="balanced")

    # Skill 默认配置映射（向后兼容）
    SKILL_DEFAULTS = {
        "bazi": ProfileInjectionConfig(specific_fields=["birth_info"]),
        "zodiac": ProfileInjectionConfig(specific_fields=["birth_info"]),
        "jungastro": ProfileInjectionConfig(specific_fields=["birth_info"]),
        "lifecoach": ProfileInjectionConfig(
            level="full",
            specific_fields=["facts", "life_events"],
            inject_findings=True
        ),
        "career": ProfileInjectionConfig(
            specific_fields=["facts"],
            inject_findings=True
        ),
        "tarot": ProfileInjectionConfig(level="minimal"),
        "mindfulness": ProfileInjectionConfig(level="minimal"),
    }

    async def inject(
        self,
        skill_id: str,
        profile: Dict[str, Any],
        skill_findings: Optional[List[Dict]] = None
    ) -> InjectedProfile:
        """
        根据 Skill 配置注入 Profile
        """
        config = self._get_config(skill_id)

        injected = InjectedProfile()

        # Layer 1: Essential (所有 Skill)
        injected.display_name = self._get_display_name(profile)
        injected.voice_mode = self._get_voice_mode(profile)
        injected.tier = self._get_tier(profile)

        # Layer 2: Shared (balanced 及以上)
        if config.level in ("balanced", "full"):
            extracted = profile.get("extracted", {})
            injected.focus = profile.get("state", {}).get("focus", [])
            injected.goals = extracted.get("goals", [])[:config.max_goals]
            injected.concerns = extracted.get("concerns", [])[:config.max_concerns]
            injected.patterns = extracted.get("patterns", [])

        # Layer 3: Specific (按声明)
        for field in config.specific_fields:
            self._inject_specific_field(injected, profile, field)

        # Layer 4: Contextual (按配置)
        if config.inject_findings and skill_findings:
            injected.findings = skill_findings[-config.max_findings:]

        return injected

    def _get_config(self, skill_id: str) -> ProfileInjectionConfig:
        """获取 Skill 的注入配置"""
        # 优先从 Skill 定义读取
        skill = load_skill(skill_id)
        if skill and hasattr(skill, 'profile_injection'):
            return skill.profile_injection

        # 否则使用默认映射
        return self.SKILL_DEFAULTS.get(skill_id, self.DEFAULT_CONFIG)
```

### 3.3 PromptBuilder 集成

```python
# prompt_builder.py 修改

class PromptBuilder:
    def __init__(self):
        self.case_index = None
        self.profile_injector = ProfileInjector()  # 新增

    async def build(self, skill_id, rule_id, message, profile,
                    skill_data, session_context, protocol_prompt):
        parts = []

        if skill_id:
            # 基础 Skill Prompt
            skill = load_skill(skill_id)
            parts.append(f"# {skill.name}\n\n{skill.expert_persona}")

            # ========================================
            # 新增：Profile 注入（在 Persona 之后）
            # ========================================
            if profile:
                findings = session_context.findings if session_context else None
                injected = await self.profile_injector.inject(
                    skill_id, profile, findings
                )
                profile_text = injected.to_prompt_text()
                if profile_text:
                    parts.append(profile_text)

            # 规则/场景
            if rule_id:
                rule = load_rule(skill_id, rule_id)
                if rule:
                    parts.append(f"\n---\n\n## 当前规则: {rule.name}\n")
                    parts.append(rule.content)

            # ... 其他部分 ...
```

### 3.4 InjectedProfile.to_prompt_text() 实现

```python
def to_prompt_text(self) -> str:
    """转换为 Prompt 文本"""
    lines = ["## 用户画像\n"]

    # 称呼
    if self.display_name:
        lines.append(f"**称呼**: {self.display_name}")

    # 当前关注
    if self.focus:
        lines.append(f"**当前关注**: {', '.join(self.focus[:3])}")

    # 目标
    if self.goals:
        lines.append(f"**用户目标**: {', '.join(self.goals)}")

    # 关注点
    if self.concerns:
        lines.append(f"**关注点**: {', '.join(self.concerns)}")

    # 行为模式
    if self.patterns:
        lines.append(f"**行为特征**: {', '.join(self.patterns[:2])}")

    # 出生信息（仅命盘类）
    if self.birth_info:
        birth = self.birth_info
        lines.append(f"**出生信息**: {birth.get('date', '')} {birth.get('time', '')} {birth.get('location', '')}")

    # 个人事实
    if self.facts:
        lines.append(f"**背景**: {'; '.join(self.facts[:3])}")

    # 历史发现
    if self.findings:
        lines.append("\n**近期洞察**:")
        for f in self.findings[-3:]:
            lines.append(f"- [{f.get('type', 'insight')}] {f.get('content', '')}")

    # 如果只有标题，返回空
    if len(lines) <= 1:
        return ""

    lines.append("\n---\n")
    return "\n".join(lines)
```

---

## 四、Skill 配置示例

### 4.1 lifecoach/SKILL.md

```yaml
---
id: lifecoach
name: 人生教练
profile_injection:
  level: full
  specific_fields:
    - facts
    - life_events
  inject_findings: true
  max_findings: 5
---
```

### 4.2 bazi/SKILL.md

```yaml
---
id: bazi
name: 八字命理
profile_injection:
  level: balanced
  specific_fields:
    - birth_info
  inject_findings: false
---
```

### 4.3 tarot/SKILL.md

```yaml
---
id: tarot
name: 塔罗牌
profile_injection:
  level: minimal
  specific_fields: []
  inject_findings: false
---
```

---

## 五、实施步骤

### Step 1: 创建 ProfileInjector 模块
- 创建 `services/agent/profile_injector.py`
- 实现 `ProfileInjector` 类
- 实现 `InjectedProfile` 数据类

### Step 2: 更新 SkillLoader
- 解析 SKILL.md 中的 `profile_injection` 配置
- 添加到 `SkillConfig` 数据类

### Step 3: 集成 PromptBuilder
- 在 `build()` 方法中调用 `ProfileInjector`
- 移除旧的直接 profile 传递

### Step 4: 更新 Skill 配置
- 为每个 Skill 添加 `profile_injection` 声明
- 使用默认值向后兼容

### Step 5: 测试验证
- 验证各 Skill 的 Profile 注入效果
- 检查 Token 消耗变化

---

## 六、验证方案

### 测试场景 1: 命盘类 Skill

```
1. 用户有 birth_info 和 extracted.goals
2. 进入 bazi skill
3. 验证：
   - birth_info 被注入 ✓
   - goals 被注入 ✓
   - life_events 不注入 ✓
```

### 测试场景 2: 规划类 Skill

```
1. 用户有完整 extracted 数据和历史 findings
2. 进入 lifecoach skill
3. 验证：
   - 所有 extracted 字段被注入 ✓
   - findings 被注入 ✓
   - birth_info 不注入 ✓
```

### 测试场景 3: 极简 Skill

```
1. 用户有完整 profile
2. 进入 tarot skill
3. 验证：
   - 只注入 display_name, voice_mode, tier
   - 其他字段不注入
   - Token 消耗最小
```

---

## 七、关键文件

| 文件 | 职责 |
|------|------|
| `services/agent/profile_injector.py` | Profile 注入核心（新增） |
| `services/agent/prompt_builder.py:47` | 集成点 |
| `services/agent/skill_loader.py:122` | SkillConfig 扩展 |
| `skills/*/SKILL.md` | 各 Skill 配置声明 |
