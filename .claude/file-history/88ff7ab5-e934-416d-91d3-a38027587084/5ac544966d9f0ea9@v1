"""
Global Tool Handlers - 全局工具执行器

使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。
"""
import json
import logging
from datetime import datetime
from typing import Dict, Any

from .tool_registry import tool_handler, ToolContext
from .skill_loader import get_skill_services

logger = logging.getLogger(__name__)


@tool_handler("search_db")
async def execute_search_db(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """从数据库检索知识或案例"""
    from services.knowledge.repository import get_knowledge_repository

    table = args.get("table", "knowledge_chunks")
    query = args.get("query", "")
    filters = args.get("filters", {})
    top_k = args.get("top_k", 5)

    # 自动添加当前 skill_id 到 filters
    if context.skill_id and "skill_id" not in filters:
        filters["skill_id"] = context.skill_id

    try:
        repo = get_knowledge_repository()
        results = await repo.search_db(
            table=table,
            query=query,
            filters=filters,
            top_k=top_k
        )
        return {
            "status": "success",
            "table": table,
            "query": query,
            "count": len(results),
            "results": results
        }
    except Exception as e:
        logger.error(f"search_db failed: {e}")
        return {"status": "error", "error": str(e)}


@tool_handler("ask_user_question")
async def execute_ask_user_question(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """向用户提问"""
    return {
        "status": "question",
        "question": args.get("question"),
        "options": args.get("options", [])
    }


@tool_handler("show_service_menu")
async def execute_show_service_menu(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示服务目录"""
    services = args.get("services", [
        {"id": "bazi", "name": "八字命理", "description": "八字排盘、运势分析", "icon": "compass"},
        {"id": "zodiac", "name": "星座占星", "description": "星盘解读、行运分析", "icon": "star"},
        {"id": "tarot", "name": "塔罗占卜", "description": "塔罗牌阵、问题指引", "icon": "cards"},
        {"id": "career", "name": "职业规划", "description": "职业方向、发展建议", "icon": "briefcase"},
    ])
    return {
        "status": "success",
        "cardType": "service_menu",
        "services": services,
    }


@tool_handler("show_skill_services")
async def execute_show_skill_services(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示 Skill 服务目录"""
    skill_id = args.get("skill_id") or context.skill_id or "bazi"

    # 从 SKILL.md 动态获取服务列表
    skill_services = get_skill_services(skill_id)
    if skill_services:
        return {
            "status": "success",
            "cardType": "skill_services",
            "skillId": skill_id,
            "skillName": skill_services.get("skill_name", skill_id),
            "services": skill_services.get("services", {}),
        }

    # 回退到静态列表
    static_services = {
        "bazi": [
            {"id": "bazi_chart", "name": "八字排盘", "description": "生成完整八字命盘", "tier": "entry"},
            {"id": "bazi_fortune", "name": "运势分析", "description": "大运流年详解", "tier": "entry"},
            {"id": "bazi_career", "name": "事业分析", "description": "职业方向与发展", "tier": "pro"},
        ],
        "zodiac": [
            {"id": "zodiac_chart", "name": "星盘解读", "description": "本命星盘分析", "tier": "entry"},
            {"id": "zodiac_transit", "name": "行运分析", "description": "当前行星影响", "tier": "entry"},
        ],
    }

    return {
        "status": "success",
        "cardType": "skill_services",
        "skillId": skill_id,
        "services": static_services.get(skill_id, []),
    }


@tool_handler("recommend_service")
async def execute_recommend_service(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """推荐升级服务"""
    return {
        "status": "success",
        "cardType": "service_recommendation",
        "scenarioId": args.get("scenario_id", ""),
        "reason": args.get("reason", ""),
        "highlights": args.get("highlights", []),
    }


@tool_handler("request_info")
async def execute_request_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """向用户请求信息"""
    info_type = args.get("info_type", "birth")

    fields_map = {
        "birth": [
            {"id": "birthDate", "label": "出生日期", "type": "date", "placeholder": ""},
            {"id": "birthTime", "label": "出生时间", "type": "time", "placeholder": ""},
            {"id": "birthPlace", "label": "出生地点", "type": "text", "placeholder": "城市名"},
            {"id": "gender", "label": "性别", "type": "select", "options": [
                {"value": "male", "label": "男"},
                {"value": "female", "label": "女"},
            ]},
        ],
        "context": [
            {"id": "situation", "label": "当前情况", "type": "text", "placeholder": "描述你目前面临的情况"},
        ],
        "goals": [
            {"id": "goals", "label": "你的目标", "type": "text", "placeholder": "你想达成什么"},
        ],
        "concerns": [
            {"id": "concerns", "label": "你的困惑", "type": "text", "placeholder": "最困扰你的是什么"},
        ],
    }

    return {
        "status": "collecting",
        "cardType": "collect_form",
        "infoType": info_type,
        "question": args.get("question"),
        "fields": fields_map.get(info_type, fields_map["birth"]),
    }


@tool_handler("show_insight")
async def execute_show_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示洞察卡片"""
    return {
        "status": "success",
        "cardType": "insight_card",
        "insightType": args.get("insight_type", "general"),
        "title": args.get("title", "关键洞察"),
        "content": args.get("content", ""),
    }


@tool_handler("show_report")
async def execute_show_report(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示报告"""
    from uuid import UUID

    report_id = args.get("report_id")
    report_type = args.get("report_type", "lite")
    user_id = context.user_id
    skill = context.skill_id or "bazi"

    # 尝试获取已有报告
    if report_id:
        try:
            from stores import report_repo
            report = await report_repo.get_report(report_id)
            if report:
                return _normalize_report(report.to_dict())
        except Exception as e:
            logger.error(f"Failed to get report {report_id}: {e}")

    if user_id and user_id != "guest":
        try:
            from stores import report_repo
            user_uuid = UUID(user_id) if isinstance(user_id, str) else user_id
            reports = await report_repo.list_reports(user_uuid, skill=skill, limit=1)
            if reports:
                report = await report_repo.get_report(reports[0].id)
                if report:
                    return _normalize_report(report.to_dict())
        except Exception as e:
            logger.error(f"Failed to get user reports: {e}")

    # 返回演示报告
    return {
        "status": "success",
        "cardType": "report_card",
        "id": "demo",
        "title": f"{'星盘' if skill == 'zodiac' else '八字'}报告（演示）",
        "createdAt": datetime.now().strftime("%Y-%m-%d"),
        "prologue": "这是一个演示版报告卡片。完善个人信息后可生成真实报告。",
        "isPaid": False,
        "reportType": report_type,
    }


def _normalize_report(report: Dict[str, Any]) -> Dict[str, Any]:
    """标准化报告字段名"""
    return {
        **report,
        "status": "success",
        "cardType": "report_card",
        "createdAt": report.get("created_at") or report.get("createdAt"),
        "isPaid": report.get("is_paid") if report.get("isPaid") is None else report.get("isPaid"),
        "reportType": report.get("report_type") or report.get("reportType"),
    }


@tool_handler("show_relationship")
async def execute_show_relationship(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示关系分析"""
    partner_info = args.get("partner_info") or args.get("partnerInfo")
    relationship_type = args.get("relationship_type") or args.get("relationshipType", "general")

    # TODO: 接入真正的关系分析服务
    return {
        "status": "success",
        "cardType": "relationship_card",
        "score": 85,
        "summary": "你们的关系有很好的互补性",
        "strengths": ["沟通顺畅", "价值观相近"],
        "challenges": ["需要更多耐心", "注意情绪表达"],
        "advice": "多倾��对方的想法，用行动表达关心。",
        "relationshipType": relationship_type,
    }


@tool_handler("recommend_skill")
async def execute_recommend_skill(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """
    推荐 Skill 给用户

    当 LLM 判断用户可能对某个未订阅的 Skill 感兴趣时调用此工具。
    前端收到此卡片后会显示推荐卡片，用户可以选择试用或了解更多。

    Args:
        skill_id: 推荐的 Skill ID
        reason: 推荐原因（基于对话内容生成）
        confidence: 推荐置信度 (high/medium/low)

    Returns:
        skill_recommendation 卡片数据
    """
    from .skill_loader import load_skill_metadata

    skill_id = args.get("skill_id")
    reason = args.get("reason", "")
    confidence = args.get("confidence", "medium")

    if not skill_id:
        return {"status": "error", "error": "skill_id is required"}

    # 加载 Skill 元数据
    metadata = load_skill_metadata(skill_id)
    if not metadata:
        return {"status": "error", "error": f"Skill not found: {skill_id}"}

    # 检查用户是否已订阅（如果已订阅则不推荐）
    user_id = context.user_id
    if user_id and user_id != "guest":
        try:
            from uuid import UUID
            from stores.skill_subscription_repo import SkillSubscriptionRepository

            user_uuid = UUID(user_id) if isinstance(user_id, str) else user_id
            subscription = await SkillSubscriptionRepository.get(user_uuid, skill_id)

            if subscription and subscription.status == "subscribed":
                # 用户已订阅，不需要推荐
                return {
                    "status": "skip",
                    "reason": "already_subscribed",
                    "skill_id": skill_id,
                }
        except Exception as e:
            logger.warning(f"Failed to check subscription for {skill_id}: {e}")

    # 返回推荐卡片数据
    return {
        "status": "success",
        "cardType": "skill_recommendation",
        "skill_id": skill_id,
        "skill": {
            "id": metadata.id,
            "name": metadata.name,
            "description": metadata.description,
            "icon": metadata.icon,
            "color": metadata.color,
            "tagline": metadata.showcase.tagline,
            "trial_messages": metadata.pricing.trial_messages,
        },
        "reason": reason,
        "confidence": confidence,
    }
