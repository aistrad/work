/**
 * Mentis OS v3.0 - Stream API Client
 *
 * SSE 流式输入处理
 */

export type StreamEvent = {
  event: string
  data: Record<string, unknown>
}

export type StreamInput = {
  content: string
  type?: string
  media_urls?: string[]
  client_metadata?: Record<string, unknown>
}

export type StreamCallbacks = {
  onEvent: (event: StreamEvent) => void
  onError?: (error: Error) => void
  onComplete?: () => void
}

const API_BASE = process.env.NEXT_PUBLIC_MENTIS_API_URL || "/api/mentis"

/**
 * 发送用户输入并接收 SSE 流式响应
 */
export function streamMentisInput(
  input: StreamInput,
  callbacks: StreamCallbacks
): AbortController {
  const abortController = new AbortController()

  const token =
    process.env.NEXT_PUBLIC_MENTIS_BEARER?.trim() ||
    process.env.NEXT_PUBLIC_MENTIS_USER_ID?.trim() ||
    ""

  fetch(`${API_BASE}/stream/input`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "text/event-stream",
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
    },
    body: JSON.stringify(input),
    signal: abortController.signal,
  })
    .then(async (response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const reader = response.body?.getReader()
      if (!reader) {
        throw new Error("No response body")
      }

      const decoder = new TextDecoder()
      let buffer = ""

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        buffer += decoder.decode(value, { stream: true })
        const lines = buffer.split("\n")
        buffer = lines.pop() || ""

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            try {
              const data = JSON.parse(line.slice(6))
              callbacks.onEvent(data)
            } catch {
              // Ignore parse errors for malformed SSE
            }
          }
        }
      }

      callbacks.onComplete?.()
    })
    .catch((error) => {
      if (error.name !== "AbortError") {
        callbacks.onError?.(error)
      }
    })

  return abortController
}

/**
 * 获取用户当前状态
 */
export async function fetchUserState(): Promise<Record<string, unknown> | null> {
  const token =
    process.env.NEXT_PUBLIC_MENTIS_BEARER?.trim() ||
    process.env.NEXT_PUBLIC_MENTIS_USER_ID?.trim() ||
    ""

  try {
    const response = await fetch(`${API_BASE}/user/state`, {
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    })

    if (!response.ok) {
      return null
    }

    return response.json()
  } catch {
    return null
  }
}

/**
 * 完成 Action Card
 */
export async function completeAction(actionId: string): Promise<boolean> {
  const token =
    process.env.NEXT_PUBLIC_MENTIS_BEARER?.trim() ||
    process.env.NEXT_PUBLIC_MENTIS_USER_ID?.trim() ||
    ""

  try {
    const response = await fetch(`${API_BASE}/actions/${actionId}/complete`, {
      method: "POST",
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    })

    return response.ok
  } catch {
    return false
  }
}

/**
 * 推迟 Action Card
 */
export async function dismissAction(actionId: string): Promise<boolean> {
  const token =
    process.env.NEXT_PUBLIC_MENTIS_BEARER?.trim() ||
    process.env.NEXT_PUBLIC_MENTIS_USER_ID?.trim() ||
    ""

  try {
    const response = await fetch(`${API_BASE}/actions/${actionId}/dismiss`, {
      method: "POST",
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    })

    return response.ok
  } catch {
    return false
  }
}
