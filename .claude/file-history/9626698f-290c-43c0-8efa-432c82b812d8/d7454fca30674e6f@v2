"""
VibeLife API Test Configuration
pytest 配置和共享 fixtures

v6.8 更新:
- 支持新的路由结构 (account, commerce, skills, chat_v5)
- 完善的 mock fixtures
- 支持 httpx AsyncClient
"""

import os
import pytest
import asyncio
from datetime import datetime, timedelta
from typing import AsyncGenerator
from unittest.mock import AsyncMock, MagicMock, patch
from uuid import UUID

# 设置测试环境变量
os.environ["VIBELIFE_ENV"] = "test"
os.environ["VIBELIFE_DB_URL"] = "postgresql://postgres:test@localhost:5432/vibelife_test"


# ═══════════════════════════════════════════════════════════════════════════
# Event Loop
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture(scope="session")
def event_loop():
    """创建 session 级别的事件循环"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


# ═══════════════════════════════════════════════════════════════════════════
# App & Client Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def app():
    """创建测试 app 实例"""
    # 延迟导入避免循环依赖
    from main import app
    return app


@pytest.fixture
async def client(app) -> AsyncGenerator:
    """Async HTTP client for testing"""
    from httpx import AsyncClient, ASGITransport

    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac


@pytest.fixture
def sync_client(app):
    """Sync HTTP client for simple tests"""
    from fastapi.testclient import TestClient
    return TestClient(app)


# ═══════════════════════════════════════════════════════════════════════════
# User & Auth Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def sample_user_id():
    """示例用户 ID"""
    return UUID("550e8400-e29b-41d4-a716-446655440000")


@pytest.fixture
def sample_user(sample_user_id):
    """示例用户数据"""
    return {
        "id": str(sample_user_id),
        "vibe_id": "VB20260105001",
        "display_name": "测试用户",
        "email": "test@example.com",
        "birth_datetime": datetime(1990, 5, 15, 10, 30),
        "birth_location": "北京",
        "timezone": "Asia/Shanghai",
        "language": "zh-CN",
        "created_at": datetime(2026, 1, 1)
    }


@pytest.fixture
def mock_current_user(sample_user_id):
    """Mock 已认证用户"""
    from dataclasses import dataclass

    @dataclass
    class CurrentUser:
        user_id: UUID
        vibe_id: str
        display_name: str
        email: str = None

    return CurrentUser(
        user_id=sample_user_id,
        vibe_id="VB20260105001",
        display_name="测试用户",
        email="test@example.com"
    )


@pytest.fixture
def auth_headers():
    """认证请求头"""
    return {"Authorization": "Bearer test_token"}


@pytest.fixture
def guest_headers():
    """访客请求头"""
    return {"X-Test-Tier": "guest"}


@pytest.fixture
def free_headers():
    """免费用户请求头"""
    return {"X-Test-Tier": "free"}


@pytest.fixture
def paid_headers():
    """付费用户请求头"""
    return {"X-Test-Tier": "paid"}


# ═══════════════════════════════════════════════════════════════════════════
# Service Mock Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def mock_auth_service():
    """Mock AuthService"""
    with patch("routes.account.AuthService") as mock:
        mock.register = AsyncMock(return_value={
            "access_token": "test_access_token",
            "refresh_token": "test_refresh_token",
            "expires_in": 3600,
            "user": {
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "vibe_id": "VB20260105001",
                "display_name": "新用户"
            }
        })
        mock.login = AsyncMock(return_value={
            "access_token": "test_access_token",
            "refresh_token": "test_refresh_token",
            "expires_in": 3600,
            "user": {
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "vibe_id": "VB20260105001"
            }
        })
        mock.refresh_token = AsyncMock(return_value={
            "access_token": "new_access_token",
            "refresh_token": "new_refresh_token",
            "expires_in": 3600,
            "user": {"user_id": "550e8400-e29b-41d4-a716-446655440000"}
        })
        yield mock


@pytest.fixture
def mock_oauth_service():
    """Mock OAuthService"""
    with patch("routes.account.OAuthService") as mock:
        mock.google_login = AsyncMock(return_value={
            "access_token": "google_access_token",
            "refresh_token": "google_refresh_token",
            "expires_in": 3600,
            "user": {
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "vibe_id": "VB20260105001",
                "display_name": "Google User"
            }
        })
        mock.apple_login = AsyncMock(return_value={
            "access_token": "apple_access_token",
            "refresh_token": "apple_refresh_token",
            "expires_in": 3600,
            "user": {
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "vibe_id": "VB20260105001",
                "display_name": "Apple User"
            }
        })
        yield mock


@pytest.fixture
def mock_guest_session_service():
    """Mock GuestSessionService"""
    with patch("routes.account.GuestSessionService") as mock:
        mock.create_session = AsyncMock(return_value={
            "session_id": "guest_session_123",
            "expires_at": datetime.now() + timedelta(days=30)
        })
        mock.get_session = AsyncMock(return_value={
            "session_id": "guest_session_123",
            "birth_datetime": None,
            "birth_location": None,
            "gender": None,
            "voice_mode": "warm",
            "skill": "bazi",
            "expires_at": datetime.now() + timedelta(days=30)
        })
        mock.save_onboarding_data = AsyncMock(return_value={
            "session_id": "guest_session_123",
            "birth_datetime": datetime(1990, 5, 15, 10, 30),
            "birth_location": "北京",
            "gender": "male",
            "voice_mode": "warm",
            "skill": "bazi",
            "expires_at": datetime.now() + timedelta(days=30)
        })
        mock.link_to_user = AsyncMock(return_value=True)
        yield mock


@pytest.fixture
def mock_user_repository(sample_user):
    """Mock UserRepository"""
    with patch("routes.account.UserRepository") as mock:
        mock.get_by_id = AsyncMock(return_value=sample_user)
        mock.update = AsyncMock(return_value=sample_user)
        mock.get_consents = AsyncMock(return_value=[])
        yield mock


@pytest.fixture
def mock_skill_repository():
    """Mock SkillRepository"""
    with patch("routes.account.SkillRepository") as mock:
        mock.get_user_profiles = AsyncMock(return_value=[
            {"skill_id": "bazi", "profile_data": {}, "total_sessions": 5},
            {"skill_id": "zodiac", "profile_data": {}, "total_sessions": 3}
        ])
        mock.get_user_insights = AsyncMock(return_value=[
            {"content": "用户关注事业发展", "created_at": datetime.now()}
        ])
        yield mock


@pytest.fixture
def mock_subscription_repository():
    """Mock SubscriptionRepository"""
    with patch("routes.account.SubscriptionRepository") as mock:
        mock.get_user_subscription = AsyncMock(return_value={
            "plan_id": "paid",
            "status": "active"
        })
        yield mock


@pytest.fixture
def mock_wechat_service():
    """Mock WechatService"""
    with patch("routes.account.WechatService") as mock:
        mock.generate_qrcode = AsyncMock(return_value={
            "scene_id": "test_scene_id_123",
            "qrcode_url": "https://open.weixin.qq.com/connect/qrconnect?...",
            "expires_at": (datetime.now() + timedelta(minutes=5)).isoformat()
        })
        mock.poll_status = AsyncMock(return_value={
            "status": "pending"
        })
        mock.handle_callback = AsyncMock(return_value={
            "access_token": "wechat_access_token",
            "refresh_token": "wechat_refresh_token",
            "token_type": "bearer",
            "expires_in": 3600,
            "user": {
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "vibe_id": "VB20260105001",
                "display_name": "微信用户"
            }
        })
        yield mock


@pytest.fixture
def mock_account_deletion_service():
    """Mock AccountDeletionService"""
    with patch("routes.account.AccountDeletionService") as mock:
        mock.request_deletion = AsyncMock(return_value={
            "status": "pending_deletion",
            "deletion_requested_at": datetime.now().isoformat(),
            "deletion_scheduled_at": (datetime.now() + timedelta(days=30)).isoformat(),
            "grace_period_days": 30,
            "message": "Your account will be permanently deleted..."
        })
        mock.cancel_deletion = AsyncMock(return_value={
            "status": "active",
            "message": "Account deletion request has been cancelled."
        })
        mock.get_deletion_status = AsyncMock(return_value={
            "status": "active",
            "can_cancel": False
        })
        yield mock


@pytest.fixture
def mock_entitlement_service():
    """Mock EntitlementService"""
    with patch("services.entitlement.EntitlementService") as mock:
        mock.get_entitlements = AsyncMock(return_value={
            "tier": "free",
            "daily_limit": 10,
            "used_today": 0,
            "skills": ["bazi", "zodiac"]
        })
        mock.check_can_chat = AsyncMock(return_value={
            "allowed": True,
            "remaining": 10
        })
        mock.upgrade_to_paid = AsyncMock(return_value=True)
        mock.downgrade_to_free = AsyncMock(return_value=True)
        yield mock


@pytest.fixture
def mock_quota_tracker():
    """Mock QuotaTracker"""
    with patch("routes.chat_v5.QuotaTracker") as mock:
        mock.check = AsyncMock(return_value=(True, ""))
        mock.record = AsyncMock()
        yield mock


# ═══════════════════════════════════════════════════════════════════════════
# Agent & LLM Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def mock_llm():
    """模拟 LLM 服务"""
    llm = MagicMock()
    llm.usage = {"input_tokens": 100, "output_tokens": 50}

    async def mock_stream(*args, **kwargs):
        yield {"type": "content", "content": "这是一个测试响应"}

    llm.stream = mock_stream
    return llm


@pytest.fixture
def mock_core_agent(mock_llm):
    """Mock CoreAgent"""
    agent = MagicMock()
    agent.usage = {"input_tokens": 100, "output_tokens": 50}

    async def mock_run(message, context):
        yield {"type": "content", "content": "测试响应内容"}

    agent.run = mock_run
    return agent


@pytest.fixture
def mock_stream_adapter():
    """Mock StreamAdapter"""
    adapter = MagicMock()

    async def mock_adapt(events):
        async for event in events:
            if isinstance(event, dict) and event.get("type") == "content":
                yield f'0:"{event.get("content", "")}"\n'
            else:
                yield '0:""\n'

    adapter.adapt = mock_adapt
    return adapter


# ═══════════════════════════════════════════════════════════════════════════
# Skill Service Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def mock_skill_service_registry():
    """Mock SkillServiceRegistry"""
    with patch("routes.skills.SkillServiceRegistry") as mock:
        mock.list_skills.return_value = ["bazi", "zodiac", "tarot", "career"]
        mock.list_services.return_value = [
            {"action": "chart", "description": "生成命盘"},
            {"action": "fortune", "description": "运势分析"},
            {"action": "compatibility", "description": "合盘分析"}
        ]
        mock.has_service.return_value = True
        mock.get_service.return_value = MagicMock(
            skill_id="bazi",
            action="chart",
            description="生成八字命盘",
            auth_required=False,
            entitlement=None
        )
        mock.execute = AsyncMock(return_value={
            "status": "success",
            "data": {
                "chart": {
                    "year": {"stem": "庚", "branch": "午"},
                    "month": {"stem": "丁", "branch": "巳"},
                    "day": {"stem": "甲", "branch": "子"},
                    "hour": {"stem": "乙", "branch": "巳"}
                }
            }
        })
        yield mock


# ═══════════════════════════════════════════════════════════════════════════
# Database Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def mock_db_pool():
    """模拟数据库连接池"""
    pool = AsyncMock()
    pool.fetch = AsyncMock(return_value=[])
    pool.fetchrow = AsyncMock(return_value=None)
    pool.fetchval = AsyncMock(return_value=None)
    pool.execute = AsyncMock(return_value="UPDATE 1")
    return pool


@pytest.fixture
async def test_db_pool():
    """
    真实测试数据库连接池（用于 E2E 测试）
    需要设置 VIBELIFE_TEST_DB_URL 环境变量
    """
    import asyncpg

    db_url = os.environ.get("VIBELIFE_TEST_DB_URL")
    if not db_url:
        pytest.skip("Test database not configured (set VIBELIFE_TEST_DB_URL)")

    pool = await asyncpg.create_pool(db_url)
    yield pool
    await pool.close()


# ═══════════════════════════════════════���═══════════════════════════════════
# Sample Data Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def sample_bazi_chart():
    """示例八字数据"""
    return {
        "year": {"stem": "庚", "branch": "午"},
        "month": {"stem": "丁", "branch": "巳"},
        "day": {"stem": "甲", "branch": "子"},
        "hour": {"stem": "乙", "branch": "巳"},
        "day_master": "甲",
        "day_master_element": "木"
    }


@pytest.fixture
def sample_zodiac_profile():
    """示例星座数据"""
    return {
        "sun_sign": "金牛座",
        "moon_sign": "双鱼座",
        "ascendant": "天蝎座",
        "sun_degree": 25.5,
        "moon_degree": 12.3,
        "asc_degree": 8.7
    }


@pytest.fixture
def sample_payment():
    """示例支付数据"""
    return {
        "id": "pay_123",
        "user_id": "550e8400-e29b-41d4-a716-446655440000",
        "amount_cents": 3900,
        "currency": "HKD",
        "status": "pending",
        "provider": "stripe",
        "provider_payment_id": "cs_test_123"
    }


# ═══════════════════════════════════════════════════════════════════════════
# Tool Registry Fixture
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture(autouse=True)
def init_tool_registry():
    """自动初始化 ToolRegistry (v6)"""
    try:
        from services.agent.tool_registry import ToolRegistry
        # 导入全局处理器以触发 @tool_handler 注册
        import services.agent.global_handlers  # noqa: F401
        ToolRegistry.initialize()
    except ImportError:
        pass  # 如果模块不存在，跳过


# ═══════════════════════════════════════════════════════════════════════════
# Stripe Mock Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def mock_stripe():
    """模拟 Stripe 服务"""
    stripe = MagicMock()

    # 模拟创建客户
    stripe.create_customer = AsyncMock(return_value="cus_test123")

    # 模拟创建 checkout session
    mock_session = MagicMock()
    mock_session.id = "cs_test123"
    mock_session.url = "https://checkout.stripe.com/test"
    mock_session.status = "open"
    stripe.checkout.Session.create = MagicMock(return_value=mock_session)

    # 模拟获取订阅
    stripe.get_subscription = AsyncMock(return_value={
        "id": "sub_test123",
        "status": "active",
        "current_period_end": datetime.now() + timedelta(days=30)
    })

    return stripe


# ═══════════════════════════════════════════════════════════════════════════
# Notification Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def mock_notification_service():
    """Mock NotificationService"""
    with patch("routes.notifications.NotificationService") as mock_cls:
        mock = MagicMock()
        mock.get_all = AsyncMock(return_value={
            "items": [
                {
                    "id": "notif_1",
                    "type": "daily_fortune",
                    "title": "今日运势",
                    "content": "今天适合...",
                    "is_read": False,
                    "created_at": datetime.now().isoformat()
                }
            ],
            "unread_count": 1
        })
        mock.get_unread = AsyncMock(return_value=[
            {
                "id": "notif_1",
                "type": "daily_fortune",
                "title": "今日运势",
                "is_read": False
            }
        ])
        mock.mark_read = AsyncMock(return_value=True)
        mock.get_today_daily = AsyncMock(return_value={
            "id": "daily_1",
            "type": "daily_fortune",
            "content": "今日运势内容..."
        })
        mock_cls.return_value = mock
        yield mock


# ═══════════════════════════════════════════════════════════════════════════
# Helper Functions
# ═══════════════════════════════════════════════════════════════════════════

def create_mock_get_current_user(mock_user):
    """创建 mock get_current_user 依赖"""
    async def mock_get_current_user():
        return mock_user
    return mock_get_current_user


def create_mock_get_optional_user(mock_user=None):
    """创建 mock get_optional_user 依赖"""
    async def mock_get_optional_user():
        return mock_user
    return mock_get_optional_user


# ═══════════════════════════════════════════════════════════════════════════
# Auth Override Fixtures (for FastAPI dependency injection)
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def override_auth(app, mock_current_user):
    """
    Override authentication dependencies for testing.
    Use this fixture when testing authenticated endpoints.
    """
    from services.identity import get_current_user, get_optional_user

    async def mock_get_current():
        return mock_current_user

    async def mock_get_optional():
        return mock_current_user

    app.dependency_overrides[get_current_user] = mock_get_current
    app.dependency_overrides[get_optional_user] = mock_get_optional

    yield mock_current_user

    # Cleanup
    app.dependency_overrides.pop(get_current_user, None)
    app.dependency_overrides.pop(get_optional_user, None)


@pytest.fixture
def override_auth_optional_none(app):
    """
    Override get_optional_user to return None (guest user).
    """
    from services.identity import get_optional_user

    async def mock_get_optional():
        return None

    app.dependency_overrides[get_optional_user] = mock_get_optional

    yield None

    app.dependency_overrides.pop(get_optional_user, None)


# ═══════════════════════════════════════════════════════════════════════════
# CardService & Core Skill Fixtures
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture
def card_service():
    """CardService 实例"""
    try:
        from skills.core.services import CardService
        return CardService()
    except ImportError:
        pytest.skip("CardService not available")


@pytest.fixture
def mock_life_context_data():
    """
    LifeContextData 工厂函数 (向后兼容)

    用法:
        data = mock_life_context_data("goals/2026/year", {"title": "目标"}, version=1)
    """
    from stores.unified_profile_repo import LifeContextData

    def _factory(path: str, content: dict, version: int = 1):
        return LifeContextData(
            path=path,
            content=content,
            version=version,
            updated_at=datetime.now()
        )

    return _factory


# ═══════════════════════════════════════════════════════════════════════════
# Real Database Fixtures (for integration tests)
# ═══════════════════════════════════════════════════════════════════════════

@pytest.fixture(scope="module")
async def real_db_pool():
    """
    真实数据库连接池 (module scope)

    使用前需设置 VIBELIFE_TEST_DB_URL 环境变量
    """
    from stores.db import init_db, close_db, get_db

    # 确保使用测试数据库
    test_db_url = os.environ.get("VIBELIFE_TEST_DB_URL")
    if not test_db_url:
        pytest.skip("VIBELIFE_TEST_DB_URL not set - skipping real database tests")

    await init_db()
    pool = await get_db()
    yield pool
    await close_db()


@pytest.fixture
async def test_user_profile(real_db_pool):
    """
    创建测试用户 Profile 并在测试后清理

    Returns:
        user_id: UUID - 测试用户 ID
    """
    from uuid import uuid4
    from stores.unified_profile_repo import UnifiedProfileRepository

    user_id = uuid4()

    # 尝试创建 vibe_users 记录
    try:
        async with real_db_pool.acquire() as conn:
            exists = await conn.fetchval(
                "SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name = 'vibe_users')"
            )
            if exists:
                await conn.execute(
                    """INSERT INTO vibe_users (id, vibe_id, display_name, email, password_hash, created_at)
                       VALUES ($1, $2, $3, $4, $5, NOW())
                       ON CONFLICT (id) DO NOTHING""",
                    user_id,
                    f"VB-TEST-{user_id.hex[:8].upper()}",
                    "测试用户",
                    f"test_{user_id.hex[:8]}@test.com",
                    "test_hash"
                )
    except Exception:
        pass

    # 创建 Profile
    await UnifiedProfileRepository.create_profile(user_id, {
        "birth_info": {"date": "1990-05-15", "time": "14:30", "place": "北京"},
        "life_context": {},
        "identity_prism": {},
        "preferences": {"voice_mode": "warm", "language": "zh-CN"},
        "skill_data": {}
    })

    yield user_id

    # 清理
    await UnifiedProfileRepository.delete_profile(user_id)
    try:
        async with real_db_pool.acquire() as conn:
            await conn.execute("DELETE FROM vibe_users WHERE id = $1", user_id)
    except Exception:
        pass
