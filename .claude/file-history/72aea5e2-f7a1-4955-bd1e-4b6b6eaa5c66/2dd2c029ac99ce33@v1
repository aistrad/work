"""
Image Generator - AI-generated posters for reports
Based on: vibelife spec v3.0

Uses Nano Banana (or similar AI image generation service) to create:
- Report poster images
- Relationship cards
- Social sharing images

Image Types:
- Full resolution (for paid users)
- Thumbnail with watermark (for lite/preview)
"""

import os
import io
import json
import base64
import logging
import httpx
from dataclasses import dataclass
from typing import Optional, Dict, Any
from enum import Enum
from uuid import uuid4

logger = logging.getLogger(__name__)

# Try to import Google Generative AI for Imagen
try:
    from google import genai
    from google.genai import types
    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False
    logger.warning("google-genai not installed, AI image generation will use placeholders")


class PosterStyle(str, Enum):
    MINIMAL = "minimal"      # 极简风格
    ARTISTIC = "artistic"    # 艺术风格
    VINTAGE = "vintage"      # 复古风格
    MODERN = "modern"        # 现代风格


@dataclass
class GeneratedImage:
    """Result of image generation"""
    id: str
    url: str
    thumbnail_url: Optional[str] = None
    width: int = 1080
    height: int = 1920
    style: PosterStyle = PosterStyle.MINIMAL
    has_watermark: bool = False
    prompt_used: Optional[str] = None

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "url": self.url,
            "thumbnail_url": self.thumbnail_url,
            "width": self.width,
            "height": self.height,
            "style": self.style.value,
            "has_watermark": self.has_watermark,
        }


# ═══════════════════════════════════════════════════════════════════════════
# Prompt Templates
# ═══════════════════════════════════════════════════════════════════════════

POSTER_PROMPT_TEMPLATES = {
    "bazi": {
        PosterStyle.MINIMAL: """Minimalist Chinese fortune telling poster,
elegant calligraphy of "{element}" element symbol,
soft watercolor wash background in {color} tones,
subtle gold accent lines,
negative space, zen aesthetic,
high quality, 4k""",

        PosterStyle.ARTISTIC: """Artistic Chinese Bazi destiny poster,
flowing ink painting style,
{element} element represented as {symbol},
dreamy ethereal atmosphere in {color} palette,
traditional meets modern aesthetic,
high quality, detailed, 4k""",

        PosterStyle.VINTAGE: """Vintage Chinese almanac style poster,
aged paper texture,
traditional {element} element iconography,
muted {color} color scheme,
subtle typography, classic composition,
high quality, textured, 4k""",
    },

    "zodiac": {
        PosterStyle.MINIMAL: """Minimalist astrology poster,
elegant constellation of {sign},
deep space background with subtle stars,
{color} accent glow,
clean lines, modern aesthetic,
high quality, 4k""",

        PosterStyle.ARTISTIC: """Artistic zodiac poster,
ethereal {sign} constellation visualization,
cosmic nebula swirls in {color} tones,
mystical yet sophisticated,
high quality, detailed, 4k""",

        PosterStyle.MODERN: """Modern astrology poster design,
geometric {sign} symbol,
gradient background in {color} spectrum,
bold typography elements,
contemporary minimalist style,
high quality, 4k""",
    },
}

# Element to visual mapping (for bazi)
ELEMENT_VISUALS = {
    "wood": {"symbol": "bamboo forest", "color": "green and brown"},
    "fire": {"symbol": "rising flames", "color": "red and orange"},
    "earth": {"symbol": "mountain peaks", "color": "yellow and brown"},
    "metal": {"symbol": "geometric crystals", "color": "white and silver"},
    "water": {"symbol": "flowing waves", "color": "blue and black"},
}

# Zodiac to visual mapping
ZODIAC_VISUALS = {
    "aries": {"symbol": "ram horns", "color": "red"},
    "taurus": {"symbol": "bull", "color": "green"},
    "gemini": {"symbol": "twins", "color": "yellow"},
    "cancer": {"symbol": "crab", "color": "silver"},
    "leo": {"symbol": "lion", "color": "gold"},
    "virgo": {"symbol": "maiden", "color": "brown"},
    "libra": {"symbol": "scales", "color": "pink"},
    "scorpio": {"symbol": "scorpion", "color": "crimson"},
    "sagittarius": {"symbol": "archer", "color": "purple"},
    "capricorn": {"symbol": "goat", "color": "dark green"},
    "aquarius": {"symbol": "water bearer", "color": "electric blue"},
    "pisces": {"symbol": "fish", "color": "sea green"},
}


# ═══════════════════════════════════════════════════════════════════════════
# Image Generator
# ═══════════════════════════════════════════════════════════════════════════

class ImageGenerator:
    """AI Image generation service using Google Gemini Imagen 3"""

    def __init__(self):
        # Get API configuration from environment
        self.google_api_key = os.getenv("GOOGLE_API_KEY", "")
        self.storage_url = os.getenv("IMAGE_STORAGE_URL", "/static/generated")
        self.storage_bucket = os.getenv("IMAGE_STORAGE_BUCKET", "")

        # Initialize Gemini client if available
        self._client = None
        if GEMINI_AVAILABLE and self.google_api_key:
            try:
                self._client = genai.Client(api_key=self.google_api_key)
                logger.info("Gemini Imagen client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize Gemini client: {e}")

    async def generate_poster(
        self,
        profile: Dict[str, Any],
        skill: str,
        prologue: str,
        style: PosterStyle = PosterStyle.MINIMAL,
        add_watermark: bool = False,
    ) -> Optional[GeneratedImage]:
        """
        Generate a poster image for a report.

        Args:
            profile: User profile data
            skill: "bazi" or "zodiac"
            prologue: Report prologue text (for context)
            style: Visual style for the poster
            add_watermark: Whether to add VibeLife watermark

        Returns:
            GeneratedImage or None if generation fails
        """
        try:
            # Build prompt based on skill and profile
            prompt = self._build_prompt(profile, skill, style)

            # Generate image using Gemini Imagen 3
            image_url = None
            if self._client:
                image_url = await self._generate_with_gemini(prompt)

            # Fallback to placeholder if generation fails
            if not image_url:
                logger.warning("Gemini generation failed, using placeholder")
                image_url = self._get_placeholder_url(skill, style)

            if not image_url:
                return None

            # Generate thumbnail
            thumbnail_url = await self._generate_thumbnail(image_url, add_watermark)

            return GeneratedImage(
                id=str(uuid4()),
                url=image_url,
                thumbnail_url=thumbnail_url,
                style=style,
                has_watermark=add_watermark,
                prompt_used=prompt,
            )

        except Exception as e:
            logger.error(f"Image generation failed: {e}")
            return None

    async def _generate_with_gemini(self, prompt: str) -> Optional[str]:
        """Generate image using Gemini Imagen 3"""
        if not self._client:
            return None

        try:
            # Use Imagen 3 model
            response = self._client.models.generate_images(
                model="imagen-3.0-generate-002",
                prompt=prompt,
                config=types.GenerateImagesConfig(
                    number_of_images=1,
                    aspect_ratio="9:16",  # Portrait for posters
                    safety_filter_level="BLOCK_MEDIUM_AND_ABOVE",
                    person_generation="DONT_ALLOW",  # Avoid person generation issues
                ),
            )

            if response.generated_images:
                image = response.generated_images[0]
                # Save image and return URL
                image_url = await self._save_image(image.image.image_bytes)
                return image_url

            return None

        except Exception as e:
            logger.error(f"Gemini Imagen generation failed: {e}")
            return None

    async def _save_image(self, image_bytes: bytes) -> Optional[str]:
        """Save image bytes and return URL"""
        try:
            image_id = str(uuid4())
            filename = f"{image_id}.png"

            # Try to upload to cloud storage if configured
            if self.storage_bucket:
                return await self._upload_to_cloud(image_bytes, filename)

            # Fallback: save locally
            local_path = os.path.join(self.storage_url, filename)
            os.makedirs(os.path.dirname(local_path), exist_ok=True)
            with open(local_path, "wb") as f:
                f.write(image_bytes)

            return f"{self.storage_url}/{filename}"

        except Exception as e:
            logger.error(f"Failed to save image: {e}")
            return None

    async def _upload_to_cloud(self, image_bytes: bytes, filename: str) -> Optional[str]:
        """Upload image to cloud storage (R2/S3/GCS)"""
        # This is a placeholder - implement based on your cloud storage provider
        # For now, return None to fall back to local storage
        logger.warning("Cloud storage upload not implemented, using local storage")
        return None

    def _build_prompt(
        self,
        profile: Dict[str, Any],
        skill: str,
        style: PosterStyle,
    ) -> str:
        """Build image generation prompt based on profile"""

        basic = profile.get("basic", {})

        if skill == "bazi":
            # Get day master element from profile
            element = basic.get("day_master_element", "wood")
            visuals = ELEMENT_VISUALS.get(element, ELEMENT_VISUALS["wood"])

            template = POSTER_PROMPT_TEMPLATES["bazi"].get(
                style,
                POSTER_PROMPT_TEMPLATES["bazi"][PosterStyle.MINIMAL]
            )

            return template.format(
                element=element,
                symbol=visuals["symbol"],
                color=visuals["color"],
            )
        else:
            # Get zodiac sign from profile
            sign = basic.get("zodiac_sign", "aries").lower()
            visuals = ZODIAC_VISUALS.get(sign, ZODIAC_VISUALS["aries"])

            template = POSTER_PROMPT_TEMPLATES["zodiac"].get(
                style,
                POSTER_PROMPT_TEMPLATES["zodiac"][PosterStyle.MINIMAL]
            )

            return template.format(
                sign=sign,
                symbol=visuals["symbol"],
                color=visuals["color"],
            )

    def _get_placeholder_url(self, skill: str, style: PosterStyle) -> str:
        """Get placeholder image URL for development"""
        # Use a placeholder service or local static file
        return f"{self.storage_url}/placeholder_{skill}_{style.value}.png"

    async def _generate_thumbnail(
        self,
        image_url: str,
        add_watermark: bool = False,
    ) -> str:
        """Generate thumbnail version of image"""
        # In production, this would resize the image and add watermark
        # For now, return the same URL with a thumbnail suffix
        if image_url.endswith(".png"):
            return image_url.replace(".png", "_thumb.png")
        return f"{image_url}?thumb=true"

    async def generate_relationship_card(
        self,
        user1_profile: Dict[str, Any],
        user2_profile: Dict[str, Any],
        relationship_summary: str,
        style: PosterStyle = PosterStyle.MINIMAL,
    ) -> Optional[GeneratedImage]:
        """Generate a shareable relationship card image"""
        # Build combined prompt for relationship
        prompt = """Elegant relationship compatibility card,
two intertwined abstract shapes representing connection,
harmonious color palette,
minimalist design, subtle patterns,
high quality, 4k"""

        image_url = None
        if self._client:
            image_url = await self._generate_with_gemini_square(prompt)

        if not image_url:
            image_url = f"{self.storage_url}/placeholder_relationship.png"

        if not image_url:
            return None

        return GeneratedImage(
            id=str(uuid4()),
            url=image_url,
            thumbnail_url=await self._generate_thumbnail(image_url, True),
            width=1080,
            height=1080,  # Square for relationship cards
            style=style,
            prompt_used=prompt,
        )

    async def _generate_with_gemini_square(self, prompt: str) -> Optional[str]:
        """Generate square image using Gemini Imagen 3"""
        if not self._client:
            return None

        try:
            response = self._client.models.generate_images(
                model="imagen-3.0-generate-002",
                prompt=prompt,
                config=types.GenerateImagesConfig(
                    number_of_images=1,
                    aspect_ratio="1:1",  # Square for cards
                    safety_filter_level="BLOCK_MEDIUM_AND_ABOVE",
                    person_generation="DONT_ALLOW",
                ),
            )

            if response.generated_images:
                image = response.generated_images[0]
                return await self._save_image(image.image.image_bytes)

            return None

        except Exception as e:
            logger.error(f"Gemini Imagen square generation failed: {e}")
            return None


# ═══════════════════════════════════════════════════════════════════════════
# Convenience Function
# ═══════════════════════════════════════════════════════════════════════════

async def generate_poster(
    profile: Dict[str, Any],
    skill: str,
    prologue: str = "",
    style: str = "minimal",
    add_watermark: bool = False,
) -> Optional[GeneratedImage]:
    """
    Convenience function to generate poster.

    Args:
        profile: User profile data
        skill: "bazi" or "zodiac"
        prologue: Report prologue text
        style: "minimal", "artistic", "vintage", or "modern"
        add_watermark: Whether to add watermark

    Returns:
        GeneratedImage or None
    """
    generator = ImageGenerator()
    style_enum = PosterStyle(style)
    return await generator.generate_poster(profile, skill, prologue, style_enum, add_watermark)
