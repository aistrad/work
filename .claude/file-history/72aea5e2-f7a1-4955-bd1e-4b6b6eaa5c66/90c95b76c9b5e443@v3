"""
Model Router - Cache Layer
In-memory caching for model routing configuration
"""
import logging
import asyncio
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
from dataclasses import dataclass, field

from .models import ModelProvider, Model, ModelRoute, QuotaRule

logger = logging.getLogger(__name__)


@dataclass
class CacheEntry:
    """缓存条目"""
    data: Any
    expires_at: datetime
    created_at: datetime = field(default_factory=datetime.utcnow)

    @property
    def is_expired(self) -> bool:
        return datetime.utcnow() > self.expires_at


class RouteCache:
    """
    路由配置缓存

    缓存策略：
    - 提供商/模型配置：较长 TTL（30分钟），变更不频繁
    - 路由规则：中等 TTL（5分钟），可能动态调整
    - 配额规则：较短 TTL（1分钟），需要相对实时
    """

    # 默认 TTL（秒）
    DEFAULT_TTL = 300  # 5 分钟
    PROVIDER_TTL = 1800  # 30 分钟
    MODEL_TTL = 1800  # 30 分钟
    ROUTE_TTL = 300  # 5 分钟
    QUOTA_TTL = 60  # 1 分钟

    def __init__(self):
        self._cache: Dict[str, CacheEntry] = {}
        self._lock = asyncio.Lock()
        self._stats = {
            "hits": 0,
            "misses": 0,
            "evictions": 0
        }

    # ═══════════════════════════════════════════════════════════════════════
    # Generic Cache Operations
    # ═══════════════════════════════════════════════════════════════════════

    async def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        async with self._lock:
            entry = self._cache.get(key)
            if entry is None:
                self._stats["misses"] += 1
                return None

            if entry.is_expired:
                del self._cache[key]
                self._stats["misses"] += 1
                self._stats["evictions"] += 1
                return None

            self._stats["hits"] += 1
            return entry.data

    async def set(self, key: str, value: Any, ttl_seconds: int = None) -> None:
        """设置缓存值"""
        ttl = ttl_seconds or self.DEFAULT_TTL
        async with self._lock:
            self._cache[key] = CacheEntry(
                data=value,
                expires_at=datetime.utcnow() + timedelta(seconds=ttl)
            )

    async def delete(self, key: str) -> bool:
        """删除缓存值"""
        async with self._lock:
            if key in self._cache:
                del self._cache[key]
                return True
            return False

    async def clear(self) -> None:
        """清空所有缓存"""
        async with self._lock:
            self._cache.clear()
            logger.info("Route cache cleared")

    async def clear_pattern(self, pattern: str) -> int:
        """清除匹配模式的缓存"""
        count = 0
        async with self._lock:
            keys_to_delete = [k for k in self._cache.keys() if pattern in k]
            for key in keys_to_delete:
                del self._cache[key]
                count += 1
        return count

    # ═══════════════════════════════════════════════════════════════════════
    # Typed Accessors
    # ═══════════════════════════════════════════════════════════════════════

    async def get_providers(self) -> Optional[List[ModelProvider]]:
        """获取缓存的提供商列表"""
        return await self.get("providers:all")

    async def set_providers(self, providers: List[ModelProvider]) -> None:
        """缓存提供商列表"""
        await self.set("providers:all", providers, self.PROVIDER_TTL)

    async def get_models(self) -> Optional[List[Model]]:
        """获取缓存的模型列表"""
        return await self.get("models:all")

    async def set_models(self, models: List[Model]) -> None:
        """缓存模型列表"""
        await self.set("models:all", models, self.MODEL_TTL)

    async def get_model(self, model_id: str) -> Optional[Model]:
        """获取缓存的单个模型"""
        return await self.get(f"models:{model_id}")

    async def set_model(self, model: Model) -> None:
        """缓存单个模型"""
        await self.set(f"models:{model.id}", model, self.MODEL_TTL)

    async def get_routes(self) -> Optional[List[ModelRoute]]:
        """获取缓存的路由规则列表"""
        return await self.get("routes:all")

    async def set_routes(self, routes: List[ModelRoute]) -> None:
        """缓存路由规则列表"""
        await self.set("routes:all", routes, self.ROUTE_TTL)

    async def get_quota_rules(self) -> Optional[List[QuotaRule]]:
        """获取缓存的配额规则列表"""
        return await self.get("quotas:all")

    async def set_quota_rules(self, rules: List[QuotaRule]) -> None:
        """缓存配额规则列表"""
        await self.set("quotas:all", rules, self.QUOTA_TTL)

    # ═══════════════════════════════════════════════════════════════════════
    # Utility Methods
    # ═══════════════════════════════════════════════════════════════════════

    async def cleanup_expired(self) -> int:
        """清理过期缓存"""
        count = 0
        async with self._lock:
            now = datetime.utcnow()
            keys_to_delete = [
                k for k, v in self._cache.items()
                if v.expires_at < now
            ]
            for key in keys_to_delete:
                del self._cache[key]
                count += 1
        if count > 0:
            logger.debug(f"Cleaned up {count} expired cache entries")
        return count

    def get_stats(self) -> Dict[str, Any]:
        """获取缓存统计"""
        total = self._stats["hits"] + self._stats["misses"]
        hit_rate = self._stats["hits"] / total if total > 0 else 0
        return {
            **self._stats,
            "total_requests": total,
            "hit_rate": f"{hit_rate:.2%}",
            "cache_size": len(self._cache)
        }

    async def invalidate_routes(self) -> None:
        """使路由缓存失效（配置变更时调用）"""
        await self.clear_pattern("routes:")
        logger.info("Route cache invalidated")

    async def invalidate_all(self) -> None:
        """使所有缓存失效"""
        await self.clear()
        self._stats = {"hits": 0, "misses": 0, "evictions": 0}
        logger.info("All cache invalidated")


# 全局缓存实例
_cache: Optional[RouteCache] = None


def get_cache() -> RouteCache:
    """获取缓存实例"""
    global _cache
    if _cache is None:
        _cache = RouteCache()
    return _cache
