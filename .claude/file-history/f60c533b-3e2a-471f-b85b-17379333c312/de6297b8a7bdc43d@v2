"""
Core Skill Tool Handlers - 全局工具执行器

所有 Skill 共享的工具执行器。
使用 @tool_handler 装饰器注册，自动被 ToolRegistry 发现。
"""
import logging
from datetime import datetime
from typing import Dict, Any, List

from services.agent.tool_registry import tool_handler, ToolContext

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# 搜索型工具
# ═══════════════════════════════════════════════════════════════════════════

@tool_handler("search_db")
async def execute_search_db(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """从数据库检索知识或案例"""
    from services.knowledge.repository import get_knowledge_repository

    table = args.get("table", "knowledge_chunks")
    query = args.get("query", "")
    filters = args.get("filters", {})
    top_k = args.get("top_k", 5)

    # 自动添加当前 skill_id 到 filters
    if context.skill_id and "skill_id" not in filters:
        filters["skill_id"] = context.skill_id
    if context.scenario_id and "scenario_id" not in filters:
        filters["scenario_id"] = context.scenario_id

    try:
        repo = get_knowledge_repository()
        results = await repo.search_db(
            table=table,
            query=query,
            filters=filters,
            top_k=top_k
        )

        return {
            "status": "success",
            "table": table,
            "query": query,
            "count": len(results),
            "results": results
        }
    except Exception as e:
        logger.error(f"search_db failed: {e}")
        return {
            "status": "error",
            "error": str(e),
            "results": []
        }


# ═══════════════════════════════════════════════════════════════════════════
# 收集型工具
# ═══════════════════════════════════════════════════════════════════════════

@tool_handler("ask_user_question")
async def execute_ask_user_question(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """主动向用户提问"""
    question = args.get("question", "")
    options = args.get("options", [])

    return {
        "status": "asking",
        "cardType": "question_card",
        "question": question,
        "options": options[:4] if options else [],  # 最多4个选项
    }


@tool_handler("request_info")
async def execute_request_info(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """向用户请求信息"""
    info_type = args.get("info_type", "birth")
    question = args.get("question")

    fields_map = {
        "birth": [
            {"id": "birthDate", "label": "出生日期", "type": "date", "required": True, "placeholder": ""},
            {"id": "birthTime", "label": "出生时间", "type": "time", "required": True, "placeholder": ""},
            {"id": "birthPlace", "label": "出生地点", "type": "text", "required": False, "placeholder": "城市名"},
            {"id": "gender", "label": "性别", "type": "select", "required": True, "options": [
                {"value": "male", "label": "男"},
                {"value": "female", "label": "女"},
            ]},
        ],
        "context": [
            {"id": "situation", "label": "当前情况", "type": "textarea", "required": True, "placeholder": "描述你目前面临的情况"},
        ],
        "goals": [
            {"id": "goals", "label": "你的目标", "type": "textarea", "required": True, "placeholder": "你想达成什么"},
        ],
        "concerns": [
            {"id": "concerns", "label": "你的困惑", "type": "textarea", "required": True, "placeholder": "最困扰你的是什么"},
        ],
    }

    return {
        "status": "collecting",
        "cardType": "collect_form",
        "infoType": info_type,
        "question": question,
        "fields": fields_map.get(info_type, fields_map["birth"]),
    }


# ═══════════════════════════════════════════════════════════════════════════
# 展示型工具
# ═══════════════════════════════════════════════════════════════════════════

@tool_handler("show_service_menu")
async def execute_show_service_menu(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示服务目录卡片"""
    services = args.get("services") or [
        {"id": "bazi", "name": "八字命理", "description": "八字排盘、运势分析", "icon": "compass"},
        {"id": "zodiac", "name": "星座占星", "description": "星盘解读、行运分析", "icon": "star"},
        {"id": "tarot", "name": "塔罗占卜", "description": "塔罗牌阵、问题指引", "icon": "cards"},
        {"id": "career", "name": "职业规划", "description": "职业方向、发展建议", "icon": "briefcase"},
    ]

    return {
        "status": "success",
        "cardType": "service_menu",
        "services": services,
    }


@tool_handler("show_skill_services")
async def execute_show_skill_services(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示 Skill 服务目录"""
    from services.agent.skill_loader import get_skill_services

    skill_id = args.get("skill_id") or context.skill_id or "bazi"

    # 从 SKILL.md 动态加载服务目录
    skill_services = get_skill_services(skill_id)

    if skill_services:
        return {
            "status": "success",
            "cardType": "skill_services",
            "skillId": skill_id,
            "skillName": skill_services.get("skill_name", skill_id),
            "description": skill_services.get("description", ""),
            "services": skill_services.get("services", {}),
        }

    # 回退到默认服务列表
    default_services = {
        "bazi": {
            "entry": [
                {"scenario_id": "basic_reading", "name": "基础命盘", "description": "快速了解你的八字命盘", "tier": "entry"},
                {"scenario_id": "personality", "name": "性格分析", "description": "从命盘看你的性格特点", "tier": "entry"},
            ],
            "standard": [
                {"scenario_id": "yearly_fortune", "name": "流年运势", "description": "详细分析今年运势走向", "tier": "standard"},
                {"scenario_id": "career", "name": "事业运势", "description": "深度分析事业发展方向", "tier": "standard"},
            ],
            "professional": [
                {"scenario_id": "life_blueprint", "name": "人生蓝图", "description": "全面深度的命盘分析", "tier": "professional"},
            ],
        },
        "zodiac": {
            "entry": [
                {"scenario_id": "basic_chart", "name": "星盘解读", "description": "本命星盘分析", "tier": "entry"},
            ],
            "standard": [
                {"scenario_id": "transit", "name": "行运分析", "description": "当前行星影响", "tier": "standard"},
            ],
        },
        "tarot": {
            "entry": [
                {"scenario_id": "single_card", "name": "单牌占卜", "description": "快速问答", "tier": "entry"},
            ],
        },
        "career": {
            "entry": [
                {"scenario_id": "direction", "name": "职业方向", "description": "适合的职业领域", "tier": "entry"},
            ],
        },
    }

    return {
        "status": "success",
        "cardType": "skill_services",
        "skillId": skill_id,
        "services": default_services.get(skill_id, {}),
    }


@tool_handler("recommend_service")
async def execute_recommend_service(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """推荐升级服务"""
    scenario_id = args.get("scenario_id", "")
    reason = args.get("reason", "")
    highlights = args.get("highlights", [])

    return {
        "status": "success",
        "cardType": "service_recommendation",
        "scenarioId": scenario_id,
        "reason": reason,
        "highlights": highlights,
    }


@tool_handler("show_insight")
async def execute_show_insight(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示洞察卡片"""
    insight_type = args.get("insight_type", "general")
    title = args.get("title", "关键洞察")
    content = args.get("content", "")

    return {
        "status": "success",
        "cardType": "insight_card",
        "insightType": insight_type,
        "insights": [
            {
                "id": f"ins-{datetime.now().timestamp()}",
                "title": title,
                "content": content,
            }
        ],
    }


@tool_handler("show_report")
async def execute_show_report(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示完整报告"""
    report_type = args.get("report_type", "lite")
    report_id = args.get("report_id")

    # 如果指定了 report_id，尝试获取
    if report_id:
        try:
            from stores import report_repo
            report = await report_repo.get_report(report_id)
            if report:
                return {
                    "status": "success",
                    "cardType": "report_card",
                    **_normalize_report(report.to_dict())
                }
        except Exception as e:
            logger.error(f"Failed to get report {report_id}: {e}")

    # 尝试获取用户最新报告
    if context.user_id and context.user_id != "guest":
        try:
            from stores import report_repo
            from uuid import UUID
            user_uuid = UUID(context.user_id)
            reports = await report_repo.list_reports(user_uuid, skill=context.skill_id, limit=1)
            if reports:
                report = await report_repo.get_report(reports[0].id)
                if report:
                    return {
                        "status": "success",
                        "cardType": "report_card",
                        **_normalize_report(report.to_dict())
                    }
        except Exception as e:
            logger.error(f"Failed to get user reports: {e}")

    # 返回演示报告
    return {
        "status": "success",
        "cardType": "report_card",
        "id": "demo",
        "title": f"{'星盘' if context.skill_id == 'zodiac' else '八字'}报告（演示）",
        "createdAt": datetime.now().strftime("%Y-%m-%d"),
        "prologue": "这是一个演示版报告卡片。完善个人信息后可生成真实报告。",
        "isPaid": False,
        "reportType": report_type,
    }


def _normalize_report(report: Dict[str, Any]) -> Dict[str, Any]:
    """标准化报告字段名"""
    return {
        **report,
        "createdAt": report.get("created_at") or report.get("createdAt"),
        "isPaid": report.get("is_paid") if report.get("isPaid") is None else report.get("isPaid"),
        "reportType": report.get("report_type") or report.get("reportType"),
    }


@tool_handler("show_relationship")
async def execute_show_relationship(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示关系分析结果"""
    partner_info = args.get("partner_info", {})
    relationship_type = args.get("relationship_type", "general")

    # 关系类型描述 - 使用标准 ASCII 注释
    type_descriptions = {
        "romantic": "恋爱关系",
        "friendship": "友谊关系",
        "family": "家庭关系",
        "work": "工作关系",
        "general": "综合关系",
    }

    # 基础关系分析数据
    analysis_data = {
        "romantic": {
            "dimensions": [
                {"name": "情感连接", "score": 78, "description": "情感共鸣较好，能感受彼此"},
                {"name": "沟通质量", "score": 72, "description": "沟通顺畅，偶有误解"},
                {"name": "价值观契合", "score": 80, "description": "核心价值观一致"},
                {"name": "生活习惯", "score": 68, "description": "需要相互适应"},
                {"name": "长期潜力", "score": 75, "description": "有发展空间"},
            ],
            "strengths": ["情感基础稳固", "相互尊重", "共同成长意愿"],
            "challenges": ["沟通方式差异", "生活节奏不同"],
            "advice": "多创造共同经历，用行动表达关心。",
        },
        "friendship": {
            "dimensions": [
                {"name": "信任度", "score": 82, "description": "相互信任，可以倾诉"},
                {"name": "共同兴趣", "score": 75, "description": "有共同话题"},
                {"name": "支持度", "score": 78, "description": "愿意相互支持"},
                {"name": "边界感", "score": 80, "description": "尊重彼此空间"},
            ],
            "strengths": ["真诚相待", "互相支持", "保持独立"],
            "challenges": ["时间协调", "期望管理"],
            "advice": "保持联系的同时尊重各自的生活节奏。",
        },
        "family": {
            "dimensions": [
                {"name": "亲密度", "score": 75, "description": "家庭纽带稳固"},
                {"name": "沟通模式", "score": 68, "description": "沟通有改善空间"},
                {"name": "期望管理", "score": 65, "description": "需要调整期望"},
                {"name": "边界设定", "score": 70, "description": "边界逐渐清晰"},
            ],
            "strengths": ["血缘纽带", "无条件支持", "共同记忆"],
            "challenges": ["代际差异", "期望落差"],
            "advice": "接纳差异，专注于建立新的相处模式。",
        },
        "work": {
            "dimensions": [
                {"name": "协作效率", "score": 78, "description": "配合默契"},
                {"name": "沟通效果", "score": 75, "description": "工作沟通顺畅"},
                {"name": "信任基础", "score": 72, "description": "专业信任建立中"},
                {"name": "目标一致", "score": 80, "description": "工作目标一致"},
            ],
            "strengths": ["专业互补", "目标一致", "高效协作"],
            "challenges": ["风格差异", "压力传导"],
            "advice": "明确分工，保持专业边界。",
        },
        "general": {
            "dimensions": [
                {"name": "整体和谐", "score": 75, "description": "关系整体和谐"},
                {"name": "沟通质量", "score": 72, "description": "沟通基本顺畅"},
                {"name": "相互理解", "score": 70, "description": "理解程度中等"},
                {"name": "发展潜力", "score": 78, "description": "有提升空间"},
            ],
            "strengths": ["相互尊重", "愿意沟通"],
            "challenges": ["需要更多了解"],
            "advice": "增加互动，加深了解。",
        },
    }

    data = analysis_data.get(relationship_type, analysis_data["general"])

    # 计算总分
    overall_score = int(sum(d["score"] for d in data["dimensions"]) / len(data["dimensions"]))

    return {
        "status": "success",
        "cardType": "relationship_card",
        "relationshipType": relationship_type,
        "relationshipTypeName": type_descriptions.get(relationship_type, "综合关系"),
        "partnerInfo": partner_info,
        "overallScore": overall_score,
        "dimensions": data["dimensions"],
        "strengths": data["strengths"],
        "challenges": data["challenges"],
        "advice": data["advice"],
    }


# ═══════════════════════════════════════════════════════════════════════════
# 用户数据工具
# ═══════════════════════════════════════════════════════════════════════════

@tool_handler("read_user_data")
async def execute_read_user_data(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """读取用户数据"""
    from uuid import UUID
    from skills.core.services.user_data import get_user_data_service

    path = args.get("path", "")

    if not context.user_id or context.user_id == "guest":
        return {
            "status": "error",
            "error": "需要登录才能读取数据",
        }

    try:
        service = get_user_data_service()
        user_uuid = UUID(context.user_id)
        data = await service.read(user_uuid, path)

        if data:
            return {
                "status": "success",
                "path": path,
                "data": data.to_dict(),
            }
        else:
            return {
                "status": "not_found",
                "path": path,
                "message": f"未找到数据: {path}",
            }
    except Exception as e:
        logger.error(f"read_user_data failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


@tool_handler("write_user_data")
async def execute_write_user_data(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """写入用户数据"""
    from uuid import UUID
    from skills.core.services.user_data import get_user_data_service

    path = args.get("path", "")
    content = args.get("content", {})
    data_type = args.get("data_type")

    if not context.user_id or context.user_id == "guest":
        return {
            "status": "error",
            "error": "需要登录才能保存数据",
        }

    if not path:
        return {
            "status": "error",
            "error": "path 参数不能为空",
        }

    if not content:
        return {
            "status": "error",
            "error": "content 参数不能为空",
        }

    try:
        service = get_user_data_service()
        user_uuid = UUID(context.user_id)
        data = await service.write(user_uuid, path, content, data_type)

        return {
            "status": "success",
            "path": path,
            "version": data.version,
            "message": f"数据已保存到 {path}",
        }
    except Exception as e:
        logger.error(f"write_user_data failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


@tool_handler("query_user_data")
async def execute_query_user_data(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """查询用户数据"""
    from uuid import UUID
    from skills.core.services.user_data import get_user_data_service

    data_type = args.get("data_type")
    path_prefix = args.get("path_prefix")
    filters = args.get("filters")
    limit = args.get("limit", 20)

    if not context.user_id or context.user_id == "guest":
        return {
            "status": "error",
            "error": "需要登录才能查询数据",
        }

    try:
        service = get_user_data_service()
        user_uuid = UUID(context.user_id)
        results = await service.query(
            user_uuid,
            data_type=data_type,
            path_prefix=path_prefix,
            filters=filters,
            limit=limit,
        )

        return {
            "status": "success",
            "count": len(results),
            "results": [r.to_dict() for r in results],
        }
    except Exception as e:
        logger.error(f"query_user_data failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


@tool_handler("delete_user_data")
async def execute_delete_user_data(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """删除用户数据"""
    from uuid import UUID
    from skills.core.services.user_data import get_user_data_service

    path = args.get("path", "")

    if not context.user_id or context.user_id == "guest":
        return {
            "status": "error",
            "error": "需要登录才能删除数据",
        }

    if not path:
        return {
            "status": "error",
            "error": "path 参数不能为空",
        }

    try:
        service = get_user_data_service()
        user_uuid = UUID(context.user_id)
        deleted = await service.delete(user_uuid, path)

        if deleted:
            return {
                "status": "success",
                "path": path,
                "message": f"已删除: {path}",
            }
        else:
            return {
                "status": "not_found",
                "path": path,
                "message": f"未找到数据: {path}",
            }
    except Exception as e:
        logger.error(f"delete_user_data failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


# ═══════════════════════════════════════════════════════════════════════════
# 提醒工具
# ═══════════════════════════════════════════════════════════════════════════

@tool_handler("schedule_reminder")
async def execute_schedule_reminder(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """设置定时提醒"""
    from uuid import UUID
    from skills.core.services.reminder import get_reminder_service

    title = args.get("title", "")
    schedule = args.get("schedule", "")
    schedule_type = args.get("schedule_type", "daily")
    reminder_type = args.get("reminder_type", "custom")
    description = args.get("description")
    metadata = args.get("metadata", {})

    if not context.user_id or context.user_id == "guest":
        return {
            "status": "error",
            "error": "需要登录才能设置提醒",
        }

    if not title:
        return {
            "status": "error",
            "error": "title 参数不能为空",
        }

    if not schedule:
        return {
            "status": "error",
            "error": "schedule 参数不能为空",
        }

    try:
        service = get_reminder_service()
        user_uuid = UUID(context.user_id)
        reminder = await service.create(
            user_id=user_uuid,
            reminder_type=reminder_type,
            title=title,
            schedule=schedule,
            schedule_type=schedule_type,
            description=description,
            metadata=metadata,
        )

        return {
            "status": "success",
            "reminder": reminder.to_dict(),
            "message": f"已设置提醒: {title}",
        }
    except Exception as e:
        logger.error(f"schedule_reminder failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


@tool_handler("list_reminders")
async def execute_list_reminders(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """列出用户提醒"""
    from uuid import UUID
    from skills.core.services.reminder import get_reminder_service

    reminder_type = args.get("reminder_type")
    status = args.get("status", "active")

    if not context.user_id or context.user_id == "guest":
        return {
            "status": "error",
            "error": "需要登录才能查看提醒",
        }

    try:
        service = get_reminder_service()
        user_uuid = UUID(context.user_id)
        reminders = await service.list(
            user_uuid,
            reminder_type=reminder_type,
            status=status,
        )

        return {
            "status": "success",
            "count": len(reminders),
            "reminders": [r.to_dict() for r in reminders],
        }
    except Exception as e:
        logger.error(f"list_reminders failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


@tool_handler("cancel_reminder")
async def execute_cancel_reminder(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """取消提醒"""
    from uuid import UUID
    from skills.core.services.reminder import get_reminder_service

    reminder_id = args.get("reminder_id", "")

    if not context.user_id or context.user_id == "guest":
        return {
            "status": "error",
            "error": "需要登录才能取消提醒",
        }

    if not reminder_id:
        return {
            "status": "error",
            "error": "reminder_id 参数不能为空",
        }

    try:
        service = get_reminder_service()
        user_uuid = UUID(context.user_id)
        reminder_uuid = UUID(reminder_id)
        cancelled = await service.cancel(user_uuid, reminder_uuid)

        if cancelled:
            return {
                "status": "success",
                "message": "提醒已取消",
            }
        else:
            return {
                "status": "not_found",
                "message": "未找到该提醒或已取消",
            }
    except Exception as e:
        logger.error(f"cancel_reminder failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


# ═══════════════════════════════════════════════════════════════════════════
# 目标追踪展示工具
# ═══════════════════════════════════════════════════════════════════════════

@tool_handler("show_goal_tree")
async def execute_show_goal_tree(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示目标树卡片"""
    from uuid import UUID
    from skills.core.services.user_data import get_user_data_service

    root_goal_path = args.get("root_goal_path")

    if not context.user_id or context.user_id == "guest":
        # 返回演示数据
        return {
            "status": "success",
            "cardType": "goal_tree",
            "goals": [
                {
                    "id": "demo-goal-1",
                    "title": "2026年目标示例",
                    "level": "year",
                    "progress": 25,
                    "status": "active",
                    "children": [
                        {"id": "demo-q1", "title": "Q1: 完成认证", "level": "quarter", "progress": 50, "status": "active"},
                        {"id": "demo-q2", "title": "Q2: 主导项目", "level": "quarter", "progress": 0, "status": "pending"},
                    ],
                }
            ],
            "isDemo": True,
        }

    try:
        service = get_user_data_service()
        user_uuid = UUID(context.user_id)

        # 查询用户目标
        if root_goal_path:
            results = await service.query(user_uuid, path_prefix=root_goal_path)
        else:
            results = await service.query(user_uuid, data_type="goals")

        goals = []
        for r in results:
            goal = r.content.copy()
            goal["id"] = r.data_path
            goal["path"] = r.data_path
            goals.append(goal)

        return {
            "status": "success",
            "cardType": "goal_tree",
            "goals": goals,
            "count": len(goals),
        }
    except Exception as e:
        logger.error(f"show_goal_tree failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


@tool_handler("show_daily_plan")
async def execute_show_daily_plan(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示今日计划卡片"""
    from uuid import UUID
    from skills.core.services.user_data import get_user_data_service

    date_str = args.get("date") or datetime.now().strftime("%Y-%m-%d")

    if not context.user_id or context.user_id == "guest":
        # 返回演示数据
        return {
            "status": "success",
            "cardType": "daily_plan",
            "date": date_str,
            "tasks": [
                {"id": "demo-1", "title": "完成报告", "time": "09:00", "completed": False, "priority": "high"},
                {"id": "demo-2", "title": "团队会议", "time": "14:00", "completed": False, "priority": "medium"},
                {"id": "demo-3", "title": "阅读30分钟", "time": "21:00", "completed": False, "priority": "low"},
            ],
            "isDemo": True,
        }

    try:
        service = get_user_data_service()
        user_uuid = UUID(context.user_id)

        # 查询当日计划
        plan_path = f"plans/daily/{date_str}"
        data = await service.read(user_uuid, plan_path)

        if data:
            return {
                "status": "success",
                "cardType": "daily_plan",
                "date": date_str,
                "tasks": data.content.get("tasks", []),
                "notes": data.content.get("notes", ""),
            }
        else:
            return {
                "status": "success",
                "cardType": "daily_plan",
                "date": date_str,
                "tasks": [],
                "message": "今天还没有计划，要现在创建吗？",
            }
    except Exception as e:
        logger.error(f"show_daily_plan failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }


@tool_handler("show_checkin_form")
async def execute_show_checkin_form(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
    """展示打卡表单卡片"""
    from uuid import UUID
    from skills.core.services.user_data import get_user_data_service

    date_str = args.get("date") or datetime.now().strftime("%Y-%m-%d")

    if not context.user_id or context.user_id == "guest":
        # 返回演示数据
        return {
            "status": "success",
            "cardType": "checkin_form",
            "date": date_str,
            "tasks": [
                {"id": "demo-1", "title": "完成报告", "completed": True},
                {"id": "demo-2", "title": "团队会议", "completed": True},
                {"id": "demo-3", "title": "阅读30分钟", "completed": False},
            ],
            "fields": [
                {"id": "energy", "label": "今日精力", "type": "rating", "max": 5},
                {"id": "reflection", "label": "今日反思", "type": "textarea"},
            ],
            "isDemo": True,
        }

    try:
        service = get_user_data_service()
        user_uuid = UUID(context.user_id)

        # 获取当日计划
        plan_path = f"plans/daily/{date_str}"
        plan_data = await service.read(user_uuid, plan_path)

        # 获取已有打卡记录
        checkin_path = f"checkins/{date_str}"
        checkin_data = await service.read(user_uuid, checkin_path)

        tasks = plan_data.content.get("tasks", []) if plan_data else []

        # 合并打卡状态
        if checkin_data:
            completed_ids = set(checkin_data.content.get("completed_tasks", []))
            for task in tasks:
                task["completed"] = task.get("id") in completed_ids

        return {
            "status": "success",
            "cardType": "checkin_form",
            "date": date_str,
            "tasks": tasks,
            "checkin": checkin_data.content if checkin_data else None,
            "fields": [
                {"id": "energy", "label": "今日精力", "type": "rating", "max": 5},
                {"id": "mood", "label": "今日心情", "type": "rating", "max": 5},
                {"id": "reflection", "label": "今日反思", "type": "textarea", "placeholder": "今天有什么收获或感悟？"},
            ],
        }
    except Exception as e:
        logger.error(f"show_checkin_form failed: {e}")
        return {
            "status": "error",
            "error": str(e),
        }
