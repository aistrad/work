"use client";

import { Suspense, useMemo } from "react";
import { cn } from "@/lib/utils";
import { SimpleVibeGlyph, type SkillType } from "@/components/core";
import { skillRegistry } from "@/skills/registry";
import { CardRegistry } from "@/skills/CardRegistry";
import { useToolSchema } from "@/hooks/useToolSchema";
import { MarkdownRenderer } from "./MarkdownRenderer";
import type { SkillId, ToolExecuteContext } from "@/skills/types";

// ═══════════════════════════════════════════════════════════════════════════
// ChatMessage - v7.1 Linear 风格设计系统
// 克制、精致、流畅
// ═══════════════════════════════════════════════════════════════════════════

// 内容段类型
interface TextSegment {
  type: 'text';
  content: string;
}

interface ToolSegment {
  type: 'tool';
  name: string;
  data: unknown;
}

type ContentSegment = TextSegment | ToolSegment;

// 解析内容，提取 [[TOOL:...]] 标记
function parseContent(content: string): ContentSegment[] {
  const regex = /\[\[TOOL:(\w+):([\s\S]*?)\]\]/g;
  const segments: ContentSegment[] = [];
  let lastIndex = 0;

  const matches = Array.from(content.matchAll(regex));
  for (const match of matches) {
    // 前面的文本
    if (match.index !== undefined && match.index > lastIndex) {
      const text = content.slice(lastIndex, match.index).trim();
      if (text) {
        segments.push({ type: 'text', content: text });
      }
    }
    // tool 块
    try {
      segments.push({
        type: 'tool',
        name: match[1],
        data: JSON.parse(match[2])
      });
    } catch {
      // JSON 解析失败，作为文本处理
      segments.push({ type: 'text', content: match[0] });
    }
    lastIndex = (match.index ?? 0) + match[0].length;
  }

  // 剩余文本
  if (lastIndex < content.length) {
    const text = content.slice(lastIndex).trim();
    if (text) {
      segments.push({ type: 'text', content: text });
    }
  }

  return segments;
}

export interface ChatMessageProps {
  role: "user" | "assistant";
  content: string;
  timestamp?: string;
  isStreaming?: boolean;
  showAvatar?: boolean;
  skill?: SkillType;
  /**
   * 表单提交回调 - 用于处理工具卡片中的表单提交
   */
  onSendMessage?: (message: string) => void;
}

export function ChatMessage({
  role,
  content,
  timestamp,
  isStreaming,
  showAvatar = true,
  skill = "bazi",
  onSendMessage,
}: ChatMessageProps) {
  const isUser = role === "user";

  // 解析内容，提取工具标记
  const segments = useMemo(() => {
    if (isUser || !content) return [];
    return parseContent(content);
  }, [content, isUser]);

  // 判断是否有工具卡片
  const hasToolCards = segments.some(s => s.type === 'tool');

  return (
    <article
      className={cn(
        // content-visibility 优化长列表 (Vercel rule: rendering-content-visibility)
        "chat-message-item",
        // CSS 动画替代 Framer Motion (Vercel rule: rerender-animation-library)
        "animate-slide-in-up",
        "flex w-full mb-4 gap-3",
        isUser ? "flex-row-reverse" : "flex-row"
      )}
      role={isUser ? "note" : "article"}
      aria-label={isUser ? "您发送的消息" : "AI 助手的回复"}
    >
      {/* Avatar */}
      {showAvatar && !isUser && (
        <div className="flex-shrink-0 w-8 h-8 flex items-center justify-center">
          <SimpleVibeGlyph size={24} skill={skill} />
        </div>
      )}

      {/* Message content area */}
      <div className={cn("flex-1 max-w-[85%]", isUser && "flex flex-col items-end")}>
        {isUser ? (
          // 用户消息：深色气泡
          <div className="chat-bubble-user">
            <p className="whitespace-pre-wrap leading-relaxed text-sm">{content}</p>
            {timestamp && <p className="chat-timestamp opacity-70 mt-1">{timestamp}</p>}
          </div>
        ) : (
          // AI 消息：解析并渲染文本+工具卡片
          <>
            {segments.map((segment, index) => {
              if (segment.type === 'text') {
                return (
                  <div key={index} className="chat-bubble-assistant">
                    <MarkdownRenderer
                      content={segment.content}
                      isStreaming={isStreaming && index === segments.length - 1}
                    />
                    {/* Streaming indicator - Linear 风格 */}
                    {isStreaming && index === segments.length - 1 && !hasToolCards && (
                      <StreamingDots />
                    )}
                  </div>
                );
              } else {
                return (
                  <ToolCardRenderer
                    key={index}
                    name={segment.name}
                    data={segment.data}
                    skill={skill as SkillId}
                    onSendMessage={onSendMessage}
                  />
                );
              }
            })}
            {/* 如果没有任何段落但有内容，显示原始内容 */}
            {segments.length === 0 && content && (
              <div className="chat-bubble-assistant">
                <MarkdownRenderer content={content} isStreaming={isStreaming} />
                {isStreaming && <StreamingDots />}
              </div>
            )}
            {timestamp && <p className="chat-timestamp mt-1">{timestamp}</p>}
          </>
        )}
      </div>

      {/* User avatar placeholder for alignment */}
      {showAvatar && isUser && (
        <div className="flex-shrink-0 w-8 h-8" />
      )}
    </article>
  );
}

// ═══════════════════════════════════════════════════════════════════════════
// StreamingDots - Linear 风格流式加载指示器
// ═══════════════════════════════════════════════════════════════════════════

function StreamingDots() {
  return (
    <span className="streaming-dots ml-1">
      <span />
      <span />
      <span />
    </span>
  );
}

// ═══════════════════════════════════════════════════════════════════════════
// ToolCardRenderer - 渲染工具卡片
// ═══════════════════════════════════════════════════════════════════════════

interface ToolCardRendererProps {
  name: string;
  data: unknown;
  skill: SkillId;
  onSendMessage?: (message: string) => void;
}

// 内部工具列表 - 静默忽略，不渲染任何内容
const INTERNAL_TOOLS = new Set([
  "use_skill",
  "search_db",
  "get_context",
  "update_memory",
  "log_event",
]);

function ToolCardRenderer({ name, data, skill, onSendMessage }: ToolCardRendererProps) {
  const { getCardType, getCardProps } = useToolSchema({ skillId: skill });

  // 0. 内部工具静默忽略
  if (INTERNAL_TOOLS.has(name)) {
    return null;
  }

  // 1. 优先使用后端返回的 cardType
  const toolData = data as Record<string, unknown> | null;
  const cardType = toolData?.cardType as string | undefined
    || toolData?.card_type as string | undefined
    || getCardType(name);

  // 2. 如果有 cardType，使用 CardRegistry 渲染
  if (cardType && CardRegistry.has(cardType)) {
    const cardProps = getCardProps(name);

    // 为表单卡片提供提交回调
    const handleFormSubmit = (formData: Record<string, any>) => {
      if (onSendMessage) {
        // 将表单数据格式化为消息
        const message = Object.entries(formData)
          .map(([key, value]) => `${key}: ${value}`)
          .join('\n');
        onSendMessage(message);
      }
    };

    // 统一的 onAction 处理器（用于 ShowCard 的 form、select 等）
    const handleAction = (action: string, payload?: any) => {
      if (action === 'submit' && onSendMessage) {
        // form 提交
        const message = Object.entries(payload)
          .map(([key, value]) => `${key}: ${value}`)
          .join('\n');
        onSendMessage(message);
      } else if (action === 'select' && onSendMessage) {
        // select 选择
        onSendMessage(String(payload));
      }
      // 其他 action 可以在这里添加
    };

    // 处理 QuestionCard 的回答提交
    const handleQuestionSubmit = (answer: string) => {
      if (onSendMessage) {
        onSendMessage(answer);
      }
    };

    // 适配不同卡片类型的 props 格式
    const adaptedProps = cardType === 'collect_form' ? {
      // CollectFormCard 专用 props
      formFields: toolData?.fields || [],
      title: toolData?.title,
      description: toolData?.description,
      allowTextInput: toolData?.allowTextInput,
      textInputPlaceholder: toolData?.textInputPlaceholder,
      onSubmit: handleFormSubmit,
    } : cardType === 'question_card' ? {
      // QuestionCard 专用 props
      data: toolData,
      onSubmit: handleQuestionSubmit,  // 直接传递字符串回答
    } : {
      // 通用卡片 props（包括 form、select 等）
      data: toolData,
      cardProps,
      onAction: handleAction,  // ShowCard 使用 onAction
      onSubmit: handleFormSubmit,  // 向后兼容
      ...toolData  // 传递所有后端数据
    };

    return (
      <Suspense fallback={<ToolLoadingFallback />}>
        <div className="mt-3">
          {CardRegistry.render(cardType, adaptedProps)}
        </div>
      </Suspense>
    );
  }

  // 3. 回退：从 skillRegistry 获取工具定义
  const toolDef = skillRegistry.getTool(name);
  if (toolDef?.render) {
    const context: ToolExecuteContext = { skillId: skill };
    return (
      <Suspense fallback={<ToolLoadingFallback />}>
        <div className="mt-3">
          {toolDef.render(toolData, context)}
        </div>
      </Suspense>
    );
  }

  // 4. Fallback: 静默忽略未知工具（不暴露技术细节）
  // 仅在开发环境输出警告
  if (process.env.NODE_ENV === "development") {
    console.warn(`[ToolCardRenderer] Unknown tool: ${name}`, data);
  }
  return null;
}

// ═══════════════════════════════════════════════════════════════════════════
// ToolLoadingFallback - Shimmer 加载骨架
// ═══════════════════════════════════════════════════════════════════════════

function ToolLoadingFallback() {
  return (
    <div className="mt-3 rounded-lg p-4 bg-bg-secondary border border-subtle">
      <div className="skeleton h-4 w-1/3 mb-3 rounded" />
      <div className="skeleton h-20 w-full rounded" />
    </div>
  );
}

function getToolDisplayName(toolName: string): string {
  const displayNames: Record<string, string> = {
    show_bazi_chart: "展示命盘",
    show_bazi_kline: "展示人生K线",
    show_bazi_fortune: "展示大运流年",
    show_zodiac_chart: "展示星盘",
    show_transit: "展示天象推运",
    show_synastry: "展示合盘分析",
    show_report: "展示报告",
    show_relationship: "关系分析",
    show_insight: "展示洞察",
    request_info: "收集信息",
    show_vibe_id: "展示 VibeID",
    vibe_id: "VibeID 分析",
    vibe_id_radar: "原型分布图",
  };
  return displayNames[toolName] || toolName;
}

// ═══════════════════════════════════════════════════════════════════════════
// SystemMessage - 系统消息
// ═══════════════════════════════════════════════════════════════════════════

interface SystemMessageProps {
  content: string;
  className?: string;
}

export function SystemMessage({ content, className }: SystemMessageProps) {
  return (
    <div className={cn("flex justify-center my-4", className)}>
      <span className="px-3 py-1.5 text-xs text-text-tertiary bg-bg-secondary rounded-full">
        {content}
      </span>
    </div>
  );
}

// ═══════════════════════════════════════════════════════════════════════════
// TypingIndicator - AI 思考指示器
// ═══════════════════════════════════════════════════════════════════════════

interface TypingIndicatorProps {
  className?: string;
}

export function TypingIndicator({ className }: TypingIndicatorProps) {
  return (
    <div
      className={cn("flex items-center gap-3 mb-4 animate-slide-in-up", className)}
    >
      <div className="flex-shrink-0 w-8 h-8 flex items-center justify-center">
        <SimpleVibeGlyph size={24} skill="bazi" />
      </div>
      <div className="chat-bubble-assistant py-3">
        <div className="streaming-dots">
          <span />
          <span />
          <span />
        </div>
      </div>
    </div>
  );
}
