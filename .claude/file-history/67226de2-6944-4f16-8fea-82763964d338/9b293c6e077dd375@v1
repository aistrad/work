---
id: skill-architecture
name: Skill 架构设计
impact: CRITICAL
tags: 架构, Phase, 全文加载, 路由
---

# Skill 架构设计 v10.3

基于 2026-01-22 调试经验总结的最佳实践。

---

## 1. 核心架构：Phase 1/2 机制

### 1.1 流程图

```
用户消息
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Phase 1: 路由阶段                                        │
│ ─────────────────                                       │
│ System Prompt: routing.yaml (~1000 字符)                │
│ 工具: activate_skill, recommend_skills, ask_user_question│
│                                                         │
│ LLM 决策:                                               │
│   - 用户意图明确 → activate_skill(skill="xxx")          │
│   - 用户意图不明确 → recommend_skills()                 │
│   - 需要更多信息 → ask_user_question()                  │
└─────────────────────────────────────────────────────────┘
    │
    │ activate_skill 被调用
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Phase 2: 执行阶段                                        │
│ ─────────────────                                       │
│ System Prompt: SKILL.md 全文 + User Context (~4000 字符) │
│ 工具: Skill 专属工具 + 全局工具                          │
│                                                         │
│ LLM 执行:                                               │
│   - 按 SKILL.md 中的规则分析                            │
│   - 调用计算工具获取数据                                 │
│   - 调用展示工具渲染卡片                                 │
└─────────────────────────────────────────────────────────┘
```

### 1.2 关键代码位置

| 功能 | 文件 | 关键函数/位置 |
|-----|------|-------------|
| Phase 1 Prompt | `apps/api/skills/core/config/routing.yaml` | `phase1_prompt` 字段 |
| Phase 2 Prompt | `apps/api/services/agent/skill_loader.py` | `build_system_prompt()` |
| Skill 激活 | `apps/api/services/agent/core.py:444` | `result.should_reload_context` |
| 工具执行 | `apps/api/services/agent/tool_executor.py` | `_handle_activate_skill()` |

### 1.3 关键问题：Phase 切换时的状态更新

**问题**：`activate_skill` 工具执行后，`self._active_skill` 必须被更新，否则 Phase 2 的 prompt 仍然使用 Phase 1 的内容。

**正确实现** (core.py:444):
```python
if result.should_reload_context:
    # 关键：从工具结果中提取激活的 skill/rule
    if isinstance(result.data, dict):
        activated_skill = result.data.get("skill")
        activated_rule = result.data.get("rule")
        if activated_skill:
            self._active_skill = activated_skill
            self._active_scenario = activated_rule

    # 重新构建 System Prompt
    new_system_prompt = await self._build_system_prompt(...)
```

---

## 2. SKILL.md 全文加载

### 2.1 加载机制

**关键原则**：SKILL.md 全文（去掉 frontmatter）会被加载到 Phase 2 的 System Prompt 中。

```python
# skill_loader.py
@lru_cache(maxsize=32)
def _load_skill_md_content(skill_id: str) -> str:
    """加载 SKILL.md 全文内容（去掉 frontmatter）"""
    skill_path = SKILLS_DIR / skill_id / "SKILL.md"
    text = skill_path.read_text(encoding='utf-8')
    _, content = parse_frontmatter(text)  # 去掉 frontmatter
    return content
```

### 2.2 为什么全文加载？

| 之前的问题 | 现在的方案 |
|----------|----------|
| 只加载 `## 专家身份` 章节 | 加载整个 SKILL.md |
| 强制工具调用规则被遗漏 | 所有规则都会被加载 |
| LLM 不知道工具使用约束 | LLM 能看到完整的约束 |

### 2.3 SKILL.md 结构建议

由于全文会被加载，SKILL.md 应该包含：

1. **专家身份** - 角色定义
2. **强制工具调用规则** - **关键！**防止 LLM 编造数据
3. **核心能力索引** - 能力表格
4. **工具快速参考** - 工具使用指南
5. **知识检索策略** - RAG 检索模板
6. **服务原则** - 行为准则
7. **伦理边界** - 禁止事项

---

## 3. 强制工具调用规则

### 3.1 为什么需要这个规则？

**问题**：LLM 可能直接编造数据（如星盘、八字），而不是调用工具计算。

**症状**：
- 用户提供出生信息后，LLM 直接说"你的太阳星座是..."
- 没有显示工具卡片
- 数据可能是错误的

### 3.2 规则模板

在 SKILL.md 的 `## 专家身份` 章节后添加：

```markdown
**⚠️ 强制工具调用规则（必须遵守）**：
- **禁止编造数据**！必须调用 `{compute_tool}` 工具计算
- 用户提供信息后，**必须**先调用 `{compute_tool}(参数...)`
- 计算完成后，**必须**调用 `{display_tool}` 展示卡片
- **禁止**在文本中直接写分析结果而不调用工具
- **禁止**在用户已提供信息时调用 `{collect_tool}`
```

### 3.3 实际示例 (zodiac)

```markdown
**⚠️ 强制工具调用规则（必须遵守）**：
- **禁止编造星盘数据**！必须调用 `calculate_zodiac` 工具计算
- 用户提供出生信息后，**必须**先调用 `calculate_zodiac(birth_date, birth_time, birth_place)`
- 计算完成后，**必须**调用 `show_zodiac_chart` 展示星盘卡片
- **禁止**在文本中直接写星盘分析结果而不调用工具
```

---

## 4. Frontmatter 配置驱动

### 4.1 支持的配置字段

```yaml
---
name: zodiac
description: 西方占星专家。触发词：星座、星盘、占星...
category: astrology
# 以下为 SOP 配置驱动字段
requires_birth_info: true      # 是否需要出生信息
requires_compute: true         # 是否需要计算
compute_tool: calculate_zodiac # 计算工具名称
collect_tool: collect_zodiac_info  # 收集工具名称
external_tools: [calculate_zodiac] # 从其他 skill 导入的工具
requires_skill_data: [bazi, zodiac] # 需要读取的 skill_data
---
```

### 4.2 配置驱动 vs Python 硬编码

| 行为 | 正确做法 | 错误做法 |
|-----|---------|---------|
| 判断是否需要出生信息 | `skill.requires_birth_info` | `if skill_id == "zodiac":` |
| 获取计算工具名称 | `skill.compute_tool` | `"calculate_" + skill_id` |
| 判断 Skill 路由 | LLM 调用 `activate_skill` | Python 关键词匹配 |

---

## 5. 目录结构

```
apps/api/skills/{skill_id}/
├── SKILL.md                 # 核心定义（全文加载到 prompt）
├── rules/                   # 分析规则（按需加载）
│   ├── _index.md            # 规则索引
│   └── {capability}.md      # 各能力规则
├── tools/
│   ├── tools.yaml           # 工具定义
│   └── handlers.py          # 工具执行器
└── services/                # 服务实现（可选）
    └── api.py               # 计算服务
```

---

## 6. 常见问题

### Q1: Phase 2 的 prompt 长度没有增加？

**检查点**：
1. `activate_skill` 是否正确设置了 `self._active_skill`
2. `build_system_prompt` 是否加载了 SKILL.md 全文
3. 缓存是否需要清除

### Q2: LLM 仍然编造数据？

**检查点**：
1. SKILL.md 中是否有"强制工具调用规则"
2. 规则是否在 `## 专家身份` 章节内（会被加载）
3. 日志中 `system_prompt_len` 是否足够大

### Q3: 工具调用了但卡片没显示？

**检查点**：
1. 工具返回的 `cardType` 是否正确
2. 前端是否注册了对应的卡片组件
3. `ChatMessage.tsx` 是否正确处理该 cardType
