"""
Report API Routes
Based on: vibelife spec v3.0, section 4.6

Endpoints:
- POST /api/v1/report/generate - Generate new report
- GET /api/v1/report/{report_id} - Get report details
- POST /api/v1/report/{report_id}/upgrade - Upgrade to full report
- GET /api/v1/report/user/{user_id} - List user's reports
- GET /api/v1/report/list - List current user's reports
"""

import logging
from typing import Optional
from uuid import UUID
from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

from services.report import (
    get_report_service,
    ReportType,
    ReportStatus,
)
from stores import report_repo, payment_repo

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/report", tags=["report"])


# ═══════════════════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════════════════

class GenerateReportRequest(BaseModel):
    """Request to generate a new report"""
    user_id: str = Field(..., description="User ID")
    skill: str = Field(..., description="Skill type: bazi or zodiac")
    report_type: str = Field(default="lite", description="Report type: lite or full")
    profile: dict = Field(default_factory=dict, description="User profile data")
    interview_result: Optional[dict] = Field(None, description="Interview result")
    voice_mode: str = Field(default="warm", description="Voice mode: warm or sarcastic")


class ReportResponse(BaseModel):
    """Report response"""
    success: bool
    report: Optional[dict] = None
    error: Optional[str] = None


class ReportListResponse(BaseModel):
    """List of reports response"""
    success: bool
    reports: list = []
    total: int = 0


# ═══════════════════════════════════════════════════════════════════════════
# Routes
# ═══════════════════════════════════════════════════════════════════════════

@router.post("/generate", response_model=ReportResponse)
async def generate_report(request: GenerateReportRequest):
    """
    Generate a new report.

    This is the main endpoint for creating reports.
    Lite reports are free, full reports require payment.
    """
    try:
        service = get_report_service()

        # Validate skill
        if request.skill not in ["bazi", "zodiac"]:
            raise HTTPException(status_code=400, detail="Invalid skill type")

        # Validate report type
        if request.report_type not in ["lite", "full"]:
            raise HTTPException(status_code=400, detail="Invalid report type")

        # Generate report
        report = await service.generate_report(
            user_id=UUID(request.user_id),
            skill=request.skill,
            report_type=request.report_type,
            profile=request.profile,
            interview_result=request.interview_result,
        )

        # Return appropriate format based on type
        if request.report_type == "lite":
            return ReportResponse(
                success=True,
                report=report.to_lite_dict(),
            )
        else:
            return ReportResponse(
                success=True,
                report=report.to_dict(),
            )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Report generation failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )


@router.get("/{report_id}", response_model=ReportResponse)
async def get_report(
    report_id: str,
    user_id: str = Query(..., description="User ID for authorization"),
    full: bool = Query(False, description="Return full report (requires payment)"),
):
    """
    Get a report by ID.

    If full=False, returns lite version with premium content hidden.
    If full=True, requires the user to have paid for the report.
    """
    try:
        # TODO: Load from database
        # For now, return placeholder
        return ReportResponse(
            success=False,
            error="Report not found. Reports are generated on-demand.",
        )

    except Exception as e:
        logger.error(f"Get report failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )


@router.post("/{report_id}/upgrade", response_model=ReportResponse)
async def upgrade_report(
    report_id: str,
    user_id: str = Query(..., description="User ID"),
    payment_id: Optional[str] = Query(None, description="Payment transaction ID"),
):
    """
    Upgrade a lite report to full.

    Requires valid payment confirmation.
    Returns the full report with all content unlocked.
    """
    try:
        # Verify payment
        if not payment_id:
            raise HTTPException(
                status_code=402,
                detail="Payment required. Please complete payment first.",
            )

        # TODO: Verify payment with billing service
        # TODO: Upgrade report in database

        return ReportResponse(
            success=False,
            error="Report upgrade requires payment integration",
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Report upgrade failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )


@router.get("/user/{user_id}", response_model=ReportListResponse)
async def list_user_reports(
    user_id: str,
    skill: Optional[str] = Query(None, description="Filter by skill"),
    limit: int = Query(10, ge=1, le=50, description="Max reports to return"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
):
    """
    List all reports for a user.

    Returns summary information, not full content.
    """
    try:
        # TODO: Load from database
        return ReportListResponse(
            success=True,
            reports=[],
            total=0,
        )

    except Exception as e:
        logger.error(f"List reports failed: {e}")
        return ReportListResponse(
            success=False,
            reports=[],
            total=0,
        )


@router.post("/preview", response_model=ReportResponse)
async def preview_report(request: GenerateReportRequest):
    """
    Generate a preview (prologue only) without saving.

    This is useful for showing users what they'll get before
    completing the full interview or payment.
    """
    try:
        from services.report.prologue_generator import PrologueGenerator

        # Generate just the prologue
        generator = PrologueGenerator()
        prologue = await generator.generate(
            profile=request.profile,
            skill=request.skill,
            interview_summary=request.interview_result.get("summary") if request.interview_result else None,
        )

        return ReportResponse(
            success=True,
            report={
                "prologue": prologue,
                "is_preview": True,
                "sections": [],  # Empty for preview
            },
        )

    except Exception as e:
        logger.error(f"Preview generation failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )
