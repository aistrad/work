"""
Report API Routes
Based on: vibelife spec v3.0, section 4.6

Endpoints:
- POST /api/v1/report/generate - Generate new report
- GET /api/v1/report/{report_id} - Get report details
- POST /api/v1/report/{report_id}/upgrade - Upgrade to full report
- GET /api/v1/report/user/{user_id} - List user's reports
- GET /api/v1/report/list - List current user's reports
"""

import logging
from typing import Optional
from uuid import UUID
from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

from services.report import (
    get_report_service,
    ReportType,
    ReportStatus,
)
from stores import report_repo, payment_repo

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/report", tags=["report"])


# ═══════════════════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════════════════

class GenerateReportRequest(BaseModel):
    """Request to generate a new report"""
    user_id: str = Field(..., description="User ID")
    skill: str = Field(..., description="Skill type: bazi or zodiac")
    report_type: str = Field(default="lite", description="Report type: lite or full")
    profile: dict = Field(default_factory=dict, description="User profile data")
    interview_result: Optional[dict] = Field(None, description="Interview result")
    voice_mode: str = Field(default="warm", description="Voice mode: warm or sarcastic")


class ReportResponse(BaseModel):
    """Report response"""
    success: bool
    report: Optional[dict] = None
    report_id: Optional[str] = None
    error: Optional[str] = None


class ReportListResponse(BaseModel):
    """List of reports response"""
    success: bool
    reports: list = []
    total: int = 0


# ═══════════════════════════════════════════════════════════════════════════
# Routes
# ═══════════════════════════════════════════════════════════════════════════

@router.post("/generate", response_model=ReportResponse)
async def generate_report(request: GenerateReportRequest):
    """
    Generate a new report.

    This is the main endpoint for creating reports.
    Lite reports are free, full reports require payment.
    """
    try:
        service = get_report_service()

        # Validate skill
        if request.skill not in ["bazi", "zodiac"]:
            raise HTTPException(status_code=400, detail="Invalid skill type")

        # Validate report type
        if request.report_type not in ["lite", "full"]:
            raise HTTPException(status_code=400, detail="Invalid report type")

        # Generate report
        report = await service.generate_report(
            user_id=UUID(request.user_id),
            skill=request.skill,
            report_type=request.report_type,
            profile=request.profile,
            interview_result=request.interview_result,
        )

        # Persist to database
        report_dict = report.to_dict() if request.report_type == "full" else report.to_lite_dict()

        db_report = await report_repo.create_report(
            user_id=UUID(request.user_id),
            skill=request.skill,
            report_type=request.report_type,
            content={"sections": report_dict.get("sections", [])},
            prologue=report_dict.get("prologue", ""),
            interview_data=request.interview_result,
            generation_metadata={
                "voice_mode": request.voice_mode,
                "profile_snapshot": request.profile,
            },
        )

        # Merge generated content with DB record
        result = {
            **report_dict,
            "id": db_report["id"],
            "user_id": db_report["user_id"],
            "created_at": db_report["created_at"],
        }

        return ReportResponse(
            success=True,
            report=result,
            report_id=db_report["id"],
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Report generation failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )


@router.get("/{report_id}", response_model=ReportResponse)
async def get_report(
    report_id: str,
    user_id: str = Query(None, description="User ID for authorization"),
    full: bool = Query(False, description="Return full report (requires payment)"),
):
    """
    Get a report by ID.

    If full=False, returns lite version with premium content hidden.
    If full=True, requires the user to have paid for the report.
    """
    try:
        # Load from database
        report = await report_repo.get_report(UUID(report_id))

        if not report:
            raise HTTPException(status_code=404, detail="Report not found")

        # Check authorization if user_id provided
        if user_id and report.get("user_id") != user_id:
            raise HTTPException(status_code=403, detail="Not authorized to view this report")

        # If requesting full report, check payment status
        if full and not report.get("is_paid"):
            raise HTTPException(
                status_code=402,
                detail="Payment required for full report"
            )

        # Build response with sections from content
        content = report.get("content", {})
        sections = content.get("sections", [])

        # If lite and not paid, mark premium sections as locked
        if not report.get("is_paid"):
            for section in sections:
                if section.get("is_premium"):
                    section["locked"] = True
                    section["content"] = section.get("content", "")[:100] + "..."

        result = {
            "id": report["id"],
            "user_id": report.get("user_id"),
            "skill": report["skill"],
            "report_type": report["report_type"],
            "status": "completed",
            "prologue": report.get("prologue", ""),
            "sections": sections,
            "poster_url": report.get("image_url"),
            "poster_thumbnail_url": report.get("image_thumbnail_url"),
            "is_paid": report.get("is_paid", False),
            "created_at": report["created_at"],
        }

        return ReportResponse(
            success=True,
            report=result,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Get report failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )


@router.post("/{report_id}/upgrade", response_model=ReportResponse)
async def upgrade_report(
    report_id: str,
    user_id: str = Query(..., description="User ID"),
    payment_id: Optional[str] = Query(None, description="Payment transaction ID"),
):
    """
    Upgrade a lite report to full.

    Requires valid payment confirmation.
    Returns the full report with all content unlocked.
    """
    try:
        # Verify payment
        if not payment_id:
            raise HTTPException(
                status_code=402,
                detail="Payment required. Please complete payment first.",
            )

        # Get report
        report = await report_repo.get_report(UUID(report_id))
        if not report:
            raise HTTPException(status_code=404, detail="Report not found")

        if report.get("user_id") != user_id:
            raise HTTPException(status_code=403, detail="Not authorized")

        # Verify payment with payment_repo
        payment = await payment_repo.get_payment_by_provider_id(
            provider="stripe" if payment_id.startswith("cs_") else "development",
            provider_payment_id=payment_id
        )

        if not payment or payment.get("status") != "success":
            raise HTTPException(
                status_code=402,
                detail="Payment not verified. Please complete payment first.",
            )

        # Upgrade report in database
        updated_report = await report_repo.update_report_status(
            report_id=UUID(report_id),
            is_paid=True,
            report_type="full",
        )

        # Return full report with all sections unlocked
        content = updated_report.get("content", {})
        sections = content.get("sections", [])

        # Unlock all sections
        for section in sections:
            section["locked"] = False

        result = {
            "id": updated_report["id"],
            "user_id": updated_report.get("user_id"),
            "skill": updated_report["skill"],
            "report_type": "full",
            "status": "completed",
            "prologue": updated_report.get("prologue", ""),
            "sections": sections,
            "poster_url": updated_report.get("image_url"),
            "poster_thumbnail_url": updated_report.get("image_thumbnail_url"),
            "is_paid": True,
            "created_at": updated_report["created_at"],
        }

        return ReportResponse(
            success=True,
            report=result,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Report upgrade failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )


@router.get("/user/{user_id}", response_model=ReportListResponse)
async def list_user_reports(
    user_id: str,
    skill: Optional[str] = Query(None, description="Filter by skill"),
    limit: int = Query(10, ge=1, le=50, description="Max reports to return"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
):
    """
    List all reports for a user.

    Returns summary information, not full content.
    """
    try:
        # TODO: Load from database
        return ReportListResponse(
            success=True,
            reports=[],
            total=0,
        )

    except Exception as e:
        logger.error(f"List reports failed: {e}")
        return ReportListResponse(
            success=False,
            reports=[],
            total=0,
        )


@router.post("/preview", response_model=ReportResponse)
async def preview_report(request: GenerateReportRequest):
    """
    Generate a preview (prologue only) without saving.

    This is useful for showing users what they'll get before
    completing the full interview or payment.
    """
    try:
        from services.report.prologue_generator import PrologueGenerator

        # Generate just the prologue
        generator = PrologueGenerator()
        prologue = await generator.generate(
            profile=request.profile,
            skill=request.skill,
            interview_summary=request.interview_result.get("summary") if request.interview_result else None,
        )

        return ReportResponse(
            success=True,
            report={
                "prologue": prologue,
                "is_preview": True,
                "sections": [],  # Empty for preview
            },
        )

    except Exception as e:
        logger.error(f"Preview generation failed: {e}")
        return ReportResponse(
            success=False,
            error=str(e),
        )
