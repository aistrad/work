"""
Proactive Worker - 主动推送系统 Worker v3.0

运行模式:
1. 单次运行: python workers/proactive_worker.py --once
2. 守护进程: python workers/proactive_worker.py --daemon --interval 3600
3. 测试模式: python workers/proactive_worker.py --dry-run

功能:
- 扫描用户并检测触发条件（静态优先 + LLM 回退）
- 调用 Agent 生成个性化内容
- 保存通知到数据库

v3.0 更新:
- 使用 ProactiveOrchestrator 替代 ProactiveEngine
- 静态条件优先求值，降低 LLM 调用
- 幂等去重机制
"""

import argparse
import asyncio
import logging
import sys
from datetime import datetime
from pathlib import Path

# 添加项目根目录到 path
sys.path.insert(0, str(Path(__file__).parent.parent))

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


def get_orchestrator():
    """获取 ProactiveOrchestrator 实例"""
    from services.proactive.orchestrator import ProactiveOrchestrator
    from services.proactive.trigger_evaluator import TriggerEvaluator
    from services.proactive.agent_adapter import ProactiveAgentAdapter
    from services.reminder.notification import NotificationService

    trigger_evaluator = TriggerEvaluator()
    agent_adapter = ProactiveAgentAdapter()
    notification_service = NotificationService()

    return ProactiveOrchestrator(
        trigger_evaluator=trigger_evaluator,
        agent_adapter=agent_adapter,
        notification_service=notification_service,
    )


async def run_once(dry_run: bool = False) -> int:
    """执行一次扫描和处理"""
    logger.info(f"Starting proactive scan at {datetime.now()}")

    orchestrator = get_orchestrator()

    # 扫描并处理
    results = await orchestrator.run_scheduled_scan(dry_run=dry_run)
    logger.info(f"Generated {len(results)} notifications")

    if dry_run:
        logger.info("Dry run mode - notifications not saved")
        for result in results:
            logger.info(f"  - {result['skill_id']}/{result['reminder_id']} for user {result['user_id']}")

    return len(results)


async def run_daemon(interval: int = 3600, dry_run: bool = False):
    """守护进程模式"""
    logger.info(f"Starting proactive worker daemon (interval: {interval}s)")

    while True:
        try:
            await run_once(dry_run)
        except Exception as e:
            logger.error(f"Error in proactive worker: {e}")

        logger.info(f"Sleeping for {interval} seconds...")
        await asyncio.sleep(interval)


def main():
    parser = argparse.ArgumentParser(description="Proactive Worker v3.0 - LLM-First 主动推送系统")
    parser.add_argument(
        "--once",
        action="store_true",
        help="执行一次后退出",
    )
    parser.add_argument(
        "--daemon",
        action="store_true",
        help="守护进程模式",
    )
    parser.add_argument(
        "--interval",
        type=int,
        default=3600,
        help="守护进程模式下的扫描间隔（秒），默认 3600",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="测试模式，只扫描不处理",
    )

    args = parser.parse_args()

    if args.daemon:
        asyncio.run(run_daemon(args.interval, args.dry_run))
    elif args.once:
        result = asyncio.run(run_once(args.dry_run))
        logger.info(f"Completed with {result} notifications")
    else:
        # 默认执行一次
        result = asyncio.run(run_once(args.dry_run))
        logger.info(f"Completed with {result} notifications")


if __name__ == "__main__":
    main()
