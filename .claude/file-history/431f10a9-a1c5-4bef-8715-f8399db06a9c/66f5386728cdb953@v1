"""
Vibe ID Authentication Routes
"""
from typing import Optional

from fastapi import APIRouter, HTTPException, status, Depends
from pydantic import BaseModel, EmailStr

from services.identity import AuthService, SSOService, get_current_user, CurrentUser


router = APIRouter(prefix="/auth", tags=["Authentication"])


# ─────────────────────────────────────────────────────────────────
# Request/Response Models
# ─────────────────────────────────────────────────────────────────

class RegisterRequest(BaseModel):
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    password: str
    display_name: Optional[str] = None


class LoginRequest(BaseModel):
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    password: str


class RefreshRequest(BaseModel):
    refresh_token: str


class SSORequest(BaseModel):
    target_site: str


class SSOCallbackRequest(BaseModel):
    token: str
    site: str


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int
    user: dict


class UserResponse(BaseModel):
    user_id: str
    vibe_id: str
    display_name: Optional[str] = None
    avatar_url: Optional[str] = None


# ─────────────────────────────────────────────────────────────────
# Endpoints
# ─────────────────────────────────────────────────────────────────

@router.post("/register", response_model=TokenResponse)
async def register(request: RegisterRequest):
    """Register a new user with Vibe ID"""
    try:
        result = await AuthService.register(
            email=request.email,
            phone=request.phone,
            password=request.password,
            display_name=request.display_name
        )
        return TokenResponse(**result)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post("/login", response_model=TokenResponse)
async def login(request: LoginRequest):
    """Login with email/phone and password"""
    try:
        result = await AuthService.login(
            email=request.email,
            phone=request.phone,
            password=request.password
        )
        return TokenResponse(**result)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e)
        )


@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(request: RefreshRequest):
    """Refresh access token"""
    try:
        result = await AuthService.refresh_token(request.refresh_token)
        return TokenResponse(**result)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e)
        )


@router.get("/me", response_model=UserResponse)
async def get_me(current_user: CurrentUser = Depends(get_current_user)):
    """Get current authenticated user"""
    return UserResponse(
        user_id=str(current_user.user_id),
        vibe_id=current_user.vibe_id,
        display_name=current_user.display_name
    )


# ─────────────────────────────────────────────────────────────────
# SSO Endpoints
# ─────────────────────────────────────────────────────────────────

@router.post("/sso/generate")
async def generate_sso_token(
    request: SSORequest,
    current_user: CurrentUser = Depends(get_current_user)
):
    """Generate SSO token for cross-site authentication"""
    token = await SSOService.generate_sso_token(
        str(current_user.user_id),
        current_user.vibe_id,
        request.target_site
    )

    if not token:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid target site"
        )

    redirect_url = SSOService.get_sso_redirect_url(request.target_site, token)

    return {
        "sso_token": token,
        "redirect_url": redirect_url,
        "expires_in": 300  # 5 minutes
    }


@router.post("/sso/callback", response_model=TokenResponse)
async def sso_callback(request: SSOCallbackRequest):
    """Exchange SSO token for access tokens"""
    result = await SSOService.exchange_sso_for_tokens(
        request.token,
        request.site
    )

    if not result:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired SSO token"
        )

    return TokenResponse(**result)


@router.post("/logout")
async def logout(current_user: CurrentUser = Depends(get_current_user)):
    """Logout user (client should discard tokens)"""
    # In a more complete implementation, you might:
    # - Add token to a blacklist
    # - Clear any server-side session
    return {"message": "Logged out successfully"}
