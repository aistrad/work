"""
Insight Generator - Generate personalized insights
"""
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
from uuid import UUID
from dataclasses import dataclass
from enum import Enum

from stores import SkillRepository


class InsightType(Enum):
    """4 types of insights"""
    DISCOVERY = "discovery"   # "I see in you..."
    PATTERN = "pattern"       # "I notice a pattern..."
    TIMING = "timing"         # "Now is a good time for..."
    GROWTH = "growth"         # "Your growth..."


@dataclass
class InsightTrigger:
    """Trigger condition for insight"""
    should_trigger: bool
    insight_type: InsightType
    confidence: float
    evidence: Dict[str, Any]
    title: Optional[str] = None
    content: Optional[str] = None


class InsightGenerator:
    """
    Generates personalized insights based on patterns, timing, and user data.
    """

    # ─────────────────────────────────────────────────────────────────
    # Trigger Rules Configuration
    # ─────────────────────────────────────────────────────────────────

    DISCOVERY_TRIGGERS = {
        "first_mention": 0.3,       # First time mentioning topic
        "strong_emotion": 0.4,      # High intensity emotion
        "important_topic": 0.3      # Topic matches important category
    }

    PATTERN_TRIGGERS = {
        "min_occurrences": 3,       # Minimum times to see pattern
        "similar_context": 0.7,     # Context similarity threshold
        "time_span_days": 30        # Within this many days
    }

    TIMING_TRIGGERS = {
        "fortune_event": True,      # Triggered by calendar event
        "energy_peak": 0.8,         # User energy above threshold
        "user_readiness": 0.7       # Assessed readiness
    }

    GROWTH_TRIGGERS = {
        "behavior_change": 0.3,     # Detected change in behavior
        "milestone": True,          # Reached a milestone
        "comparison_period_days": 90
    }

    # Cooldown periods (hours)
    COOLDOWN = {
        InsightType.DISCOVERY: 24,
        InsightType.PATTERN: 72,
        InsightType.TIMING: 48,
        InsightType.GROWTH: 168  # 1 week
    }

    # Minimum confidence to trigger
    MIN_CONFIDENCE = 0.7

    # ─────────────────────────────────────────────────────────────────
    # Insight Title Templates
    # ─────────────────────────────────────────────────────────────────

    TITLES = {
        InsightType.DISCOVERY: [
            "我看见你...",
            "我注意到一些特别的...",
            "关于你，我发现...",
        ],
        InsightType.PATTERN: [
            "我注意到一个模式...",
            "我发现了一个规律...",
            "有个有趣的模式...",
        ],
        InsightType.TIMING: [
            "现在是...的好时机",
            "时机来了...",
            "这个时刻很特别...",
        ],
        InsightType.GROWTH: [
            "你的成长...",
            "我看到了变化...",
            "回顾你的旅程...",
        ]
    }

    # ─────────────────────────────────────────────────────────────────
    # Check Methods
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def check_discovery_trigger(
        cls,
        user_id: UUID,
        skill_id: str,
        message: str,
        emotion_result=None,
        topics: Optional[List[str]] = None
    ) -> InsightTrigger:
        """Check if DISCOVERY insight should be triggered"""
        confidence = 0.0
        evidence = {}

        # Check for strong emotion
        if emotion_result and emotion_result.intensity > 0.7:
            confidence += cls.DISCOVERY_TRIGGERS["strong_emotion"]
            evidence["strong_emotion"] = {
                "emotion": emotion_result.primary.value,
                "intensity": emotion_result.intensity
            }

        # Check for important topics (simplified)
        important_keywords = ["人生", "未来", "感情", "事业", "健康", "家庭"]
        for kw in important_keywords:
            if kw in message:
                confidence += cls.DISCOVERY_TRIGGERS["important_topic"]
                evidence["important_topic"] = kw
                break

        # Check if topic is first mentioned (would need topic tracking)
        # For now, add small base confidence
        confidence += 0.1

        should_trigger = confidence >= cls.MIN_CONFIDENCE

        return InsightTrigger(
            should_trigger=should_trigger,
            insight_type=InsightType.DISCOVERY,
            confidence=min(1.0, confidence),
            evidence=evidence
        )

    @classmethod
    async def check_pattern_trigger(
        cls,
        user_id: UUID,
        skill_id: str,
        recent_messages: List[Dict[str, Any]],
        recent_insights: List[Dict[str, Any]]
    ) -> InsightTrigger:
        """Check if PATTERN insight should be triggered"""
        confidence = 0.0
        evidence = {}

        # Count repeated themes/emotions in recent messages
        emotion_counts = {}
        topic_counts = {}

        for msg in recent_messages:
            if "emotion" in msg:
                emotion = msg["emotion"]
                emotion_counts[emotion] = emotion_counts.get(emotion, 0) + 1

        # Check for patterns
        for emotion, count in emotion_counts.items():
            if count >= cls.PATTERN_TRIGGERS["min_occurrences"]:
                confidence += 0.4
                evidence["repeated_emotion"] = {
                    "emotion": emotion,
                    "count": count
                }

        should_trigger = confidence >= cls.MIN_CONFIDENCE

        return InsightTrigger(
            should_trigger=should_trigger,
            insight_type=InsightType.PATTERN,
            confidence=min(1.0, confidence),
            evidence=evidence
        )

    @classmethod
    async def check_timing_trigger(
        cls,
        user_id: UUID,
        skill_id: str,
        current_events: Optional[List[Dict[str, Any]]] = None,
        user_energy: Optional[float] = None
    ) -> InsightTrigger:
        """Check if TIMING insight should be triggered"""
        confidence = 0.0
        evidence = {}

        # Check for fortune events
        if current_events:
            for event in current_events:
                confidence += 0.4
                evidence["fortune_event"] = event
                break

        # Check user energy
        if user_energy and user_energy >= cls.TIMING_TRIGGERS["energy_peak"]:
            confidence += 0.3
            evidence["high_energy"] = user_energy

        should_trigger = confidence >= cls.MIN_CONFIDENCE

        return InsightTrigger(
            should_trigger=should_trigger,
            insight_type=InsightType.TIMING,
            confidence=min(1.0, confidence),
            evidence=evidence
        )

    @classmethod
    async def check_growth_trigger(
        cls,
        user_id: UUID,
        skill_id: str,
        historical_insights: List[Dict[str, Any]],
        current_state: Optional[Dict[str, Any]] = None
    ) -> InsightTrigger:
        """Check if GROWTH insight should be triggered"""
        confidence = 0.0
        evidence = {}

        # Check for milestones
        if len(historical_insights) in [10, 25, 50, 100]:
            confidence += 0.5
            evidence["milestone"] = f"{len(historical_insights)} insights reached"

        # Check for behavioral changes (simplified)
        if current_state:
            confidence += 0.2

        should_trigger = confidence >= cls.MIN_CONFIDENCE

        return InsightTrigger(
            should_trigger=should_trigger,
            insight_type=InsightType.GROWTH,
            confidence=min(1.0, confidence),
            evidence=evidence
        )

    # ─────────────────────────────────────────────────────────────────
    # Cooldown Check
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def check_cooldown(
        cls,
        user_id: UUID,
        skill_id: str,
        insight_type: InsightType
    ) -> bool:
        """Check if insight type is in cooldown period"""
        recent_insights = await SkillRepository.get_user_insights(
            user_id, skill_id,
            insight_type=insight_type.value,
            limit=1
        )

        if not recent_insights:
            return False  # No cooldown

        last_insight_time = recent_insights[0]["created_at"]
        cooldown_hours = cls.COOLDOWN[insight_type]
        cooldown_end = last_insight_time + timedelta(hours=cooldown_hours)

        return datetime.utcnow() < cooldown_end

    # ─────────────────────────────────────────────────────────────────
    # Content Generation
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def generate_insight_content(
        cls,
        trigger: InsightTrigger,
        user_context: Dict[str, Any],
        llm_orchestrator=None
    ) -> tuple[str, str]:
        """Generate insight title and content using LLM"""
        import random

        # Select title template
        title_templates = cls.TITLES[trigger.insight_type]
        title = random.choice(title_templates)

        if not llm_orchestrator:
            # Return placeholder content
            return title, f"[需要 LLM 生成内容: {trigger.evidence}]"

        from .llm_orchestrator import LLMMessage

        # Build prompt based on insight type
        prompt = cls._build_insight_prompt(
            trigger.insight_type,
            trigger.evidence,
            user_context
        )

        messages = [LLMMessage(role="user", content=prompt)]

        response = await llm_orchestrator.chat(
            messages,
            temperature=0.7,
            max_tokens=300
        )

        return title, response.content

    @classmethod
    def _build_insight_prompt(
        cls,
        insight_type: InsightType,
        evidence: Dict[str, Any],
        user_context: Dict[str, Any]
    ) -> str:
        """Build prompt for insight content generation"""
        prompts = {
            InsightType.DISCOVERY: f"""你是一个温暖、有洞察力的朋友。

基于以下发现，生成一段简短的洞察内容（2-3句话）：
证据: {evidence}
用户背景: {user_context}

以"我看见"或"我注意到"开头，语气温暖、不说教。只输出内容，不要解释。""",

            InsightType.PATTERN: f"""你是一个善于发现规律的朋友。

基于以下模式，生成一段简短的洞察内容（2-3句话）：
证据: {evidence}
用户背景: {user_context}

以"我注意到一个模式"开头，帮助用户觉察，不评判。只输出内容，不要解释。""",

            InsightType.TIMING: f"""你是一个懂得时机的朋友。

基于以下时机信息，生成一段简短的建议（2-3句话）：
证据: {evidence}
用户背景: {user_context}

以"现在"或"这个时候"开头，给出具体可行的建议。只输出内容，不要解释。""",

            InsightType.GROWTH: f"""你是一个见证成长的朋友。

基于以下变化，生成一段简短的成长回顾（2-3句话）：
证据: {evidence}
用户背景: {user_context}

以"回顾"或"我看到"开头，肯定进步，鼓励继续。只输出内容，不要解释。"""
        }

        return prompts.get(insight_type, prompts[InsightType.DISCOVERY])

    # ─────────────────────────────────────────────────────────────────
    # Main Entry Point
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def maybe_generate_insight(
        cls,
        user_id: UUID,
        skill_id: str,
        message: str,
        conversation_id: UUID,
        emotion_result=None,
        user_context: Optional[Dict[str, Any]] = None,
        llm_orchestrator=None
    ) -> Optional[Dict[str, Any]]:
        """
        Main entry point - check if insight should be generated and create it.
        Returns insight data or None.
        """
        # Check discovery trigger (most common)
        trigger = await cls.check_discovery_trigger(
            user_id, skill_id, message, emotion_result
        )

        if trigger.should_trigger:
            # Check cooldown
            if await cls.check_cooldown(user_id, skill_id, trigger.insight_type):
                return None  # In cooldown

            # Generate content
            title, content = await cls.generate_insight_content(
                trigger,
                user_context or {},
                llm_orchestrator
            )

            # Save insight
            insight = await SkillRepository.create_insight(
                user_id=user_id,
                skill_id=skill_id,
                insight_type=trigger.insight_type.value,
                title=title,
                content=content,
                evidence=trigger.evidence,
                confidence=trigger.confidence,
                conversation_id=conversation_id
            )

            return insight

        return None
