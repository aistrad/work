"""
Emotion Engine - Emotion analysis and tracking
"""
import re
from typing import Optional, List, Dict, Any
from dataclasses import dataclass
from enum import Enum


class PrimaryEmotion(Enum):
    """8 Primary Emotions"""
    JOY = "joy"
    SADNESS = "sadness"
    ANGER = "anger"
    FEAR = "fear"
    SURPRISE = "surprise"
    DISGUST = "disgust"
    TRUST = "trust"
    ANTICIPATION = "anticipation"


class SecondaryEmotion(Enum):
    """12 Secondary Emotions"""
    LOVE = "love"           # joy + trust
    GUILT = "guilt"         # joy + fear
    DELIGHT = "delight"     # joy + surprise
    SUBMISSION = "submission"   # trust + fear
    AWE = "awe"             # fear + surprise
    DISAPPROVAL = "disapproval" # surprise + sadness
    REMORSE = "remorse"     # sadness + disgust
    CONTEMPT = "contempt"   # disgust + anger
    AGGRESSIVENESS = "aggressiveness"  # anger + anticipation
    OPTIMISM = "optimism"   # anticipation + joy
    ANXIETY = "anxiety"     # fear + anticipation
    ENVY = "envy"           # sadness + anger


@dataclass
class EmotionResult:
    """Emotion analysis result"""
    primary: PrimaryEmotion
    secondary: Optional[SecondaryEmotion] = None
    intensity: float = 0.5  # 0-1
    confidence: float = 0.7  # 0-1
    energy_delta: int = 0  # -10 to +10
    triggers: List[str] = None
    context: Optional[str] = None


class EmotionEngine:
    """
    Emotion analysis engine using rule-based + optional LLM analysis.
    """

    # ─────────────────────────────────────────────────────────────────
    # Emotion Keywords (Chinese)
    # ─────────────────────────────────────────────────────────────────

    EMOTION_KEYWORDS = {
        PrimaryEmotion.JOY: [
            "开心", "高兴", "快乐", "幸福", "兴奋", "满足", "愉快",
            "欣喜", "喜悦", "爽", "棒", "太好了", "哈哈", "嘿嘿"
        ],
        PrimaryEmotion.SADNESS: [
            "难过", "伤心", "悲伤", "失落", "沮丧", "郁闷", "心痛",
            "哭", "泪", "想哭", "心酸", "唉", "好惨", "可怜"
        ],
        PrimaryEmotion.ANGER: [
            "生气", "愤怒", "气死", "火大", "恼火", "烦躁", "暴躁",
            "讨厌", "可恶", "混蛋", "受不了", "崩溃", "操", "靠"
        ],
        PrimaryEmotion.FEAR: [
            "害怕", "恐惧", "担心", "焦虑", "紧张", "不安", "忐忑",
            "怕", "慌", "心虚", "压力", "吓", "可怕", "恐怖"
        ],
        PrimaryEmotion.SURPRISE: [
            "惊讶", "震惊", "意外", "没想到", "居然", "竟然", "吃惊",
            "天哪", "卧槽", "我去", "什么", "不敢相信"
        ],
        PrimaryEmotion.DISGUST: [
            "恶心", "厌恶", "反感", "讨厌", "鄙视", "看不起",
            "恶", "呸", "无语", "受不了"
        ],
        PrimaryEmotion.TRUST: [
            "相信", "信任", "依赖", "可靠", "放心", "安心",
            "值得", "信赖", "托付"
        ],
        PrimaryEmotion.ANTICIPATION: [
            "期待", "盼望", "希望", "想要", "等待", "憧憬",
            "展望", "计划", "打算"
        ]
    }

    # Energy impact by emotion
    ENERGY_IMPACT = {
        PrimaryEmotion.JOY: 3,
        PrimaryEmotion.SADNESS: -3,
        PrimaryEmotion.ANGER: -2,
        PrimaryEmotion.FEAR: -2,
        PrimaryEmotion.SURPRISE: 1,
        PrimaryEmotion.DISGUST: -2,
        PrimaryEmotion.TRUST: 2,
        PrimaryEmotion.ANTICIPATION: 2
    }

    # Intensity modifiers
    INTENSITY_MODIFIERS = {
        "very": ["非常", "特别", "超级", "太", "极其", "十分", "相当"],
        "slightly": ["有点", "稍微", "略微", "一点点", "些许"]
    }

    # ─────────────────────────────────────────────────────────────────
    # Rule-based Analysis
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    def analyze_rule_based(cls, text: str) -> EmotionResult:
        """Analyze emotion using keyword rules"""
        text_lower = text.lower()

        # Count keyword matches for each emotion
        scores = {}
        matched_keywords = {}

        for emotion, keywords in cls.EMOTION_KEYWORDS.items():
            count = 0
            matches = []
            for kw in keywords:
                if kw in text:
                    count += 1
                    matches.append(kw)
            if count > 0:
                scores[emotion] = count
                matched_keywords[emotion] = matches

        if not scores:
            # Default to neutral (trust with low intensity)
            return EmotionResult(
                primary=PrimaryEmotion.TRUST,
                intensity=0.3,
                confidence=0.4,
                energy_delta=0,
                triggers=[]
            )

        # Find dominant emotion
        primary = max(scores, key=scores.get)

        # Calculate intensity
        intensity = min(0.9, 0.4 + scores[primary] * 0.15)

        # Check intensity modifiers
        for modifier in cls.INTENSITY_MODIFIERS["very"]:
            if modifier in text:
                intensity = min(1.0, intensity + 0.2)
                break

        for modifier in cls.INTENSITY_MODIFIERS["slightly"]:
            if modifier in text:
                intensity = max(0.2, intensity - 0.2)
                break

        # Calculate energy delta
        base_energy = cls.ENERGY_IMPACT[primary]
        energy_delta = int(base_energy * intensity * 2)

        # Determine secondary emotion (simplified)
        secondary = None
        sorted_emotions = sorted(scores.items(), key=lambda x: x[1], reverse=True)
        if len(sorted_emotions) > 1:
            secondary = cls._derive_secondary(primary, sorted_emotions[1][0])

        return EmotionResult(
            primary=primary,
            secondary=secondary,
            intensity=round(intensity, 2),
            confidence=0.7,
            energy_delta=energy_delta,
            triggers=matched_keywords.get(primary, [])
        )

    @classmethod
    def _derive_secondary(
        cls,
        primary: PrimaryEmotion,
        secondary_primary: PrimaryEmotion
    ) -> Optional[SecondaryEmotion]:
        """Derive secondary emotion from two primary emotions"""
        combo = {primary, secondary_primary}

        mappings = {
            frozenset({PrimaryEmotion.JOY, PrimaryEmotion.TRUST}): SecondaryEmotion.LOVE,
            frozenset({PrimaryEmotion.JOY, PrimaryEmotion.FEAR}): SecondaryEmotion.GUILT,
            frozenset({PrimaryEmotion.JOY, PrimaryEmotion.SURPRISE}): SecondaryEmotion.DELIGHT,
            frozenset({PrimaryEmotion.TRUST, PrimaryEmotion.FEAR}): SecondaryEmotion.SUBMISSION,
            frozenset({PrimaryEmotion.FEAR, PrimaryEmotion.SURPRISE}): SecondaryEmotion.AWE,
            frozenset({PrimaryEmotion.SURPRISE, PrimaryEmotion.SADNESS}): SecondaryEmotion.DISAPPROVAL,
            frozenset({PrimaryEmotion.SADNESS, PrimaryEmotion.DISGUST}): SecondaryEmotion.REMORSE,
            frozenset({PrimaryEmotion.DISGUST, PrimaryEmotion.ANGER}): SecondaryEmotion.CONTEMPT,
            frozenset({PrimaryEmotion.ANGER, PrimaryEmotion.ANTICIPATION}): SecondaryEmotion.AGGRESSIVENESS,
            frozenset({PrimaryEmotion.ANTICIPATION, PrimaryEmotion.JOY}): SecondaryEmotion.OPTIMISM,
            frozenset({PrimaryEmotion.FEAR, PrimaryEmotion.ANTICIPATION}): SecondaryEmotion.ANXIETY,
            frozenset({PrimaryEmotion.SADNESS, PrimaryEmotion.ANGER}): SecondaryEmotion.ENVY,
        }

        return mappings.get(frozenset(combo))

    # ─────────────────────────────────────────────────────────────────
    # Combined Analysis
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def analyze(
        cls,
        text: str,
        use_llm: bool = False,
        llm_orchestrator=None
    ) -> EmotionResult:
        """
        Analyze emotion using combined methods.
        Rule-based by default, optionally enhanced with LLM.
        """
        # Always start with rule-based
        result = cls.analyze_rule_based(text)

        # Optionally enhance with LLM for complex cases
        if use_llm and llm_orchestrator and result.confidence < 0.6:
            try:
                llm_result = await cls._analyze_with_llm(text, llm_orchestrator)
                if llm_result.confidence > result.confidence:
                    return llm_result
            except Exception:
                pass  # Fall back to rule-based result

        return result

    @classmethod
    async def _analyze_with_llm(
        cls,
        text: str,
        llm_orchestrator
    ) -> EmotionResult:
        """Analyze emotion using LLM"""
        from .llm_orchestrator import LLMMessage

        prompt = f"""分析以下文本的情绪。

文本: "{text}"

请以JSON格式回复:
{{
    "primary_emotion": "joy|sadness|anger|fear|surprise|disgust|trust|anticipation",
    "intensity": 0.1-1.0之间的数值,
    "triggers": ["触发词1", "触发词2"],
    "context": "简短的情境描述"
}}

只返回JSON，不要其他内容。"""

        messages = [LLMMessage(role="user", content=prompt)]

        response = await llm_orchestrator.chat(
            messages,
            temperature=0.3,
            max_tokens=256
        )

        import json
        data = json.loads(response.content)

        primary = PrimaryEmotion(data["primary_emotion"])
        intensity = float(data["intensity"])
        energy_delta = int(cls.ENERGY_IMPACT[primary] * intensity * 2)

        return EmotionResult(
            primary=primary,
            intensity=intensity,
            confidence=0.85,
            energy_delta=energy_delta,
            triggers=data.get("triggers", []),
            context=data.get("context")
        )

    # ─────────────────────────────────────────────────────────────────
    # Utility Methods
    # ─────────────────────────────────────────────────────────────────

    @staticmethod
    def emotion_to_dict(result: EmotionResult) -> Dict[str, Any]:
        """Convert EmotionResult to dictionary"""
        return {
            "primary": result.primary.value,
            "secondary": result.secondary.value if result.secondary else None,
            "intensity": result.intensity,
            "confidence": result.confidence,
            "energy_delta": result.energy_delta,
            "triggers": result.triggers or [],
            "context": result.context
        }

    @staticmethod
    def get_emotion_color(emotion: PrimaryEmotion) -> str:
        """Get color associated with emotion"""
        colors = {
            PrimaryEmotion.JOY: "#FFD700",      # Gold
            PrimaryEmotion.SADNESS: "#4169E1",   # Royal Blue
            PrimaryEmotion.ANGER: "#DC143C",     # Crimson
            PrimaryEmotion.FEAR: "#800080",      # Purple
            PrimaryEmotion.SURPRISE: "#FF69B4",  # Hot Pink
            PrimaryEmotion.DISGUST: "#228B22",   # Forest Green
            PrimaryEmotion.TRUST: "#00CED1",     # Dark Turquoise
            PrimaryEmotion.ANTICIPATION: "#FFA500"  # Orange
        }
        return colors.get(emotion, "#808080")
