"""
Authentication Service & Dependencies
"""
from typing import Optional
from uuid import UUID

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

from .jwt import JWTService
from stores.user_repo import UserRepository


# ─────────────────────────────────────────────────────────────────
# Security scheme
# ─────────────────────────────────────────────────────────────────

bearer_scheme = HTTPBearer(auto_error=False)


# ─────────────────────────────────────────────────────────────────
# Current User Data Class
# ─────────────────────────────────────────────────────────────────

class CurrentUser:
    """Current authenticated user"""

    def __init__(
        self,
        user_id: UUID,
        vibe_id: str,
        display_name: Optional[str] = None,
        email: Optional[str] = None
    ):
        self.user_id = user_id
        self.vibe_id = vibe_id
        self.display_name = display_name
        self.email = email

    def __repr__(self):
        return f"<CurrentUser {self.vibe_id}>"


# ─────────────────────────────────────────────────────────────────
# Auth Dependencies
# ─────────────────────────────────────────────────────────────────

async def get_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme)
) -> CurrentUser:
    """
    Get current authenticated user.
    Raises 401 if not authenticated.
    """
    if not credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token = credentials.credentials
    payload = JWTService.verify_access_token(token)

    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    user_id = payload.get("sub")
    vibe_id = payload.get("vibe_id")

    if not user_id or not vibe_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Optionally verify user still exists
    user = await UserRepository.get_by_id(UUID(user_id))
    if not user or user.get("status") != "active":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive",
            headers={"WWW-Authenticate": "Bearer"},
        )

    return CurrentUser(
        user_id=UUID(user_id),
        vibe_id=vibe_id,
        display_name=user.get("display_name")
    )


async def get_optional_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme)
) -> Optional[CurrentUser]:
    """
    Get current user if authenticated, None otherwise.
    Does not raise error if not authenticated.
    """
    if not credentials:
        return None

    token = credentials.credentials
    payload = JWTService.verify_access_token(token)

    if not payload:
        return None

    user_id = payload.get("sub")
    vibe_id = payload.get("vibe_id")

    if not user_id or not vibe_id:
        return None

    return CurrentUser(
        user_id=UUID(user_id),
        vibe_id=vibe_id
    )


# ─────────────────────────────────────────────────────────────────
# Auth Service Class
# ─────────────────────────────────────────────────────────────────

class AuthService:
    """Authentication service"""

    @staticmethod
    async def register(
        email: Optional[str] = None,
        phone: Optional[str] = None,
        password: str = None,
        display_name: Optional[str] = None,
        birth_datetime=None,
        birth_location: Optional[str] = None
    ) -> dict:
        """Register a new user"""
        if not email and not phone:
            raise ValueError("Email or phone is required")

        if not password:
            raise ValueError("Password is required")

        # Check if identifier already exists
        auth_type = "email" if email else "phone"
        auth_identifier = email if email else phone

        existing = await UserRepository.get_auth_by_identifier(auth_type, auth_identifier)
        if existing:
            raise ValueError(f"{auth_type.capitalize()} already registered")

        # Create user
        user = await UserRepository.create(
            display_name=display_name or (email.split("@")[0] if email else phone[-4:]),
            birth_datetime=birth_datetime,
            birth_location=birth_location
        )

        # Create auth
        await UserRepository.create_auth(
            user_id=user["id"],
            auth_type=auth_type,
            auth_identifier=auth_identifier,
            auth_credential=password  # Will be hashed in repo
        )

        # Generate tokens
        access_token = JWTService.create_access_token(
            str(user["id"]), user["vibe_id"]
        )
        refresh_token = JWTService.create_refresh_token(
            str(user["id"]), user["vibe_id"]
        )

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer",
            "expires_in": JWTService.get_token_expiry(),
            "user": {
                "user_id": str(user["id"]),
                "vibe_id": user["vibe_id"],
                "display_name": user["display_name"]
            }
        }

    @staticmethod
    async def login(
        email: Optional[str] = None,
        phone: Optional[str] = None,
        password: str = None
    ) -> dict:
        """Login user"""
        if not email and not phone:
            raise ValueError("Email or phone is required")

        auth_type = "email" if email else "phone"
        auth_identifier = email if email else phone

        # Verify credentials
        user = await UserRepository.verify_auth(auth_type, auth_identifier, password)

        if not user:
            raise ValueError("Invalid credentials")

        if user.get("status") != "active":
            raise ValueError("Account is not active")

        # Generate tokens
        access_token = JWTService.create_access_token(
            str(user["id"]), user["vibe_id"]
        )
        refresh_token = JWTService.create_refresh_token(
            str(user["id"]), user["vibe_id"]
        )

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer",
            "expires_in": JWTService.get_token_expiry(),
            "user": {
                "user_id": str(user["id"]),
                "vibe_id": user["vibe_id"],
                "display_name": user["display_name"]
            }
        }

    @staticmethod
    async def refresh_token(refresh_token: str) -> dict:
        """Refresh access token"""
        payload = JWTService.verify_refresh_token(refresh_token)

        if not payload:
            raise ValueError("Invalid or expired refresh token")

        user_id = payload.get("sub")
        vibe_id = payload.get("vibe_id")

        # Verify user
        user = await UserRepository.get_by_id(UUID(user_id))
        if not user or user.get("status") != "active":
            raise ValueError("User not found or inactive")

        # Generate new tokens
        new_access_token = JWTService.create_access_token(user_id, vibe_id)
        new_refresh_token = JWTService.create_refresh_token(user_id, vibe_id)

        return {
            "access_token": new_access_token,
            "refresh_token": new_refresh_token,
            "token_type": "bearer",
            "expires_in": JWTService.get_token_expiry(),
            "user": {
                "user_id": str(user["id"]),
                "vibe_id": user["vibe_id"],
                "display_name": user["display_name"]
            }
        }
