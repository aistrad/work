import { test, expect } from '@playwright/test';
import * as fs from 'fs';
import * as path from 'path';

/**
 * æ€§èƒ½æµ‹è¯•å¥—ä»¶ - åˆ†æç½‘é¡µåŠ è½½æ—¶åº
 *
 * æµ‹è¯•ç›®æ ‡:
 * 1. è®°å½•é¡µé¢åŠ è½½å„ä¸ªé˜¶æ®µçš„æ—¶é—´
 * 2. åˆ†æèµ„æºåŠ è½½æ—¶åº
 * 3. ç”Ÿæˆæ—¶åºå›¾æ•°æ®
 * 4. è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
 */

interface PerformanceMetrics {
  // Navigation Timing
  navigationStart: number;
  domainLookupStart: number;
  domainLookupEnd: number;
  connectStart: number;
  connectEnd: number;
  requestStart: number;
  responseStart: number;
  responseEnd: number;
  domLoading: number;
  domInteractive: number;
  domContentLoadedEventStart: number;
  domContentLoadedEventEnd: number;
  domComplete: number;
  loadEventStart: number;
  loadEventEnd: number;

  // Calculated metrics
  dnsLookup: number;
  tcpConnect: number;
  ttfb: number; // Time to First Byte
  contentDownload: number;
  domParsing: number;
  domContentLoaded: number;
  pageLoad: number;
}

interface ResourceTiming {
  name: string;
  type: string;
  startTime: number;
  duration: number;
  transferSize: number;
  decodedBodySize: number;
}

interface SequenceDiagramData {
  title: string;
  participants: string[];
  events: Array<{
    from: string;
    to: string;
    label: string;
    startTime: number;
    endTime: number;
    duration: number;
  }>;
}

test.describe('Page Performance Analysis', () => {
  let performanceData: {
    metrics: PerformanceMetrics | null;
    resources: ResourceTiming[];
    sequenceDiagram: SequenceDiagramData;
  };

  test.beforeEach(async ({ page }) => {
    performanceData = {
      metrics: null,
      resources: [],
      sequenceDiagram: {
        title: 'VibeLife Page Load Sequence',
        participants: ['Browser', 'DNS', 'Server', 'CDN'],
        events: [],
      },
    };
  });

  test('Analyze homepage load performance', async ({ page }) => {
    console.log('ğŸš€ Starting performance analysis...\n');

    // Enable performance tracking
    await page.goto('/', { waitUntil: 'networkidle' });

    // Extract Navigation Timing API data
    const navTiming = await page.evaluate(() => {
      const timing = performance.timing;
      const nav = {
        navigationStart: timing.navigationStart,
        domainLookupStart: timing.domainLookupStart,
        domainLookupEnd: timing.domainLookupEnd,
        connectStart: timing.connectStart,
        connectEnd: timing.connectEnd,
        requestStart: timing.requestStart,
        responseStart: timing.responseStart,
        responseEnd: timing.responseEnd,
        domLoading: timing.domLoading,
        domInteractive: timing.domInteractive,
        domContentLoadedEventStart: timing.domContentLoadedEventStart,
        domContentLoadedEventEnd: timing.domContentLoadedEventEnd,
        domComplete: timing.domComplete,
        loadEventStart: timing.loadEventStart,
        loadEventEnd: timing.loadEventEnd,
      };

      const base = timing.navigationStart;
      return {
        ...nav,
        dnsLookup: timing.domainLookupEnd - timing.domainLookupStart,
        tcpConnect: timing.connectEnd - timing.connectStart,
        ttfb: timing.responseStart - timing.requestStart,
        contentDownload: timing.responseEnd - timing.responseStart,
        domParsing: timing.domInteractive - timing.domLoading,
        domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
        pageLoad: timing.loadEventEnd - timing.navigationStart,
      };
    });

    performanceData.metrics = navTiming;

    // Extract Resource Timing data
    const resources = await page.evaluate(() => {
      const entries = performance.getEntriesByType('resource') as PerformanceResourceTiming[];
      return entries.map(entry => ({
        name: entry.name,
        type: entry.initiatorType,
        startTime: entry.startTime,
        duration: entry.duration,
        transferSize: entry.transferSize || 0,
        decodedBodySize: entry.decodedBodySize || 0,
      }));
    });

    performanceData.resources = resources;

    // Build sequence diagram data
    const navStart = navTiming.navigationStart;
    performanceData.sequenceDiagram.events = [
      {
        from: 'Browser',
        to: 'DNS',
        label: 'DNS Lookup',
        startTime: navTiming.domainLookupStart - navStart,
        endTime: navTiming.domainLookupEnd - navStart,
        duration: navTiming.dnsLookup,
      },
      {
        from: 'Browser',
        to: 'Server',
        label: 'TCP Connect',
        startTime: navTiming.connectStart - navStart,
        endTime: navTiming.connectEnd - navStart,
        duration: navTiming.tcpConnect,
      },
      {
        from: 'Browser',
        to: 'Server',
        label: 'HTTP Request',
        startTime: navTiming.requestStart - navStart,
        endTime: navTiming.responseStart - navStart,
        duration: navTiming.ttfb,
      },
      {
        from: 'Server',
        to: 'Browser',
        label: 'Download HTML',
        startTime: navTiming.responseStart - navStart,
        endTime: navTiming.responseEnd - navStart,
        duration: navTiming.contentDownload,
      },
      {
        from: 'Browser',
        to: 'Browser',
        label: 'Parse DOM',
        startTime: navTiming.domLoading - navStart,
        endTime: navTiming.domInteractive - navStart,
        duration: navTiming.domParsing,
      },
      {
        from: 'Browser',
        to: 'Browser',
        label: 'DOMContentLoaded',
        startTime: navTiming.domContentLoadedEventStart - navStart,
        endTime: navTiming.domContentLoadedEventEnd - navStart,
        duration: navTiming.domContentLoaded,
      },
      {
        from: 'Browser',
        to: 'Browser',
        label: 'Complete Load',
        startTime: navTiming.domComplete - navStart,
        endTime: navTiming.loadEventEnd - navStart,
        duration: navTiming.loadEventEnd - navTiming.domComplete,
      },
    ];

    // Print detailed performance report
    console.log('ğŸ“Š Performance Metrics:\n');
    console.log('  DNS Lookup:         ', navTiming.dnsLookup.toFixed(2), 'ms');
    console.log('  TCP Connect:        ', navTiming.tcpConnect.toFixed(2), 'ms');
    console.log('  TTFB:               ', navTiming.ttfb.toFixed(2), 'ms');
    console.log('  Content Download:   ', navTiming.contentDownload.toFixed(2), 'ms');
    console.log('  DOM Parsing:        ', navTiming.domParsing.toFixed(2), 'ms');
    console.log('  DOMContentLoaded:   ', navTiming.domContentLoaded.toFixed(2), 'ms');
    console.log('  Total Page Load:    ', navTiming.pageLoad.toFixed(2), 'ms\n');

    // Analyze resources by type
    const resourcesByType: Record<string, ResourceTiming[]> = {};
    resources.forEach(r => {
      if (!resourcesByType[r.type]) resourcesByType[r.type] = [];
      resourcesByType[r.type].push(r);
    });

    console.log('ğŸ“¦ Resources by Type:\n');
    for (const [type, items] of Object.entries(resourcesByType)) {
      const totalSize = items.reduce((sum, r) => sum + r.transferSize, 0);
      const totalTime = items.reduce((sum, r) => sum + r.duration, 0);
      console.log(`  ${type.padEnd(12)} Count: ${items.length.toString().padStart(3)}  Size: ${(totalSize / 1024).toFixed(1).padStart(8)} KB  Time: ${totalTime.toFixed(1).padStart(8)} ms`);
    }
    console.log('');

    // Find slowest resources
    const slowest = [...resources]
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 10);

    console.log('â±ï¸  Top 10 Slowest Resources:\n');
    slowest.forEach((r, i) => {
      const name = r.name.split('/').pop() || r.name;
      const displayName = name.length > 40 ? '...' + name.slice(-37) : name;
      console.log(`  ${(i + 1).toString().padStart(2)}. ${displayName.padEnd(40)} ${r.duration.toFixed(1).padStart(8)} ms  (${(r.transferSize / 1024).toFixed(1).padStart(6)} KB)`);
    });
    console.log('');

    // Save data to files
    const outputDir = path.join(process.cwd(), 'performance-reports');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const metricsFile = path.join(outputDir, `metrics-${timestamp}.json`);
    const sequenceFile = path.join(outputDir, `sequence-${timestamp}.json`);
    const mermaidFile = path.join(outputDir, `sequence-${timestamp}.mmd`);

    fs.writeFileSync(metricsFile, JSON.stringify(performanceData, null, 2));
    console.log(`ğŸ’¾ Saved metrics to: ${metricsFile}`);

    fs.writeFileSync(sequenceFile, JSON.stringify(performanceData.sequenceDiagram, null, 2));
    console.log(`ğŸ’¾ Saved sequence data to: ${sequenceFile}`);

    // Generate Mermaid sequence diagram
    const mermaidDiagram = generateMermaidSequenceDiagram(performanceData.sequenceDiagram);
    fs.writeFileSync(mermaidFile, mermaidDiagram);
    console.log(`ğŸ’¾ Saved Mermaid diagram to: ${mermaidFile}\n`);

    // Performance assertions
    expect(navTiming.ttfb).toBeLessThan(1000); // TTFB < 1s
    expect(navTiming.domContentLoaded).toBeLessThan(500); // DCL < 500ms
    expect(navTiming.pageLoad).toBeLessThan(5000); // Total load < 5s
  });

  test('Analyze chat page load performance', async ({ page }) => {
    console.log('ğŸš€ Analyzing chat page performance...\n');

    await page.goto('/chat', { waitUntil: 'networkidle' });

    const navTiming = await page.evaluate(() => {
      const timing = performance.timing;
      return {
        ttfb: timing.responseStart - timing.requestStart,
        domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
        pageLoad: timing.loadEventEnd - timing.navigationStart,
      };
    });

    console.log('ğŸ“Š Chat Page Metrics:\n');
    console.log('  TTFB:               ', navTiming.ttfb.toFixed(2), 'ms');
    console.log('  DOMContentLoaded:   ', navTiming.domContentLoaded.toFixed(2), 'ms');
    console.log('  Total Page Load:    ', navTiming.pageLoad.toFixed(2), 'ms\n');

    expect(navTiming.ttfb).toBeLessThan(1000);
    expect(navTiming.pageLoad).toBeLessThan(5000);
  });
});

/**
 * Generate Mermaid sequence diagram from performance data
 */
function generateMermaidSequenceDiagram(data: SequenceDiagramData): string {
  let diagram = `sequenceDiagram
    title ${data.title}

`;

  // Add participants
  data.participants.forEach(p => {
    diagram += `    participant ${p}\n`;
  });
  diagram += '\n';

  // Add events in chronological order
  const sortedEvents = [...data.events].sort((a, b) => a.startTime - b.startTime);

  sortedEvents.forEach(event => {
    const arrow = event.from === event.to ? '->>' : '->>';
    diagram += `    ${event.from}${arrow}${event.to}: ${event.label} (${event.duration.toFixed(0)}ms)\n`;

    // Add note for significant delays
    if (event.duration > 100) {
      diagram += `    Note over ${event.from},${event.to}: âš ï¸ ${event.duration.toFixed(0)}ms\n`;
    }
  });

  diagram += '\n';
  return diagram;
}
