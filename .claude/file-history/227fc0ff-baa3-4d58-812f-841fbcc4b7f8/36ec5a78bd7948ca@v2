/**
 * Context Builder for Fortune AI Agent Runtime
 *
 * Builds the system prompt from context fetched from FastAPI internal API.
 * The context includes user profile, preferences, evidence, and anti-dependency check.
 */

export interface UserContext {
  user_id: number;
  system_prompt: string;
  persona_style: string;
  user_context: Record<string, unknown>;
  evidence: Record<string, unknown>;
  anti_dependency: {
    should_intervene: boolean;
    intervention_type: string | null;
    intervention_message: string | null;
  };
  history: Array<{ role: string; content: string }>;
}

/**
 * Build system prompt from context.
 *
 * SSOT: The system_prompt comes from FastAPI (soul_os.py), not built here.
 * This ensures consistency between different chat runtimes.
 *
 * The FastAPI system_prompt is already formatted with:
 * - Persona style rules
 * - User context (facts, evidence)
 * - Anti-dependency interventions
 *
 * We only add tools-specific instructions here if needed.
 */
export function buildSystemPrompt(context: UserContext): string {
  // SSOT: Use system_prompt from FastAPI as-is
  let prompt = context.system_prompt || '';

  // If FastAPI didn't provide system_prompt, use minimal fallback
  if (!prompt.trim()) {
    prompt = buildFallbackSystemPrompt(context);
  }

  // Add tools instruction (not in FastAPI prompt)
  const toolsInstruction = `

【工具使用】
当需要查询八字、运势、心理等功能时，使用提供的 tools 来获取数据。
`;

  return prompt + toolsInstruction;
}

/**
 * Fallback system prompt when FastAPI doesn't provide one.
 * This should rarely be used in production.
 */
function buildFallbackSystemPrompt(context: UserContext): string {
  return `你是 Mentis 的对话 Agent，角色是积极心理学教练。

【硬性规则】
1) 禁止恐吓、羞辱、宿命论断言
2) 每次输出必须包含：结论 + 依据 + ≤3条处方 + 承诺邀请
3) 每条处方必须包含 if_then

【语言风格】
${context.persona_style || 'warm'}

【用户上下文】
${JSON.stringify(context.user_context, null, 2)}

【依据】
${JSON.stringify(context.evidence, null, 2)}
${
  context.anti_dependency?.should_intervene
    ? `
【反依赖干预】
类型: ${context.anti_dependency.intervention_type}
消息: ${context.anti_dependency.intervention_message}
`
    : ''
}`;
}

// Convert chat history to Vercel AI SDK format
export function buildMessages(
  context: UserContext,
  userMessage: string
): Array<{ role: 'user' | 'assistant'; content: string }> {
  const messages: Array<{ role: 'user' | 'assistant'; content: string }> = [];

  // Add history
  for (const msg of context.history) {
    if (msg.role === 'user' || msg.role === 'assistant') {
      messages.push({
        role: msg.role as 'user' | 'assistant',
        content: msg.content,
      });
    }
  }

  // Add current message
  messages.push({
    role: 'user',
    content: userMessage,
  });

  return messages;
}

// Internal service token for secure internal API calls
const INTERNAL_SERVICE_TOKEN = process.env.FORTUNE_INTERNAL_SERVICE_TOKEN || '';

// Fetch context from FastAPI internal API
export async function fetchContext(
  sessionId: string | null,
  query: string,
  sessionCookie: string
): Promise<UserContext> {
  const fastApiUrl = process.env.FASTAPI_URL || 'http://localhost:8230';

  const params = new URLSearchParams();
  if (sessionId) params.set('session_id', sessionId);
  if (query) params.set('query', query);

  const headers: Record<string, string> = {
    Cookie: `fortune_session=${sessionCookie}`,
  };

  // Add service token for internal API trust boundary
  if (INTERNAL_SERVICE_TOKEN) {
    headers['X-Service-Token'] = INTERNAL_SERVICE_TOKEN;
  }

  const res = await fetch(`${fastApiUrl}/internal/context?${params.toString()}`, {
    headers,
  });

  if (!res.ok) {
    throw new Error(`Failed to fetch context: ${res.status}`);
  }

  return res.json();
}
