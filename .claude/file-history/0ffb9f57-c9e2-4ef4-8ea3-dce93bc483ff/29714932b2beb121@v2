"use client";

/**
 * ThinkingBlock - AI 思考过程可视化组件
 *
 * 设计参考 Claude.ai / Gemini 的思考展示方式：
 * - 流式时展开显示详细步骤
 * - 完成后自动折叠为一行摘要
 * - 点击可手动展开/折叠
 *
 * v11.0 新增
 */

import { memo, useState, useEffect } from "react";
import { cn } from "@/lib/utils";
import { ChevronDown, ChevronUp, Sparkles } from "lucide-react";

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

export interface ThinkingStep {
  id: string;
  content: string;
  phase: "analyzing" | "skill_activate" | "tool_call" | "complete";
  iteration?: number;
}

export interface ThinkingBlockProps {
  steps: ThinkingStep[];
  isStreaming: boolean;
  defaultExpanded?: boolean;
}

// ═══════════════════════════════════════════════════════════════════════════
// StreamingDots - 流式加载指示器
// ═══════════════════════════════════════════════════════════════════════════

function StreamingDots() {
  return (
    <span className="thinking-dots ml-2">
      <span />
      <span />
      <span />
    </span>
  );
}

// ═══════════════════════════════════════════════════════════════════════════
// ThinkingBlock Component
// ═══════════════════════════════════════════════════════════════════════════

export const ThinkingBlock = memo(function ThinkingBlock({
  steps,
  isStreaming,
  defaultExpanded = true,
}: ThinkingBlockProps) {
  const [isExpanded, setIsExpanded] = useState(defaultExpanded);

  // Auto-expand when streaming, auto-collapse when complete
  useEffect(() => {
    if (isStreaming) {
      setIsExpanded(true);
    } else if (steps.some((s) => s.phase === "complete")) {
      // Delay collapse to let user see the completion state
      const timer = setTimeout(() => setIsExpanded(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [isStreaming, steps]);

  // Get summary text for collapsed state
  const lastStep = steps[steps.length - 1];
  const summary = lastStep?.content || "思考中...";
  const isComplete = lastStep?.phase === "complete";

  // Don't render if no steps
  if (steps.length === 0) {
    return null;
  }

  return (
    <div
      className={cn(
        "thinking-block",
        isStreaming && "streaming",
        isComplete && "complete"
      )}
    >
      {/* Header */}
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="thinking-header"
        aria-expanded={isExpanded}
        aria-label={isExpanded ? "折叠思考过程" : "展开思考过程"}
      >
        <Sparkles className="w-4 h-4 text-accent-primary/60 shrink-0" />
        <span className="flex-1 text-left truncate">
          {isExpanded ? "思考过程" : summary}
        </span>
        {isStreaming && <StreamingDots />}
        {!isStreaming && (
          isExpanded ? (
            <ChevronUp className="w-4 h-4 shrink-0" />
          ) : (
            <ChevronDown className="w-4 h-4 shrink-0" />
          )
        )}
      </button>

      {/* Content */}
      <div
        className={cn(
          "thinking-content-wrapper",
          isExpanded ? "expanded" : "collapsed"
        )}
      >
        <ul className="thinking-steps">
          {steps.map((step, i) => (
            <ThinkingStepItem
              key={`${step.id}-${step.phase}-${i}`}
              step={step}
              isLast={i === steps.length - 1}
              isStreaming={isStreaming}
            />
          ))}
        </ul>
      </div>
    </div>
  );
});

// ═══════════════════════════════════════════════════════════════════════════
// ThinkingStepItem - Individual step
// ═══════════════════════════════════════════════════════════════════════════

const ThinkingStepItem = memo(function ThinkingStepItem({
  step,
  isLast,
  isStreaming,
}: {
  step: ThinkingStep;
  isLast: boolean;
  isStreaming: boolean;
}) {
  const isActive = isLast && isStreaming;

  return (
    <li className={cn("thinking-step", isActive && "active")}>
      <span className={cn("step-dot", step.phase)} />
      <span className="step-content">{step.content}</span>
    </li>
  );
});

export default ThinkingBlock;
