"""
Mentis OS v3.0 - 认证 API 路由
"""
from __future__ import annotations

import time
from typing import Any, Dict, Optional
from uuid import UUID, uuid4

from fastapi import APIRouter, Depends, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr, Field

from services import auth_service
from services.auth_service import AuthError


router = APIRouter(prefix="/v3/auth", tags=["auth"])


# =============================================================================
# 通用用户解析依赖
# =============================================================================

def resolve_user_id(request: Request) -> str:
    """
    从请求中解析用户 ID

    支持:
    - Bearer JWT token
    - Bearer UUID (直接作为用户 ID)
    - X-Mentis-User-Id header

    用法:
    @router.get("/example")
    async def example(user_id: str = Depends(resolve_user_id)):
        ...
    """
    auth = (request.headers.get("Authorization") or "").strip()
    if auth.startswith("Bearer "):
        token = auth[7:].strip()
        try:
            # 首先尝试解析 JWT token
            result = auth_service.verify_access_token(token)
            return result["user_id"]
        except auth_service.AuthError as e:
            raise HTTPException(status_code=401, detail=e.code)
        except Exception:
            # 回退：尝试当作 UUID
            try:
                UUID(token)
                return token
            except Exception:
                raise HTTPException(status_code=401, detail="auth/invalid-token")

    header_user = (request.headers.get("X-Mentis-User-Id") or "").strip()
    if header_user:
        try:
            UUID(header_user)
            return header_user
        except Exception:
            raise HTTPException(status_code=401, detail="auth/invalid-token")

    raise HTTPException(status_code=401, detail="auth/missing-token")


def _request_id(prefix: str) -> str:
    return f"{prefix}-{int(time.time())}-{uuid4().hex[:8]}"


def _ok(data: Dict[str, Any]) -> JSONResponse:
    return JSONResponse({"ok": True, "data": data})


def _error_response(
    *,
    status_code: int,
    code: str,
    message: str,
    request_id: str,
) -> JSONResponse:
    return JSONResponse(
        {
            "ok": False,
            "error": {
                "code": code,
                "message": message,
                "request_id": request_id,
            },
        },
        status_code=status_code,
    )


# =============================================================================
# Request Models
# =============================================================================

class RegisterRequest(BaseModel):
    """注册请求"""
    email: EmailStr = Field(..., description="邮箱")
    password: str = Field(..., min_length=6, max_length=100, description="密码")
    name: Optional[str] = Field(None, max_length=100, description="用户名")


class LoginRequest(BaseModel):
    """登录请求"""
    email: EmailStr = Field(..., description="邮箱")
    password: str = Field(..., description="密码")


class RefreshRequest(BaseModel):
    """刷新令牌请求"""
    refresh_token: str = Field(..., description="刷新令牌")


# =============================================================================
# API Endpoints
# =============================================================================

@router.post("/register")
async def register(body: RegisterRequest):
    """
    用户注册

    返回用户信息和访问令牌。
    """
    request_id = _request_id("register")

    try:
        result = auth_service.register_user(
            email=body.email,
            password=body.password,
            name=body.name,
        )
        return _ok(result)
    except AuthError as e:
        return _error_response(
            status_code=400 if e.code == "auth/email-exists" else 500,
            code=e.code,
            message=e.message,
            request_id=request_id,
        )
    except Exception as e:
        return _error_response(
            status_code=500,
            code="auth/registration-error",
            message=str(e)[:100],
            request_id=request_id,
        )


@router.post("/login")
async def login(body: LoginRequest):
    """
    用户登录

    返回用户信息和访问令牌。
    """
    request_id = _request_id("login")

    try:
        result = auth_service.login_user(
            email=body.email,
            password=body.password,
        )
        return _ok(result)
    except AuthError as e:
        return _error_response(
            status_code=401 if e.code == "auth/invalid-credentials" else 500,
            code=e.code,
            message=e.message,
            request_id=request_id,
        )
    except Exception as e:
        return _error_response(
            status_code=500,
            code="auth/login-error",
            message=str(e)[:100],
            request_id=request_id,
        )


@router.post("/refresh")
async def refresh_token(body: RefreshRequest):
    """
    刷新访问令牌

    使用刷新令牌获取新的访问令牌。
    """
    request_id = _request_id("refresh")

    try:
        result = auth_service.refresh_tokens(body.refresh_token)
        return _ok(result)
    except AuthError as e:
        return _error_response(
            status_code=401,
            code=e.code,
            message=e.message,
            request_id=request_id,
        )
    except Exception as e:
        return _error_response(
            status_code=500,
            code="auth/refresh-error",
            message=str(e)[:100],
            request_id=request_id,
        )


@router.get("/me")
async def get_current_user(request: Request):
    """
    获取当前用户信息

    需要 Bearer token 认证。
    """
    request_id = _request_id("me")

    auth = (request.headers.get("Authorization") or "").strip()
    if not auth.startswith("Bearer "):
        return _error_response(
            status_code=401,
            code="auth/missing-token",
            message="未提供认证令牌",
            request_id=request_id,
        )

    token = auth[7:].strip()

    try:
        user = auth_service.get_current_user(token)
        return _ok(user)
    except AuthError as e:
        return _error_response(
            status_code=401,
            code=e.code,
            message=e.message,
            request_id=request_id,
        )
    except Exception as e:
        return _error_response(
            status_code=500,
            code="auth/error",
            message=str(e)[:100],
            request_id=request_id,
        )


@router.post("/logout")
async def logout(request: Request):
    """
    用户登出

    客户端应删除本地存储的 token。
    服务端可以将 token 加入黑名单（可选实现）。
    """
    request_id = _request_id("logout")

    # 简单实现：返回成功，客户端负责清除 token
    return _ok({"logged_out": True})
