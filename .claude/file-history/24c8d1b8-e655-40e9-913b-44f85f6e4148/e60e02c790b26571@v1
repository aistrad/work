"""
ProactiveEngine - 主动推送系统核心引擎

职责:
1. 加载 Skill 级提醒定义 (reminders.yaml)
2. 协调触发检测、内容生成、推送投递
3. 管理数据源 (unified_profiles)

设计原则:
- Skill 级定义: 每个 Skill 在 reminders.yaml 定义自己的提醒类型
- 数据源统一: unified_profiles 是唯一真源
- 智能化: 基于 life_context 个性化内容 + 事件触发
"""

import logging
import yaml
from dataclasses import dataclass, field
from datetime import datetime, date, timedelta
from enum import Enum
from pathlib import Path
from typing import List, Dict, Any, Optional
from uuid import UUID

import pytz

from stores.db import get_connection
from stores.unified_profile_repo import UnifiedProfileRepository
from stores.skill_subscription_repo import SkillSubscriptionRepository
from services.reminder.notification import NotificationService
# v7.5: 使用 async 版本，从数据库优先加载
from services.agent.skill_loader import load_skill_metadata_async

logger = logging.getLogger(__name__)


class ReminderPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


@dataclass
class ReminderTask:
    """提醒任务"""
    user_id: UUID
    skill_id: str
    reminder_type: str
    priority: ReminderPriority = ReminderPriority.MEDIUM
    trigger_event: Optional[str] = None
    trigger_date: Optional[date] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ReminderContent:
    """提醒内容"""
    title: str
    body: str
    data: Dict[str, Any] = field(default_factory=dict)
    card_type: Optional[str] = None
    # 对话引导字段
    suggested_prompt: Optional[str] = None
    quick_actions: List[Dict[str, str]] = field(default_factory=list)


class ProactiveEngine:
    """主动推送引擎"""

    # 默认推送时间 (用户本地时间) - 可被 global_config 覆盖
    DEFAULT_PUSH_HOUR = 4

    def __init__(self):
        self._skill_configs: Dict[str, Dict] = {}
        self._global_config: Dict[str, Any] = {}  # 全局配置
        self._trigger_detector = None
        self._content_generator = None
        self._notification_service = NotificationService()
        self._load_skill_configs()

    def _get_default_push_hour(self, skill_id: Optional[str] = None) -> int:
        """
        获取默认推送时间（支持全局和 Skill 级别配置）

        优先级: Skill global_config > 系统默认值
        """
        if skill_id:
            skill_config = self._skill_configs.get(skill_id, {})
            global_config = skill_config.get("global_config", {})
            if "default_push_hour" in global_config:
                return global_config["default_push_hour"]

        return self.DEFAULT_PUSH_HOUR

    def _load_skill_configs(self):
        """加载所有 Skill 的 reminders.yaml"""
        skills_dir = Path(__file__).parent.parent.parent / "skills"

        for skill_dir in skills_dir.iterdir():
            if skill_dir.is_dir():
                reminders_file = skill_dir / "reminders.yaml"
                if reminders_file.exists():
                    try:
                        with open(reminders_file, encoding="utf-8") as f:
                            config = yaml.safe_load(f)
                            if config and "skill_id" in config:
                                self._skill_configs[config["skill_id"]] = config
                                logger.info(f"Loaded reminders config for skill: {config['skill_id']}")
                    except Exception as e:
                        logger.error(f"Failed to load {reminders_file}: {e}")

        logger.info(f"Loaded {len(self._skill_configs)} skill reminder configs")

    @property
    def trigger_detector(self):
        """延迟加载 TriggerDetector"""
        if self._trigger_detector is None:
            from .trigger_detector import TriggerDetector
            self._trigger_detector = TriggerDetector()
        return self._trigger_detector

    @property
    def content_generator(self):
        """延迟加载 ContentGenerator"""
        if self._content_generator is None:
            from .content_generator import ContentGenerator
            self._content_generator = ContentGenerator()
        return self._content_generator

    async def run_scheduled_scan(self) -> List[ReminderTask]:
        """
        定时扫描入口 (由 Worker 调用)

        流程:
        1. 获取当前时段应该推送的用户
        2. 检测每个用户的触发条件
        3. 生成提醒任务
        """
        tasks = []

        # 获取当前时段的用户
        users = await self._get_users_for_current_hour()
        logger.info(f"Found {len(users)} users for current hour")

        for user in users:
            try:
                user_tasks = await self._detect_user_triggers(user)
                tasks.extend(user_tasks)
            except Exception as e:
                logger.error(f"Failed to detect triggers for user {user.get('user_id')}: {e}")

        logger.info(f"Generated {len(tasks)} reminder tasks")
        return tasks

    async def process_tasks(self, tasks: List[ReminderTask]) -> int:
        """
        处理提醒任务

        流程:
        1. 生成个性化内容
        2. 投递到推送渠道
        3. 记录到数据库
        """
        success_count = 0

        for task in tasks:
            try:
                # 获取用户 Profile
                profile = await UnifiedProfileRepository.get_profile(task.user_id)
                if not profile:
                    logger.warning(f"Profile not found for user {task.user_id}")
                    continue

                # 获取 Skill 配置
                skill_config = self._skill_configs.get(task.skill_id, {})
                reminder_config = self._get_reminder_config(skill_config, task.reminder_type)

                # 生成内容
                content = await self.content_generator.generate(
                    task=task,
                    profile=profile,
                    config=reminder_config,
                )

                # 投递 (保存到数据库)
                # 使用统一的 notification_type 格式: {skill_id}_{reminder_type}
                notification_type = f"{task.skill_id}_{task.reminder_type}"
                await self._notification_service.send_notification(
                    user_id=task.user_id,
                    notification_type=notification_type,
                    title=content.title,
                    content=content.data,
                    trigger_date=task.trigger_date or date.today(),
                )

                success_count += 1
                logger.debug(f"Processed task: {task.skill_id}/{task.reminder_type} for user {task.user_id}")

            except Exception as e:
                logger.error(f"Failed to process task {task}: {e}")

        logger.info(f"Successfully processed {success_count}/{len(tasks)} tasks")
        return success_count

    async def run_once(self) -> int:
        """执行一次完整的扫描和处理"""
        tasks = await self.run_scheduled_scan()
        if tasks:
            return await self.process_tasks(tasks)
        return 0

    def _get_all_configured_push_hours(self) -> set:
        """
        获取所有 Skill 配置的推送时间

        收集所有 reminders.yaml 中的 global_config.default_push_hour
        """
        hours = {self.DEFAULT_PUSH_HOUR}  # 始终包含系统默认值

        for skill_id, config in self._skill_configs.items():
            global_config = config.get("global_config", {})
            if "default_push_hour" in global_config:
                hours.add(global_config["default_push_hour"])

        return hours

    async def _get_users_for_current_hour(self) -> List[Dict[str, Any]]:
        """
        获取当前时段应该推送的用户

        改进: 支持多个 Skill 不同的推送时间
        - 收集所有配置的推送时间
        - 返回用户本地时间匹配任一推送时间的用户
        """
        now_utc = datetime.now(pytz.UTC)
        target_hours = self._get_all_configured_push_hours()

        logger.debug(f"Configured push hours: {target_hours}")

        # 找出当前时刻为目标时间的时区偏移 (支持多个小时)
        valid_offsets = set()
        for target_hour in target_hours:
            for offset in range(-12, 15):
                tz_time = now_utc + timedelta(hours=offset)
                if tz_time.hour == target_hour:
                    valid_offsets.add(offset)

        if not valid_offsets:
            return []

        # 查询付费用户 (使用 unified_profiles)
        query = """
            SELECT u.id as user_id, up.profile
            FROM vibe_users u
            JOIN unified_profiles up ON up.user_id = u.id
            WHERE u.subscription_status = 'active'
        """

        users = []
        try:
            async with get_connection() as conn:
                rows = await conn.fetch(query)

            for row in rows:
                profile = row["profile"] if isinstance(row["profile"], dict) else {}
                tz_name = profile.get("preferences", {}).get("timezone", "Asia/Shanghai")

                try:
                    tz = pytz.timezone(tz_name)
                    user_time = now_utc.astimezone(tz)
                    # 检查用户本地时间是否匹配任一配置的推送时间
                    if user_time.hour in target_hours:
                        users.append({
                            "user_id": row["user_id"],
                            "profile": profile,
                            "timezone": tz_name,
                            "local_hour": user_time.hour,  # 添加本地时间信息
                        })
                except Exception:
                    # 默认使用 Asia/Shanghai (UTC+8)
                    if 8 in valid_offsets:
                        users.append({
                            "user_id": row["user_id"],
                            "profile": profile,
                            "timezone": "Asia/Shanghai",
                            "local_hour": (now_utc.hour + 8) % 24,
                        })
        except Exception as e:
            logger.error(f"Failed to get users: {e}")

        return users

    async def _should_send_to_user(
        self,
        user_id: UUID,
        skill_id: str,
    ) -> bool:
        """
        检查是否应该发送推送

        基于 Skill 订阅状态决定：
        - Core Skill: 始终发送
        - Default Skill: 未取消订阅且 push_enabled 时发送
        - Professional Skill: 已订阅且 push_enabled 时发送
        """
        # 获取 Skill 元数据
        skill_meta = load_skill_metadata(skill_id)
        category = skill_meta.category if skill_meta else "professional"

        # Core Skill 始终发送
        if category == "core":
            return True

        # 获取用户订阅状态
        subscription = await SkillSubscriptionRepository.get(user_id, skill_id)

        # Default Skill: 检查取消订阅和推送开关
        if category == "default":
            if subscription and subscription.status == "unsubscribed":
                return False
            if subscription and not subscription.push_enabled:
                return False
            return True

        # Professional Skill: 需要有效订阅且开启推送
        if not subscription or subscription.status != "subscribed":
            return False

        return subscription.push_enabled

    async def _detect_user_triggers(self, user: Dict[str, Any]) -> List[ReminderTask]:
        """检测用户的所有触发条件 - 集成订阅检查"""
        tasks = []
        user_id = user["user_id"]
        profile = user["profile"]
        user_local_hour = user.get("local_hour")

        # 遍历所有 Skill 配置
        for skill_id, config in self._skill_configs.items():
            # 检查 Skill 配置的推送时间是否匹配用户本地时间
            skill_push_hour = self._get_default_push_hour(skill_id)
            if user_local_hour is not None and user_local_hour != skill_push_hour:
                continue

            # 先检查订阅状态（避免无谓的触发检测）
            if not await self._should_send_to_user(user_id, skill_id):
                continue

            # 支持新旧配置格式: reminders (新) / reminder_types (旧)
            reminders = config.get("reminders") or config.get("reminder_types", [])

            # 获取 Skill 级别的 cooldown 配置
            global_config = config.get("global_config", {})
            default_cooldown = global_config.get("cooldown_hours", 24)

            for reminder in reminders:
                trigger_config = reminder.get("trigger", {})
                reminder_id = reminder.get("id", "unknown")

                try:
                    # 检测触发条件
                    should_trigger, event_info = await self.trigger_detector.should_trigger(
                        trigger_config=trigger_config,
                        profile=profile,
                        skill_id=skill_id,
                    )

                    if should_trigger:
                        # 检查 cooldown（支持 trigger 级别和 skill 级别配置）
                        cooldown_hours = trigger_config.get("cooldown_hours", default_cooldown)
                        notification_type = f"{skill_id}_{reminder_id}"

                        if not await self._notification_service.check_cooldown(
                            user_id=user_id,
                            notification_type=notification_type,
                            cooldown_hours=cooldown_hours,
                        ):
                            logger.debug(f"Cooldown active for {notification_type}, skipping")
                            continue

                        tasks.append(ReminderTask(
                            user_id=user_id,
                            skill_id=skill_id,
                            reminder_type=reminder_id,
                            priority=ReminderPriority(reminder.get("priority", "medium")),
                            trigger_event=event_info.get("event_name") if event_info else None,
                            trigger_date=event_info.get("event_date") if event_info else date.today(),
                            metadata={"config": reminder, "event_info": event_info},
                        ))
                except Exception as e:
                    logger.error(f"Failed to check trigger {reminder_id} for user {user_id}: {e}")

        return tasks

    def _get_reminder_config(self, skill_config: Dict, reminder_type: str) -> Dict:
        """获取特定提醒类型的配置"""
        # 支持新旧配置格式
        reminders = skill_config.get("reminders") or skill_config.get("reminder_types", [])
        for reminder in reminders:
            if reminder["id"] == reminder_type:
                return reminder
        return {}

    def get_skill_configs(self) -> Dict[str, Dict]:
        """获取所有 Skill 配置 (用于调试)"""
        return self._skill_configs


# ═══════════════════════════════════════════════════════════════════════════
# Singleton
# ═══════════════════════════════════════════════════════════════════════════

_engine: Optional[ProactiveEngine] = None


def get_proactive_engine() -> ProactiveEngine:
    """获取单例 ProactiveEngine"""
    global _engine
    if _engine is None:
        _engine = ProactiveEngine()
    return _engine
