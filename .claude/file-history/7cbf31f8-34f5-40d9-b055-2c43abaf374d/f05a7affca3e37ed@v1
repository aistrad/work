# Proactive 模块 LLM-First 重构设计 v3.0

> Version: 3.0 | Date: 2026-01-25
> 目标：将 Proactive 系统升级为 LLM-First + Agent 驱动架构

---

## 概述

本文档定义 Proactive 模块从 v2.0（硬编码架构）到 v3.0（LLM-First + Agent 驱动）的升级方案。核心变化是消除 TriggerDetector 和 ContentGenerator 中的硬编码逻辑，统一复用 CoreAgent 能力。

### 设计原则

| 原则 | v2.0 | v3.0 |
|-----|------|------|
| 触发检测 | 10+ 硬编码 `_detect_*` 方法 | LLM 评估声明式 conditions |
| 内容生成 | 10+ 硬编码 `_generate_*` 方法 | 调用 CoreAgent Phase 2 |
| 新增功能 | 需要修改 Python 代码 | 只需修改 YAML + rules/*.md |
| 与 Agent 关系 | 独立系统 | 统一架构，复用 Agent |

### 遵循的 LLM-First 原则

来自 `/docs/archive/v9/LLM-FIRST-DESIGN.md` V10.3：

```python
# ❌ 禁止：Python 层面的条件判断
if "职业" in focus:
    hints.append("优先考虑 career")
if event_type == "birthday":
    return self._detect_birthday()

# ✅ 正确：让 LLM 读取配置自主决定
# conditions 声明式配置，LLM 根据 profile 自主判断
```

---

## 架构对比

### v2.0 架构（当前）

```
┌─────────────────┐    ┌──────────────────┐    ┌────────────────────┐
│ ProactiveWorker │───▶│ ProactiveEngine  │───▶│ TriggerDetector    │
└─────────────────┘    │                  │    │ (643 行硬编码)     │
                       │                  │    │ _detect_birthday() │
                       │                  │    │ _detect_dayun()    │
                       │                  │    │ _check_has_data()  │
                       │                  │    │ ...10+ 方法        │
                       │                  │    └────────────────────┘
                       │                  │    ┌────────────────────┐
                       │                  │───▶│ ContentGenerator   │
                       └──────────────────┘    │ (1037 行硬编码)    │
                                               │ _generate_fortune()│
                                               │ _generate_dayun()  │
                                               │ ...10+ 方法        │
                                               └────────────────────┘
```

### v3.0 架构（目标）

```
┌─────────────────┐    ┌──────────────────────┐    ┌──────────────────┐
│ ProactiveWorker │───▶│ ProactiveOrchestrator│───▶│ TriggerEvaluator │
└─────────────────┘    │ (纯配置加载+分发)    │    │ (LLM 评估触发)   │
                       │                      │    │ - cron 匹配      │
                       │                      │    │ - LLM conditions │
                       │                      │    └──────────────────┘
                       │                      │    ┌──────────────────┐
                       │                      │───▶│ CoreAgent.run()  │
                       └──────────────────────┘    │ (复用 Phase 2)   │
                                                   │ - Skill 工具     │
                                                   │ - Rules 规则     │
                                                   │ - 知识检索       │
                                                   └──────────────────┘
```

---

## 需要删除的硬编码

### TriggerDetector（trigger_detector.py，643 行）

| 方法 | 替代方案 |
|------|---------|
| `_detect_birthday()` | `conditions: [{event: birthday}]` + LLM 评估 |
| `_detect_dayun_change()` | `conditions: [{event: dayun_change}]` + LLM 评估 |
| `_detect_new_year()` | `conditions: [{event: new_year}]` + LLM 评估 |
| `_detect_solar_term()` | `conditions: [{event: solar_term}]` + LLM 评估 |
| `_detect_lunar_phase()` | `conditions: [{event: lunar_phase}]` + LLM 评估 |
| `_detect_mercury_retrograde()` | `conditions: [{event: mercury_retrograde}]` + LLM 评估 |
| `_detect_significant_transit()` | `conditions: [{event: significant_transit}]` + LLM 评估 |
| `_detect_streak_broken()` | `conditions: [{event: streak_broken}]` + LLM 评估 |
| `_check_has_data()` | `conditions: [{data_path: "...", operator: exists}]` |
| `_check_not_checked_in_today()` | `conditions: [{data_path: "...", operator: "!=", value: "{today}"}]` |
| `_check_has_pending_levers()` | `conditions: [{description: "有未完成杠杆"}]` + LLM 评估 |

### ContentGenerator（content_generator.py，1037 行）

| 方法 | 替代方案 |
|------|---------|
| `_generate_daily_fortune()` | `content.rule: rules/proactive/daily-fortune-push.md` + Agent |
| `_generate_dayun_transition()` | `content.rule: rules/proactive/dayun-push.md` + Agent |
| `_generate_fortune_alert()` | `content.rule: rules/proactive/fortune-alert-push.md` + Agent |
| `_generate_daily_horoscope()` | `content.rule: rules/proactive/daily-horoscope-push.md` + Agent |
| `_generate_transit_alert()` | `content.rule: rules/proactive/transit-alert-push.md` + Agent |
| `_generate_lunar_phase()` | `content.rule: rules/proactive/lunar-phase-push.md` + Agent |
| `_generate_solar_term()` | `content.rule: rules/proactive/solar-term-push.md` + Agent |
| `_generate_weekly_summary()` | `content.rule: rules/proactive/weekly-summary-push.md` + Agent |
| `_generate_birthday()` | `content.rule: rules/proactive/birthday-push.md` + Agent |
| `_generate_daily_checkin()` | `content.rule: rules/proactive/daily-checkin-push.md` + Agent |

---

## 配置规范 v3.0

### reminders.yaml 升级格式

```yaml
version: "3.0"  # 标识使用新架构
skill_id: bazi
enabled: true

reminders:
  - id: daily_fortune
    name: 每日运势

    # 触发配置
    trigger:
      type: time_based          # 时间触发保留 cron 匹配
      schedule: "0 8 * * *"
      cooldown_hours: 24

    # 条件配置（声明式，LLM 评估）
    conditions:
      - description: "用户已设定八字信息"
        data_path: "identity.birth_info"
        operator: "exists"
      - description: "今天还未收到运势推送"
        data_path: "notifications.bazi.daily_fortune.last_sent"
        operator: "!="
        value: "{today}"

    # 内容配置（Agent 驱动）
    content:
      rule: rules/proactive/daily-fortune-push.md  # Agent 使用此 Rule
      card_type: DailyFortuneCard
      suggested_prompt: "想了解今天的运势详情？"
      quick_actions:
        - label: "今日宜忌"
          prompt: "今天适合做什么？有什么需要注意的？"
        - label: "开运建议"
          prompt: "今天如何提升运势？"

    priority: medium

# 事件触发示例
  - id: birthday_reminder
    name: 生日提醒

    trigger:
      type: event_based
      event: birthday
      advance_days: [7, 0]      # 提前 7 天和当天

    conditions:
      - description: "用户生日信息存在"
        data_path: "identity.birth_info.date"
        operator: "exists"

    content:
      rule: rules/proactive/birthday-push.md
      card_type: BirthdayCard

# 数据条件触发示例
  - id: daily_checkin
    name: 每日签到提醒

    trigger:
      type: data_condition
      # 不再使用 type: has_data，改为声明式 conditions

    conditions:
      - description: "用户已设定愿景"
        data_path: "lifecoach.north_star.vision"
        operator: "exists"
      - description: "今天还未签到"
        data_path: "lifecoach.progress.last_checkin_date"
        operator: "!="
        value: "{today}"

    content:
      rule: rules/proactive/daily-checkin-push.md

global_config:
  default_push_hour: 8
  cooldown_hours: 24
  max_daily_pushes: 5
  quiet_hours:
    start: 22
    end: 7
```

### conditions 声明式语法

| 字段 | 类型 | 说明 |
|-----|------|------|
| `description` | string | 条件的自然语言描述（LLM 理解用） |
| `data_path` | string | Profile 数据路径（可选） |
| `operator` | string | 操作符：`exists`, `!exists`, `==`, `!=`, `>`, `<`, `>=`, `<=`, `contains` |
| `value` | string/number | 比较值，支持 `{today}`, `{now}`, `{user_timezone}` 等变量 |

**复杂条件示例**：

```yaml
conditions:
  # 数据存在检查
  - description: "用户已设定八字信息"
    data_path: "identity.birth_info"
    operator: "exists"

  # 日期比较
  - description: "今天还未签到"
    data_path: "lifecoach.progress.last_checkin_date"
    operator: "!="
    value: "{today}"

  # 数值阈值
  - description: "运势分数低于 40"
    data_path: "skills.bazi.daily_fortune.score"
    operator: "<"
    value: 40

  # 复杂条件（纯 LLM 评估）
  - description: "用户连续 3 天情绪低落且未进行冥想"
    # 无 data_path，完全由 LLM 评估
```

---

## 核心组件设计

### 1. TriggerEvaluator（LLM 驱动）

**文件**: `apps/api/services/proactive/trigger_evaluator.py`

```python
"""
TriggerEvaluator - LLM 驱动的触发条件评估器

设计原则:
- time_based: 保留 cron 匹配（确定性计算，无需 LLM）
- event_based: LLM 评估事件是否发生
- data_condition: LLM 评估声明式 conditions
- threshold_based: LLM 评估指标阈值

平台层保留的逻辑（非业务逻辑）:
- cron 表达式解析
- 时区转换
- cooldown 检查
"""

from typing import Dict, Any, Tuple, Optional, List
from datetime import datetime
import croniter


class TriggerEvaluator:
    """LLM 驱动的触发评估器"""

    def __init__(self, llm_service):
        self.llm_service = llm_service

    async def evaluate(
        self,
        trigger_config: Dict[str, Any],
        profile: Dict[str, Any],
        conditions: Optional[List[Dict]] = None,
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """
        评估触发条件

        Returns:
            (triggered: bool, event_info: Optional[Dict])
        """
        trigger_type = trigger_config.get("type")

        # 1. 时间触发：确定性计算，不需要 LLM
        if trigger_type == "time_based":
            cron_matched = self._evaluate_cron(trigger_config.get("schedule"))
            if not cron_matched:
                return False, None
            # 如果有 conditions，继续评估
            if conditions:
                return await self._evaluate_conditions_with_llm(conditions, profile)
            return True, None

        # 2. 事件触发：LLM 评估
        if trigger_type == "event_based":
            return await self._evaluate_event_with_llm(trigger_config, profile, conditions)

        # 3. 数据条件触发：LLM 评估 conditions
        if trigger_type == "data_condition":
            return await self._evaluate_conditions_with_llm(conditions, profile)

        # 4. 阈值触发：LLM 评估
        if trigger_type == "threshold_based":
            return await self._evaluate_threshold_with_llm(trigger_config, profile, conditions)

        return False, None

    def _evaluate_cron(self, schedule: str) -> bool:
        """确定性 cron 匹配（保留）"""
        if not schedule:
            return False
        try:
            cron = croniter.croniter(schedule, datetime.now())
            # 检查当前时间是否匹配 cron
            prev_time = cron.get_prev(datetime)
            # 允许 5 分钟误差
            return (datetime.now() - prev_time).total_seconds() < 300
        except Exception:
            return False

    async def _evaluate_conditions_with_llm(
        self,
        conditions: List[Dict],
        profile: Dict[str, Any],
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """LLM 评估声明式 conditions"""
        prompt = self._build_conditions_eval_prompt(conditions, profile)
        result = await self.llm_service.evaluate(
            prompt=prompt,
            response_format={"type": "json_object"},
        )
        return result.get("triggered", False), result.get("event_info")

    def _build_conditions_eval_prompt(
        self,
        conditions: List[Dict],
        profile: Dict[str, Any],
    ) -> str:
        """构建 conditions 评估 Prompt"""
        return f"""你是一个触发条件评估器。根据用户数据判断是否满足所有条件。

## 用户数据
```json
{json.dumps(profile, ensure_ascii=False, indent=2)}
```

## 触发条件（必须全部满足）
{self._format_conditions(conditions)}

## 任务
判断用户是否满足所有条件。

## 输出格式
```json
{{
  "triggered": true/false,
  "reason": "满足/不满足的原因",
  "event_info": {{}}  // 可选，触发事件的详细信息
}}
```
"""

    async def _evaluate_event_with_llm(
        self,
        trigger_config: Dict,
        profile: Dict,
        conditions: Optional[List[Dict]],
    ) -> Tuple[bool, Optional[Dict]]:
        """LLM 评估事件触发"""
        event_type = trigger_config.get("event")
        advance_days = trigger_config.get("advance_days", [0])

        prompt = f"""你是一个事件检测器。判断用户是否处于 "{event_type}" 事件的触发时间点。

## 用户数据
```json
{json.dumps(profile, ensure_ascii=False, indent=2)}
```

## 事件类型
- 事件名称: {event_type}
- 提前触发天数: {advance_days}
- 今日日期: {datetime.now().strftime('%Y-%m-%d')}

## 条件（如有）
{self._format_conditions(conditions) if conditions else "无额外条件"}

## 输出格式
```json
{{
  "triggered": true/false,
  "reason": "判断依据",
  "event_info": {{
    "event_type": "{event_type}",
    "event_date": "YYYY-MM-DD",
    "days_until": 0
  }}
}}
```
"""
        result = await self.llm_service.evaluate(prompt=prompt)
        return result.get("triggered", False), result.get("event_info")
```

### 2. ProactiveOrchestrator

**文件**: `apps/api/services/proactive/orchestrator.py`

```python
"""
ProactiveOrchestrator - 主动推送编排器

职责:
1. 加载 Skill 级 reminders.yaml 配置
2. 调度触发评估（TriggerEvaluator）
3. 调用 CoreAgent 生成内容
4. 投递通知

设计原则:
- 平台只做"加载/聚合/权限/校验/观测"
- 业务逻辑完全由配置 + Agent 驱动
"""

from typing import Dict, List, Optional, Any
from uuid import UUID
import logging

from .trigger_evaluator import TriggerEvaluator
from .agent_adapter import ProactiveAgentAdapter
from .models import ReminderTask, ReminderContent
from services.notification import NotificationService


class ProactiveOrchestrator:
    """主动推送编排器"""

    def __init__(
        self,
        trigger_evaluator: TriggerEvaluator,
        agent_adapter: ProactiveAgentAdapter,
        notification_service: NotificationService,
    ):
        self.trigger_evaluator = trigger_evaluator
        self.agent_adapter = agent_adapter
        self.notification_service = notification_service
        self._skill_configs: Dict[str, Dict] = {}
        self._load_skill_configs()

    async def run_scheduled_scan(self, dry_run: bool = False) -> List[Dict]:
        """
        定时扫描入口

        流程:
        1. 获取当前时段应推送的用户
        2. 对每个用户检测所有 Skill 的触发条件
        3. 生成推送内容（调用 Agent）
        4. 保存通知
        """
        results = []
        users = await self._get_users_for_current_hour()

        for user_id, profile in users:
            user_notifications = await self._process_user(user_id, profile, dry_run)
            results.extend(user_notifications)

        return results

    async def _process_user(
        self,
        user_id: UUID,
        profile: Dict,
        dry_run: bool = False,
    ) -> List[Dict]:
        """处理单个用户的所有推送"""
        notifications = []

        for skill_id, config in self._skill_configs.items():
            # 1. 检查订阅状态（平台层逻辑，保留）
            if not await self._should_send_to_user(user_id, skill_id):
                continue

            for reminder in config.get("reminders", []):
                # 2. 评估触发条件（LLM 驱动）
                triggered, event_info = await self.trigger_evaluator.evaluate(
                    trigger_config=reminder.get("trigger", {}),
                    profile=profile,
                    conditions=reminder.get("conditions"),
                )

                if not triggered:
                    continue

                # 3. 检查 cooldown（平台层逻辑，保留）
                if not await self._check_cooldown(user_id, skill_id, reminder["id"]):
                    continue

                # 4. 生成内容（调用 Agent）
                content = await self.agent_adapter.generate_content(
                    user_id=str(user_id),
                    profile=profile,
                    skill_id=skill_id,
                    reminder=reminder,
                    event_info=event_info,
                )

                # 5. 保存通知
                if not dry_run:
                    await self.notification_service.save(
                        user_id=user_id,
                        notification_type=f"{skill_id}_{reminder['id']}",
                        title=content.title,
                        content=content.to_dict(),
                    )

                notifications.append({
                    "user_id": str(user_id),
                    "skill_id": skill_id,
                    "reminder_id": reminder["id"],
                    "title": content.title,
                })

        return notifications
```

### 3. ProactiveAgentAdapter

**文件**: `apps/api/services/proactive/agent_adapter.py`

```python
"""
ProactiveAgentAdapter - Agent 适配器

职责:
- 封装 Proactive 调用 CoreAgent 的逻辑
- 构建 Proactive 专用 Prompt
- 提取 Agent 输出的结构化内容
"""

from typing import Dict, Any, Optional
from dataclasses import dataclass
import json

from services.agent import create_agent, AgentContext
from .models import ReminderContent


@dataclass
class ProactivePromptConfig:
    """Proactive Prompt 配置"""
    skill_id: str
    reminder_id: str
    rule_path: str
    event_info: Optional[Dict] = None
    profile_summary: Optional[str] = None


class ProactiveAgentAdapter:
    """Agent 适配器"""

    async def generate_content(
        self,
        user_id: str,
        profile: Dict,
        skill_id: str,
        reminder: Dict,
        event_info: Optional[Dict] = None,
    ) -> ReminderContent:
        """
        调用 Agent 生成推送内容

        流程:
        1. 构建 Agent 上下文
        2. 构建 Proactive Prompt
        3. 运行 Agent（非流式）
        4. 提取结构化内容
        """
        # 1. 构建上下文
        context = AgentContext(
            user_id=user_id,
            profile=profile,
            skill=skill_id,
            scenario="proactive",
        )

        # 2. 构建 Prompt
        proactive_prompt = self._build_proactive_prompt(
            reminder=reminder,
            event_info=event_info,
            profile=profile,
        )

        # 3. 运行 Agent（非流式，直接获取结果）
        agent = create_agent(max_iterations=3)
        content_buffer = ""

        async for event in agent.run(proactive_prompt, context):
            if event.type == "content":
                content_buffer += event.data.get("content", "")

        # 4. 提取内容
        return self._extract_content(content_buffer, reminder)

    def _build_proactive_prompt(
        self,
        reminder: Dict,
        event_info: Optional[Dict],
        profile: Dict,
    ) -> str:
        """构建 Proactive Prompt"""
        rule_path = reminder.get("content", {}).get("rule", "")

        prompt_parts = [
            f"# 推送内容生成任务",
            f"",
            f"## 场景",
            f"- 推送类型: {reminder.get('name', reminder['id'])}",
            f"- 规则文件: {rule_path}",
        ]

        if event_info:
            prompt_parts.extend([
                f"",
                f"## 触发事件",
                f"```json",
                json.dumps(event_info, ensure_ascii=False, indent=2),
                f"```",
            ])

        prompt_parts.extend([
            f"",
            f"## 用户画像摘要",
            self._build_profile_summary(profile),
            f"",
            f"## 任务",
            f"1. 读取规则文件 `{rule_path}` 中的生成要求",
            f"2. 根据用户画像和触发事件生成个性化推送内容",
            f"3. 输出 JSON 格式：",
            f"```json",
            f'{{',
            f'  "title": "推送标题（≤20字）",',
            f'  "body": "推送正文（≤100字）",',
            f'  "fortune_hint": "可选，运势提示",',
            f'  "action_tip": "可选，行动建议"',
            f'}}',
            f"```",
        ])

        return "\n".join(prompt_parts)

    def _build_profile_summary(self, profile: Dict) -> str:
        """构建用户画像摘要"""
        lines = []

        # 身份信息
        identity = profile.get("identity", {})
        if birth := identity.get("birth_info"):
            lines.append(f"- 生日: {birth.get('date')}")

        # 状态
        state = profile.get("state", {})
        if focus := state.get("focus"):
            lines.append(f"- 关注领域: {', '.join(focus)}")
        if emotion := state.get("emotion"):
            lines.append(f"- 当前情绪: {emotion}")

        # 目标
        goals = profile.get("life_context", {}).get("goals", [])
        if goals:
            goal_names = [g.get("name", str(g)) for g in goals[:3]]
            lines.append(f"- 目标: {', '.join(goal_names)}")

        return "\n".join(lines) if lines else "（无画像信息）"

    def _extract_content(
        self,
        content_buffer: str,
        reminder: Dict,
    ) -> ReminderContent:
        """提取结构化内容"""
        # 尝试提取 JSON
        try:
            # 查找 JSON 块
            import re
            json_match = re.search(r'```json\s*(.*?)\s*```', content_buffer, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group(1))
            else:
                # 尝试直接解析
                data = json.loads(content_buffer)
        except json.JSONDecodeError:
            # 回退：使用原始内容
            data = {
                "title": reminder.get("name", "推送通知"),
                "body": content_buffer[:100],
            }

        # 附加对话引导
        content_config = reminder.get("content", {})

        return ReminderContent(
            title=data.get("title", reminder.get("name")),
            body=data.get("body", ""),
            fortune_hint=data.get("fortune_hint"),
            action_tip=data.get("action_tip"),
            card_type=content_config.get("card_type"),
            suggested_prompt=content_config.get("suggested_prompt"),
            quick_actions=content_config.get("quick_actions", []),
        )
```

---

## Proactive Rule 模板

### 模板文件

**文件**: `skills/core/rules/proactive/_template.md`

```markdown
---
id: proactive-{reminder_id}
name: {reminder_name} 推送内容生成
type: proactive
version: 1.0.0
---

# {reminder_name} 推送内容生成

## 场景说明
{场景描述}

## 触发事件
- 事件类型: {event_type}
- 触发条件: {conditions_description}

## 用户画像读取
从 profile 中读取以下信息：
- `identity.birth_info` - 出生信息
- `state.focus` - 关注领域
- `state.emotion` - 当前情绪
- `skills.{skill_id}.*` - Skill 相关数据

## 生成要求

### 标题
- 字数: ≤20 字
- 风格: {风格描述}
- 包含: {必须包含的元素}

### 正文
- 字数: ≤100 字
- 风格: 温暖、个性化
- 结构: {结构要求}

### 可选字段
- `fortune_hint`: 运势提示（如适用）
- `action_tip`: 行动建议

## 语气风格
根据用户 `preferences.voice_mode` 调整：
- `warm`: 温暖关怀型
- `sarcastic`: 毒舌激励型
- `wise`: 智慧洞察型

## 输出格式
```json
{
  "title": "推送标题",
  "body": "推送正文，个性化内容...",
  "fortune_hint": "可选，运势提示",
  "action_tip": "可选，行动建议"
}
```

## 示例

### 示例 1: 标准场景
输入:
- 用户关注: 事业
- 当前情绪: 平静
- 触发事件: {example_event}

输出:
```json
{
  "title": "{example_title}",
  "body": "{example_body}",
  "action_tip": "{example_action_tip}"
}
```
```

### Bazi 每日运势 Rule

**文件**: `skills/bazi/rules/proactive/daily-fortune-push.md`

```markdown
---
id: proactive-daily-fortune
name: 每日运势推送内容生成
type: proactive
skill_id: bazi
---

# 每日运势推送内容生成

## 场景说明
每日早晨为用户推送个性化运势提醒，帮助用户了解当日运势趋势并提供行动建议。

## 数据读取
从 profile 中读取：
- `identity.birth_info` - 八字信息
- `skills.bazi.daily_fortune` - 今日运势数据（如已计算）
- `state.focus` - 关注领域
- `preferences.voice_mode` - 语气偏好

## 生成要求

### 标题
- 字数: ≤15 字
- 包含: 日期感、运势关键词
- 示例: "今日运势 · 事业有突破"

### 正文
- 字数: 60-100 字
- 结构:
  1. 今日运势概述（1句）
  2. 重点关注事项（1句）
  3. 行动建议（1句）
- 风格: 根据 voice_mode 调整

### fortune_hint
- 今日宜/忌（简短）

### action_tip
- 具体可执行的建议

## 语气风格示例

### warm（温暖型）
"今天土气旺盛，适合稳扎稳打。事业上可能遇到贵人相助，记得保持谦逊哦～"

### sarcastic（毒舌型）
"今天运势不错，别浪费了。有贵人送机会上门，这次可别又错过了。"

### wise（智慧型）
"戊土当令，厚德载物。今日宜守不宜攻，静待时机方为上策。"

## 输出格式
```json
{
  "title": "今日运势 · {关键词}",
  "body": "{个性化正文}",
  "fortune_hint": "宜: {宜事} | 忌: {忌事}",
  "action_tip": "{具体建议}"
}
```
```

### Lifecoach 每日签到 Rule

**文件**: `skills/lifecoach/rules/proactive/daily-checkin-push.md`

```markdown
---
id: proactive-daily-checkin
name: 每日签到推送内容生成
type: proactive
skill_id: lifecoach
---

# 每日签到推送内容生成

## 场景说明
每日提醒用户进行签到，以 Future Self 人格进行温暖的问候。

## 数据读取
从 profile 中读取：
- `lifecoach.north_star.vision` - 用户愿景
- `lifecoach.progress.streak_days` - 连续签到天数
- `lifecoach.progress.last_checkin_date` - 上次签到日期
- `state.emotion` - 当前情绪

## 场景判断

### 场景 1: 正常签到（昨天有签到）
- 风格: 日常问候
- 提及: 连续签到天数

### 场景 2: 久别重逢（3-7 天未签到）
- 风格: 温暖欢迎
- 提及: 没关系，重新开始

### 场景 3: 长时间未互动（>7 天）
- 风格: 关心询问
- 不提及: 断签

### 场景 4: 连续签到里程碑（7天/30天/100天）
- 风格: 庆祝
- 提及: 具体成就

## 生成要求

### 标题
- 字数: ≤12 字
- 示例: "早上好！"、"想你了～"、"恭喜连续 7 天！"

### 正文
- 字数: 40-80 字
- 以 Future Self 口吻
- 引导用户签到

## 输出格式
```json
{
  "title": "{场景化标题}",
  "body": "{Future Self 口吻的问候}",
  "action_tip": "点击开始今天的签到"
}
```

## 示例

### 正常签到
```json
{
  "title": "早上好！",
  "body": "连续签到第 15 天了，稳步前进中！今天想和我聊聊最近的进展吗？",
  "action_tip": "开始今日签到"
}
```

### 久别重逢
```json
{
  "title": "好久不见～",
  "body": "几天没见你了，一切都好吗？没关系，每一天都是新的开始。准备好继续了吗？",
  "action_tip": "重新开始"
}
```
```

---

## 文件变更清单

### 新增文件（11个）

| 文件 | 描述 |
|------|------|
| `services/proactive/trigger_evaluator.py` | LLM 触发评估器 |
| `services/proactive/orchestrator.py` | 主动推送编排器 |
| `services/proactive/agent_adapter.py` | Agent 适配器 |
| `services/proactive/models.py` | 数据模型（提取自 engine.py） |
| `skills/core/rules/proactive/_template.md` | Proactive Rule 模板 |
| `skills/bazi/rules/proactive/daily-fortune-push.md` | Bazi 每日运势 Rule |
| `skills/bazi/rules/proactive/birthday-push.md` | Bazi 生日 Rule |
| `skills/lifecoach/rules/proactive/daily-checkin-push.md` | Lifecoach 签到 Rule |
| `skills/zodiac/rules/proactive/daily-horoscope-push.md` | Zodiac 每日星座 Rule |
| `tests/services/proactive/test_trigger_evaluator.py` | 评估器单元测试 |
| `tests/services/proactive/test_orchestrator.py` | 编排器集成测试 |

### 修改文件（5个）

| 文件 | 变更 |
|------|------|
| `workers/proactive_worker.py` | 使用 ProactiveOrchestrator |
| `skills/bazi/reminders.yaml` | 升级到 v3.0 格式 |
| `skills/lifecoach/reminders.yaml` | 升级到 v3.0 格式 |
| `skills/zodiac/reminders.yaml` | 升级到 v3.0 格式 |
| `services/proactive/__init__.py` | 更新导出 |

### 删除文件（2个）

| 文件 | 行数 | 原因 |
|------|------|------|
| `services/proactive/trigger_detector.py` | 643 | 所有检测逻辑 LLM 化 |
| `services/proactive/content_generator.py` | 1037 | 所有生成逻辑 Agent 化 |

---

## 迁移指南

### 1. v2.0 → v3.0 配置迁移

```yaml
# v2.0 (旧)
reminders:
  - id: daily_fortune
    trigger:
      type: time_based
      schedule: "0 8 * * *"
    conditions:
      - type: has_data
        path: "identity.birth_info"
    content:
      generator: rules/daily-fortune.md

# v3.0 (新)
version: "3.0"
reminders:
  - id: daily_fortune
    trigger:
      type: time_based
      schedule: "0 8 * * *"
    conditions:
      - description: "用户已设定八字信息"
        data_path: "identity.birth_info"
        operator: "exists"
    content:
      rule: rules/proactive/daily-fortune-push.md  # 独立的 proactive rule
```

### 2. conditions 迁移对照表

| v2.0 type | v3.0 声明式 |
|-----------|------------|
| `has_data` | `{data_path: "...", operator: "exists"}` |
| `not_checked_in_today` | `{data_path: "...last_checkin_date", operator: "!=", value: "{today}"}` |
| `has_pending_levers` | `{description: "有未完成杠杆"}` |
| 自定义 type | `{description: "..."}` + LLM 评估 |

### 3. generator → rule 迁移

旧的 `content.generator` 指向的 Rule 文件需要重构为 Proactive 专用 Rule：

```
rules/daily-fortune.md (通用 Skill Rule)
    ↓ 提取推送相关部分
rules/proactive/daily-fortune-push.md (Proactive 专用 Rule)
```

---

## 验证方案

### 单元测试

```bash
# 触发评估器测试
pytest tests/services/proactive/test_trigger_evaluator.py -v

# 编排器测试
pytest tests/services/proactive/test_orchestrator.py -v
```

### E2E 验证用例

| 场景 | 预期结果 |
|------|---------|
| Bazi 每日运势 | cron 匹配 → conditions 通过 → Agent 生成 → 通知保存 |
| Lifecoach 签到 | data_condition → LLM 评估 conditions → Agent 生成 → 通知保存 |
| Bazi 生日提醒 | event_based → LLM 检测生日 → Agent 生成 → 通知保存 |
| 新增触发类型 | 只改 YAML + Rule 文件，零代码改动 ✅ |

### 性能验收

| 指标 | 目标 |
|------|------|
| 推送延迟增加 | ≤2 秒 |
| LLM 调用模型 | Haiku（成本优化） |
| 批量处理 | 支持 |

---

## 风险与缓解

| 风险 | 描述 | 缓解措施 |
|------|------|---------|
| LLM 误判触发 | LLM 可能错误评估 conditions | 1. time_based 保留 cron 匹配<br>2. 关键条件添加 fallback |
| Agent 内容质量 | 生成内容不符合预期 | 1. Rule 文件提供详细示例<br>2. JSON Schema 校验 |
| 性能影响 | LLM 调用增加延迟 | 1. 批量处理<br>2. 使用 Haiku |
| 向后兼容 | v2.0 配置无法直接使用 | 1. 支持 version 自动检测<br>2. 渐进迁移 |

---

## 成功标准

- [ ] 新增触发条件只需修改 YAML，零代码改动
- [ ] 新增推送内容只需添加 Rule 文件，零代码改动
- [ ] 删除 trigger_detector.py（643 行）
- [ ] 删除 content_generator.py（1037 行）
- [ ] 所有现有 reminders.yaml 迁移到 v3.0 格式
- [ ] 测试覆盖率 80%+
- [ ] 推送延迟增加 ≤2 秒

---

## 时间线

| 周 | 阶段 | 任务 |
|----|------|------|
| 1 | 基础架构 | TriggerEvaluator + ProactiveOrchestrator + AgentAdapter |
| 2 | Rules 迁移 | Proactive Rule 文件 + reminders.yaml v3.0 |
| 3 | 清理测试 | 删除硬编码 + 单元测试 + E2E 测试 |

---

## 相关文档

- [SPEC.md](./ref/SPEC.md) - v2.0 规范（当前）
- [LLM-FIRST-DESIGN.md](/docs/archive/v9/LLM-FIRST-DESIGN.md) - LLM-First 架构设计
- [ARCHITECTURE.md](/docs/archive/v8/ARCHITECTURE.md) - 系统架构
