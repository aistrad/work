/**
 * Authentication Provider - v5.2 性能优化版
 * Based on: vibelife spec v3.0
 *
 * v3.0 更新：
 * - 实现真实的认证状态管理
 * - 支持多标签页同步
 * - 基于 JWT + localStorage
 *
 * v5.2 优化：
 * - 使用缓存的 localStorage 工具 (Vercel rule: js-cache-storage)
 * - 优化初始化流程，先显示缓存用户再后台验证
 */
"use client";

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useMemo,
} from "react";
import {
  getTokens,
  setTokens,
  clearTokens,
  getMe,
  login as apiLogin,
  logout as apiLogout,
  register as apiRegister,
  registerWithSession as apiRegisterWithSession,
  type TokenResponse,
  type OnboardingData,
} from "@/lib/api";
import {
  getLocalStorageJSON,
  setLocalStorageJSON,
  getLocalStorage,
  invalidateStorageCache,
} from "@/utils/storage";

// ─────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────

export interface User {
  user_id: string;
  vibe_id: string;
  display_name?: string;
  email?: string;
  phone?: string;
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

interface AuthActions {
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (
    email?: string,
    password?: string,
    displayName?: string,
    phone?: string
  ) => Promise<void>;
  registerWithSession: (
    email?: string,
    password?: string,
    displayName?: string,
    phone?: string,
    sessionId?: string,
    onboarding?: OnboardingData
  ) => Promise<void>;
  refreshUser: () => Promise<void>;
}

type AuthContextType = AuthState & AuthActions;

// ─────────────────────────────────────────────────────────────────
// Context
// ─────────────────────────────────────────────────────────────────

const AuthContext = createContext<AuthContextType | null>(null);

// ─────────────────────────────────────────────────────────────────
// Provider
// ─────────────────────────────────────────────────────────────────

interface AuthProviderProps {
  children: React.ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [state, setState] = useState<AuthState>({
    user: null,
    isAuthenticated: false,
    isLoading: true,
  });

  // Initialize auth state from localStorage
  const initAuth = useCallback(async () => {
    const { accessToken } = getTokens();

    if (!accessToken) {
      setState({ user: null, isAuthenticated: false, isLoading: false });
      return;
    }

    try {
      // Use cached localStorage read (Vercel rule: js-cache-storage)
      const cachedUser = getLocalStorageJSON<User | null>("user", null);
      if (cachedUser) {
        // Show cached user immediately (faster perceived load)
        setState({ user: cachedUser, isAuthenticated: true, isLoading: false });
      }

      // Then verify with backend (in background)
      const userData = await getMe();
      const user: User = {
        user_id: userData.user_id,
        vibe_id: userData.vibe_id,
        display_name: userData.display_name,
        email: userData.email,
        phone: userData.phone,
      };

      // Update localStorage and state using cached utility
      setLocalStorageJSON("user", user);
      setState({ user, isAuthenticated: true, isLoading: false });
    } catch {
      // Token invalid, clear everything
      clearTokens();
      invalidateStorageCache("user");
      setState({ user: null, isAuthenticated: false, isLoading: false });
    }
  }, []);

  // Initialize on mount
  useEffect(() => {
    initAuth();
  }, [initAuth]);

  // Listen for storage events (multi-tab sync)
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === "access_token") {
        if (!e.newValue) {
          // Token was removed (logout in another tab)
          setState({ user: null, isAuthenticated: false, isLoading: false });
        } else if (e.newValue && !e.oldValue) {
          // Token was added (login in another tab)
          initAuth();
        }
      }

      if (e.key === "user") {
        if (e.newValue) {
          try {
            const user = JSON.parse(e.newValue) as User;
            setState((prev) => ({ ...prev, user, isAuthenticated: true }));
          } catch {
            // Invalid JSON, ignore
          }
        }
      }
    };

    window.addEventListener("storage", handleStorageChange);
    return () => window.removeEventListener("storage", handleStorageChange);
  }, [initAuth]);

  // ─────────────────────────────────────────────────────────────────
  // Actions
  // ─────────────────────────────────────────────────────────────────

  const login = useCallback(async (email: string, password: string) => {
    setState((prev) => ({ ...prev, isLoading: true }));

    try {
      const response: TokenResponse = await apiLogin(email, password);
      const user: User = {
        user_id: response.user.user_id,
        vibe_id: response.user.vibe_id,
        display_name: response.user.display_name,
      };

      setState({ user, isAuthenticated: true, isLoading: false });
    } catch (error) {
      setState((prev) => ({ ...prev, isLoading: false }));
      throw error;
    }
  }, []);

  const logout = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true }));

    try {
      await apiLogout();
    } finally {
      setState({ user: null, isAuthenticated: false, isLoading: false });
    }
  }, []);

  const register = useCallback(
    async (
      email?: string,
      password?: string,
      displayName?: string,
      phone?: string
    ) => {
      setState((prev) => ({ ...prev, isLoading: true }));

      try {
        const response: TokenResponse = await apiRegister(
          email,
          password,
          displayName,
          phone
        );
        const user: User = {
          user_id: response.user.user_id,
          vibe_id: response.user.vibe_id,
          display_name: response.user.display_name,
        };

        setState({ user, isAuthenticated: true, isLoading: false });
      } catch (error) {
        setState((prev) => ({ ...prev, isLoading: false }));
        throw error;
      }
    },
    []
  );

  const registerWithSession = useCallback(
    async (
      email?: string,
      password?: string,
      displayName?: string,
      phone?: string,
      sessionId?: string,
      onboarding?: OnboardingData
    ) => {
      setState((prev) => ({ ...prev, isLoading: true }));

      try {
        const response: TokenResponse = await apiRegisterWithSession(
          email,
          password,
          displayName,
          phone,
          sessionId,
          onboarding
        );
        const user: User = {
          user_id: response.user.user_id,
          vibe_id: response.user.vibe_id,
          display_name: response.user.display_name,
        };

        setState({ user, isAuthenticated: true, isLoading: false });
      } catch (error) {
        setState((prev) => ({ ...prev, isLoading: false }));
        throw error;
      }
    },
    []
  );

  const refreshUser = useCallback(async () => {
    try {
      const userData = await getMe();
      const user: User = {
        user_id: userData.user_id,
        vibe_id: userData.vibe_id,
        display_name: userData.display_name,
        email: userData.email,
        phone: userData.phone,
      };

      // Use cached localStorage (Vercel rule: js-cache-storage)
      setLocalStorageJSON("user", user);
      setState((prev) => ({ ...prev, user }));
    } catch {
      // Silently fail - user data refresh is not critical
    }
  }, []);

  // ─────────────────────────────────────────────────────────────────
  // Memoized value
  // ─────────────────────────────────────────────────────────────────

  const value = useMemo<AuthContextType>(
    () => ({
      ...state,
      login,
      logout,
      register,
      registerWithSession,
      refreshUser,
    }),
    [state, login, logout, register, registerWithSession, refreshUser]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// ─────────────────────────────────────────────────────────────────
// Hooks
// ─────────────────────────────────────────────────────────────────

export function useAuth() {
  const context = useContext(AuthContext);

  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }

  return {
    isSignedIn: context.isAuthenticated,
    isLoaded: !context.isLoading,
    userId: context.user?.user_id ?? null,
    user: context.user,
    login: context.login,
    logout: context.logout,
    register: context.register,
    registerWithSession: context.registerWithSession,
    refreshUser: context.refreshUser,
  };
}

export function useUser() {
  const context = useContext(AuthContext);

  if (!context) {
    throw new Error("useUser must be used within an AuthProvider");
  }

  return {
    user: context.user,
    isLoaded: !context.isLoading,
  };
}

// Clerk compatibility shims
export function useClerk() {
  const { logout } = useAuth();
  return {
    signOut: logout,
  };
}

// Placeholder components for Clerk compatibility
export function SignIn() {
  return null;
}

export function SignUp() {
  return null;
}

export function UserButton() {
  return null;
}
