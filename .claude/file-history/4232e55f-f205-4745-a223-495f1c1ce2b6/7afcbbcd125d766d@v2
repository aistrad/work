/**
 * Authentication Provider - v8.0 OAuth Only
 * Based on: vibelife spec v3.0
 *
 * v8.0 Changes:
 * - Removed password authentication methods
 * - OAuth-only authentication (Google, Apple, WeChat)
 * - Multi-tab sync support
 * - JWT + localStorage based
 */
"use client";

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useMemo,
} from "react";
import {
  getTokens,
  clearTokens,
  getMe,
  logout as apiLogout,
} from "@/lib/api";
import {
  getLocalStorageJSON,
  setLocalStorageJSON,
  invalidateStorageCache,
} from "@/utils/storage";

// ─────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────

export interface User {
  user_id: string;
  vibe_id: string;
  display_name?: string;
  email?: string;
  phone?: string;
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

interface AuthActions {
  logout: () => Promise<void>;
  refreshUser: () => Promise<void>;
}

type AuthContextType = AuthState & AuthActions;

// ─────────────────────────────────────────────────────────────────
// Context
// ─────────────────────────────────────────────────────────────────

const AuthContext = createContext<AuthContextType | null>(null);

// ─────────────────────────────────────────────────────────────────
// Provider
// ─────────────────────────────────────────────────────────────────

interface AuthProviderProps {
  children: React.ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [state, setState] = useState<AuthState>({
    user: null,
    isAuthenticated: false,
    isLoading: true,
  });

  // Initialize auth state from localStorage
  const initAuth = useCallback(async () => {
    const { accessToken } = getTokens();

    if (!accessToken) {
      setState({ user: null, isAuthenticated: false, isLoading: false });
      return;
    }

    try {
      // Use cached localStorage read for faster perceived load
      const cachedUser = getLocalStorageJSON<User | null>("user", null);
      if (cachedUser) {
        // Show cached user immediately
        setState({ user: cachedUser, isAuthenticated: true, isLoading: false });
      }

      // Then verify with backend (in background)
      const userData = await getMe();
      const user: User = {
        user_id: userData.user_id,
        vibe_id: userData.vibe_id,
        display_name: userData.display_name,
        email: userData.email,
        phone: userData.phone,
      };

      // Update localStorage and state
      setLocalStorageJSON("user", user);
      setState({ user, isAuthenticated: true, isLoading: false });
    } catch {
      // Token invalid, clear everything
      clearTokens();
      invalidateStorageCache("user");
      setState({ user: null, isAuthenticated: false, isLoading: false });
    }
  }, []);

  // Initialize on mount
  useEffect(() => {
    initAuth();
  }, [initAuth]);

  // Listen for storage events (multi-tab sync)
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === "access_token") {
        if (!e.newValue) {
          // Token was removed (logout in another tab)
          setState({ user: null, isAuthenticated: false, isLoading: false });
        } else if (e.newValue && !e.oldValue) {
          // Token was added (login in another tab)
          initAuth();
        }
      }

      if (e.key === "user") {
        if (e.newValue) {
          try {
            const user = JSON.parse(e.newValue) as User;
            setState((prev) => ({ ...prev, user, isAuthenticated: true }));
          } catch {
            // Invalid JSON, ignore
          }
        }
      }
    };

    window.addEventListener("storage", handleStorageChange);
    return () => window.removeEventListener("storage", handleStorageChange);
  }, [initAuth]);

  // ─────────────────────────────────────────────────────────────────
  // Actions
  // ─────────────────────────────────────────────────────────────────

  const logout = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true }));

    try {
      await apiLogout();
    } finally {
      setState({ user: null, isAuthenticated: false, isLoading: false });
    }
  }, []);

  const refreshUser = useCallback(async () => {
    try {
      const userData = await getMe();
      const user: User = {
        user_id: userData.user_id,
        vibe_id: userData.vibe_id,
        display_name: userData.display_name,
        email: userData.email,
        phone: userData.phone,
      };

      setLocalStorageJSON("user", user);
      setState((prev) => ({ ...prev, user }));
    } catch {
      // Silently fail - user data refresh is not critical
    }
  }, []);

  // ─────────────────────────────────────────────────────────────────
  // Memoized value
  // ─────────────────────────────────────────────────────────────────

  const value = useMemo<AuthContextType>(
    () => ({
      ...state,
      logout,
      refreshUser,
    }),
    [state, logout, refreshUser]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// ─────────────────────────────────────────────────────────────────
// Hooks
// ─────────────────────────────────────────────────────────────────

export function useAuth() {
  const context = useContext(AuthContext);

  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }

  return {
    isSignedIn: context.isAuthenticated,
    isLoaded: !context.isLoading,
    userId: context.user?.user_id ?? null,
    user: context.user,
    logout: context.logout,
    refreshUser: context.refreshUser,
  };
}

export function useUser() {
  const context = useContext(AuthContext);

  if (!context) {
    throw new Error("useUser must be used within an AuthProvider");
  }

  return {
    user: context.user,
    isLoaded: !context.isLoading,
  };
}

// Clerk compatibility shims
export function useClerk() {
  const { logout } = useAuth();
  return {
    signOut: logout,
  };
}

// Placeholder components for Clerk compatibility
export function SignIn() {
  return null;
}

export function SignUp() {
  return null;
}

export function UserButton() {
  return null;
}
