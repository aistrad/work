import { create } from "zustand"
import type { Message, Artifact, Quest, DashboardTab, Relation, Block, ActionButton } from "@/types"
import * as api from "@/lib/api"

// Map API types to frontend types
interface UserStatus {
  energy: number
  emotion: number
  connection: number
  growth: number
  fortune: number
}

interface StateScore {
  score: number
  breakdown: {
    emotion: number
    action: number
    streak: number
  }
  recoveryAction: string | null
}

interface PermaData {
  positiveEmotion: { score: number; trend?: string }
  engagement: { score: number; trend?: string }
  relationships: { score: number; trend?: string }
  meaning: { score: number; trend?: string }
  accomplishment: { score: number; trend?: string }
}

interface L0Facts {
  dayMaster: string
  strength: string
  translations: { concept: string; translation: string; action: string }[]
}

interface L1Schema {
  permaSnapshot: PermaData
  cognitivePatterns: { identifiedSchemas: string[]; reframeCount?: number }
  strengthsInUse: string[]
}

interface RiskAlert {
  type: string
  message: string
}

interface TrendPoint {
  date: string
  score: number
}

interface TrendEvent {
  date: string
  type: string
  title: string
}

interface AppState {
  // UI State
  isSidebarOpen: boolean
  activeTab: DashboardTab
  isMobile: boolean

  // Preferences
  chatBackend: api.ChatBackend

  // Loading States
  isLoading: boolean
  loadingTab: DashboardTab | null

  // Chat State
  messages: Message[]
  isStreaming: boolean
  sessionId: string | null

  // Artifacts
  artifacts: Artifact[]
  pinnedArtifacts: Artifact[]

  // Overview Data
  insight: string
  stateScore: StateScore
  perma: PermaData
  todayTasks: api.TaskItem[]
  riskAlerts: RiskAlert[]

  // Status Data
  l0Facts: L0Facts | null
  l1Schema: L1Schema | null

  // Trends Data
  trendHistory: TrendPoint[]
  trendEvents: TrendEvent[]

  // Tasks Data
  activeTasks: api.TaskItem[]
  suggestedTasks: api.TaskItem[]
  completedTasks: api.TaskItem[]

  // Relations Data
  relations: Relation[]

  // Explore Data
  mysticEntries: api.ExploreItem[]
  courses: api.ExploreItem[]

  // Legacy (for compatibility)
  status: UserStatus
  quests: Quest[]
  todayQuests: Quest[]

  // Computed: pending task count (for mobile tab badge)
  pendingTaskCount: number

  // UI Actions
  setSidebarOpen: (open: boolean) => void
  setActiveTab: (tab: DashboardTab) => void
  setIsMobile: (mobile: boolean) => void
  setChatBackend: (backend: api.ChatBackend) => void

  // Fetch Actions
  fetchOverview: () => Promise<void>
  fetchStatus: () => Promise<void>
  fetchTrends: (days?: number) => Promise<void>
  fetchTasks: () => Promise<void>
  fetchRelations: () => Promise<void>
  fetchExplore: () => Promise<void>
  fetchPreferences: () => Promise<void>
  updateChatBackend: (backend: api.ChatBackend) => Promise<void>

  // Task Actions
  acceptTask: (taskId: string, type?: 'start_task' | 'schedule_task') => Promise<void>
  completeTask: (taskId: string, note?: string) => Promise<void>
  skipTask: (taskId: string, reason?: string) => Promise<void>

  // Checkin
  submitCheckin: (mood: string, intensity: number, note?: string) => Promise<api.CheckinResponse>

  // Chat Actions
  sendMessage: (content: string) => Promise<void>
  addMessage: (message: Message) => void
  setStreaming: (streaming: boolean) => void
  clearMessages: () => void

  // Artifact Actions
  addArtifact: (artifact: Artifact) => void
  pinArtifact: (id: string) => void
  unpinArtifact: (id: string) => void
}

// Helper to convert API perma to frontend format
function convertPerma(perma: api.PermaData): PermaData {
  return {
    positiveEmotion: { score: perma.positive_emotion.score, trend: perma.positive_emotion.trend },
    engagement: { score: perma.engagement.score, trend: perma.engagement.trend },
    relationships: { score: perma.relationships.score, trend: perma.relationships.trend },
    meaning: { score: perma.meaning.score, trend: perma.meaning.trend },
    accomplishment: { score: perma.accomplishment.score, trend: perma.accomplishment.trend },
  }
}

// Helper to convert PERMA to 5-dimension status
function permaToStatus(perma: PermaData): UserStatus {
  return {
    energy: Math.round(perma.positiveEmotion.score * 10),
    emotion: Math.round(perma.engagement.score * 10),
    connection: Math.round(perma.relationships.score * 10),
    growth: Math.round(perma.meaning.score * 10),
    fortune: Math.round(perma.accomplishment.score * 10),
  }
}

type A2UIComponent = {
  type?: unknown
  title?: unknown
  data?: unknown
}

function a2uiToBlocks(uiComponents: unknown[] | undefined): Block[] | undefined {
  if (!Array.isArray(uiComponents) || uiComponents.length === 0) return undefined

  const now = Date.now()
  const blocks: Block[] = []

  uiComponents.forEach((raw, idx) => {
    if (!raw || typeof raw !== 'object') return
    const c = raw as A2UIComponent
    const type = String(c.type || '')
    const title = typeof c.title === 'string' ? c.title : undefined
    const id = `${type || 'component'}-${now}-${idx}`

    if (type === 'markdown_text') {
      blocks.push({
        id,
        type: 'markdown_text',
        content: typeof c.data === 'string' ? c.data : String(c.data ?? ''),
        ...(title ? { title } : {}),
      } as unknown as Block)
      return
    }

    if (type === 'action_buttons') {
      const data = Array.isArray(c.data) ? c.data : []
      const buttons: ActionButton[] = data
        .filter((b) => b && typeof b === 'object')
        .map((b) => {
          const btn = b as { label?: unknown; action?: unknown }
          const label = typeof btn.label === 'string' ? btn.label : '下一步'
          const action = (btn.action && typeof btn.action === 'object' ? btn.action : {}) as Record<string, unknown>
          const actionType = typeof action.type === 'string' ? action.type : 'opt_out'
          return {
            label,
            action: {
              type: actionType as ActionButton['action']['type'],
              task_id: typeof action.task_id === 'string' ? action.task_id : undefined,
              panel: typeof action.panel === 'string' ? action.panel : undefined,
            },
          }
        })

      blocks.push({
        id,
        type: 'action_buttons',
        content: '',
        buttons,
        ...(title ? { title } : {}),
      } as unknown as Block)
      return
    }

    // Fallback: show as a simple callout
    blocks.push({
      id,
      type: 'callout',
      content: typeof c.data === 'string' ? c.data : JSON.stringify(c.data ?? c),
      ...(title ? { title } : {}),
    } as unknown as Block)
  })

  return blocks.length > 0 ? blocks : undefined
}

export const useAppStore = create<AppState>((set, get) => ({
  // Initial UI State
  isSidebarOpen: true,
  activeTab: "overview",
  isMobile: false,

  // Preferences
  chatBackend: 'agent_service',

  // Loading States
  isLoading: false,
  loadingTab: null,

  // Initial Chat State
  messages: [],
  isStreaming: false,
  sessionId: null,

  // Initial Artifacts
  artifacts: [],
  pinnedArtifacts: [],

  // Overview Data (defaults)
  insight: "加载中...",
  stateScore: { score: 0, breakdown: { emotion: 0, action: 0, streak: 0 }, recoveryAction: null },
  perma: {
    positiveEmotion: { score: 5 },
    engagement: { score: 5 },
    relationships: { score: 5 },
    meaning: { score: 5 },
    accomplishment: { score: 5 },
  },
  todayTasks: [],
  riskAlerts: [],

  // Status Data
  l0Facts: null,
  l1Schema: null,

  // Trends Data
  trendHistory: [],
  trendEvents: [],

  // Tasks Data
  activeTasks: [],
  suggestedTasks: [],
  completedTasks: [],

  // Relations Data
  relations: [],

  // Explore Data
  mysticEntries: [],
  courses: [],

  // Legacy (for compatibility)
  status: { energy: 50, emotion: 50, connection: 50, growth: 50, fortune: 50 },
  quests: [],
  todayQuests: [],

  // Computed: pending task count
  pendingTaskCount: 0,

  // UI Actions
  setSidebarOpen: (open) => set({ isSidebarOpen: open }),
  setActiveTab: (tab) => set({ activeTab: tab }),
  setIsMobile: (mobile) => set({ isMobile: mobile }),
  setChatBackend: (backend) => set({ chatBackend: backend }),

  // Fetch Overview
  fetchOverview: async () => {
    set({ isLoading: true, loadingTab: 'overview' })
    try {
      const data = await api.fetchOverview()
      const perma = convertPerma(data.perma)
      set({
        insight: data.insight,
        stateScore: {
          score: data.state_score.score,
          breakdown: data.state_score.breakdown,
          recoveryAction: data.state_score.recovery_action,
        },
        perma,
        todayTasks: data.today_tasks,
        riskAlerts: data.risk_alerts,
        status: permaToStatus(perma),
      })
    } catch (err) {
      console.error('Failed to fetch overview:', err)
    } finally {
      set({ isLoading: false, loadingTab: null })
    }
  },

  // Fetch Status
  fetchStatus: async () => {
    set({ isLoading: true, loadingTab: 'status' })
    try {
      const data = await api.fetchStatus()
      set({
        l0Facts: {
          dayMaster: data.l0_facts.day_master,
          strength: data.l0_facts.strength,
          translations: data.l0_facts.translations,
        },
        l1Schema: {
          permaSnapshot: convertPerma(data.l1_schema.perma_snapshot),
          cognitivePatterns: {
            identifiedSchemas: data.l1_schema.cognitive_patterns.identified_schemas,
            reframeCount: data.l1_schema.cognitive_patterns.reframe_count,
          },
          strengthsInUse: data.l1_schema.strengths_in_use,
        },
        stateScore: {
          score: data.state_score.score,
          breakdown: data.state_score.breakdown,
          recoveryAction: data.state_score.recovery_action,
        },
      })
    } catch (err) {
      console.error('Failed to fetch status:', err)
    } finally {
      set({ isLoading: false, loadingTab: null })
    }
  },

  // Fetch Trends
  fetchTrends: async (days = 7) => {
    set({ isLoading: true, loadingTab: 'trends' })
    try {
      const data = await api.fetchTrends(days)
      set({
        trendHistory: data.state_score_history,
        trendEvents: data.events,
      })
    } catch (err) {
      console.error('Failed to fetch trends:', err)
    } finally {
      set({ isLoading: false, loadingTab: null })
    }
  },

  // Fetch Tasks
  fetchTasks: async () => {
    set({ isLoading: true, loadingTab: 'quests' })
    try {
      const data = await api.fetchTasks()
      const pendingCount = data.active.length + data.suggested.length
      set({
        activeTasks: data.active,
        suggestedTasks: data.suggested,
        completedTasks: data.completed_recent,
        pendingTaskCount: pendingCount,
      })
    } catch (err) {
      console.error('Failed to fetch tasks:', err)
    } finally {
      set({ isLoading: false, loadingTab: null })
    }
  },

  // Fetch Relations
  fetchRelations: async () => {
    set({ isLoading: true, loadingTab: 'relations' })
    try {
      const data = await api.fetchRelations()
      set({
        relations: data.relations.map((r) => ({
          id: r.id,
          name: r.name,
          type: r.type as Relation['type'],
          compatibility: r.compatibility,
        })),
      })
    } catch (err) {
      console.error('Failed to fetch relations:', err)
    } finally {
      set({ isLoading: false, loadingTab: null })
    }
  },

  // Fetch Explore
  fetchExplore: async () => {
    set({ isLoading: true, loadingTab: 'explore' })
    try {
      const data = await api.fetchExplore()
      set({
        mysticEntries: data.mystic_entries,
        courses: data.courses,
      })
    } catch (err) {
      console.error('Failed to fetch explore:', err)
    } finally {
      set({ isLoading: false, loadingTab: null })
    }
  },

  // Preferences
  fetchPreferences: async () => {
    try {
      const prefs = await api.fetchPreferences()
      set({ chatBackend: prefs.chat_backend })
    } catch (err) {
      console.error('Failed to fetch preferences:', err)
    }
  },

  updateChatBackend: async (backend) => {
    try {
      await api.updatePreferences({ chat_backend: backend })
      set({ chatBackend: backend })
    } catch (err) {
      console.error('Failed to update chat backend:', err)
    }
  },

  // Accept Task
  acceptTask: async (taskId, type = 'start_task') => {
    try {
      await api.acceptTask(taskId, type)
      // Refresh tasks
      get().fetchTasks()
      get().fetchOverview()
    } catch (err) {
      console.error('Failed to accept task:', err)
    }
  },

  // Complete Task
  completeTask: async (taskId, note = '') => {
    try {
      const result = await api.completeTask(taskId, note)
      set({
        stateScore: {
          score: result.state_score.score,
          breakdown: result.state_score.breakdown,
          recoveryAction: result.state_score.recovery_action,
        },
      })
      // Refresh tasks
      get().fetchTasks()
      get().fetchOverview()
    } catch (err) {
      console.error('Failed to complete task:', err)
    }
  },

  // Skip Task
  skipTask: async (taskId, reason = '') => {
    try {
      await api.skipTask(taskId, reason)
      get().fetchTasks()
      get().fetchOverview()
    } catch (err) {
      console.error('Failed to skip task:', err)
    }
  },

  // Submit Checkin
  submitCheckin: async (mood, intensity, note = '') => {
    const result = await api.submitCheckin(mood, intensity, note)
    set({
      stateScore: {
        score: result.state_score.score,
        breakdown: result.state_score.breakdown,
        recoveryAction: result.state_score.recovery_action,
      },
    })
    return result
  },

  // Chat: Send Message
  // Uses AI SDK 6.0 Agent Runtime for streaming responses
  sendMessage: async (content) => {
    const { sessionId, messages } = get()

    // Extract command if content starts with /
    let command: string | undefined
    let messageText = content
    if (content.startsWith('/')) {
      const parts = content.split(/\s+/)
      const cmdPart = parts[0]
      if (cmdPart.length > 1) {
        command = cmdPart // e.g., "/bazi" or "/yunshi"
        messageText = parts.slice(1).join(' ') || content // Keep original if no args
      }
    }

    // Add user message
    const userMessage: Message = {
      id: `user-${Date.now()}`,
      role: 'user',
      content,
      timestamp: new Date(),
    }
    const assistantId = `assistant-${Date.now()}`
    const assistantMessage: Message = {
      id: assistantId,
      role: 'assistant',
      content: '',
      timestamp: new Date(),
    }
    set({ messages: [...messages, userMessage, assistantMessage], isStreaming: true })

    try {
      let streamedText = ''

      // Use smart stream function that picks legacy or new runtime
      api.streamChat(
        content, // Send full content including command
        sessionId || undefined,
        {
          command, // For new runtime tool selection
          onChunk: (chunk) => {
            streamedText += chunk
            set((state) => ({
              messages: state.messages.map((m) =>
                m.id === assistantId
                  ? { ...m, content: streamedText }
                  : m
              ),
            }))
          },
          onToolCall: (toolInvocation) => {
            // Handle tool call updates (new runtime only)
            console.log('[chat] Tool call:', toolInvocation.toolName, toolInvocation.result ? '(completed)' : '(pending)')
          },
          onDone: (final) => {
            set((state) => ({
              messages: state.messages.map((m) =>
                m.id === assistantId
                  ? {
                      ...m,
                      content: final.reply || streamedText || '收到了，让我想想...',
                      blocks: a2uiToBlocks(final.ui_components),
                    }
                  : m
              ),
              sessionId: final.session_id,
              isStreaming: false,
            }))
          },
          onError: (err) => {
            console.error('Chat stream failed:', err)
            const msg = err instanceof Error ? err.message : String(err || 'unknown_error')
            set((state) => ({
              messages: state.messages.map((m) =>
                m.id === assistantId
                  ? { ...m, content: streamedText || `（请求失败：${msg}）` }
                  : m
              ),
              isStreaming: false,
            }))
          },
        }
      )
    } catch (err) {
      console.error('Failed to send message:', err)
      set({ isStreaming: false })
    }
  },

  // Chat: Add Message (for non-streaming)
  addMessage: (message) =>
    set((state) => ({
      messages: [...state.messages, message],
    })),

  setStreaming: (streaming) => set({ isStreaming: streaming }),

  clearMessages: () => set({ messages: [], sessionId: null }),

  // Artifact Actions
  addArtifact: (artifact) =>
    set((state) => ({
      artifacts: [...state.artifacts, artifact],
    })),

  pinArtifact: (id) =>
    set((state) => {
      const artifact = state.artifacts.find((a) => a.id === id)
      if (!artifact) return state

      const updated = { ...artifact, pinned: true }
      return {
        artifacts: state.artifacts.map((a) => (a.id === id ? updated : a)),
        pinnedArtifacts: [...state.pinnedArtifacts, updated],
      }
    }),

  unpinArtifact: (id) =>
    set((state) => ({
      artifacts: state.artifacts.map((a) =>
        a.id === id ? { ...a, pinned: false } : a
      ),
      pinnedArtifacts: state.pinnedArtifacts.filter((a) => a.id !== id),
    })),
}))
