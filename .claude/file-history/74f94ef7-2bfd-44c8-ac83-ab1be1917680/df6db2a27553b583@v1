"""
VibeLife Fortune Event Calendar
运势事件日历 - 管理八字节气、星座行星事件等
"""

from datetime import date, datetime, timedelta
from typing import Optional
from enum import Enum
from pydantic import BaseModel
import asyncpg


class EventType(str, Enum):
    # 八字事件
    SOLAR_TERM = "solar_term"           # 节气
    BAZI_MONTH = "bazi_month"           # 月运交接
    BAZI_YEAR = "bazi_year"             # 流年交接
    BAZI_DAYUN = "bazi_dayun"           # 大运交接

    # 星座事件
    MERCURY_RETROGRADE = "mercury_retrograde"    # 水逆
    NEW_MOON = "new_moon"                        # 新月
    FULL_MOON = "full_moon"                      # 满月
    PLANET_RETROGRADE = "planet_retrograde"      # 行星逆行
    SUN_SIGN_CHANGE = "sun_sign_change"          # 太阳换座

    # 用户事件
    BIRTHDAY = "birthday"                # 生日
    ANNIVERSARY = "anniversary"          # 纪念日
    CUSTOM = "custom"                    # 自定义事件


class FortuneEvent(BaseModel):
    """运势事件"""
    id: Optional[str] = None
    event_type: EventType
    name: str
    start_date: date
    end_date: Optional[date] = None
    event_data: dict = {}


# 2026年24节气日期 (预计算)
SOLAR_TERMS_2026 = [
    ("小寒", date(2026, 1, 5)),
    ("大寒", date(2026, 1, 20)),
    ("立春", date(2026, 2, 4)),
    ("雨水", date(2026, 2, 19)),
    ("惊蛰", date(2026, 3, 6)),
    ("春分", date(2026, 3, 21)),
    ("清明", date(2026, 4, 5)),
    ("谷雨", date(2026, 4, 20)),
    ("立夏", date(2026, 5, 5)),
    ("小满", date(2026, 5, 21)),
    ("芒种", date(2026, 6, 6)),
    ("夏至", date(2026, 6, 21)),
    ("小暑", date(2026, 7, 7)),
    ("大暑", date(2026, 7, 23)),
    ("立秋", date(2026, 8, 7)),
    ("处暑", date(2026, 8, 23)),
    ("白露", date(2026, 9, 8)),
    ("秋分", date(2026, 9, 23)),
    ("寒露", date(2026, 10, 8)),
    ("霜降", date(2026, 10, 23)),
    ("立冬", date(2026, 11, 7)),
    ("小雪", date(2026, 11, 22)),
    ("大雪", date(2026, 12, 7)),
    ("冬至", date(2026, 12, 22)),
]

# 2026年月运交接节气 (每月第一个节气)
BAZI_MONTH_TRANSITIONS_2026 = [
    ("丙寅月", date(2026, 2, 4)),   # 立春 -> 寅月
    ("丁卯月", date(2026, 3, 6)),   # 惊蛰 -> 卯月
    ("戊辰月", date(2026, 4, 5)),   # 清明 -> 辰月
    ("己巳月", date(2026, 5, 5)),   # 立夏 -> 巳月
    ("庚午月", date(2026, 6, 6)),   # 芒种 -> 午月
    ("辛未月", date(2026, 7, 7)),   # 小暑 -> 未月
    ("壬申月", date(2026, 8, 7)),   # 立秋 -> 申月
    ("癸酉月", date(2026, 9, 8)),   # 白露 -> 酉月
    ("甲戌月", date(2026, 10, 8)),  # 寒露 -> 戌月
    ("乙亥月", date(2026, 11, 7)),  # 立冬 -> 亥月
    ("丙子月", date(2026, 12, 7)),  # 大雪 -> 子月
]

# 2026年水逆日期 (预计算)
MERCURY_RETROGRADES_2026 = [
    {
        "name": "2026年第一次水逆 (水瓶座)",
        "start": date(2026, 1, 26),
        "end": date(2026, 2, 16),
        "sign": "水瓶座"
    },
    {
        "name": "2026年第二次水逆 (双子座→金牛座)",
        "start": date(2026, 5, 19),
        "end": date(2026, 6, 11),
        "sign": "双子座→金牛座"
    },
    {
        "name": "2026年第三次水逆 (天秤座→处女座)",
        "start": date(2026, 9, 12),
        "end": date(2026, 10, 4),
        "sign": "天秤座→处女座"
    },
]

# 2026年新月满月日期
MOON_PHASES_2026 = [
    {"type": "new_moon", "date": date(2026, 1, 10), "sign": "摩羯座"},
    {"type": "full_moon", "date": date(2026, 1, 25), "sign": "狮子座"},
    {"type": "new_moon", "date": date(2026, 2, 9), "sign": "水瓶座"},
    {"type": "full_moon", "date": date(2026, 2, 24), "sign": "处女座"},
    {"type": "new_moon", "date": date(2026, 3, 10), "sign": "双鱼座"},
    {"type": "full_moon", "date": date(2026, 3, 25), "sign": "天秤座"},
    {"type": "new_moon", "date": date(2026, 4, 9), "sign": "白羊座"},
    {"type": "full_moon", "date": date(2026, 4, 24), "sign": "天蝎座"},
    {"type": "new_moon", "date": date(2026, 5, 8), "sign": "金牛座"},
    {"type": "full_moon", "date": date(2026, 5, 23), "sign": "射手座"},
    {"type": "new_moon", "date": date(2026, 6, 7), "sign": "双子座"},
    {"type": "full_moon", "date": date(2026, 6, 22), "sign": "摩羯座"},
    {"type": "new_moon", "date": date(2026, 7, 6), "sign": "巨蟹座"},
    {"type": "full_moon", "date": date(2026, 7, 21), "sign": "水瓶座"},
    {"type": "new_moon", "date": date(2026, 8, 5), "sign": "狮子座"},
    {"type": "full_moon", "date": date(2026, 8, 20), "sign": "双鱼座"},
    {"type": "new_moon", "date": date(2026, 9, 3), "sign": "处女座"},
    {"type": "full_moon", "date": date(2026, 9, 18), "sign": "白羊座"},
    {"type": "new_moon", "date": date(2026, 10, 3), "sign": "天秤座"},
    {"type": "full_moon", "date": date(2026, 10, 17), "sign": "白羊座"},
    {"type": "new_moon", "date": date(2026, 11, 1), "sign": "天蝎座"},
    {"type": "full_moon", "date": date(2026, 11, 16), "sign": "金牛座"},
    {"type": "new_moon", "date": date(2026, 12, 1), "sign": "射手座"},
    {"type": "full_moon", "date": date(2026, 12, 16), "sign": "双子座"},
    {"type": "new_moon", "date": date(2026, 12, 30), "sign": "摩羯座"},
]


class FortuneCalendar:
    """运势日历服务"""

    def __init__(self, db_pool: asyncpg.Pool):
        self.db = db_pool

    async def initialize_events(self) -> int:
        """初始化预计算的运势事件到数据库"""
        events_created = 0

        # 插入节气事件
        for name, event_date in SOLAR_TERMS_2026:
            await self._upsert_event(
                EventType.SOLAR_TERM,
                f"节气·{name}",
                event_date,
                {"solar_term": name}
            )
            events_created += 1

        # 插入月运交接事件
        for month_name, event_date in BAZI_MONTH_TRANSITIONS_2026:
            await self._upsert_event(
                EventType.BAZI_MONTH,
                f"月运交接·{month_name}",
                event_date,
                {"bazi_month": month_name}
            )
            events_created += 1

        # 插入水逆事件
        for retro in MERCURY_RETROGRADES_2026:
            await self._upsert_event(
                EventType.MERCURY_RETROGRADE,
                retro["name"],
                retro["start"],
                end_date=retro["end"],
                event_data={"sign": retro["sign"]}
            )
            events_created += 1

        # 插入新月满月事件
        for phase in MOON_PHASES_2026:
            event_type = EventType.NEW_MOON if phase["type"] == "new_moon" else EventType.FULL_MOON
            phase_name = "新月" if phase["type"] == "new_moon" else "满月"
            await self._upsert_event(
                event_type,
                f"{phase_name}·{phase['sign']}",
                phase["date"],
                event_data={"sign": phase["sign"]}
            )
            events_created += 1

        return events_created

    async def _upsert_event(
        self,
        event_type: EventType,
        name: str,
        start_date: date,
        event_data: dict = None,
        end_date: date = None
    ):
        """插入或更新事件"""
        import json
        await self.db.execute("""
            INSERT INTO fortune_events (id, event_type, name, start_date, end_date, event_data)
            VALUES (uuid_generate_v4(), $1, $2, $3, $4, $5)
            ON CONFLICT (event_type, name, start_date) DO UPDATE SET
                end_date = EXCLUDED.end_date,
                event_data = EXCLUDED.event_data
        """, event_type.value, name, start_date, end_date, json.dumps(event_data or {}))

    async def get_upcoming_events(
        self,
        days_ahead: int = 7,
        event_types: list[EventType] = None
    ) -> list[FortuneEvent]:
        """获取即将到来的事件"""
        today = date.today()
        end_date = today + timedelta(days=days_ahead)

        query = """
            SELECT id, event_type, name, start_date, end_date, event_data
            FROM fortune_events
            WHERE start_date BETWEEN $1 AND $2
        """
        params = [today, end_date]

        if event_types:
            type_values = [t.value for t in event_types]
            query += f" AND event_type = ANY($3)"
            params.append(type_values)

        query += " ORDER BY start_date ASC"

        rows = await self.db.fetch(query, *params)
        return [
            FortuneEvent(
                id=str(row["id"]),
                event_type=EventType(row["event_type"]),
                name=row["name"],
                start_date=row["start_date"],
                end_date=row["end_date"],
                event_data=row["event_data"] if isinstance(row["event_data"], dict) else {}
            )
            for row in rows
        ]

    async def get_events_for_date(self, target_date: date) -> list[FortuneEvent]:
        """获取指定日期的事件"""
        rows = await self.db.fetch("""
            SELECT id, event_type, name, start_date, end_date, event_data
            FROM fortune_events
            WHERE start_date = $1
               OR (start_date <= $1 AND end_date >= $1)
            ORDER BY event_type, name
        """, target_date)

        return [
            FortuneEvent(
                id=str(row["id"]),
                event_type=EventType(row["event_type"]),
                name=row["name"],
                start_date=row["start_date"],
                end_date=row["end_date"],
                event_data=row["event_data"] if isinstance(row["event_data"], dict) else {}
            )
            for row in rows
        ]

    async def is_mercury_retrograde(self, check_date: date = None) -> tuple[bool, Optional[dict]]:
        """检查是否在水逆期间"""
        if check_date is None:
            check_date = date.today()

        row = await self.db.fetchrow("""
            SELECT name, start_date, end_date, event_data
            FROM fortune_events
            WHERE event_type = $1
              AND start_date <= $2
              AND end_date >= $2
        """, EventType.MERCURY_RETROGRADE.value, check_date)

        if row:
            return True, {
                "name": row["name"],
                "start_date": row["start_date"].isoformat(),
                "end_date": row["end_date"].isoformat(),
                "event_data": row["event_data"]
            }
        return False, None

    async def get_next_solar_term(self, from_date: date = None) -> Optional[FortuneEvent]:
        """获取下一个节气"""
        if from_date is None:
            from_date = date.today()

        row = await self.db.fetchrow("""
            SELECT id, event_type, name, start_date, end_date, event_data
            FROM fortune_events
            WHERE event_type = $1 AND start_date > $2
            ORDER BY start_date ASC
            LIMIT 1
        """, EventType.SOLAR_TERM.value, from_date)

        if row:
            return FortuneEvent(
                id=str(row["id"]),
                event_type=EventType(row["event_type"]),
                name=row["name"],
                start_date=row["start_date"],
                end_date=row["end_date"],
                event_data=row["event_data"] if isinstance(row["event_data"], dict) else {}
            )
        return None

    async def get_next_moon_phase(
        self,
        phase_type: str = None,
        from_date: date = None
    ) -> Optional[FortuneEvent]:
        """获取下一个月相 (new_moon/full_moon)"""
        if from_date is None:
            from_date = date.today()

        event_types = []
        if phase_type == "new_moon":
            event_types = [EventType.NEW_MOON.value]
        elif phase_type == "full_moon":
            event_types = [EventType.FULL_MOON.value]
        else:
            event_types = [EventType.NEW_MOON.value, EventType.FULL_MOON.value]

        row = await self.db.fetchrow("""
            SELECT id, event_type, name, start_date, end_date, event_data
            FROM fortune_events
            WHERE event_type = ANY($1) AND start_date > $2
            ORDER BY start_date ASC
            LIMIT 1
        """, event_types, from_date)

        if row:
            return FortuneEvent(
                id=str(row["id"]),
                event_type=EventType(row["event_type"]),
                name=row["name"],
                start_date=row["start_date"],
                end_date=row["end_date"],
                event_data=row["event_data"] if isinstance(row["event_data"], dict) else {}
            )
        return None

    async def add_user_event(
        self,
        user_id: str,
        event_type: EventType,
        name: str,
        event_date: date,
        event_data: dict = None
    ) -> str:
        """添加用户自定义事件"""
        import json
        result = await self.db.fetchrow("""
            INSERT INTO fortune_events (id, event_type, name, start_date, event_data)
            VALUES (uuid_generate_v4(), $1, $2, $3, $4)
            RETURNING id
        """, event_type.value, name, event_date, json.dumps({
            **(event_data or {}),
            "user_id": user_id
        }))
        return str(result["id"])
