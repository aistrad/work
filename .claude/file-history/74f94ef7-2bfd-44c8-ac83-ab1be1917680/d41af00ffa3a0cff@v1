"""
VibeLife Subscription Service
订阅管理服务
"""

from datetime import datetime, timedelta
from typing import Optional
from pydantic import BaseModel
from enum import Enum
import asyncpg
import json
import logging

from .stripe_service import StripeService

logger = logging.getLogger(__name__)


class SubscriptionTier(str, Enum):
    FREE = "free"
    SKILL_SINGLE = "skill_single"      # 单站订阅
    SKILL_BUNDLE = "skill_bundle"      # 多站捆绑
    VIBELIFE_ALL = "vibelife_all"      # 全站订阅


class SubscriptionStatus(str, Enum):
    ACTIVE = "active"
    TRIALING = "trialing"
    PAST_DUE = "past_due"
    CANCELED = "canceled"
    EXPIRED = "expired"


class SubscriptionPlan(BaseModel):
    """订阅计划"""
    id: str
    name: str
    plan_type: SubscriptionTier
    skill_ids: list[str]
    price_monthly: int  # 分
    price_yearly: int   # 分
    currency: str = "CNY"
    features: list[str]
    is_active: bool = True


class UserSubscription(BaseModel):
    """用户订阅"""
    id: str
    user_id: str
    plan_id: str
    status: SubscriptionStatus
    started_at: datetime
    current_period_end: Optional[datetime] = None
    cancelled_at: Optional[datetime] = None
    payment_provider: str = "stripe"
    payment_subscription_id: Optional[str] = None


# 预定义订阅计划
SUBSCRIPTION_PLANS = [
    SubscriptionPlan(
        id="free",
        name="免费版",
        plan_type=SubscriptionTier.FREE,
        skill_ids=[],
        price_monthly=0,
        price_yearly=0,
        features=[
            "1次完整命盘解读",
            "每天3次提问",
            "基础运势分析"
        ]
    ),
    SubscriptionPlan(
        id="bazi_premium",
        name="八字会员",
        plan_type=SubscriptionTier.SKILL_SINGLE,
        skill_ids=["bazi"],
        price_monthly=2900,  # ¥29
        price_yearly=19900,  # ¥199
        features=[
            "无限对话",
            "深度十神分析",
            "每月运势推送",
            "详细大运解读",
            "格局深度分析"
        ]
    ),
    SubscriptionPlan(
        id="zodiac_premium",
        name="星座会员",
        plan_type=SubscriptionTier.SKILL_SINGLE,
        skill_ids=["zodiac"],
        price_monthly=2900,
        price_yearly=19900,
        features=[
            "无限对话",
            "完整星盘分析",
            "每周运势推送",
            "行运深度解读",
            "相位详细分析"
        ]
    ),
    SubscriptionPlan(
        id="mbti_premium",
        name="MBTI会员",
        plan_type=SubscriptionTier.SKILL_SINGLE,
        skill_ids=["mbti"],
        price_monthly=2900,
        price_yearly=19900,
        features=[
            "无限对话",
            "认知功能深度分析",
            "类型成长建议",
            "职业发展指导"
        ]
    ),
    SubscriptionPlan(
        id="vibelife_all",
        name="VibeLife 全能会员",
        plan_type=SubscriptionTier.VIBELIFE_ALL,
        skill_ids=["bazi", "zodiac", "mbti"],
        price_monthly=6900,  # ¥69
        price_yearly=49900,  # ¥499
        features=[
            "全部技能无限使用",
            "跨技能深度洞察",
            "优先客服支持",
            "专属会员活动",
            "新功能优先体验"
        ]
    ),
]


class SubscriptionService:
    """订阅管理服务"""

    def __init__(self, db_pool: asyncpg.Pool, stripe: StripeService = None):
        self.db = db_pool
        self.stripe = stripe or StripeService()

    async def get_all_plans(self) -> list[SubscriptionPlan]:
        """获取所有订阅计划"""
        return SUBSCRIPTION_PLANS

    async def get_plan(self, plan_id: str) -> Optional[SubscriptionPlan]:
        """获取指定订阅计划"""
        for plan in SUBSCRIPTION_PLANS:
            if plan.id == plan_id:
                return plan
        return None

    async def get_user_subscription(self, user_id: str) -> Optional[UserSubscription]:
        """获取用户当前订阅"""
        row = await self.db.fetchrow("""
            SELECT id, user_id::text, plan_id, status, started_at,
                   current_period_end, cancelled_at, payment_provider,
                   payment_subscription_id
            FROM user_subscriptions
            WHERE user_id = $1::uuid AND status IN ('active', 'trialing')
            ORDER BY created_at DESC
            LIMIT 1
        """, user_id)

        if row:
            return UserSubscription(
                id=str(row["id"]),
                user_id=row["user_id"],
                plan_id=row["plan_id"],
                status=SubscriptionStatus(row["status"]),
                started_at=row["started_at"],
                current_period_end=row["current_period_end"],
                cancelled_at=row["cancelled_at"],
                payment_provider=row["payment_provider"] or "stripe",
                payment_subscription_id=row["payment_subscription_id"]
            )
        return None

    async def get_user_subscription_history(
        self,
        user_id: str,
        limit: int = 10
    ) -> list[UserSubscription]:
        """获取用户订阅历史"""
        rows = await self.db.fetch("""
            SELECT id, user_id::text, plan_id, status, started_at,
                   current_period_end, cancelled_at, payment_provider,
                   payment_subscription_id
            FROM user_subscriptions
            WHERE user_id = $1::uuid
            ORDER BY started_at DESC
            LIMIT $2
        """, user_id, limit)

        return [
            UserSubscription(
                id=str(row["id"]),
                user_id=row["user_id"],
                plan_id=row["plan_id"],
                status=SubscriptionStatus(row["status"]),
                started_at=row["started_at"],
                current_period_end=row["current_period_end"],
                cancelled_at=row["cancelled_at"],
                payment_provider=row["payment_provider"] or "stripe",
                payment_subscription_id=row["payment_subscription_id"]
            )
            for row in rows
        ]

    async def create_subscription(
        self,
        user_id: str,
        plan_id: str,
        payment_subscription_id: str,
        current_period_end: datetime
    ) -> str:
        """创建订阅记录"""
        result = await self.db.fetchrow("""
            INSERT INTO user_subscriptions (
                id, user_id, plan_id, status, started_at,
                current_period_end, payment_provider, payment_subscription_id
            ) VALUES (
                uuid_generate_v4(), $1::uuid, $2, 'active', NOW(),
                $3, 'stripe', $4
            )
            RETURNING id
        """, user_id, plan_id, current_period_end, payment_subscription_id)

        return str(result["id"])

    async def update_subscription_status(
        self,
        payment_subscription_id: str,
        status: SubscriptionStatus,
        current_period_end: Optional[datetime] = None
    ) -> bool:
        """更新订阅状态"""
        if current_period_end:
            result = await self.db.execute("""
                UPDATE user_subscriptions
                SET status = $1, current_period_end = $2
                WHERE payment_subscription_id = $3
            """, status.value, current_period_end, payment_subscription_id)
        else:
            result = await self.db.execute("""
                UPDATE user_subscriptions
                SET status = $1
                WHERE payment_subscription_id = $2
            """, status.value, payment_subscription_id)

        return "UPDATE" in result

    async def cancel_subscription(self, user_id: str) -> bool:
        """取消用户订阅"""
        subscription = await self.get_user_subscription(user_id)
        if not subscription:
            return False

        # 在 Stripe 取消
        if subscription.payment_subscription_id:
            success = await self.stripe.cancel_subscription(
                subscription.payment_subscription_id,
                cancel_immediately=False
            )
            if not success:
                return False

        # 更新数据库
        await self.db.execute("""
            UPDATE user_subscriptions
            SET cancelled_at = NOW()
            WHERE id = $1::uuid
        """, subscription.id)

        return True

    async def check_feature_access(
        self,
        user_id: str,
        feature: str,
        skill_id: str = None
    ) -> bool:
        """检查用户是否有权访问某功能"""
        subscription = await self.get_user_subscription(user_id)

        # 检查订阅是否有效
        if not subscription or subscription.status != SubscriptionStatus.ACTIVE:
            # 使用免费层
            return self._check_free_tier_access(feature)

        # 获取计划
        plan = await self.get_plan(subscription.plan_id)
        if not plan:
            return self._check_free_tier_access(feature)

        # 全站订阅
        if plan.plan_type == SubscriptionTier.VIBELIFE_ALL:
            return True

        # 单站订阅检查
        if skill_id and skill_id not in plan.skill_ids:
            return self._check_free_tier_access(feature)

        return True

    def _check_free_tier_access(self, feature: str) -> bool:
        """检查免费层是否可访问"""
        free_features = [
            "basic_chat",
            "basic_chart",
            "daily_fortune",
        ]
        return feature in free_features

    async def get_user_usage(self, user_id: str) -> dict:
        """获取用户使用量"""
        # 今日对话次数
        today_messages = await self.db.fetchval("""
            SELECT COUNT(*) FROM skill_messages sm
            JOIN skill_conversations sc ON sm.conversation_id = sc.id
            WHERE sc.user_id = $1::uuid
              AND sm.role = 'user'
              AND sm.created_at >= CURRENT_DATE
        """, user_id)

        # 本月对话次数
        month_messages = await self.db.fetchval("""
            SELECT COUNT(*) FROM skill_messages sm
            JOIN skill_conversations sc ON sm.conversation_id = sc.id
            WHERE sc.user_id = $1::uuid
              AND sm.role = 'user'
              AND sm.created_at >= DATE_TRUNC('month', CURRENT_DATE)
        """, user_id)

        return {
            "today_messages": today_messages or 0,
            "month_messages": month_messages or 0,
            "daily_limit": 3,  # 免费用户每日限制
            "remaining_today": max(0, 3 - (today_messages or 0))
        }

    async def sync_stripe_subscription(self, payment_subscription_id: str):
        """同步 Stripe 订阅状态"""
        stripe_sub = await self.stripe.get_subscription(payment_subscription_id)
        if not stripe_sub:
            return

        status_map = {
            "active": SubscriptionStatus.ACTIVE,
            "trialing": SubscriptionStatus.TRIALING,
            "past_due": SubscriptionStatus.PAST_DUE,
            "canceled": SubscriptionStatus.CANCELED,
            "unpaid": SubscriptionStatus.EXPIRED,
        }

        status = status_map.get(stripe_sub["status"], SubscriptionStatus.EXPIRED)
        current_period_end = stripe_sub.get("current_period_end")

        await self.update_subscription_status(
            payment_subscription_id,
            status,
            current_period_end
        )
