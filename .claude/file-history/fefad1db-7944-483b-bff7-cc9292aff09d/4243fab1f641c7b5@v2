"""
è¿åŠ¿è®¡ç®—æœåŠ¡
- ä»Šæ—¥è¿åŠ¿ï¼šåŸºäºå…«å­— + å½“æ—¥å¹²æ”¯
- å‘¨è¿åŠ¿ï¼šåŸºäºæœ¬å‘¨å…³é”®æ—¥å¹²æ”¯
- æœˆè¿åŠ¿ï¼šåŸºäºæœˆä»¤ä¸å…«å­—çš„ä½œç”¨
- æµå¹´è¿åŠ¿ï¼šåŸºäºæµå¹´å¹²æ”¯ä¸å…«å­—çš„ä½œç”¨
"""

from __future__ import annotations

import json
import uuid
from dataclasses import asdict, dataclass, field
from datetime import date, datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple

from lunar_python import Lunar, LunarYear, Solar

from common.logging import get_logger
from services import bazi_facts, kb_service
from stores import fortune_db


logger = get_logger(__name__)

YUNSHI_COMPUTE_VERSION = "yunshi-v1.0"


# =============================================================================
# Data Classes
# =============================================================================

@dataclass
class Prescription:
    """è¡ŒåŠ¨å¤„æ–¹"""
    task_id: str
    content: str
    estimated_minutes: int
    priority: str  # high, medium, low

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class TimeWindow:
    """æ—¶è¾°çª—å£"""
    hour_range: str  # e.g., "9-11ç‚¹"
    quality: str     # å‰, å¹³, å‡¶
    suggestion: str

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class DailyYunshi:
    """ä»Šæ—¥è¿åŠ¿ç»“æœ"""
    date: date
    day_ganzhi: str
    day_gan_relation: str
    day_zhi_specials: List[str]
    score: int
    summary: str
    highlights: List[str]
    risks: List[str]
    prescriptions: List[Prescription]
    time_windows: List[TimeWindow]
    evidence: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "date": self.date.isoformat(),
            "day_ganzhi": self.day_ganzhi,
            "day_gan_relation": self.day_gan_relation,
            "day_zhi_specials": self.day_zhi_specials,
            "score": self.score,
            "summary": self.summary,
            "highlights": self.highlights,
            "risks": self.risks,
            "prescriptions": [p.to_dict() for p in self.prescriptions],
            "time_windows": [t.to_dict() for t in self.time_windows],
            "evidence": self.evidence,
        }


@dataclass
class AnnualYunshi:
    """æµå¹´è¿åŠ¿ç»“æœ"""
    year: int
    liu_nian_ganzhi: str
    da_yun_ganzhi: str
    key_interactions: List[str]
    score: int
    summary: str
    themes: List[str]
    key_months: List[Dict[str, Any]]
    prescriptions: List[Prescription]
    evidence: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "year": self.year,
            "liu_nian_ganzhi": self.liu_nian_ganzhi,
            "da_yun_ganzhi": self.da_yun_ganzhi,
            "key_interactions": self.key_interactions,
            "score": self.score,
            "summary": self.summary,
            "themes": self.themes,
            "key_months": self.key_months,
            "prescriptions": [p.to_dict() for p in self.prescriptions],
            "evidence": self.evidence,
        }


# =============================================================================
# Constants
# =============================================================================

GAN_ELEMENT = {
    "ç”²": "æœ¨", "ä¹™": "æœ¨", "ä¸™": "ç«", "ä¸": "ç«",
    "æˆŠ": "åœŸ", "å·±": "åœŸ", "åºš": "é‡‘", "è¾›": "é‡‘",
    "å£¬": "æ°´", "ç™¸": "æ°´",
}

ZHI_ELEMENT = {
    "å­": "æ°´", "ä¸‘": "åœŸ", "å¯…": "æœ¨", "å¯": "æœ¨",
    "è¾°": "åœŸ", "å·³": "ç«", "åˆ": "ç«", "æœª": "åœŸ",
    "ç”³": "é‡‘", "é…‰": "é‡‘", "æˆŒ": "åœŸ", "äº¥": "æ°´",
}

ELEMENT_REL = {
    "æœ¨": {"generator": "æ°´", "produces": "ç«", "controls": "åœŸ", "controlled_by": "é‡‘"},
    "ç«": {"generator": "æœ¨", "produces": "åœŸ", "controls": "é‡‘", "controlled_by": "æ°´"},
    "åœŸ": {"generator": "ç«", "produces": "é‡‘", "controls": "æ°´", "controlled_by": "æœ¨"},
    "é‡‘": {"generator": "åœŸ", "produces": "æ°´", "controls": "æœ¨", "controlled_by": "ç«"},
    "æ°´": {"generator": "é‡‘", "produces": "æœ¨", "controls": "ç«", "controlled_by": "åœŸ"},
}

# åäºŒæ—¶è¾°å¯¹åº”æ—¶æ®µ
SHICHEN_HOURS = [
    ("å­", 23, 1), ("ä¸‘", 1, 3), ("å¯…", 3, 5), ("å¯", 5, 7),
    ("è¾°", 7, 9), ("å·³", 9, 11), ("åˆ", 11, 13), ("æœª", 13, 15),
    ("ç”³", 15, 17), ("é…‰", 17, 19), ("æˆŒ", 19, 21), ("äº¥", 21, 23),
]

# ç¥ç…è§¦å‘æ¡ä»¶ - ä¸‰åˆå±€
SHENSHA_SANHE_GROUPS = [
    ("ç”³å­è¾°", {"taohua": "é…‰", "yima": "å¯…", "huagai": "è¾°"}),
    ("äº¥å¯æœª", {"taohua": "å­", "yima": "å·³", "huagai": "æœª"}),
    ("å¯…åˆæˆŒ", {"taohua": "å¯", "yima": "ç”³", "huagai": "æˆŒ"}),
    ("å·³é…‰ä¸‘", {"taohua": "åˆ", "yima": "äº¥", "huagai": "ä¸‘"}),
]

# å¤©ä¹™è´µäºº
TIANYI_BY_DAY_GAN = {
    "ç”²": ["ä¸‘", "æœª"], "æˆŠ": ["ä¸‘", "æœª"], "åºš": ["ä¸‘", "æœª"],
    "ä¹™": ["å­", "ç”³"], "å·±": ["å­", "ç”³"],
    "ä¸™": ["äº¥", "é…‰"], "ä¸": ["äº¥", "é…‰"],
    "è¾›": ["å¯…", "åˆ"],
    "å£¬": ["å¯", "å·³"], "ç™¸": ["å¯", "å·³"],
}

# å…­åˆ
LIU_HE = {
    "å­": "ä¸‘", "ä¸‘": "å­", "å¯…": "äº¥", "äº¥": "å¯…",
    "å¯": "æˆŒ", "æˆŒ": "å¯", "è¾°": "é…‰", "é…‰": "è¾°",
    "å·³": "ç”³", "ç”³": "å·³", "åˆ": "æœª", "æœª": "åˆ",
}

# å…­å†²
LIU_CHONG = {
    "å­": "åˆ", "åˆ": "å­", "ä¸‘": "æœª", "æœª": "ä¸‘",
    "å¯…": "ç”³", "ç”³": "å¯…", "å¯": "é…‰", "é…‰": "å¯",
    "è¾°": "æˆŒ", "æˆŒ": "è¾°", "å·³": "äº¥", "äº¥": "å·³",
}


# =============================================================================
# Yunshi Service
# =============================================================================

class YunshiService:
    """è¿åŠ¿è®¡ç®—æœåŠ¡"""

    def compute_daily_yunshi(
        self,
        user_id: int,
        target_date: Optional[date] = None,
        use_cache: bool = True,
    ) -> DailyYunshi:
        """
        è®¡ç®—ä»Šæ—¥è¿åŠ¿

        æµç¨‹ï¼š
        1. è¯»å–ç”¨æˆ· bazi_snapshot (facts)
        2. è®¡ç®—ç›®æ ‡æ—¥æœŸçš„å¹²æ”¯
        3. åˆ†ææ—¥å¹²ä¸æ—¥ä¸»çš„äº”è¡Œå…³ç³»
        4. åˆ†ææ—¥æ”¯çš„ç‰¹æ®Šæ ‡è®°ï¼ˆæ¡ƒèŠ±/é©¿é©¬ç­‰ï¼‰
        5. æ£€ç´¢çŸ¥è¯†åº“è·å–è§£è¯»ä¾æ®
        6. ç”Ÿæˆç»¼åˆè¯„åˆ†ä¸è¡ŒåŠ¨å¤„æ–¹
        """
        target_date = target_date or date.today()

        # 1. è·å–å…«å­—äº‹å®
        snapshot = bazi_facts.ensure_snapshot_for_user(user_id)
        facts = snapshot["facts"]
        facts_hash = snapshot["facts_hash"]

        # Check cache first
        if use_cache:
            cached = self._get_cached_yunshi(user_id, "daily", target_date, facts_hash)
            if cached:
                return cached

        bazi = facts.get("bazi", {})
        day_master = bazi.get("day_master", {})
        day_master_element = day_master.get("element", "")
        day_master_gan = day_master.get("gan", "")
        pillars = bazi.get("pillars", {})
        shensha_list = bazi.get("shensha", [])

        # 2. è®¡ç®—å½“æ—¥å¹²æ”¯
        # Solar.fromDate expects datetime, not date
        if isinstance(target_date, date) and not isinstance(target_date, datetime):
            target_datetime = datetime.combine(target_date, datetime.min.time())
        else:
            target_datetime = target_date
        solar = Solar.fromDate(target_datetime)
        lunar = solar.getLunar()
        day_gan = lunar.getDayGan()
        day_zhi = lunar.getDayZhi()
        day_ganzhi = day_gan + day_zhi

        # 3. åˆ†æäº”è¡Œå…³ç³»
        relation = self._compute_gan_relation(day_master_element, day_gan)

        # 4. åˆ†æåœ°æ”¯ç‰¹æ®Šæ ‡è®°
        specials = self._check_branch_specials(day_zhi, day_master_gan, pillars, shensha_list)

        # 5. æ£€ç´¢çŸ¥è¯†åº“
        kb_refs = self._search_kb_for_ganzhi(day_ganzhi, relation["name"])

        # 6. è®¡ç®—è¯„åˆ†ä¸ç”Ÿæˆå¤„æ–¹
        score = self._compute_daily_score(relation, specials)
        highlights = self._build_highlights(relation, specials)
        risks = self._build_risks(relation, specials)
        summary = self._build_daily_summary(day_ganzhi, relation, score)
        prescriptions = self._generate_daily_prescriptions(relation, specials, score)
        time_windows = self._compute_time_windows(day_ganzhi, day_master_element)

        yunshi = DailyYunshi(
            date=target_date,
            day_ganzhi=day_ganzhi,
            day_gan_relation=relation["name"],
            day_zhi_specials=specials,
            score=score,
            summary=summary,
            highlights=highlights,
            risks=risks,
            prescriptions=prescriptions,
            time_windows=time_windows,
            evidence={
                "rule_ids": ["RULE-DAILY-DAYGAN-V1", "RULE-DAILY-DAYZHI-V1"],
                "kb_refs": kb_refs,
            },
        )

        # Cache the result
        self._cache_yunshi(user_id, "daily", target_date, facts_hash, yunshi)

        logger.info(
            "computed daily yunshi",
            extra={
                "operation": "yunshi_compute",
                "user_id": user_id,
                "type": "daily",
                "date": str(target_date),
                "score": score,
            },
        )

        return yunshi

    def compute_annual_yunshi(
        self,
        user_id: int,
        target_year: Optional[int] = None,
        use_cache: bool = True,
    ) -> AnnualYunshi:
        """
        è®¡ç®—æµå¹´è¿åŠ¿

        æµç¨‹ï¼š
        1. è¯»å–å…«å­—äº‹å®ï¼ˆå«å¤§è¿ï¼‰
        2. è·å–æµå¹´å¹²æ”¯
        3. åˆ†ææµå¹´ä¸åŸå±€çš„ä½œç”¨
        4. åˆ†æå½“å‰å¤§è¿ä¸æµå¹´çš„å åŠ 
        5. ç¡®å®šå¹´åº¦ä¸»é¢˜ä¸å…³é”®æœˆä»½
        6. ç”Ÿæˆè¡ŒåŠ¨å¤„æ–¹
        """
        target_year = target_year or datetime.now().year
        target_date = date(target_year, 1, 1)

        # 1. è·å–å…«å­—äº‹å®
        snapshot = bazi_facts.ensure_snapshot_for_user(user_id)
        facts = snapshot["facts"]
        facts_hash = snapshot["facts_hash"]

        # Check cache first
        if use_cache:
            cached = self._get_cached_yunshi(user_id, "annual", target_date, facts_hash)
            if cached:
                return cached

        bazi = facts.get("bazi", {})
        luck = bazi.get("luck", {})
        pillars = bazi.get("pillars", {})
        day_master = bazi.get("day_master", {})

        # 2. è·å–æµå¹´å¹²æ”¯
        liu_nian_ganzhi = LunarYear.fromYear(target_year).getGanZhi()

        # 3. è·å–å½“å‰å¤§è¿
        da_yun = self._get_current_dayun(luck.get("da_yun", []), target_year)
        da_yun_ganzhi = da_yun.get("gan_zhi", "") if da_yun else ""

        # 4. åˆ†æä½œç”¨å…³ç³»
        interactions = self._analyze_liunian_interactions(
            liu_nian_ganzhi=liu_nian_ganzhi,
            pillars=pillars,
            da_yun_ganzhi=da_yun_ganzhi,
        )

        # 5. è®¡ç®—è¯„åˆ†ä¸ä¸»é¢˜
        score = self._compute_annual_score(interactions)
        themes = self._extract_annual_themes(interactions, day_master, liu_nian_ganzhi)
        key_months = self._identify_key_months(target_year, pillars, day_master)
        summary = self._build_annual_summary(target_year, liu_nian_ganzhi, score, themes)

        # 6. ç”Ÿæˆè¡ŒåŠ¨å¤„æ–¹
        prescriptions = self._generate_annual_prescriptions(themes, score)

        yunshi = AnnualYunshi(
            year=target_year,
            liu_nian_ganzhi=liu_nian_ganzhi,
            da_yun_ganzhi=da_yun_ganzhi,
            key_interactions=interactions,
            score=score,
            summary=summary,
            themes=themes,
            key_months=key_months,
            prescriptions=prescriptions,
            evidence={
                "rule_ids": ["RULE-LIUNIAN-INTERACTION-V1"],
                "kb_refs": [],
            },
        )

        # Cache the result
        self._cache_yunshi(user_id, "annual", target_date, facts_hash, yunshi)

        logger.info(
            "computed annual yunshi",
            extra={
                "operation": "yunshi_compute",
                "user_id": user_id,
                "type": "annual",
                "year": target_year,
                "score": score,
            },
        )

        return yunshi

    # =========================================================================
    # Helper Methods - Relation Computation
    # =========================================================================

    def _compute_gan_relation(self, day_master_element: str, target_gan: str) -> Dict[str, Any]:
        """è®¡ç®—å¤©å¹²äº”è¡Œå…³ç³»"""
        target_element = GAN_ELEMENT.get(target_gan, "")

        if not day_master_element or not target_element:
            return {"name": "æœªçŸ¥", "score": 0, "desc": "", "relation": "unknown"}

        if target_element == day_master_element:
            return {"name": "æ¯”è‚©", "score": 0, "desc": "å¹³ç¨³ï¼Œå®œå®ˆæˆ", "relation": "same"}

        rel = ELEMENT_REL.get(day_master_element, {})
        if target_element == rel.get("generator"):
            return {"name": "å°ç»¶", "score": 2, "desc": "æœ‰åŠ©åŠ›ï¼Œè´µäººè¿", "relation": "generates"}
        if target_element == rel.get("produces"):
            return {"name": "é£Ÿä¼¤", "score": 1, "desc": "é€‚åˆè¡¨è¾¾ã€åˆ›ä½œ", "relation": "produced"}
        if target_element == rel.get("controls"):
            return {"name": "è´¢æ˜Ÿ", "score": 1, "desc": "é€‚åˆè´¢åŠ¡ã€äº‹ä¸šæ¨è¿›", "relation": "controls"}
        if target_element == rel.get("controlled_by"):
            return {"name": "å®˜æ€", "score": -1, "desc": "å‹åŠ›å¢å¤§ï¼Œå®œè°¨æ…", "relation": "controlled"}

        return {"name": "æœªçŸ¥", "score": 0, "desc": "", "relation": "unknown"}

    def _check_branch_specials(
        self,
        day_zhi: str,
        day_master_gan: str,
        pillars: Dict[str, str],
        shensha_list: List[Dict],
    ) -> List[str]:
        """æ£€æŸ¥åœ°æ”¯ç‰¹æ®Šæ ‡è®°"""
        specials = []

        # è·å–å¹´æ”¯/æ—¥æ”¯ç”¨äºåˆ¤æ–­
        year_zhi = pillars.get("year", "")[1:2] if len(pillars.get("year", "")) >= 2 else ""
        birth_day_zhi = pillars.get("day", "")[1:2] if len(pillars.get("day", "")) >= 2 else ""

        # æŸ¥æ‰¾ä¸‰åˆå±€å¯¹åº”çš„ç¥ç…è§¦å‘åœ°æ”¯
        for group_str, targets in SHENSHA_SANHE_GROUPS:
            if year_zhi in group_str or birth_day_zhi in group_str:
                if day_zhi == targets.get("taohua"):
                    specials.append("æ¡ƒèŠ±æ—¥")
                if day_zhi == targets.get("yima"):
                    specials.append("é©¿é©¬æ—¥")
                if day_zhi == targets.get("huagai"):
                    specials.append("åç›–æ—¥")

        # å¤©ä¹™è´µäºº
        tianyi_targets = TIANYI_BY_DAY_GAN.get(day_master_gan, [])
        if day_zhi in tianyi_targets:
            specials.append("è´µäººæ—¥")

        # å…­åˆ
        if birth_day_zhi and LIU_HE.get(birth_day_zhi) == day_zhi:
            specials.append("å…­åˆæ—¥")

        # å…­å†²
        if birth_day_zhi and LIU_CHONG.get(birth_day_zhi) == day_zhi:
            specials.append("å…­å†²æ—¥")

        return specials

    # =========================================================================
    # Helper Methods - Score & Content Building
    # =========================================================================

    def _compute_daily_score(self, relation: Dict, specials: List[str]) -> int:
        """è®¡ç®—æ¯æ—¥ç»¼åˆè¯„åˆ†"""
        score = relation.get("score", 0)

        # ç‰¹æ®Šæ ‡è®°åŠ å‡åˆ†
        if "è´µäººæ—¥" in specials:
            score += 2
        if "æ¡ƒèŠ±æ—¥" in specials:
            score += 1
        if "åç›–æ—¥" in specials:
            score += 1
        if "å…­åˆæ—¥" in specials:
            score += 1
        if "å…­å†²æ—¥" in specials:
            score -= 2
        if "é©¿é©¬æ—¥" in specials:
            score += 0  # ä¸­æ€§ï¼Œé€‚åˆå˜åŠ¨

        return max(-10, min(10, score))

    def _build_daily_summary(self, day_ganzhi: str, relation: Dict, score: int) -> str:
        """æ„å»ºæ¯æ—¥è¿åŠ¿ä¸€å¥è¯æ€»ç»“"""
        relation_name = relation.get("name", "")
        relation_desc = relation.get("desc", "")

        if score >= 5:
            quality = "è¿åŠ¿æä½³"
        elif score >= 2:
            quality = "è¿åŠ¿è‰¯å¥½"
        elif score >= 0:
            quality = "è¿åŠ¿å¹³ç¨³"
        elif score >= -2:
            quality = "è¿åŠ¿åå¼±"
        else:
            quality = "è¿åŠ¿æ¬ ä½³"

        return f"ä»Šæ—¥{day_ganzhi}ï¼Œ{relation_name}æ—¥ï¼Œ{quality}ã€‚{relation_desc}"

    def _build_highlights(self, relation: Dict, specials: List[str]) -> List[str]:
        """æ„å»ºäº®ç‚¹åˆ—è¡¨"""
        highlights = []

        relation_name = relation.get("name", "")
        if relation_name == "å°ç»¶":
            highlights.append("è´µäººè¿ä½³ï¼Œæœ‰åŠ©åŠ›")
        elif relation_name == "é£Ÿä¼¤":
            highlights.append("é€‚åˆè¡¨è¾¾ä¸åˆ›ä½œ")
        elif relation_name == "è´¢æ˜Ÿ":
            highlights.append("é€‚åˆè´¢åŠ¡ä¸äº‹ä¸šæ¨è¿›")
        elif relation_name == "æ¯”è‚©":
            highlights.append("é€‚åˆåˆä½œä¸ç¨³å®šå‘å±•")

        if "è´µäººæ—¥" in specials:
            highlights.append("å¤©ä¹™è´µäººç…§ä¸´ï¼Œæ˜“å¾—å¸®åŠ©")
        if "æ¡ƒèŠ±æ—¥" in specials:
            highlights.append("äººé™…ä¸æ„Ÿæƒ…æ´»è·ƒ")
        if "åç›–æ—¥" in specials:
            highlights.append("é€‚åˆå­¦ä¹ ä¸å†…çœ")
        if "å…­åˆæ—¥" in specials:
            highlights.append("äººé™…å’Œè°ï¼Œåˆä½œé¡ºåˆ©")

        return highlights[:3]

    def _build_risks(self, relation: Dict, specials: List[str]) -> List[str]:
        """æ„å»ºé£é™©æç¤º"""
        risks = []

        relation_name = relation.get("name", "")
        if relation_name == "å®˜æ€":
            risks.append("å‹åŠ›è¾ƒå¤§ï¼Œé¿å…å†²åŠ¨å†³ç­–")

        if "å…­å†²æ—¥" in specials:
            risks.append("å˜åŠ¨è¾ƒå¤šï¼Œé‡è¦äº‹åŠ¡éœ€è°¨æ…")

        return risks[:2]

    def _generate_daily_prescriptions(
        self,
        relation: Dict,
        specials: List[str],
        score: int,
    ) -> List[Prescription]:
        """ç”Ÿæˆæ¯æ—¥è¡ŒåŠ¨å¤„æ–¹"""
        prescriptions = []

        relation_name = relation.get("name", "")

        if relation_name == "å°ç»¶" or "è´µäººæ—¥" in specials:
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="ä»Šæ—¥è´µäººè¿ä½³ï¼Œä¸»åŠ¨è”ç³»ä¸€ä½å¯ä»¥å¸®åŠ©ä½ çš„äºº",
                estimated_minutes=15,
                priority="high",
            ))
        elif relation_name == "å®˜æ€" or score < 0:
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="ä»Šæ—¥å‹åŠ›è¾ƒå¤§ï¼Œåš 3 åˆ†é’Ÿæ­£å¿µå‘¼å¸å†å¤„ç†é‡è¦äº‹åŠ¡",
                estimated_minutes=3,
                priority="high",
            ))
        elif relation_name == "é£Ÿä¼¤":
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="ä»Šæ—¥é€‚åˆè¡¨è¾¾ï¼Œè®°å½•ä¸€ä¸ªåˆ›æ„æƒ³æ³•æˆ–å®Œæˆä¸€æ¬¡åˆ†äº«",
                estimated_minutes=15,
                priority="medium",
            ))
        elif relation_name == "è´¢æ˜Ÿ":
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="ä»Šæ—¥è´¢æ˜Ÿå½“å€¼ï¼Œæ¨è¿›ä¸€é¡¹äº‹ä¸šç›¸å…³çš„é‡è¦äº‹åŠ¡",
                estimated_minutes=30,
                priority="high",
            ))

        # ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªå¤„æ–¹
        if not prescriptions:
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="å›é¡¾ä»Šæ—¥ç›®æ ‡ï¼Œå®Œæˆæœ€é‡è¦çš„ä¸€ä»¶äº‹",
                estimated_minutes=10,
                priority="medium",
            ))

        return prescriptions[:3]

    def _compute_time_windows(
        self,
        day_ganzhi: str,
        day_master_element: str,
    ) -> List[TimeWindow]:
        """è®¡ç®—æ—¶è¾°çª—å£"""
        windows = []
        day_zhi = day_ganzhi[1] if len(day_ganzhi) >= 2 else ""

        for shichen, start_hour, end_hour in SHICHEN_HOURS:
            zhi_element = ZHI_ELEMENT.get(shichen, "")
            rel = ELEMENT_REL.get(day_master_element, {})

            # ç®€åŒ–çš„æ—¶è¾°å‰å‡¶åˆ¤æ–­
            if zhi_element == rel.get("generator"):
                quality = "å‰"
                suggestion = "é€‚åˆé‡è¦å†³ç­–ä¸æ²Ÿé€š"
            elif zhi_element == rel.get("controlled_by"):
                quality = "å‡¶"
                suggestion = "é¿å…é‡è¦å†³ç­–ï¼Œé€‚åˆä¼‘æ¯"
            else:
                quality = "å¹³"
                suggestion = "å¸¸è§„äº‹åŠ¡"

            # åªæ·»åŠ å‰æ—¶
            if quality == "å‰":
                hour_range = f"{start_hour}-{end_hour}ç‚¹" if end_hour > start_hour else f"{start_hour}-æ¬¡æ—¥{end_hour}ç‚¹"
                windows.append(TimeWindow(
                    hour_range=hour_range,
                    quality=quality,
                    suggestion=suggestion,
                ))

        return windows[:3]  # æœ€å¤šè¿”å›3ä¸ªå‰æ—¶

    # =========================================================================
    # Helper Methods - Annual Yunshi
    # =========================================================================

    def _get_current_dayun(self, da_yun_list: List[Dict], target_year: int) -> Optional[Dict]:
        """è·å–å½“å‰å¤§è¿"""
        for dy in da_yun_list:
            start_year = dy.get("start_year", 0)
            end_year = dy.get("end_year", 0)
            if start_year <= target_year <= end_year:
                return dy
        return None

    def _analyze_liunian_interactions(
        self,
        liu_nian_ganzhi: str,
        pillars: Dict[str, str],
        da_yun_ganzhi: str,
    ) -> List[str]:
        """åˆ†ææµå¹´ä¸åŸå±€çš„ä½œç”¨å…³ç³»"""
        interactions = []

        if len(liu_nian_ganzhi) < 2:
            return interactions

        ln_gan = liu_nian_ganzhi[0]
        ln_zhi = liu_nian_ganzhi[1]

        # ä¸æ—¥æŸ±æ¯”è¾ƒ
        day_pillar = pillars.get("day", "")
        if len(day_pillar) >= 2:
            day_gan = day_pillar[0]
            day_zhi = day_pillar[1]

            # å¤©å…‹åœ°å†²
            if LIU_CHONG.get(ln_zhi) == day_zhi:
                interactions.append("å¤©å…‹åœ°å†²")
            # ä¼åŸ
            if ln_gan == day_gan and ln_zhi == day_zhi:
                interactions.append("ä¼åŸ")

        # ä¸å¹´æŸ±æ¯”è¾ƒ
        year_pillar = pillars.get("year", "")
        if len(year_pillar) >= 2:
            year_zhi = year_pillar[1]
            # å…­åˆ
            if LIU_HE.get(ln_zhi) == year_zhi:
                interactions.append("å¤©åˆåœ°åˆ")

        return interactions

    def _compute_annual_score(self, interactions: List[str]) -> int:
        """è®¡ç®—æµå¹´ç»¼åˆè¯„åˆ†"""
        score = 3  # åŸºç¡€åˆ†

        score_map = {
            "å¤©å…‹åœ°å†²": -3,
            "å¤©åˆåœ°åˆ": 2,
            "ä¼åŸ": -1,
            "ååŸ": -2,
        }

        for interaction in interactions:
            score += score_map.get(interaction, 0)

        return max(-10, min(10, score))

    def _extract_annual_themes(
        self,
        interactions: List[str],
        day_master: Dict,
        liu_nian_ganzhi: str,
    ) -> List[str]:
        """æå–å¹´åº¦ä¸»é¢˜"""
        themes = []

        ln_element = GAN_ELEMENT.get(liu_nian_ganzhi[0], "") if liu_nian_ganzhi else ""
        dm_element = day_master.get("element", "")

        if ln_element and dm_element:
            rel = ELEMENT_REL.get(dm_element, {})
            if ln_element == rel.get("generator"):
                themes.append("è´µäººåŠ©åŠ›å¹´")
            elif ln_element == rel.get("produces"):
                themes.append("è¡¨è¾¾å±•ç¤ºå¹´")
            elif ln_element == rel.get("controls"):
                themes.append("äº‹ä¸šè´¢è¿å¹´")
            elif ln_element == rel.get("controlled_by"):
                themes.append("å‹åŠ›æŒ‘æˆ˜å¹´")
            else:
                themes.append("ç¨³å®šå‘å±•å¹´")

        if "å¤©å…‹åœ°å†²" in interactions:
            themes.append("å˜åŠ¨è°ƒæ•´æœŸ")
        if "å¤©åˆåœ°åˆ" in interactions:
            themes.append("æœºé‡å’Œè°æœŸ")

        return themes[:3]

    def _identify_key_months(
        self,
        target_year: int,
        pillars: Dict[str, str],
        day_master: Dict,
    ) -> List[Dict[str, Any]]:
        """è¯†åˆ«å…³é”®æœˆä»½"""
        key_months = []
        dm_element = day_master.get("element", "")
        rel = ELEMENT_REL.get(dm_element, {})

        # ç®€åŒ–å®ç°ï¼šåŸºäºæœˆä»¤äº”è¡Œ
        month_elements = [
            (1, "åœŸ", "ä¸‘æœˆ"), (2, "æœ¨", "å¯…æœˆ"), (3, "æœ¨", "å¯æœˆ"),
            (4, "åœŸ", "è¾°æœˆ"), (5, "ç«", "å·³æœˆ"), (6, "ç«", "åˆæœˆ"),
            (7, "åœŸ", "æœªæœˆ"), (8, "é‡‘", "ç”³æœˆ"), (9, "é‡‘", "é…‰æœˆ"),
            (10, "åœŸ", "æˆŒæœˆ"), (11, "æ°´", "äº¥æœˆ"), (12, "æ°´", "å­æœˆ"),
        ]

        for month, element, name in month_elements:
            if element == rel.get("generator"):
                key_months.append({
                    "month": month,
                    "name": name,
                    "theme": "è´µäººæœˆ",
                    "suggestion": "é€‚åˆå¯»æ±‚å¸®åŠ©ä¸åˆä½œ",
                })
            elif element == rel.get("controlled_by"):
                key_months.append({
                    "month": month,
                    "name": name,
                    "theme": "å‹åŠ›æœˆ",
                    "suggestion": "éœ€è°¨æ…è¡Œäº‹ï¼Œé¿å…å†²åŠ¨",
                })

        return key_months[:4]

    def _build_annual_summary(
        self,
        year: int,
        liu_nian_ganzhi: str,
        score: int,
        themes: List[str],
    ) -> str:
        """æ„å»ºæµå¹´è¿åŠ¿ä¸€å¥è¯æ€»ç»“"""
        theme_str = "ã€".join(themes[:2]) if themes else "ç¨³å®šå‘å±•"

        if score >= 5:
            quality = "è¿åŠ¿æä½³"
        elif score >= 2:
            quality = "è¿åŠ¿è‰¯å¥½"
        elif score >= 0:
            quality = "è¿åŠ¿å¹³ç¨³"
        else:
            quality = "è¿åŠ¿åå¼±"

        return f"{year}å¹´{liu_nian_ganzhi}ï¼Œ{quality}ï¼Œä¸»é¢˜ï¼š{theme_str}"

    def _generate_annual_prescriptions(
        self,
        themes: List[str],
        score: int,
    ) -> List[Prescription]:
        """ç”Ÿæˆæµå¹´è¡ŒåŠ¨å¤„æ–¹"""
        prescriptions = []

        if "è´µäººåŠ©åŠ›å¹´" in themes:
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="æœ¬å¹´è´µäººè¿ä½³ï¼Œä¸»åŠ¨æ‹“å±•äººè„‰ï¼Œå»ºç«‹æœ‰ä»·å€¼çš„è¿æ¥",
                estimated_minutes=60,
                priority="high",
            ))

        if "äº‹ä¸šè´¢è¿å¹´" in themes:
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="æœ¬å¹´è´¢è¿å½“å€¼ï¼Œåˆ¶å®šæ¸…æ™°çš„äº‹ä¸šç›®æ ‡å¹¶æŒç»­æ¨è¿›",
                estimated_minutes=120,
                priority="high",
            ))

        if "å‹åŠ›æŒ‘æˆ˜å¹´" in themes or "å˜åŠ¨è°ƒæ•´æœŸ" in themes:
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="æœ¬å¹´å˜åŠ¨è¾ƒå¤šï¼Œä¿æŒç¨³å¥èŠ‚å¥ï¼Œé‡è¦å†³ç­–å‰å¤šæ–¹å’¨è¯¢",
                estimated_minutes=30,
                priority="high",
            ))

        if not prescriptions:
            prescriptions.append(Prescription(
                task_id=str(uuid.uuid4()),
                content="ç¨³æ­¥æ¨è¿›å¹´åº¦ç›®æ ‡ï¼Œä¿æŒç§¯æå¿ƒæ€",
                estimated_minutes=30,
                priority="medium",
            ))

        return prescriptions[:3]

    # =========================================================================
    # Helper Methods - KB Search
    # =========================================================================

    def _search_kb_for_ganzhi(self, ganzhi: str, relation_name: str) -> List[Dict[str, Any]]:
        """æ£€ç´¢çŸ¥è¯†åº“"""
        try:
            query = f"{ganzhi} {relation_name} è¿åŠ¿"
            hits = kb_service.search_bazi_kb(query, top_k=3)
            return [{"kb_ref": h["kb_ref"], "preview": h["preview"]} for h in hits]
        except Exception as e:
            logger.warning(f"kb search failed: {e}")
            return []

    # =========================================================================
    # Helper Methods - Caching
    # =========================================================================

    def _get_cached_yunshi(
        self,
        user_id: int,
        snapshot_type: str,
        snapshot_date: date,
        facts_hash: str,
    ) -> Optional[DailyYunshi]:
        """è·å–ç¼“å­˜çš„è¿åŠ¿å¿«ç…§"""
        row = fortune_db.fetch_one(
            """
            SELECT analysis, highlights, risks, prescriptions, summary, score,
                   day_ganzhi, period_ganzhi, time_windows, rule_ids, kb_refs
            FROM fortune_yunshi_snapshot
            WHERE user_id = %s
              AND snapshot_type = %s
              AND snapshot_date = %s
              AND bazi_facts_hash = %s
              AND (expires_at IS NULL OR expires_at > NOW())
            ORDER BY created_at DESC
            LIMIT 1
            """,
            (user_id, snapshot_type, snapshot_date, facts_hash),
        )

        if not row:
            return None

        try:
            analysis = row.get("analysis", {})
            if snapshot_type == "daily":
                return DailyYunshi(
                    date=snapshot_date,
                    day_ganzhi=row.get("day_ganzhi", ""),
                    day_gan_relation=analysis.get("day_gan_relation", ""),
                    day_zhi_specials=analysis.get("day_zhi_specials", []),
                    score=row.get("score", 0),
                    summary=row.get("summary", ""),
                    highlights=row.get("highlights", []),
                    risks=row.get("risks", []),
                    prescriptions=[
                        Prescription(**p) for p in (row.get("prescriptions") or [])
                    ],
                    time_windows=[
                        TimeWindow(**t) for t in (row.get("time_windows") or [])
                    ],
                    evidence={
                        "rule_ids": row.get("rule_ids", []),
                        "kb_refs": row.get("kb_refs", []),
                    },
                )
        except Exception as e:
            logger.warning(f"failed to parse cached yunshi: {e}")
            return None

        return None

    def _cache_yunshi(
        self,
        user_id: int,
        snapshot_type: str,
        snapshot_date: date,
        facts_hash: str,
        yunshi: DailyYunshi | AnnualYunshi,
    ) -> None:
        """ç¼“å­˜è¿åŠ¿å¿«ç…§"""
        try:
            # Determine expiration
            if snapshot_type == "daily":
                expires_at = datetime.combine(snapshot_date + timedelta(days=1), datetime.min.time())
            elif snapshot_type == "annual":
                expires_at = datetime.combine(date(snapshot_date.year + 1, 1, 1), datetime.min.time())
            else:
                expires_at = None

            yunshi_dict = yunshi.to_dict()

            # Prepare prescriptions and time_windows for JSONB
            prescriptions_json = json.dumps(yunshi_dict.get("prescriptions", []), ensure_ascii=False)
            highlights_json = json.dumps(yunshi_dict.get("highlights", []), ensure_ascii=False)
            risks_json = json.dumps(yunshi_dict.get("risks", []), ensure_ascii=False)
            time_windows_json = json.dumps(yunshi_dict.get("time_windows", []), ensure_ascii=False)
            analysis_json = json.dumps({
                "day_gan_relation": yunshi_dict.get("day_gan_relation", ""),
                "day_zhi_specials": yunshi_dict.get("day_zhi_specials", []),
            }, ensure_ascii=False)
            kb_refs_json = json.dumps(yunshi_dict.get("evidence", {}).get("kb_refs", []), ensure_ascii=False)
            rule_ids = yunshi_dict.get("evidence", {}).get("rule_ids", [])

            fortune_db.execute(
                """
                INSERT INTO fortune_yunshi_snapshot (
                    user_id, snapshot_type, snapshot_date, bazi_facts_hash,
                    day_ganzhi, summary, score, analysis,
                    highlights, risks, prescriptions, time_windows,
                    rule_ids, kb_refs, compute_version, expires_at
                ) VALUES (
                    %s, %s, %s, %s,
                    %s, %s, %s, %s::jsonb,
                    %s::jsonb, %s::jsonb, %s::jsonb, %s::jsonb,
                    %s, %s::jsonb, %s, %s
                )
                ON CONFLICT (user_id, snapshot_type, snapshot_date, bazi_facts_hash)
                DO UPDATE SET
                    summary = EXCLUDED.summary,
                    score = EXCLUDED.score,
                    analysis = EXCLUDED.analysis,
                    highlights = EXCLUDED.highlights,
                    risks = EXCLUDED.risks,
                    prescriptions = EXCLUDED.prescriptions,
                    time_windows = EXCLUDED.time_windows
                """,
                (
                    user_id, snapshot_type, snapshot_date, facts_hash,
                    yunshi_dict.get("day_ganzhi", ""),
                    yunshi_dict.get("summary", ""),
                    yunshi_dict.get("score", 0),
                    analysis_json,
                    highlights_json,
                    risks_json,
                    prescriptions_json,
                    time_windows_json,
                    rule_ids,
                    kb_refs_json,
                    YUNSHI_COMPUTE_VERSION,
                    expires_at,
                ),
            )
        except Exception as e:
            logger.warning(f"failed to cache yunshi: {e}")


# =============================================================================
# A2UI Builder
# =============================================================================

def build_daily_yunshi_a2ui(yunshi: DailyYunshi) -> Dict[str, Any]:
    """æ„å»ºä»Šæ—¥è¿åŠ¿ A2UI"""
    # Score to stars
    if yunshi.score >= 7:
        stars = "â˜…â˜…â˜…â˜…â˜…"
    elif yunshi.score >= 4:
        stars = "â˜…â˜…â˜…â˜…â˜†"
    elif yunshi.score >= 1:
        stars = "â˜…â˜…â˜…â˜†â˜†"
    elif yunshi.score >= -2:
        stars = "â˜…â˜…â˜†â˜†â˜†"
    else:
        stars = "â˜…â˜†â˜†â˜†â˜†"

    # Build markdown content
    md_parts = [
        f"### {yunshi.date.isoformat()} Â· {yunshi.day_ganzhi} Â· {yunshi.day_gan_relation}",
        "",
        f"**ç»¼åˆè¯„åˆ†ï¼š{stars} ({yunshi.score}/10)**",
        "",
    ]

    if yunshi.highlights:
        md_parts.append("#### äº®ç‚¹")
        for h in yunshi.highlights:
            md_parts.append(f"- âœ“ {h}")
        md_parts.append("")

    if yunshi.risks:
        md_parts.append("#### æ³¨æ„")
        for r in yunshi.risks:
            md_parts.append(f"- ! {r}")
        md_parts.append("")

    if yunshi.time_windows:
        md_parts.append("#### æ—¶è¾°æç¤º")
        for tw in yunshi.time_windows:
            md_parts.append(f"- ğŸ• {tw.hour_range}ï¼š{tw.suggestion}")

    markdown_text = "\n".join(md_parts)

    # Build action buttons
    action_buttons = []
    for p in yunshi.prescriptions[:2]:
        action_buttons.append({
            "label": p.content[:20] + ("..." if len(p.content) > 20 else ""),
            "action": {
                "type": "start_task",
                "task_id": p.task_id,
            },
        })

    action_buttons.append({
        "label": "æŸ¥çœ‹è¯¦ç»†åˆ†æ",
        "action": {
            "type": "open_panel",
            "panel": "yunshi_detail",
        },
    })

    return {
        "meta": {
            "summary": yunshi.summary,
        },
        "ui_components": [
            {
                "type": "markdown_text",
                "title": "ä»Šæ—¥è¿åŠ¿",
                "data": markdown_text,
            },
            {
                "type": "action_buttons",
                "title": "ä»Šæ—¥è¡ŒåŠ¨",
                "data": action_buttons,
            },
        ],
    }


def build_annual_yunshi_a2ui(yunshi: AnnualYunshi) -> Dict[str, Any]:
    """æ„å»ºæµå¹´è¿åŠ¿ A2UI"""
    md_parts = [
        f"### {yunshi.year}å¹´ Â· {yunshi.liu_nian_ganzhi}",
        "",
        f"**å¤§è¿ï¼š{yunshi.da_yun_ganzhi}**" if yunshi.da_yun_ganzhi else "",
        "",
        f"**ç»¼åˆè¯„åˆ†ï¼š{yunshi.score}/10**",
        "",
        "#### å¹´åº¦ä¸»é¢˜",
    ]

    for theme in yunshi.themes:
        md_parts.append(f"- {theme}")

    md_parts.append("")

    if yunshi.key_months:
        md_parts.append("#### å…³é”®æœˆä»½")
        for km in yunshi.key_months:
            md_parts.append(f"- {km['month']}æœˆï¼ˆ{km['name']}ï¼‰ï¼š{km['theme']}")

    markdown_text = "\n".join(md_parts)

    return {
        "meta": {
            "summary": yunshi.summary,
        },
        "ui_components": [
            {
                "type": "markdown_text",
                "title": "æµå¹´è¿åŠ¿",
                "data": markdown_text,
            },
        ],
    }


# =============================================================================
# Module-level instance
# =============================================================================

yunshi_service = YunshiService()
