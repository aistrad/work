"""
Session Manager v10 - 会话状态管理

管理用户的活跃会话生命周期：
- 获取当前活跃会话
- 开始新会话
- 暂停/恢复会话
- 完成会话

与 ContextManager 协作：
- SessionManager: 管理会话生命周期
- ContextManager: 管理会话内的数据
"""
import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from typing import Optional, Dict, Any, List
from uuid import UUID
from enum import Enum

logger = logging.getLogger(__name__)


class SessionStatus(str, Enum):
    """会话状态"""
    IN_PROGRESS = "in_progress"
    PAUSED = "paused"
    COMPLETED = "completed"
    ABANDONED = "abandoned"


@dataclass
class ActiveSession:
    """活跃会话信息"""
    skill_id: str
    rule_id: Optional[str] = None
    conversation_id: Optional[str] = None
    started_at: Optional[str] = None
    last_activity: Optional[str] = None
    status: str = SessionStatus.IN_PROGRESS
    goal: Optional[str] = None
    checkpoint_step: int = 0
    checkpoint_total: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ActiveSession":
        return cls(
            skill_id=data.get("skill_id", ""),
            rule_id=data.get("rule_id"),
            conversation_id=data.get("conversation_id"),
            started_at=data.get("started_at"),
            last_activity=data.get("last_activity"),
            status=data.get("status", SessionStatus.IN_PROGRESS),
            goal=data.get("goal"),
            checkpoint_step=data.get("checkpoint_step", 0),
            checkpoint_total=data.get("checkpoint_total", 0)
        )

    @property
    def is_active(self) -> bool:
        """会话是否活跃"""
        return self.status in (SessionStatus.IN_PROGRESS, SessionStatus.PAUSED)

    @property
    def progress_text(self) -> str:
        """进度文本"""
        if self.checkpoint_total > 0:
            return f"{self.checkpoint_step}/{self.checkpoint_total}"
        return ""


class SessionManager:
    """
    会话状态管理器

    职责：
    1. 检测活跃会话
    2. 管理会话生命周期

    LLM-First v10.3: 移除硬编码关键词判断
    - 会话恢复/放弃决策由 LLM 自主判断
    - 不再使用 RESUME_KEYWORDS / ABANDON_KEYWORDS
    """

    def __init__(self):
        from .context_manager import get_context_manager
        self.context_manager = get_context_manager()

    async def get_active_session(self, user_id: str) -> Optional[ActiveSession]:
        """
        获取当前活跃会话

        从 profile.state.active_session 读取
        """
        from stores.unified_profile_repo import UnifiedProfileRepository

        if user_id == "guest":
            return None

        try:
            user_uuid = UUID(user_id)
            state = await UnifiedProfileRepository.get_state(user_uuid)

            active_session_data = state.get("active_session")
            if not active_session_data:
                return None

            session = ActiveSession.from_dict(active_session_data)

            # 检查是否仍然活跃
            if not session.is_active:
                return None

            # 获取最新的 checkpoint 信息
            if session.skill_id:
                skill_state = await UnifiedProfileRepository.get_skill_state(
                    user_uuid, session.skill_id
                )
                skill_session = skill_state.get("_session", {})
                checkpoint = skill_session.get("checkpoint", {})
                session.checkpoint_step = checkpoint.get("step", 0)
                session.checkpoint_total = checkpoint.get("total_steps", 0)

            logger.info(f"[SessionManager] Found active session: skill={session.skill_id}, rule={session.rule_id}, step={session.checkpoint_step}")

            return session

        except Exception as e:
            logger.error(f"[SessionManager] Failed to get active session: {e}")
            return None

    def should_resume(
        self,
        message: str,
        active_session: Optional[ActiveSession]
    ) -> bool:
        """
        LLM-First v10.3: 简化为仅检查是否有活跃会话

        不再做关键词判断，由 LLM 根据用户意图自主决定是否恢复。
        此函数仅返回是否存在可恢复的会话。
        """
        if not active_session:
            return False
        return active_session.is_active and active_session.checkpoint_step > 0

    def should_ask_resume(
        self,
        message: str,
        active_session: Optional[ActiveSession]
    ) -> bool:
        """
        LLM-First v10.3: 简化为仅检查是否有活跃会话

        不再做关键词判断，由 LLM 决定如何处理会话恢复。
        """
        if not active_session:
            return False
        return active_session.is_active and active_session.checkpoint_step > 0

    async def start_session(
        self,
        user_id: str,
        skill_id: str,
        rule_id: Optional[str] = None,
        conversation_id: Optional[str] = None,
        goal: Optional[str] = None,
        total_steps: int = 0
    ) -> ActiveSession:
        """
        开始新会话

        写入 profile.state.active_session
        初始化 profile.skills.{skill_id}._session
        """
        from stores.unified_profile_repo import UnifiedProfileRepository

        now = datetime.now(timezone.utc).isoformat()

        session = ActiveSession(
            skill_id=skill_id,
            rule_id=rule_id,
            conversation_id=conversation_id,
            started_at=now,
            last_activity=now,
            status=SessionStatus.IN_PROGRESS,
            goal=goal,
            checkpoint_step=0,
            checkpoint_total=total_steps
        )

        if user_id == "guest":
            return session

        try:
            user_uuid = UUID(user_id)

            # 更新全局 active_session
            await UnifiedProfileRepository.update_state(user_uuid, {
                "active_session": session.to_dict()
            })

            # 初始化 skill session
            await self.context_manager.start_session(
                user_id, skill_id, rule_id, goal, total_steps
            )

            logger.info(f"[SessionManager] Started session: skill={skill_id}, rule={rule_id}")

            return session

        except Exception as e:
            logger.error(f"[SessionManager] Failed to start session: {e}")
            return session

    async def pause_session(self, user_id: str) -> None:
        """
        暂停会话

        更新 status 为 paused
        """
        from stores.unified_profile_repo import UnifiedProfileRepository

        if user_id == "guest":
            return

        try:
            user_uuid = UUID(user_id)
            state = await UnifiedProfileRepository.get_state(user_uuid)

            active_session = state.get("active_session", {})
            if active_session:
                active_session["status"] = SessionStatus.PAUSED
                active_session["last_activity"] = datetime.now(timezone.utc).isoformat()

                await UnifiedProfileRepository.update_state(user_uuid, {
                    "active_session": active_session
                })

            logger.info(f"[SessionManager] Paused session for user={user_id}")

        except Exception as e:
            logger.error(f"[SessionManager] Failed to pause session: {e}")

    async def resume_session(self, user_id: str) -> Optional[ActiveSession]:
        """
        恢复会话

        更新 status 为 in_progress
        返回完整的会话上下文
        """
        from stores.unified_profile_repo import UnifiedProfileRepository

        session = await self.get_active_session(user_id)
        if not session:
            return None

        if user_id == "guest":
            return session

        try:
            user_uuid = UUID(user_id)

            # 更新状态
            session.status = SessionStatus.IN_PROGRESS
            session.last_activity = datetime.now(timezone.utc).isoformat()

            await UnifiedProfileRepository.update_state(user_uuid, {
                "active_session": session.to_dict()
            })

            logger.info(f"[SessionManager] Resumed session: skill={session.skill_id}")

            return session

        except Exception as e:
            logger.error(f"[SessionManager] Failed to resume session: {e}")
            return session

    async def complete_session(
        self,
        user_id: str,
        summary: Optional[str] = None
    ) -> None:
        """
        完成会话

        更新 status 为 completed
        清理 checkpoint，保留 findings
        """
        session = await self.get_active_session(user_id)
        if not session:
            return

        from stores.unified_profile_repo import UnifiedProfileRepository

        if user_id == "guest":
            return

        try:
            user_uuid = UUID(user_id)

            # 清除 active_session
            await UnifiedProfileRepository.update_state(user_uuid, {
                "active_session": None
            })

            # 完成 skill session
            await self.context_manager.complete_session(
                user_id, session.skill_id, summary
            )

            logger.info(f"[SessionManager] Completed session: skill={session.skill_id}")

        except Exception as e:
            logger.error(f"[SessionManager] Failed to complete session: {e}")

    async def abandon_session(self, user_id: str) -> None:
        """
        放弃会话

        更新 status 为 abandoned
        清理所有状态
        """
        session = await self.get_active_session(user_id)
        if not session:
            return

        from stores.unified_profile_repo import UnifiedProfileRepository

        if user_id == "guest":
            return

        try:
            user_uuid = UUID(user_id)

            # 清除 active_session
            await UnifiedProfileRepository.update_state(user_uuid, {
                "active_session": None
            })

            # 清理 skill session（不保留 findings）
            await self.context_manager.clear_session(
                user_id, session.skill_id, keep_findings=False
            )

            logger.info(f"[SessionManager] Abandoned session: skill={session.skill_id}")

        except Exception as e:
            logger.error(f"[SessionManager] Failed to abandon session: {e}")

    async def update_activity(
        self,
        user_id: str,
        conversation_id: Optional[str] = None
    ) -> None:
        """
        更新会话活动时间

        每次用户交互时调用
        """
        from stores.unified_profile_repo import UnifiedProfileRepository

        if user_id == "guest":
            return

        try:
            user_uuid = UUID(user_id)
            state = await UnifiedProfileRepository.get_state(user_uuid)

            active_session = state.get("active_session", {})
            if active_session:
                active_session["last_activity"] = datetime.now(timezone.utc).isoformat()
                if conversation_id:
                    active_session["conversation_id"] = conversation_id

                await UnifiedProfileRepository.update_state(user_uuid, {
                    "active_session": active_session
                })

        except Exception as e:
            logger.error(f"[SessionManager] Failed to update activity: {e}")

    def build_resume_prompt(self, session: ActiveSession) -> Dict[str, Any]:
        """
        LLM-First v10.3: 返回结构化数据而非硬编码文本

        返回会话状态数据，由 LLM 自主决定如何向用户呈现。
        """
        if not session:
            return {}

        # 动态获取技能显示名
        skill_name = session.skill_id
        rule_name = session.rule_id
        try:
            from services.agent.skill_loader import load_skill, get_rule_name
            skill = load_skill(session.skill_id)
            if skill and getattr(skill, 'name', None):
                skill_name = skill.name
            if session.rule_id and get_rule_name:
                rule_name = get_rule_name(session.skill_id, session.rule_id)
        except Exception:
            pass

        return {
            "skill_id": session.skill_id,
            "skill_name": skill_name,
            "rule_id": session.rule_id,
            "rule_name": rule_name,
            "checkpoint_step": session.checkpoint_step,
            "checkpoint_total": session.checkpoint_total,
            "goal": session.goal,
            "has_progress": session.checkpoint_step > 0
        }


# ═══════════════════════════════════════════════════════════════════════════
# Singleton
# ═══════════════════════════════════════════════════════════════════════════

_session_manager: Optional[SessionManager] = None


def get_session_manager() -> SessionManager:
    """获取 SessionManager 单例"""
    global _session_manager
    if _session_manager is None:
        _session_manager = SessionManager()
    return _session_manager
