"""
CoreAgent v10 - Context Engineering 驱动

v10 架构特性：
- Context Engineering: 文件/JSONB 持久化状态，断点续传
- 模块化: ContextManager, SessionManager, PromptBuilder, ToolExecutor
- 会话恢复: 自动检测未完成会话，支持断点续传
- 跨 Skill 共享: profile.extracted + identity

v9 架构特性（保留）：
- Phase 1 提供所有路由工具，LLM 一次性决策
- 移除 Python 硬编码决策逻辑
- 工具即行为：activate_skill, show_protocol_invitation, show_skill_intro

v8 架构特性（保留）：
- 分阶段上下文加载：Phase 1 (Skill 选择) / Phase 2 (Skill 执行)
- use_skill 同轮重载：激活 skill 后同一轮内重新构建上下文
"""
import json
import logging
import time
from typing import Optional, List, Dict, Any, AsyncGenerator
from dataclasses import dataclass
from enum import Enum

from services.llm import LLMClient, get_llm_client
from services.llm.client import LLMMessage
from .case_index import get_case_index, CaseIndex
from .skill_loader import (
    load_skill, skill_requires_birth_info, skill_requires_compute,
    get_skill_compute_type, get_skill_rules,
)
from .tool_registry import ToolRegistry, ToolContext
from .routing_config import (
    get_phase1_prompt, get_all_protocols,
    build_protocol_tool_description, build_skill_tool_description,
)
from .context_manager import get_context_manager, ContextManager, SessionContext
from .session_manager import get_session_manager, SessionManager, ActiveSession
from .prompt_builder import get_prompt_builder, PromptBuilder
from .tool_executor import get_tool_executor, ToolExecutor

logger = logging.getLogger(__name__)


class AgentState(str, Enum):
    """Agent 执行状态"""
    IDLE = "idle"
    THINKING = "thinking"
    TOOL_CALLING = "tool_calling"
    COMPLETED = "completed"
    ERROR = "error"


@dataclass
class AgentEvent:
    """Agent 执行事件"""
    type: str  # thinking, content, tool_call, tool_result, done, error, sop_phase, session_resume
    data: Any = None


@dataclass
class AgentContext:
    """Agent 执行上下文

    v10 更新：
    - 新增 session_context 支持断点续传
    """
    user_id: str
    user_tier: str = "free"
    profile: Optional[Dict[str, Any]] = None
    skill_data: Optional[Dict[str, Any]] = None
    history: Optional[List[Dict[str, str]]] = None
    skill: Optional[str] = None
    scenario: Optional[str] = None
    conversation_id: Optional[str] = None
    voice_mode: Optional[str] = "warm"
    protocol_prompt: Optional[str] = None
    session_context: Optional[SessionContext] = None  # v10: 会话上下文


def build_phase1_tools() -> List[Dict[str, Any]]:
    """
    构建 Phase 1 路由工具集 - v10: 配置驱动

    工具列表：
    1. activate_skill - 激活 skill 并切换上下文
    2. show_protocol_invitation - 展示协议邀请卡片
    3. show_skill_intro - 展示 skill 介绍卡片
    4. recommend_skills - 推荐相关 skills
    """
    from .skill_loader import get_available_skills

    available_skills = [s for s in get_available_skills() if s != "core"]
    protocols = get_all_protocols()
    protocol_ids = list(protocols.keys()) if protocols else ["dankoe", "covey", "yangming", "liaofan"]

    # 工具 1: activate_skill
    activate_skill_tool = {
        "type": "function",
        "function": {
            "name": "activate_skill",
            "description": build_skill_tool_description(),
            "parameters": {
                "type": "object",
                "properties": {
                    "skill": {
                        "type": "string",
                        "enum": available_skills,
                        "description": "要激活的技能 ID"
                    },
                    "rule": {
                        "type": "string",
                        "description": "可选的规则 ID，用于指定具体场景"
                    }
                },
                "required": ["skill"]
            }
        }
    }

    # 工具 2: show_protocol_invitation
    show_protocol_invitation_tool = {
        "type": "function",
        "function": {
            "name": "show_protocol_invitation",
            "description": build_protocol_tool_description(),
            "parameters": {
                "type": "object",
                "properties": {
                    "protocol_id": {
                        "type": "string",
                        "enum": protocol_ids,
                        "description": "协议 ID"
                    }
                },
                "required": ["protocol_id"]
            }
        }
    }

    # 工具 3: show_skill_intro
    show_skill_intro_tool = {
        "type": "function",
        "function": {
            "name": "show_skill_intro",
            "description": """展示 Skill 介绍卡片。

## 何时调用
- 用户问"这个能做什么"、"有什么功能"
- 用户首次使用某个 Skill""",
            "parameters": {
                "type": "object",
                "properties": {
                    "skill": {
                        "type": "string",
                        "enum": available_skills,
                        "description": "要介绍的技能 ID"
                    }
                },
                "required": ["skill"]
            }
        }
    }

    # 工具 4: recommend_skills
    recommend_skills_tool = {
        "type": "function",
        "function": {
            "name": "recommend_skills",
            "description": "推荐 Skills 给用户选择。\n\n## 何时调用\n- 用户打招呼（你好）→ 展示能力\n- 不确定用户想用哪个 skill\n- 用户说「帮帮我」、「有什么推荐」",
            "parameters": {
                "type": "object",
                "properties": {
                    "skills": {
                        "type": "array",
                        "items": {"type": "string", "enum": available_skills},
                        "description": "推荐的技能列表（2-3个）"
                    },
                    "reason": {
                        "type": "string",
                        "description": "简短的推荐理由或欢迎语"
                    }
                },
                "required": ["skills", "reason"]
            }
        }
    }

    return [
        activate_skill_tool,
        show_protocol_invitation_tool,
        show_skill_intro_tool,
        recommend_skills_tool
    ]


# 缓存动态生成的工具定义
_PHASE1_TOOLS_CACHE: Optional[List[Dict[str, Any]]] = None


def get_phase1_tools() -> List[Dict[str, Any]]:
    """获取 Phase 1 工具定义（带缓存）"""
    global _PHASE1_TOOLS_CACHE
    if _PHASE1_TOOLS_CACHE is None:
        _PHASE1_TOOLS_CACHE = build_phase1_tools()
    return _PHASE1_TOOLS_CACHE


class CoreAgent:
    """
    CoreAgent v10 - Context Engineering 驱动

    Features:
    - 会话恢复检查：自动检测未完成会话
    - 断点续传：从 checkpoint 恢复执行
    - 模块化设计：ContextManager, SessionManager, PromptBuilder, ToolExecutor
    - 分阶段上下文加载
    """

    def __init__(
        self,
        llm: Optional[LLMClient] = None,
        max_iterations: int = 10,
        case_index: Optional[CaseIndex] = None
    ):
        self.llm = llm or get_llm_client()
        self.max_iterations = max_iterations
        self.case_index = case_index or get_case_index()
        self.state = AgentState.IDLE

        # v10: 新增模块
        self.context_manager: ContextManager = get_context_manager()
        self.session_manager: SessionManager = get_session_manager()
        self.prompt_builder: PromptBuilder = get_prompt_builder()
        self.tool_executor: ToolExecutor = get_tool_executor()

        # 运行时状态 (V9: 支持多 Skill 激活)
        self._active_skills: List[str] = []  # V9: 多 Skill 列表
        self._active_skill: Optional[str] = None  # V9: 主 Skill（向后兼容）
        self._active_scenario: Optional[str] = None
        self._current_message: str = ""
        self._context: Optional[AgentContext] = None
        self._messages: Optional[List[LLMMessage]] = None
        self._session_context: Optional[SessionContext] = None
        self._perf_log: Dict[str, Any] = {}

    @property
    def usage(self) -> Dict[str, int]:
        """获取 LLM 使用统计"""
        return self.llm.usage

    async def run(
        self,
        message: str,
        context: AgentContext
    ) -> AsyncGenerator[AgentEvent, None]:
        """执行 Agent 循环 - v10: Context Engineering 增强"""
        self.state = AgentState.IDLE
        self._current_message = message
        self._context = context
        self._perf_log = {
            "iterations": 0,
            "llm_calls": [],
            "phase": "phase1" if not context.skill else "phase2"
        }

        # ═══════════════════════════════════════════════════════════════
        # v10 Phase 0: 会话恢复检查
        # ═══════════════════════════════════════════════════════════════
        active_session = await self.session_manager.get_active_session(context.user_id)

        if active_session and active_session.is_active:
            # 检查是否应该恢复
            if self.session_manager.should_resume(message, active_session):
                # 恢复会话
                yield AgentEvent(type="session_resume", data={
                    "skill": active_session.skill_id,
                    "rule": active_session.rule_id,
                    "step": active_session.checkpoint_step,
                    "total": active_session.checkpoint_total
                })

                # 自动激活 skill
                self._active_skill = active_session.skill_id
                self._active_scenario = active_session.rule_id

                # 加载会话上下文
                self._session_context = await self.context_manager.load_session_context(
                    context.user_id,
                    active_session.skill_id,
                    active_session.rule_id
                )
                context.session_context = self._session_context

                # 动态加载 profile
                await self._reload_profile_for_skill(active_session.skill_id)

                logger.info(f"[CoreAgent] Session resumed: skill={active_session.skill_id}, step={active_session.checkpoint_step}")

            elif self.session_manager.should_ask_resume(message, active_session):
                # 提示用户是否继续
                resume_prompt = self.session_manager.build_resume_prompt(active_session)
                yield AgentEvent(type="session_prompt", data={
                    "prompt": resume_prompt,
                    "session": active_session.to_dict()
                })

        # ═══════════════════════════════════════════════════════════════
        # Phase 1/2: 正常执行流程
        # ═══════════════════════════════════════════════════════════════

        # 使用前端指定的 skill/scenario，或从会话恢复
        if context.skill:
            self._active_skill = context.skill
            self._active_scenario = context.scenario
        elif not self._active_skill:
            self._active_skill = None
            self._active_scenario = None

        # 如果有 active skill 且没有加载 session context，现在加载
        if self._active_skill and not self._session_context:
            self._session_context = await self.context_manager.load_session_context(
                context.user_id,
                self._active_skill,
                self._active_scenario
            )
            context.session_context = self._session_context

        # 发送 SOP 阶段事件
        if self._active_skill:
            sop_status = self._compute_sop_status(context)
            yield AgentEvent(type="sop_phase", data={
                "skill": self._active_skill,
                "scenario": self._active_scenario,
                "status": sop_status,
                "has_checkpoint": self._session_context.has_checkpoint if self._session_context else False,
                "message": "LLM 驱动模式"
            })

        # 构建初始消息
        t_prompt_start = time.time()
        messages = await self._build_initial_messages(message, context)
        self._messages = messages
        self._perf_log["prompt_build_ms"] = int((time.time() - t_prompt_start) * 1000)
        self._perf_log["system_prompt_len"] = len(messages[0].content) if messages else 0
        logger.info(f"[PERF Agent] Prompt built: {self._perf_log['prompt_build_ms']}ms, len={self._perf_log['system_prompt_len']}")

        # 主循环
        for iteration in range(self.max_iterations):
            self.state = AgentState.THINKING
            yield AgentEvent(type="thinking", data={"iteration": iteration})
            self._perf_log["iterations"] = iteration + 1

            tools = self._get_current_tools(context)

            try:
                content_buffer = ""
                tool_calls = []

                t_llm_start = time.time()
                first_token_time = None

                async for chunk in self.llm.stream(
                    messages=messages,
                    tools=tools,
                    tool_choice=None,
                    user_tier=context.user_tier
                ):
                    if first_token_time is None:
                        first_token_time = time.time()
                        ttft = int((first_token_time - t_llm_start) * 1000)
                        logger.info(f"[PERF Agent] LLM #{iteration+1} TTFT: {ttft}ms")

                    if chunk["type"] == "content":
                        content_buffer += chunk["content"]
                        yield AgentEvent(type="content", data={"content": chunk["content"]})
                    elif chunk["type"] == "tool_call":
                        tool_calls.append(chunk)

                llm_total = int((time.time() - t_llm_start) * 1000)
                self._perf_log["llm_calls"].append({
                    "iteration": iteration + 1,
                    "ttft_ms": int((first_token_time - t_llm_start) * 1000) if first_token_time else 0,
                    "total_ms": llm_total,
                    "has_tools": len(tool_calls) > 0
                })

                if tool_calls:
                    self.state = AgentState.TOOL_CALLING

                    assistant_tool_calls = []
                    for tc in tool_calls:
                        assistant_tool_calls.append({
                            "id": tc["tool_call_id"],
                            "function": {
                                "name": tc["tool_name"],
                                "arguments": tc["tool_args"]
                            }
                        })
                    messages.append(LLMMessage(
                        role="assistant",
                        content=content_buffer or "",
                        tool_calls=assistant_tool_calls
                    ))
                    content_buffer = ""

                    # 执行工具
                    t_tools_start = time.time()
                    tool_results = []
                    for tc in tool_calls:
                        tool_name = tc["tool_name"]
                        tool_args = tc["tool_args"]
                        tool_call_id = tc["tool_call_id"]

                        yield AgentEvent(type="tool_call", data={
                            "id": tool_call_id,
                            "name": tool_name,
                            "arguments": tool_args
                        })

                        t_tool_start = time.time()

                        # 创建工具上下文
                        tool_context = ToolContext(
                            user_id=context.user_id,
                            user_tier=context.user_tier,
                            profile=context.profile or {},
                            skill_data=context.skill_data or {},
                            skill_id=self._active_skill,
                            scenario_id=self._active_scenario,
                            conversation_id=context.conversation_id
                        )

                        # v10: 使用 ToolExecutor
                        result = await self.tool_executor.execute(
                            tool_name=tool_name,
                            tool_args=tool_args,
                            context=tool_context,
                            current_message=self._current_message,
                            reload_callback=lambda: self._handle_skill_activation(context)
                        )

                        # 处理需要重载上下文的工具
                        if result.should_reload_context:
                            # v10.3: 从工具结果中提取激活的 skill/rule
                            if isinstance(result.data, dict):
                                activated_skill = result.data.get("skill")
                                activated_rule = result.data.get("rule")
                                if activated_skill:
                                    self._active_skill = activated_skill
                                    self._active_scenario = activated_rule
                                    logger.info(f"[CoreAgent] Skill activated: {activated_skill}, rule: {activated_rule}")

                            # 重新构建 System Prompt
                            new_system_prompt = await self._build_system_prompt(
                                self._current_message, context
                            )
                            self._messages[0] = LLMMessage(role="system", content=new_system_prompt)
                            messages[0] = self._messages[0]
                            self._perf_log["phase"] = "phase2"
                            self._perf_log["system_prompt_len"] = len(new_system_prompt)
                            logger.info(f"[CoreAgent] Phase 2 prompt rebuilt, len={len(new_system_prompt)}")

                        tool_exec_ms = int((time.time() - t_tool_start) * 1000)
                        logger.info(f"[PERF Agent] Tool {tool_name}: {tool_exec_ms}ms")

                        tool_results.append({
                            "tool_call_id": tool_call_id,
                            "result": result.data
                        })

                        yield AgentEvent(type="tool_result", data={
                            "id": tool_call_id,
                            "name": tool_name,
                            "result": result.data
                        })

                    tools_total = int((time.time() - t_tools_start) * 1000)
                    logger.info(f"[PERF Agent] All tools: {tools_total}ms")

                    for tr in tool_results:
                        result_content = tr["result"]
                        if isinstance(result_content, dict):
                            result_content = json.dumps(result_content, ensure_ascii=False)
                        messages.append(LLMMessage(
                            role="tool",
                            content=str(result_content),
                            tool_call_id=tr["tool_call_id"]
                        ))
                else:
                    self.state = AgentState.COMPLETED
                    logger.info(f"[PERF Agent] Done: {self._perf_log}")
                    yield AgentEvent(type="done", data={"content": content_buffer})
                    return

            except Exception as e:
                self.state = AgentState.ERROR
                logger.error(f"Agent error: {e}")
                yield AgentEvent(type="error", data={"error": str(e)})
                return

        self.state = AgentState.COMPLETED
        yield AgentEvent(type="done", data={"max_iterations_reached": True})

    async def _handle_skill_activation(self, context: AgentContext) -> None:
        """处理 skill 激活后的上下文重载"""
        if self._context and self._context.user_id != "guest":
            try:
                from stores.profile_cache import get_cached_profile_with_skill
                from uuid import UUID

                user_id = UUID(self._context.user_id)
                skill = self._active_skill

                result = await get_cached_profile_with_skill(user_id, skill)
                self._context.profile = result.get("profile", {})
                self._context.skill_data = result.get("skill_data", {})
                context.profile = self._context.profile
                context.skill_data = self._context.skill_data

                # 加载 session context
                if skill:
                    self._session_context = await self.context_manager.load_session_context(
                        self._context.user_id, skill, self._active_scenario
                    )
                    context.session_context = self._session_context

                logger.info(f"[CoreAgent] Profile reloaded for skill={skill}")
            except Exception as e:
                logger.warning(f"[CoreAgent] Failed to reload profile: {e}")

    async def _reload_profile_for_skill(self, skill_id: str) -> None:
        """为指定 skill 重载 profile"""
        if not self._context or self._context.user_id == "guest":
            return

        try:
            from stores.profile_cache import get_cached_profile_with_skill
            from uuid import UUID

            user_id = UUID(self._context.user_id)
            result = await get_cached_profile_with_skill(user_id, skill_id)
            self._context.profile = result.get("profile", {})
            self._context.skill_data = result.get("skill_data", {})

            logger.info(f"[CoreAgent] Profile loaded for skill={skill_id}")
        except Exception as e:
            logger.warning(f"[CoreAgent] Failed to load profile: {e}")

    def _filter_valid_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """过滤历史消息，确保 tool 消息配对完整"""
        if not history:
            return []

        valid_tool_ids = set()
        for msg in history:
            if msg.get("role") == "assistant" and msg.get("tool_calls"):
                for tc in msg["tool_calls"]:
                    tc_id = tc.get("id")
                    if tc_id:
                        valid_tool_ids.add(tc_id)

        filtered = []
        for msg in history:
            role = msg.get("role", "user")
            if role == "tool":
                tool_call_id = msg.get("tool_call_id")
                if tool_call_id and tool_call_id in valid_tool_ids:
                    filtered.append(msg)
                else:
                    logger.warning(f"Skipping orphan tool message: {tool_call_id}")
            else:
                filtered.append(msg)

        return filtered

    async def _build_initial_messages(
        self,
        message: str,
        context: AgentContext
    ) -> List[LLMMessage]:
        """构建初始消息列表"""
        system_prompt = await self._build_system_prompt(message, context)

        messages = [LLMMessage(role="system", content=system_prompt)]

        if context.history:
            filtered_history = self._filter_valid_history(context.history[-10:])
            for msg in filtered_history:
                messages.append(LLMMessage(
                    role=msg.get("role", "user"),
                    content=msg.get("content", ""),
                    tool_call_id=msg.get("tool_call_id"),
                    tool_calls=msg.get("tool_calls")
                ))

        messages.append(LLMMessage(role="user", content=message))
        return messages

    async def _build_system_prompt(self, message: str, context: AgentContext) -> str:
        """构建 System Prompt - v10: 使用 PromptBuilder"""
        return await self.prompt_builder.build(
            skill_id=self._active_skill,
            rule_id=self._active_scenario,
            message=message,
            profile=context.profile,
            skill_data=context.skill_data,
            session_context=self._session_context,
            protocol_prompt=context.protocol_prompt
        )

    def _compute_sop_status(self, context: AgentContext) -> Dict[str, Any]:
        """计算 SOP 状态"""
        skill_id = self._active_skill

        needs_birth = skill_requires_birth_info(skill_id) if skill_id else False
        identity = context.profile.get("identity", {}) if context.profile else {}
        birth_info = identity.get("birth_info", {})
        has_birth = bool(birth_info.get("birth_date") or birth_info.get("date"))

        needs_compute = skill_requires_compute(skill_id) if skill_id else False
        compute_type = get_skill_compute_type(skill_id) if skill_id else None
        actual_compute_type = compute_type or skill_id

        has_chart = False
        if context.skill_data and actual_compute_type:
            skill_data = context.skill_data.get(actual_compute_type, {})
            has_chart = bool(skill_data.get("chart") or skill_data.get("cards"))

        # v10: 添加 checkpoint 信息
        checkpoint_info = {}
        if self._session_context and self._session_context.checkpoint:
            cp = self._session_context.checkpoint
            checkpoint_info = {
                "step": cp.step,
                "total_steps": cp.total_steps,
                "has_data": bool(cp.collected_data)
            }

        return {
            "skill_id": skill_id,
            "needs_birth_info": needs_birth,
            "has_birth_info": has_birth,
            "needs_compute": needs_compute,
            "has_chart_data": has_chart,
            "compute_type": actual_compute_type,
            "ready_for_analysis": (not needs_birth or has_birth) and (not needs_compute or has_chart),
            "checkpoint": checkpoint_info
        }

    def _get_current_tools(self, context: AgentContext) -> List[Dict[str, Any]]:
        """获取当前可用工具"""
        if not context.skill and not self._active_skill:
            return get_phase1_tools()

        skill_id = self._active_skill or context.skill
        tools = ToolRegistry.get_tools_for_skill(skill_id)
        if not tools:
            return get_phase1_tools()

        # Phase 2: 添加 activate_skill 工具，支持动态切换 skill
        phase1_tools = get_phase1_tools()
        activate_skill_tool = next(
            (t for t in phase1_tools if t.get("function", {}).get("name") == "activate_skill"),
            None
        )
        if activate_skill_tool and activate_skill_tool not in tools:
            tools = tools + [activate_skill_tool]

        return tools


def create_agent(
    llm: Optional[LLMClient] = None,
    max_iterations: int = 10
) -> CoreAgent:
    """创建 CoreAgent 实例"""
    return CoreAgent(llm=llm, max_iterations=max_iterations)
