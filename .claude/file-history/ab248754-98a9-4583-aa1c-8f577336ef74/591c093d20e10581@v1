"""
Validators v2.0 - 数据验证与跨技能契约校验

v2.0 更新：
- 新增 Provider/Consumer 契约校验
- imports ⊆ exports 验证
- 版本兼容性检查
- 循环依赖检测
"""
import re
import logging
from typing import Dict, Any, Tuple, List, Optional, Set
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


# LLM-FIRST: 路径白名单（统一 save/read）
SAVE_PATH_WHITELIST = [
    r"^identity\.birth_info$",
    r"^state\.[A-Za-z0-9_\.]+$",
    r"^preferences\.[A-Za-z0-9_\.]+$",
    r"^skills\.[A-Za-z0-9_]+(\.[A-Za-z0-9_\.]+)*$",
    r"^goals(\.[A-Za-z0-9_\.]+)*$",
]


def validate_save_path(path: str) -> bool:
    return any(re.match(p, path) for p in SAVE_PATH_WHITELIST)


def validate_show_args(args: Dict[str, Any]) -> Tuple[bool, str]:
    show_type = args.get("type")
    if show_type not in {"skill_list", "recommendation", "card", "insight"}:
        return False, "show.type 必须是 skill_list|recommendation|card|insight"
    if show_type == "card" and not args.get("card_type"):
        return False, "type=card 时必须提供 card_type"
    if show_type == "recommendation":
        data = args.get("data", {})
        if not isinstance(data, dict) or not data.get("skill_id"):
            return False, "recommendation 需要 data.skill_id"
    return True, ""


def validate_remind_args(args: Dict[str, Any]) -> Tuple[bool, str]:
    action = args.get("action")
    if action not in {"set", "list", "cancel"}:
        return False, "remind.action 必须是 set|list|cancel"
    if action == "set":
        if not args.get("title"):
            return False, "创建提醒需要 title"
        if not args.get("schedule"):
            return False, "创建提醒需要 schedule"
        st = args.get("schedule_type", "daily")
        if st not in {"once", "daily", "weekly"}:
            return False, "schedule_type 必须是 once|daily|weekly"
    if action == "cancel" and not args.get("id"):
        return False, "取消提醒需要 id"
    return True, ""
