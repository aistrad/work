# Mentis: Software Architecture Design
## Complete System Architecture Specification

---

## 1. Executive Overview

### 1.1 System Vision

Mentis is a **Stream-Centric Agentic Personal OS** — an AI-native platform that combines:
- Real-time conversational AI with persistent memory
- Multi-dimensional life-state tracking (Vibe Score)
- Pluggable insight module framework
- Proactive intelligent agent capabilities

### 1.2 Architecture Goals

| Goal | Priority | Description |
|------|----------|-------------|
| **Scalability** | P0 | Support 1M+ concurrent users |
| **Latency** | P0 | <500ms response for chat, <100ms for UI |
| **Privacy** | P0 | End-to-end encryption for sensitive data |
| **Extensibility** | P1 | Pluggable modules without core changes |
| **Reliability** | P1 | 99.9% uptime SLA |
| **Cost Efficiency** | P1 | Optimize LLM costs at scale |

### 1.3 Architecture Principles

1. **Event-Driven Core**: All state changes flow through events
2. **API-First Design**: Every capability exposed via API
3. **Polyglot Persistence**: Right database for each data type
4. **Edge-Ready**: Optimize for global deployment
5. **AI-Native**: LLM operations as first-class citizens

---

## 2. System Architecture

### 2.1 High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              CLIENT LAYER                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  Web App    │  │ Mobile App  │  │  Widgets    │  │  Wearables  │        │
│  │  (Next.js)  │  │  (React     │  │  (iOS/      │  │  (WatchOS/  │        │
│  │             │  │   Native)   │  │   Android)  │  │   WearOS)   │        │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘        │
│         │                │                │                │               │
└─────────┼────────────────┼────────────────┼────────────────┼───────────────┘
          │                │                │                │
          └────────────────┴────────────────┴────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              GATEWAY LAYER                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        API Gateway (Kong/AWS API Gateway)            │   │
│  │  • Rate Limiting  • Authentication  • Request Routing  • SSL/TLS    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌──────────────┐  ┌──────────────┐│┌──────────────┐  ┌──────────────┐     │
│  │  REST API    │  │  GraphQL     │││  WebSocket   │  │  gRPC        │     │
│  │  Endpoints   │  │  Gateway     │││  Gateway     │  │  Internal    │     │
│  └──────────────┘  └──────────────┘│└──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            APPLICATION LAYER                                │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     COMPANION LAYER (AI Persona)                     │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │   │
│  │  │ Persona      │  │ Interaction  │  │ Proactive    │               │   │
│  │  │ Engine       │  │ Engine       │  │ Agent        │               │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   MENTIS INTELLIGENCE ENGINE                         │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │   │
│  │  │ Stream       │  │ Emotion      │  │ Memory       │               │   │
│  │  │ Processor    │  │ Engine       │  │ System       │               │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘               │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │   │
│  │  │ Pattern      │  │ Module       │  │ Vibe Score   │               │   │
│  │  │ Detector     │  │ Orchestrator │  │ Engine       │               │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌───────────────── INSIGHT MODULES (Pluggable) ───────────────────────┐   │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐  │   │
│  │  │  CBT   │ │  ACT   │ │  BaZi  │ │ ZiWei  │ │ Health │ │ Finance│  │   │
│  │  └────────┘ └────────┘ └────────┘ └────────┘ └────────┘ └────────┘  │   │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────────────────────────────┐│   │
│  │  │ Career │ │ Invest │ │ Custom │ │       Module SDK               ││   │
│  │  └────────┘ └────────┘ └────────┘ └────────────────────────────────┘│   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     DOMAIN SERVICES                                  │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │   │
│  │  │ Auth     │ │ Stream   │ │ Digest   │ │ Share    │ │ Media    │   │   │
│  │  │ Service  │ │ Service  │ │ Service  │ │ Service  │ │ Service  │   │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘   │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐               │   │
│  │  │ Entity   │ │ Evolve   │ │ Realtime │ │ Decode   │               │   │
│  │  │ Service  │ │ Service  │ │ Service  │ │ Service  │               │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           DATA & KNOWLEDGE LAYER                            │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  PostgreSQL  │  │   Pinecone   │  │    Redis     │  │   S3/GCS     │    │
│  │  (Primary)   │  │  (Vectors)   │  │   (Cache)    │  │  (Objects)   │    │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                      │
│  │    Neo4j     │  │  TimescaleDB │  │  ClickHouse  │                      │
│  │ (Knowledge   │  │  (Time-      │  │ (Analytics)  │                      │
│  │    Graph)    │  │   series)    │  │              │                      │
│  └──────────────┘  └──────────────┘  └──────────────┘                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          INFRASTRUCTURE LAYER                               │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │   LLM        │  │   Push       │  │   CDN        │  │   Message    │    │
│  │  Providers   │  │  Services    │  │  (Cloud-     │  │   Queue      │    │
│  │(Claude/GPT/  │  │ (FCM/APNs)   │  │   flare)     │  │  (Kafka/     │    │
│  │   Gemini)    │  │              │  │              │  │   RabbitMQ)  │    │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                      │
│  │  Kubernetes  │  │  Terraform   │  │  Monitoring  │                      │
│  │  (Container  │  │  (IaC)       │  │  (Datadog/   │                      │
│  │   Orch.)     │  │              │  │   Grafana)   │                      │
│  └──────────────┘  └──────────────┘  └──────────────┘                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Layer Responsibilities

| Layer | Responsibility | Technologies |
|-------|----------------|--------------|
| **Client** | User interface, local state | Next.js, React Native, Zustand |
| **Gateway** | Auth, rate limiting, routing | Kong, AWS API Gateway |
| **Application** | Business logic, AI orchestration | FastAPI, Python |
| **Data** | Persistence, caching, search | PostgreSQL, Redis, Pinecone |
| **Infrastructure** | Compute, networking, observability | K8s, Terraform, Datadog |

---

## 3. Core Components

### 3.1 Stream Processor

The heart of user interaction processing.

```python
# Conceptual Flow
class StreamProcessor:
    async def process_input(self, user_id: str, input: StreamInput) -> StreamOutput:
        """
        Main processing pipeline for all user inputs
        """
        # 1. Context Assembly
        context = await self.build_context(user_id, input)

        # 2. Emotion Sensing
        emotion = await self.emotion_engine.analyze(input, context)

        # 3. Memory Retrieval
        memories = await self.memory_system.retrieve_relevant(
            user_id, input, limit=10
        )

        # 4. Module Selection & Insight Generation
        active_modules = await self.module_orchestrator.select_modules(
            context, emotion
        )
        insights = await self.gather_insights(active_modules, context)

        # 5. Response Strategy
        strategy = await self.response_strategist.determine(
            emotion, insights, context
        )

        # 6. Response Generation
        response = await self.generate_response(
            input, context, emotion, insights, strategy
        )

        # 7. Post-Processing
        await self.update_vibe_score(user_id, input, response)
        await self.store_to_memory(user_id, input, response)
        await self.check_proactive_triggers(user_id)

        return response
```

#### Data Flow Diagram

```
User Input
    │
    ▼
┌─────────────────┐
│ Input Parsing   │ ← Text/Voice/Image normalization
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Context Builder │ ← User profile + Recent history + Active modules
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Emotion Engine  │ ← Primary/Secondary emotions + Intensity + Needs
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Memory System   │ ← Relevant past conversations + Patterns
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Module Selector │ ← CBT? BaZi? Health? Based on context
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Insight Gather  │ ← Parallel module execution
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Response        │ ← Mirror? Challenge? Suggest? Based on needs
│ Strategist      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ LLM Generation  │ ← Prompt assembly + Generation + Persona styling
└────────┬────────┘
         │
         ▼
Response Output
```

### 3.2 Memory System

Persistent, contextual memory architecture.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           MEMORY SYSTEM                                     │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     SHORT-TERM MEMORY (Redis)                        │   │
│  │  • Current session context                                          │   │
│  │  • Last N messages (sliding window)                                 │   │
│  │  • Active emotional state                                           │   │
│  │  • Pending action cards                                             │   │
│  │  TTL: 24 hours                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     WORKING MEMORY (PostgreSQL + Vector)             │   │
│  │  • Recent conversations (7-30 days)                                 │   │
│  │  • Extracted entities and topics                                    │   │
│  │  • Emotion labels and patterns                                      │   │
│  │  • Vector embeddings for semantic search                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     LONG-TERM MEMORY (Knowledge Graph)               │   │
│  │  • User personality model                                           │   │
│  │  • Relationship map (people mentioned)                              │   │
│  │  • Core beliefs and values                                          │   │
│  │  • Life events timeline                                             │   │
│  │  • Pattern history                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     ARCHIVAL MEMORY (Cold Storage)                   │   │
│  │  • Full conversation history                                        │   │
│  │  • Media files (images, voice)                                      │   │
│  │  • Compressed older data                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Memory Retrieval Strategy

```python
class MemoryRetriever:
    async def retrieve(
        self,
        user_id: str,
        query: str,
        limit: int = 10
    ) -> List[Memory]:
        """
        Multi-strategy memory retrieval
        """
        results = []

        # 1. Recency - most recent messages
        recent = await self.get_recent(user_id, limit=5)

        # 2. Semantic similarity - vector search
        similar = await self.vector_search(
            user_id, query, limit=5
        )

        # 3. Entity-based - mentioned people/topics
        entities = extract_entities(query)
        related = await self.graph_query(user_id, entities)

        # 4. Pattern-based - similar emotional contexts
        emotion = await self.emotion_engine.quick_classify(query)
        emotional = await self.find_similar_emotions(
            user_id, emotion, limit=3
        )

        # Merge and rank
        return self.merge_and_rank(recent, similar, related, emotional)
```

### 3.3 Emotion Engine

LLM-powered emotion analysis with caching.

```python
class EmotionEngine:
    """
    Analyzes emotional content of user input
    """

    async def analyze(
        self,
        input: StreamInput,
        context: ConversationContext
    ) -> EmotionAnalysis:
        # Check cache for similar inputs
        cache_key = self.compute_cache_key(input.text)
        if cached := await self.cache.get(cache_key):
            return cached

        # LLM-based analysis
        prompt = self.build_emotion_prompt(input, context)
        result = await self.llm.complete(prompt)

        analysis = EmotionAnalysis(
            primary_emotion=result.primary,      # e.g., "frustrated"
            secondary_emotions=result.secondary,  # e.g., ["hurt", "angry"]
            intensity=result.intensity,          # 0.0 - 1.0
            valence=result.valence,              # -1.0 to 1.0
            arousal=result.arousal,              # 0.0 to 1.0
            user_needs=result.needs,             # e.g., ["validation", "advice"]
        )

        # Cache for 1 hour
        await self.cache.set(cache_key, analysis, ttl=3600)

        return analysis

    def build_emotion_prompt(self, input, context):
        return f"""
        Analyze the emotional content of this message.

        User profile: {context.user_profile}
        Recent conversation: {context.recent_messages[-5:]}
        Current message: {input.text}

        Respond with:
        - primary_emotion: The dominant emotion
        - secondary_emotions: Up to 3 secondary emotions
        - intensity: How strong (0.0-1.0)
        - valence: Positive or negative (-1.0 to 1.0)
        - arousal: Energy level (0.0 to 1.0)
        - user_needs: What the user likely needs right now
        """
```

### 3.4 Module Orchestrator

Manages pluggable insight modules.

```python
class ModuleOrchestrator:
    """
    Coordinates insight modules based on context
    """

    def __init__(self):
        self.registry: Dict[str, InsightModule] = {}
        self.load_core_modules()

    async def select_modules(
        self,
        context: ConversationContext,
        emotion: EmotionAnalysis
    ) -> List[InsightModule]:
        """
        Determine which modules should be active for this interaction
        """
        active = []

        for module in self.registry.values():
            # Check if module is enabled for user
            if not self.is_enabled(context.user_id, module.id):
                continue

            # Check module activation conditions
            activation = await module.should_activate(context, emotion)

            if activation.activate and activation.confidence > 0.5:
                active.append({
                    "module": module,
                    "confidence": activation.confidence,
                    "reason": activation.reason
                })

        # Sort by confidence, limit to top 3
        active.sort(key=lambda x: x["confidence"], reverse=True)
        return [a["module"] for a in active[:3]]

    async def gather_insights(
        self,
        modules: List[InsightModule],
        context: ConversationContext
    ) -> List[Insight]:
        """
        Parallel insight generation from active modules
        """
        tasks = [
            module.generate_insight(context)
            for module in modules
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        return [
            r for r in results
            if isinstance(r, Insight) and r.confidence > 0.6
        ]
```

### 3.5 Insight Module Interface

Standard interface for all modules.

```python
from abc import ABC, abstractmethod
from typing import Optional

class InsightModule(ABC):
    """
    Base interface for all insight modules
    """

    @property
    @abstractmethod
    def metadata(self) -> ModuleMetadata:
        """
        Return module metadata
        """
        pass

    @abstractmethod
    async def initialize_profile(
        self,
        user_data: UserData
    ) -> ModuleProfile:
        """
        Initialize user-specific module profile
        """
        pass

    @abstractmethod
    async def should_activate(
        self,
        context: ConversationContext,
        emotion: EmotionAnalysis
    ) -> ActivationDecision:
        """
        Determine if module should be active for this context
        """
        pass

    @abstractmethod
    async def generate_insight(
        self,
        context: ConversationContext
    ) -> Optional[Insight]:
        """
        Generate insight based on current context
        """
        pass

    @abstractmethod
    async def generate_proactive_push(
        self,
        user_state: UserState
    ) -> Optional[ProactivePush]:
        """
        Generate proactive push content if appropriate
        """
        pass


# Example: BaZi Module Implementation
class BaZiModule(InsightModule):

    @property
    def metadata(self) -> ModuleMetadata:
        return ModuleMetadata(
            id="bazi",
            name="Eastern Personality Framework",
            description="八字性格分析与时机洞察",
            category="eastern_wisdom",
            required_inputs=["birth_datetime"],
        )

    async def should_activate(
        self,
        context: ConversationContext,
        emotion: EmotionAnalysis
    ) -> ActivationDecision:
        # Activate on life direction, timing, personality topics
        topic_keywords = ["方向", "选择", "时机", "适合", "为什么"]
        text = context.current_input.text

        is_relevant = any(kw in text for kw in topic_keywords)
        user_receptive = context.user_profile.module_preferences.get(
            "bazi_receptivity", 0.5
        ) > 0.4

        return ActivationDecision(
            activate=is_relevant and user_receptive,
            confidence=0.75 if is_relevant else 0.0,
            reason="Topic relates to life direction and timing"
        )
```

### 3.6 Vibe Score Engine

Multi-dimensional wellness tracking.

```python
class VibeScoreEngine:
    """
    Calculates and tracks multi-dimensional Vibe Score
    """

    DIMENSIONS = ["emotional", "productive", "physical", "social", "growth"]

    async def calculate(
        self,
        user_id: str,
        time_window: timedelta = timedelta(hours=24)
    ) -> VibeScore:
        """
        Calculate current Vibe Score across all dimensions
        """
        scores = {}

        for dim in self.DIMENSIONS:
            scores[dim] = await self.calculate_dimension(
                user_id, dim, time_window
            )

        # Weighted aggregate based on user's life stage
        weights = await self.get_user_weights(user_id)
        total = sum(
            scores[d] * weights.get(d, 1.0)
            for d in self.DIMENSIONS
        ) / sum(weights.values())

        return VibeScore(
            total=round(total),
            dimensions=scores,
            label=self.get_label(total),
            trend=await self.calculate_trend(user_id)
        )

    async def calculate_dimension(
        self,
        user_id: str,
        dimension: str,
        time_window: timedelta
    ) -> int:
        """
        Calculate score for a single dimension
        """
        # Get relevant data points
        entries = await self.get_entries(user_id, dimension, time_window)

        if not entries:
            return 50  # Default baseline

        # Aggregate based on dimension type
        if dimension == "emotional":
            return self.aggregate_emotional(entries)
        elif dimension == "productive":
            return self.aggregate_productive(entries)
        # ... etc

    def get_label(self, score: int) -> str:
        """
        Human-readable label for score
        """
        labels = [
            (90, "Thriving"),
            (75, "Energized"),
            (60, "Steady"),
            (45, "Navigating"),
            (30, "Struggling"),
            (0, "In the depths"),
        ]
        for threshold, label in labels:
            if score >= threshold:
                return label
        return "Unknown"
```

### 3.7 Proactive Agent

Autonomous agent for proactive engagement.

```python
class ProactiveAgent:
    """
    Manages proactive push scheduling and generation
    """

    PUSH_TYPES = [
        "morning_checkin",
        "evening_reflection",
        "pattern_insight",
        "caring_intervention",
        "interest_content",
        "event_reminder",
    ]

    async def run_scheduler(self):
        """
        Main scheduler loop - runs continuously
        """
        while True:
            users = await self.get_eligible_users()

            for user in users:
                push = await self.determine_push(user)
                if push:
                    await self.send_push(user.id, push)

            await asyncio.sleep(60)  # Check every minute

    async def determine_push(
        self,
        user: User
    ) -> Optional[ProactivePush]:
        """
        Determine if and what to push to user
        """
        # Check daily limits
        today_count = await self.get_push_count_today(user.id)
        if today_count >= user.settings.max_daily_pushes:
            return None

        # Check quiet hours
        if self.in_quiet_hours(user):
            return None

        # Priority order of push types
        for push_type in self.PUSH_TYPES:
            if await self.should_push(user, push_type):
                return await self.generate_push(user, push_type)

        return None

    async def should_push_caring_intervention(
        self,
        user: User
    ) -> bool:
        """
        Check if user needs caring intervention
        """
        # Check for concerning patterns
        recent_vibe = await self.vibe_engine.get_recent(
            user.id, days=3
        )

        # Consecutive low emotional scores
        if all(v.emotional < 40 for v in recent_vibe[-3:]):
            return True

        # Sudden silence after high activity
        last_message = await self.get_last_message_time(user.id)
        usual_frequency = user.stats.avg_messages_per_day

        if (
            usual_frequency > 3 and
            last_message < datetime.now() - timedelta(days=2)
        ):
            return True

        return False
```

---

## 4. Data Architecture

### 4.1 Database Selection Rationale

| Data Type | Database | Rationale |
|-----------|----------|-----------|
| User profiles, settings | PostgreSQL | ACID, relational integrity |
| Stream entries | PostgreSQL + Vector | Structured + semantic search |
| Embeddings | Pinecone | Optimized vector operations |
| User knowledge graph | Neo4j | Relationship traversal |
| Session cache | Redis | Sub-ms latency |
| Time-series (Vibe) | TimescaleDB | Efficient time queries |
| Analytics | ClickHouse | OLAP workloads |
| Media files | S3/GCS | Cost-effective object storage |

### 4.2 Core Schema (PostgreSQL)

```sql
-- Users and Authentication
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT UNIQUE NOT NULL,
    phone TEXT UNIQUE,
    name TEXT,
    avatar_url TEXT,
    birth_datetime TIMESTAMPTZ,
    birth_location TEXT,
    timezone TEXT DEFAULT 'UTC',
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Stream Entries (core content)
CREATE TABLE stream_entries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    type TEXT NOT NULL CHECK (type IN (
        'user_message', 'ai_response', 'proactive_push',
        'pattern_insight', 'action_card', 'for_you'
    )),
    content TEXT NOT NULL,
    content_embedding VECTOR(1536),  -- for semantic search
    emotion_data JSONB,
    metadata JSONB DEFAULT '{}',
    parent_id UUID REFERENCES stream_entries(id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Vibe Scores (time-series)
CREATE TABLE vibe_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    total_score INTEGER CHECK (total_score BETWEEN 0 AND 100),
    emotional INTEGER CHECK (emotional BETWEEN 0 AND 100),
    productive INTEGER CHECK (productive BETWEEN 0 AND 100),
    physical INTEGER CHECK (physical BETWEEN 0 AND 100),
    social INTEGER CHECK (social BETWEEN 0 AND 100),
    growth INTEGER CHECK (growth BETWEEN 0 AND 100),
    label TEXT
);

-- Module Profiles (per-user module data)
CREATE TABLE module_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    module_id TEXT NOT NULL,
    enabled BOOLEAN DEFAULT true,
    profile_data JSONB DEFAULT '{}',
    last_insight_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, module_id)
);

-- Proactive Push Log
CREATE TABLE proactive_pushes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    push_type TEXT NOT NULL,
    content TEXT NOT NULL,
    delivered_at TIMESTAMPTZ DEFAULT NOW(),
    read_at TIMESTAMPTZ,
    response TEXT,
    response_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_stream_user_time ON stream_entries(user_id, created_at DESC);
CREATE INDEX idx_stream_embedding ON stream_entries USING ivfflat (content_embedding vector_cosine_ops);
CREATE INDEX idx_vibe_user_time ON vibe_scores(user_id, timestamp DESC);
```

### 4.3 Knowledge Graph Schema (Neo4j)

```cypher
// User node
(:User {
    id: string,
    name: string
})

// People mentioned by user
(:Person {
    id: string,
    name: string,
    relationship: string,  // "friend", "family", "colleague"
    first_mention: datetime,
    mention_count: int
})

// Topics/Interests
(:Topic {
    id: string,
    name: string,
    category: string
})

// Life Events
(:LifeEvent {
    id: string,
    type: string,
    description: string,
    date: date,
    emotional_impact: float
})

// Patterns discovered
(:Pattern {
    id: string,
    type: string,
    description: string,
    confidence: float,
    first_detected: datetime
})

// Relationships
(u:User)-[:KNOWS]->(p:Person)
(u:User)-[:INTERESTED_IN]->(t:Topic)
(u:User)-[:EXPERIENCED]->(e:LifeEvent)
(u:User)-[:HAS_PATTERN]->(pat:Pattern)
(p:Person)-[:MENTIONED_WITH]->(t:Topic)
(e:LifeEvent)-[:RELATED_TO]->(p:Person)
```

### 4.4 Vector Index Design (Pinecone)

```python
# Index configuration
index_config = {
    "name": "mentis-memory",
    "dimension": 1536,  # OpenAI/Anthropic embedding size
    "metric": "cosine",
    "pods": 1,
    "pod_type": "p1.x1",  # Performance tier
}

# Vector structure
vector = {
    "id": f"{user_id}:{entry_id}",
    "values": embedding,
    "metadata": {
        "user_id": user_id,
        "entry_type": "user_message",
        "emotion": "frustrated",
        "topics": ["work", "boss"],
        "timestamp": "2026-01-04T10:00:00Z",
    }
}

# Query with metadata filtering
results = index.query(
    vector=query_embedding,
    filter={
        "user_id": {"$eq": user_id},
        "timestamp": {"$gte": "2025-12-01T00:00:00Z"}
    },
    top_k=10,
    include_metadata=True
)
```

---

## 5. API Design

### 5.1 REST API Endpoints

```yaml
# Authentication
POST /api/auth/register
POST /api/auth/login
POST /api/auth/refresh
POST /api/auth/logout

# Stream
GET  /api/stream                    # Get stream entries
POST /api/stream/input              # Send user input
POST /api/stream/input/voice        # Voice input (multipart)
POST /api/stream/input/image        # Image input (multipart)

# Vibe Score
GET  /api/vibe/current              # Current Vibe Score
GET  /api/vibe/history              # Historical scores
GET  /api/vibe/dimension/{dim}      # Single dimension detail

# Modules
GET  /api/modules                   # List available modules
GET  /api/modules/{id}              # Module details
POST /api/modules/{id}/enable       # Enable module
POST /api/modules/{id}/disable      # Disable module
GET  /api/modules/{id}/profile      # Get module profile

# Goals & Tasks
GET  /api/goals                     # List goals
POST /api/goals                     # Create goal
PUT  /api/goals/{id}                # Update goal
GET  /api/tasks                     # List tasks
POST /api/tasks/{id}/complete       # Complete task

# Weekly Mirror
GET  /api/mirror/weekly             # Current week mirror
GET  /api/mirror/weekly/{week}      # Specific week
GET  /api/mirror/weekly/share       # Shareable image

# User Profile
GET  /api/me                        # Current user profile
PUT  /api/me                        # Update profile
PUT  /api/me/settings               # Update settings
DELETE /api/me                      # Delete account
```

### 5.2 WebSocket Protocol

```typescript
// Connection
ws://api.mentis.app/realtime?token={jwt}

// Message Types
interface RealtimeMessage {
  type: 'stream_entry' | 'vibe_update' | 'typing' | 'error';
  payload: any;
  timestamp: string;
}

// Client -> Server
interface ClientMessage {
  type: 'subscribe' | 'unsubscribe' | 'ping';
  channel?: string;
}

// Server -> Client (Stream Entry)
{
  "type": "stream_entry",
  "payload": {
    "id": "uuid",
    "type": "ai_response",
    "content": "紧张说明你在乎...",
    "emotion_data": { ... }
  },
  "timestamp": "2026-01-04T10:00:00Z"
}

// Server -> Client (Vibe Update)
{
  "type": "vibe_update",
  "payload": {
    "total": 67,
    "emotional": 72,
    "label": "Steady but tired"
  },
  "timestamp": "2026-01-04T10:00:00Z"
}
```

### 5.3 Response Format

```json
{
  "success": true,
  "data": { ... },
  "meta": {
    "request_id": "uuid",
    "timestamp": "2026-01-04T10:00:00Z",
    "took_ms": 234
  }
}

// Error Response
{
  "success": false,
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many requests",
    "details": {
      "retry_after": 60
    }
  },
  "meta": { ... }
}
```

---

## 6. LLM Integration

### 6.1 Provider Strategy

```python
class LLMRouter:
    """
    Routes requests to appropriate LLM provider based on task
    """

    PROVIDERS = {
        "claude": ClaudeProvider(),
        "openai": OpenAIProvider(),
        "gemini": GeminiProvider(),
        "glm": GLMProvider(),  # Chinese market
    }

    TASK_ROUTING = {
        "emotion_analysis": ["claude", "openai"],
        "response_generation": ["claude"],
        "pattern_detection": ["claude", "gemini"],
        "embedding": ["openai"],
        "vision": ["claude", "gemini"],
        "chinese_content": ["glm", "claude"],
    }

    async def complete(
        self,
        task: str,
        prompt: str,
        **kwargs
    ) -> LLMResponse:
        providers = self.TASK_ROUTING.get(task, ["claude"])

        for provider_name in providers:
            provider = self.PROVIDERS[provider_name]
            try:
                return await provider.complete(prompt, **kwargs)
            except RateLimitError:
                continue
            except ProviderError:
                continue

        raise AllProvidersFailedError()
```

### 6.2 Cost Optimization

| Strategy | Implementation | Savings |
|----------|----------------|---------|
| **Caching** | Redis cache for similar queries | 30-40% |
| **Tiering** | Haiku for simple, Opus for complex | 50% |
| **Batching** | Group similar requests | 20% |
| **Prompt Compression** | Remove redundant context | 15% |
| **Local Models** | Edge processing for simple tasks | Variable |

### 6.3 Prompt Engineering

```python
class PromptBuilder:
    """
    Constructs prompts with consistent structure
    """

    def build_response_prompt(
        self,
        input: StreamInput,
        context: ConversationContext,
        emotion: EmotionAnalysis,
        insights: List[Insight],
        strategy: ResponseStrategy
    ) -> str:
        return f"""
        <system>
        You are Vibe, a warm and insightful AI companion for {context.user.name}.

        Persona traits:
        - Warmth: {context.persona.warmth}/10
        - Directness: {context.persona.directness}/10
        - Humor: {context.persona.humor}/10

        Communication style: {context.user.preferred_style}
        Current emotional state: {emotion.primary_emotion} (intensity: {emotion.intensity})
        User needs: {', '.join(emotion.user_needs)}
        </system>

        <context>
        User profile: {context.user_profile_summary}
        Recent conversation:
        {self.format_recent_messages(context.recent_messages)}

        Relevant memories:
        {self.format_memories(context.memories)}

        Active insights:
        {self.format_insights(insights)}
        </context>

        <strategy>
        Response approach: {strategy.approach}
        Response length: {strategy.length}
        Include: {strategy.include}
        Avoid: {strategy.avoid}
        </strategy>

        <user_message>
        {input.text}
        </user_message>

        Respond as Vibe. Be authentic, not performative.
        """
```

---

## 7. Security & Privacy

### 7.1 Data Protection

| Data Type | Protection | Access |
|-----------|------------|--------|
| Auth credentials | Argon2 hashing | Auth service only |
| Personal data | AES-256 encryption at rest | User + admin |
| Conversations | E2E encryption option | User only |
| Embeddings | Pseudonymized | AI services |
| Analytics | Aggregated, anonymized | Analytics team |

### 7.2 Authentication Flow

```
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│  Client  │────▶│  Auth    │────▶│  User    │────▶│  Token   │
│          │     │  Gateway │     │  Service │     │  Service │
└──────────┘     └──────────┘     └──────────┘     └──────────┘
      │                                                   │
      │              JWT (Access + Refresh)               │
      │◀──────────────────────────────────────────────────│
      │
      │         Protected API Request
      ▼         Authorization: Bearer {jwt}
┌──────────┐     ┌──────────┐
│  Client  │────▶│  API     │ ─── JWT Validation ───▶ Allow/Deny
│          │     │  Gateway │
└──────────┘     └──────────┘
```

### 7.3 Privacy Controls

```python
class PrivacyManager:
    """
    User-controlled privacy settings
    """

    async def export_data(self, user_id: str) -> DataExport:
        """
        GDPR-compliant data export
        """
        return DataExport(
            profile=await self.get_profile(user_id),
            conversations=await self.get_conversations(user_id),
            vibe_history=await self.get_vibe_history(user_id),
            module_data=await self.get_module_data(user_id),
        )

    async def delete_account(self, user_id: str):
        """
        Complete account deletion
        """
        # 1. Delete from all databases
        await self.postgres.delete_user(user_id)
        await self.neo4j.delete_user_graph(user_id)
        await self.pinecone.delete_vectors(user_id)
        await self.redis.delete_user_cache(user_id)
        await self.s3.delete_user_media(user_id)

        # 2. Invalidate all sessions
        await self.auth.revoke_all_tokens(user_id)

        # 3. Audit log
        await self.audit.log("account_deleted", user_id)
```

---

## 8. Scalability & Performance

### 8.1 Scaling Strategy

| Component | Scaling Approach | Target |
|-----------|------------------|--------|
| Web servers | Horizontal (K8s HPA) | 10K req/s per pod |
| WebSocket | Sticky sessions + Redis pub/sub | 50K connections/pod |
| PostgreSQL | Read replicas + Citus | 100K QPS |
| Redis | Cluster mode | 1M ops/s |
| Pinecone | Managed scaling | Auto |
| LLM calls | Queue + rate limiting | Provider limits |

### 8.2 Caching Strategy

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           CACHING LAYERS                                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  L1: In-Memory (Application)                                        │   │
│  │  • Hot user sessions                                                │   │
│  │  • Frequently accessed configs                                      │   │
│  │  TTL: Request lifecycle                                             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  L2: Redis Cluster                                                  │   │
│  │  • User profiles                                                    │   │
│  │  • Recent conversations                                             │   │
│  │  • Emotion analysis results                                         │   │
│  │  • LLM response cache                                               │   │
│  │  TTL: 1 hour - 24 hours                                             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  L3: CDN (Cloudflare)                                               │   │
│  │  • Static assets                                                    │   │
│  │  • Public content                                                   │   │
│  │  • Share card images                                                │   │
│  │  TTL: 1 day - 1 year                                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.3 Performance Targets

| Metric | Target | Current |
|--------|--------|---------|
| API latency (p50) | <100ms | TBD |
| API latency (p99) | <500ms | TBD |
| Chat response | <2s | TBD |
| WebSocket delivery | <50ms | TBD |
| Page load (LCP) | <2.5s | TBD |
| Uptime | 99.9% | TBD |

---

## 9. Observability

### 9.1 Monitoring Stack

| Tool | Purpose |
|------|---------|
| **Datadog** | APM, metrics, logs |
| **Sentry** | Error tracking |
| **Grafana** | Dashboards |
| **PagerDuty** | Alerting |
| **PostHog** | Product analytics |

### 9.2 Key Metrics

```python
# Business Metrics
- daily_active_users
- messages_per_user_per_day
- proactive_push_engagement_rate
- module_activation_rate
- vibe_score_trend

# Technical Metrics
- api_request_rate
- api_error_rate
- api_latency_percentiles
- llm_token_usage
- llm_cost_per_user
- cache_hit_rate
- db_query_latency
- websocket_connections
```

### 9.3 Alerting Rules

```yaml
alerts:
  - name: high_error_rate
    condition: error_rate > 1%
    duration: 5m
    severity: critical

  - name: high_latency
    condition: p99_latency > 2s
    duration: 5m
    severity: warning

  - name: llm_cost_spike
    condition: daily_llm_cost > $1000
    severity: warning

  - name: low_cache_hit
    condition: cache_hit_rate < 70%
    duration: 15m
    severity: warning
```

---

## 10. Deployment Architecture

### 10.1 Environment Strategy

| Environment | Purpose | Config |
|-------------|---------|--------|
| **Local** | Development | Docker Compose |
| **Dev** | Integration testing | K8s (single node) |
| **Staging** | Pre-production | K8s (full replica) |
| **Production** | Live users | K8s (multi-region) |

### 10.2 CI/CD Pipeline

```yaml
# GitHub Actions workflow
name: Deploy

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run tests
        run: pnpm test

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Build Docker images
        run: docker build -t mentis-api .
      - name: Push to registry
        run: docker push gcr.io/mentis/api:${{ github.sha }}

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to staging
        run: kubectl apply -f k8s/staging/

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Deploy to production
        run: kubectl apply -f k8s/production/
```

### 10.3 Infrastructure as Code

```hcl
# Terraform example
resource "google_container_cluster" "mentis" {
  name     = "mentis-production"
  location = "us-central1"

  node_pool {
    name       = "default-pool"
    node_count = 3

    node_config {
      machine_type = "n2-standard-4"
    }

    autoscaling {
      min_node_count = 3
      max_node_count = 20
    }
  }
}

resource "google_sql_database_instance" "mentis" {
  name             = "mentis-postgres"
  database_version = "POSTGRES_15"
  region           = "us-central1"

  settings {
    tier = "db-custom-4-16384"

    backup_configuration {
      enabled = true
    }
  }
}
```

---

## 11. Technology Stack Summary

### 11.1 Frontend

| Component | Technology | Rationale |
|-----------|------------|-----------|
| Web Framework | Next.js 14 | SSR, App Router, RSC |
| UI Library | React 18 | Ecosystem, hooks |
| Styling | Tailwind CSS | Utility-first, fast |
| State Management | Zustand | Lightweight, simple |
| Animations | Framer Motion | Declarative, powerful |
| Forms | React Hook Form + Zod | Validation, performance |

### 11.2 Backend

| Component | Technology | Rationale |
|-----------|------------|-----------|
| API Framework | FastAPI | Async, type hints |
| Language | Python 3.11+ | AI/ML ecosystem |
| Task Queue | Celery + Redis | Reliable, scalable |
| WebSocket | FastAPI + Redis Pub/Sub | Real-time |
| ORM | SQLAlchemy 2.0 | Async, powerful |

### 11.3 AI/ML

| Component | Technology | Rationale |
|-----------|------------|-----------|
| Primary LLM | Claude (Anthropic) | Quality, safety |
| Fallback LLM | GPT-4 (OpenAI) | Availability |
| Chinese LLM | GLM-4 (Zhipu) | Chinese market |
| Embeddings | text-embedding-3 | Quality, cost |
| Vector DB | Pinecone | Managed, fast |

### 11.4 Infrastructure

| Component | Technology | Rationale |
|-----------|------------|-----------|
| Container Orch | Kubernetes (GKE) | Scalability |
| IaC | Terraform | Declarative |
| CI/CD | GitHub Actions | Integration |
| CDN | Cloudflare | Performance |
| Secrets | Google Secret Manager | Security |

---

## 12. Future Architecture Considerations

### 12.1 Multi-Region Deployment

- Primary: US-Central
- Secondary: Europe (GDPR compliance)
- Tertiary: Asia-Pacific (Chinese market)

### 12.2 Offline Capabilities

- Service Worker for web
- SQLite for mobile local storage
- Sync protocol for reconnection

### 12.3 Edge Computing

- Emotion detection at edge
- Local embedding generation
- Reduced latency for common operations

### 12.4 Multi-Modal Expansion

- Real-time voice conversation
- Video analysis for emotion
- Wearable integration for biometrics

---

## Version History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | Jan 2026 | Architecture Team | Initial specification |

---

*Mentis Architecture Team*
*Decode. Reframe. Evolve.*
