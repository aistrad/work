"""
Portrait Service - User portrait (Hot Memory) management

Design: docs/user-data-context-design.md
Core Idea: LLM-generated natural language portraits with structured format
"""
import os
from typing import Optional, List, Dict, Any
from uuid import UUID
from datetime import datetime

from stores.db import get_connection


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Prompts
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PORTRAIT_UPDATE_PROMPT = """ä½ æ˜¯ä¸€ä¸ªç”¨æˆ·ç”»åƒåˆ†æžä¸“å®¶ã€‚è¯·åŸºäºŽä»¥ä¸‹ä¿¡æ¯ï¼Œä¸ºè¿™ä½ç”¨æˆ·ç”Ÿæˆæˆ–æ›´æ–°ç”»åƒæ‘˜è¦ã€‚

## å½“å‰ç”»åƒ (å¦‚æžœå­˜åœ¨)
{current_portrait}

## ç”¨æˆ·åŸºç¡€ä¿¡æ¯
- å‡ºç”Ÿæ—¥æœŸ: {birth_datetime}
- å…«å­—: {bazi_chart}
- ä½¿ç”¨æŠ€èƒ½: {skill_id}

## æœ€è¿‘ {message_count} æ¡å¯¹è¯
{recent_messages}

## ä»»åŠ¡
è¯·ç”Ÿæˆç»“æž„åŒ–çš„ç”¨æˆ·ç”»åƒï¼Œ**å¿…é¡»**åŒ…å«ä»¥ä¸‹å››ä¸ªåŒºåŸŸï¼š

# ç”¨æˆ·ç”»åƒ

## ðŸ“Œ é•¿æœŸäº‹å®ž (Facts)
*ä¸éšæ—¶é—´æ”¹å˜çš„ç¡¬äº‹å®žã€‚å¦‚ï¼šå§“åã€ç”Ÿæ—¥ã€å® ç‰©åã€é‡å¤§ç»åŽ†ã€è¿‡æ•ä¿¡æ¯ã€‚*
*ã€é‡è¦ã€‘æ›´æ–°æ—¶å¿…é¡»ä¿ç•™å·²æœ‰çš„äº‹å®žï¼Œé™¤éžç”¨æˆ·æ˜Žç¡®çº æ­£ï¼*

## ðŸŒŠ å½“å‰çŠ¶æ€ (State)
*æµåŠ¨çš„æƒ…ç»ªã€è¿‘æœŸè¯é¢˜ã€å½“å‰å›°æ‰°ã€‚å¯ä»¥éšæ—¶æ›´æ–°ã€‚*

## ðŸ’¡ äº’åŠ¨åå¥½ (Preferences)
*ç”¨æˆ·å–œæ¬¢ä»€ä¹ˆæ ·çš„å›žåº”æ–¹å¼ã€æ²Ÿé€šé£Žæ ¼ã€‚*

## ðŸŽ¯ å½“å‰å…³æ³¨ (Focus)
*ç”¨æˆ·æ­£åœ¨æ€è€ƒæˆ–å¤„ç†çš„äº‹æƒ…ã€‚*

è¦æ±‚:
- æ¯ä¸ªåŒºåŸŸç”¨ bullet points
- å…·ä½“è€Œéžç¬¼ç»Ÿ
- ðŸ“Œ Facts åŒºåŸŸï¼šåªå¢žä¸åˆ ï¼Œé™¤éžç”¨æˆ·æ˜Žç¡®çº æ­£
- æ€»é•¿åº¦æŽ§åˆ¶åœ¨ 500 å­—ä»¥å†…
- åªè¾“å‡ºç”»åƒå†…å®¹ï¼Œä¸è¦å…¶ä»–è§£é‡Š
"""

PORTRAIT_INIT_TEXT = """# ç”¨æˆ·ç”»åƒ

## ðŸ“Œ é•¿æœŸäº‹å®ž (Facts)
*ç­‰å¾…å‘çŽ°...*

## ðŸŒŠ å½“å‰çŠ¶æ€ (State)
*æ–°ç”¨æˆ·ï¼Œè¿˜æ²¡æœ‰è¶³å¤Ÿçš„äº†è§£*

## ðŸ’¡ äº’åŠ¨åå¥½ (Preferences)
*ç­‰å¾…è§‚å¯Ÿ...*

## ðŸŽ¯ å½“å‰å…³æ³¨ (Focus)
*ç­‰å¾…äº†è§£...*
"""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Portrait Service
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PortraitService:
    """
    User Portrait Service (Hot Memory)

    Core Design:
    - Stores LLM-generated natural language portraits
    - Structured format: Facts/State/Preferences/Focus
    - Facts are "anchored" and protected from compression loss
    - Updated every N messages via background task

    Phase 1.5:
    - Portraits are isolated per skill_id (keeps persona pure)
    - Reserved skill_id 'global' for future aggregation
    """

    # Trigger conditions (can be overridden by env var)
    UPDATE_INTERVAL_MESSAGES = int(os.getenv("PORTRAIT_UPDATE_INTERVAL", "20"))  # Default: every 20 messages
    PORTRAIT_MAX_TOKENS = 1000     # Max tokens for portrait generation

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Read Operations
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @staticmethod
    async def get_portrait(user_id: UUID, skill_id: str) -> Optional[str]:
        """
        Get user portrait text for a skill.
        Returns None if no portrait exists yet.
        """
        async with get_connection() as conn:
            row = await conn.fetchrow(
                """
                SELECT portrait_text FROM user_portraits
                WHERE user_id = $1 AND skill_id = $2
                """,
                user_id, skill_id
            )
            return row["portrait_text"] if row else None

    @staticmethod
    async def get_portrait_metadata(user_id: UUID, skill_id: str) -> Optional[dict]:
        """Get portrait with metadata (for update decision)"""
        async with get_connection() as conn:
            row = await conn.fetchrow(
                """
                SELECT id, portrait_text, based_on_messages, last_message_id, version
                FROM user_portraits
                WHERE user_id = $1 AND skill_id = $2
                """,
                user_id, skill_id
            )
            return dict(row) if row else None

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Update Decision
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @classmethod
    async def should_update(cls, user_id: UUID, skill_id: str) -> bool:
        """
        Check if portrait should be updated.
        Returns True if:
        - No portrait exists (new user)
        - New messages >= UPDATE_INTERVAL_MESSAGES since last update
        """
        async with get_connection() as conn:
            portrait = await conn.fetchrow(
                """
                SELECT based_on_messages, last_message_id
                FROM user_portraits
                WHERE user_id = $1 AND skill_id = $2
                """,
                user_id, skill_id
            )

            # New user, needs portrait
            if not portrait:
                # Check if user has any messages first
                msg_count = await conn.fetchval(
                    """
                    SELECT COUNT(*) FROM skill_messages sm
                    JOIN skill_conversations sc ON sm.conversation_id = sc.id
                    WHERE sc.user_id = $1 AND sc.skill_id = $2
                    """,
                    user_id, skill_id
                )
                return msg_count >= 3  # At least 3 messages to generate portrait

            # Count new messages since last update
            new_messages = await conn.fetchval(
                """
                SELECT COUNT(*) FROM skill_messages sm
                JOIN skill_conversations sc ON sm.conversation_id = sc.id
                WHERE sc.user_id = $1 AND sc.skill_id = $2
                  AND (sm.id > $3 OR $3 IS NULL)
                """,
                user_id, skill_id, portrait["last_message_id"]
            )

            return new_messages >= cls.UPDATE_INTERVAL_MESSAGES

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Update Operations
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @classmethod
    async def update_portrait(
        cls,
        user_id: UUID,
        skill_id: str,
        llm_orchestrator,
        user_repo=None,
        skill_repo=None
    ) -> Optional[str]:
        """
        Update user portrait (background task).

        Process:
        1. Get current portrait
        2. Get user basic info
        3. Get recent messages
        4. Call LLM to generate/update portrait
        5. Save with optimistic lock

        Returns new portrait text or None on failure.
        """
        from .llm_orchestrator import LLMMessage

        # Late imports to avoid circular dependency
        if user_repo is None:
            from stores import UserRepository
            user_repo = UserRepository
        if skill_repo is None:
            from stores import SkillRepository
            skill_repo = SkillRepository

        try:
            # 1. Get current portrait and metadata
            portrait_meta = await cls.get_portrait_metadata(user_id, skill_id)
            current_portrait = portrait_meta["portrait_text"] if portrait_meta else None
            expected_version = portrait_meta["version"] if portrait_meta else 0

            # 2. Get user basic info
            user_data = await user_repo.get_by_id(user_id)
            profile = await skill_repo.get_or_create_profile(user_id, skill_id)

            birth_datetime = user_data.get("birth_datetime") if user_data else None
            bazi_chart = profile.get("profile_data", {}).get("bazi", {}) if profile else {}

            # 3. Get recent messages
            messages = await skill_repo.get_recent_messages(
                user_id, skill_id, limit=50
            )

            if not messages:
                return None  # No messages to process

            # 4. Build prompt and call LLM
            prompt = PORTRAIT_UPDATE_PROMPT.format(
                current_portrait=current_portrait or "è¿™æ˜¯æ–°ç”¨æˆ·ï¼Œè¿˜æ²¡æœ‰ç”»åƒ",
                birth_datetime=birth_datetime or "æœªçŸ¥",
                bazi_chart=bazi_chart or "æœªæŽ’ç›˜",
                skill_id=skill_id,
                message_count=len(messages),
                recent_messages=cls._format_messages(messages)
            )

            response = await llm_orchestrator.chat(
                [LLMMessage(role="user", content=prompt)],
                temperature=0.3,
                max_tokens=cls.PORTRAIT_MAX_TOKENS
            )

            new_portrait = response.content

            # 5. Save portrait with optimistic lock
            last_msg_id = messages[0]["id"] if messages else None

            success = await cls._save_portrait(
                user_id=user_id,
                skill_id=skill_id,
                portrait_text=new_portrait,
                message_count=len(messages),
                last_message_id=last_msg_id,
                expected_version=expected_version,
                old_portrait=current_portrait
            )

            if success:
                return new_portrait
            else:
                # Optimistic lock failed, concurrent update
                print(f"Portrait update skipped (concurrent): user={user_id}, skill={skill_id}")
                return None

        except Exception as e:
            print(f"Portrait update failed: user={user_id}, skill={skill_id}, error={e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    async def _save_portrait(
        user_id: UUID,
        skill_id: str,
        portrait_text: str,
        message_count: int,
        last_message_id: Optional[UUID],
        expected_version: int,
        old_portrait: Optional[str]
    ) -> bool:
        """
        Save portrait with optimistic lock.
        Returns True if saved successfully, False if concurrent update detected.
        """
        async with get_connection() as conn:
            async with conn.transaction():
                # Archive old portrait to history (if exists)
                if old_portrait and expected_version > 0:
                    await conn.execute(
                        """
                        INSERT INTO user_portrait_history (user_id, skill_id, portrait_text, version)
                        VALUES ($1, $2, $3, $4)
                        """,
                        user_id, skill_id, old_portrait, expected_version
                    )

                if expected_version == 0:
                    # New portrait (INSERT)
                    await conn.execute(
                        """
                        INSERT INTO user_portraits (
                            user_id, skill_id, portrait_text,
                            based_on_messages, last_message_id, version
                        )
                        VALUES ($1, $2, $3, $4, $5, 1)
                        ON CONFLICT (user_id, skill_id) DO NOTHING
                        """,
                        user_id, skill_id, portrait_text, message_count, last_message_id
                    )
                    return True
                else:
                    # Update with optimistic lock
                    result = await conn.execute(
                        """
                        UPDATE user_portraits
                        SET portrait_text = $1,
                            based_on_messages = based_on_messages + $2,
                            last_message_id = $3,
                            version = version + 1,
                            generated_at = NOW()
                        WHERE user_id = $4 AND skill_id = $5 AND version = $6
                        """,
                        portrait_text, message_count, last_message_id,
                        user_id, skill_id, expected_version
                    )

                    return "UPDATE 1" in result

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Helper Methods
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @staticmethod
    def _format_messages(messages: List[dict]) -> str:
        """Format messages for portrait prompt"""
        formatted = []
        for msg in messages[-30:]:  # Limit to last 30 messages
            role = "ç”¨æˆ·" if msg["role"] == "user" else "Vibe"
            content = msg["content"][:200]  # Truncate long messages
            formatted.append(f"[{role}]: {content}")
        return "\n".join(formatted)

    @staticmethod
    def get_default_portrait() -> str:
        """Get default portrait for new users"""
        return PORTRAIT_INIT_TEXT
