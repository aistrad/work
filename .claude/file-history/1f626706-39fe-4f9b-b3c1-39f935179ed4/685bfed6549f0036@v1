"""
Zodiac Calculator - Western Astrology Calculations
Based on: vibelife spec v3.0

Uses flatlib library for astronomical calculations.
Install: pip install flatlib

References:
- https://github.com/flatangle/flatlib
"""

import logging
from dataclasses import dataclass, field, asdict
from typing import Dict, Any, Optional, List
from datetime import datetime, date
from enum import Enum

logger = logging.getLogger(__name__)

# Try to import flatlib
try:
    from flatlib.datetime import Datetime
    from flatlib.geopos import GeoPos
    from flatlib.chart import Chart
    from flatlib import const
    FLATLIB_AVAILABLE = True
except ImportError:
    FLATLIB_AVAILABLE = False
    logger.warning("flatlib not installed. Install with: pip install flatlib")


class ZodiacSign(str, Enum):
    """Zodiac Signs (黄道十二宫)"""
    ARIES = "aries"           # 白羊座
    TAURUS = "taurus"         # 金牛座
    GEMINI = "gemini"         # 双子座
    CANCER = "cancer"         # 巨蟹座
    LEO = "leo"               # 狮子座
    VIRGO = "virgo"           # 处女座
    LIBRA = "libra"           # 天秤座
    SCORPIO = "scorpio"       # 天蝎座
    SAGITTARIUS = "sagittarius"  # 射手座
    CAPRICORN = "capricorn"   # 摩羯座
    AQUARIUS = "aquarius"     # 水瓶座
    PISCES = "pisces"         # 双鱼座


class Planet(str, Enum):
    """Planets (行星)"""
    SUN = "sun"           # 太阳
    MOON = "moon"         # 月亮
    MERCURY = "mercury"   # 水星
    VENUS = "venus"       # 金星
    MARS = "mars"         # 火星
    JUPITER = "jupiter"   # 木星
    SATURN = "saturn"     # 土星
    URANUS = "uranus"     # 天王星
    NEPTUNE = "neptune"   # 海王星
    PLUTO = "pluto"       # 冥王星


class Element(str, Enum):
    """Elements (元素)"""
    FIRE = "fire"     # 火象
    EARTH = "earth"   # 土象
    AIR = "air"       # 风象
    WATER = "water"   # 水象


class Modality(str, Enum):
    """Modalities (模式)"""
    CARDINAL = "cardinal"   # 本位
    FIXED = "fixed"         # 固定
    MUTABLE = "mutable"     # 变动


# Sign mappings
SIGN_CHINESE = {
    "aries": "白羊座", "taurus": "金牛座", "gemini": "双子座",
    "cancer": "巨蟹座", "leo": "狮子座", "virgo": "处女座",
    "libra": "天秤座", "scorpio": "天蝎座", "sagittarius": "射手座",
    "capricorn": "摩羯座", "aquarius": "水瓶座", "pisces": "双鱼座",
}

SIGN_ELEMENT = {
    "aries": Element.FIRE, "leo": Element.FIRE, "sagittarius": Element.FIRE,
    "taurus": Element.EARTH, "virgo": Element.EARTH, "capricorn": Element.EARTH,
    "gemini": Element.AIR, "libra": Element.AIR, "aquarius": Element.AIR,
    "cancer": Element.WATER, "scorpio": Element.WATER, "pisces": Element.WATER,
}

SIGN_MODALITY = {
    "aries": Modality.CARDINAL, "cancer": Modality.CARDINAL,
    "libra": Modality.CARDINAL, "capricorn": Modality.CARDINAL,
    "taurus": Modality.FIXED, "leo": Modality.FIXED,
    "scorpio": Modality.FIXED, "aquarius": Modality.FIXED,
    "gemini": Modality.MUTABLE, "virgo": Modality.MUTABLE,
    "sagittarius": Modality.MUTABLE, "pisces": Modality.MUTABLE,
}

PLANET_CHINESE = {
    "sun": "太阳", "moon": "月亮", "mercury": "水星",
    "venus": "金星", "mars": "火星", "jupiter": "木星",
    "saturn": "土星", "uranus": "天王星", "neptune": "海王星", "pluto": "冥王星",
}

# City coordinates (simplified)
CITY_COORDS = {
    "shanghai": (31.2304, 121.4737),
    "beijing": (39.9042, 116.4074),
    "guangzhou": (23.1291, 113.2644),
    "shenzhen": (22.5431, 114.0579),
    "hong kong": (22.3193, 114.1694),
    "taipei": (25.0330, 121.5654),
    "new york": (40.7128, -74.0060),
    "los angeles": (34.0522, -118.2437),
    "london": (51.5074, -0.1278),
    "tokyo": (35.6762, 139.6503),
    "default": (31.2304, 121.4737),  # Default to Shanghai
}


@dataclass
class PlanetPosition:
    """Planet position in the chart"""
    planet: str
    sign: str
    sign_chinese: str
    degree: float
    house: int
    retrograde: bool = False

    def to_dict(self) -> dict:
        return {
            "planet": self.planet,
            "sign": self.sign,
            "sign_chinese": self.sign_chinese,
            "degree": round(self.degree, 2),
            "house": self.house,
            "retrograde": self.retrograde,
        }


@dataclass
class Aspect:
    """Aspect between two planets"""
    planet1: str
    planet2: str
    aspect_type: str  # "conjunction", "opposition", "trine", "square", "sextile"
    orb: float
    description: str = ""

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class Transit:
    """Transit event"""
    planet: str
    sign: str
    aspect: str
    natal_planet: str
    influence: str  # "positive", "challenging", "neutral"
    description: str
    start_date: str
    end_date: str
    is_active: bool = True

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class ZodiacChart:
    """Complete Zodiac Chart (星盘)"""
    birth_info: Dict[str, Any]
    sun_sign: str
    moon_sign: str
    rising_sign: str
    planets: List[PlanetPosition]
    aspects: List[Aspect]
    dominant_element: str
    dominant_modality: str

    def to_dict(self) -> dict:
        return {
            "birth_info": self.birth_info,
            "sun_sign": self.sun_sign,
            "sun_sign_chinese": SIGN_CHINESE.get(self.sun_sign, self.sun_sign),
            "moon_sign": self.moon_sign,
            "moon_sign_chinese": SIGN_CHINESE.get(self.moon_sign, self.moon_sign),
            "rising_sign": self.rising_sign,
            "rising_sign_chinese": SIGN_CHINESE.get(self.rising_sign, self.rising_sign),
            "planets": [p.to_dict() for p in self.planets],
            "aspects": [a.to_dict() for a in self.aspects],
            "dominant_element": self.dominant_element,
            "dominant_modality": self.dominant_modality,
        }


class ZodiacCalculator:
    """
    Zodiac (Western Astrology) Calculator

    Usage:
        calculator = ZodiacCalculator()
        chart = calculator.calculate(
            birth_date="1990-05-15",
            birth_time="08:00",
            birth_place="Shanghai"
        )
    """

    # Aspect definitions
    ASPECTS = {
        0: ("conjunction", "合相"),
        60: ("sextile", "六分相"),
        90: ("square", "刑相"),
        120: ("trine", "三分相"),
        180: ("opposition", "冲相"),
    }

    def __init__(self):
        if not FLATLIB_AVAILABLE:
            logger.warning("flatlib not available, calculations will be limited")

    def calculate(
        self,
        birth_date: str,  # "YYYY-MM-DD"
        birth_time: str = "12:00",  # "HH:MM"
        birth_place: str = "Shanghai"
    ) -> ZodiacChart:
        """
        Calculate complete zodiac chart from birth information.

        Args:
            birth_date: Date in "YYYY-MM-DD" format
            birth_time: Time in "HH:MM" format
            birth_place: City name for coordinates

        Returns:
            ZodiacChart with all calculations
        """
        if not FLATLIB_AVAILABLE:
            return self._demo_chart(birth_date, birth_time, birth_place)

        try:
            # Parse date and time
            year, month, day = map(int, birth_date.split("-"))
            hour, minute = map(int, birth_time.split(":"))

            # Get coordinates
            place_lower = birth_place.lower()
            lat, lon = CITY_COORDS.get(place_lower, CITY_COORDS["default"])

            # Create flatlib datetime and position
            dt = Datetime(f'{year}/{month:02d}/{day:02d}', f'{hour:02d}:{minute:02d}', '+08:00')
            pos = GeoPos(lat, lon)

            # Create chart
            chart = Chart(dt, pos)

            # Get planet positions
            planets = []
            planet_signs = {}

            for planet_name in [const.SUN, const.MOON, const.MERCURY, const.VENUS,
                               const.MARS, const.JUPITER, const.SATURN,
                               const.URANUS, const.NEPTUNE, const.PLUTO]:
                try:
                    obj = chart.get(planet_name)
                    sign = obj.sign.lower()
                    planet_key = planet_name.lower()
                    planet_signs[planet_key] = sign

                    planets.append(PlanetPosition(
                        planet=planet_key,
                        sign=sign,
                        sign_chinese=SIGN_CHINESE.get(sign, sign),
                        degree=obj.signlon,
                        house=self._get_house(chart, obj),
                        retrograde=obj.movement() == const.RETROGRADE if hasattr(obj, 'movement') else False,
                    ))
                except Exception as e:
                    logger.warning(f"Failed to get {planet_name}: {e}")

            # Get sun, moon, rising
            sun_sign = planet_signs.get("sun", "aries")
            moon_sign = planet_signs.get("moon", "cancer")

            # Get rising sign (Ascendant)
            try:
                asc = chart.get(const.ASC)
                rising_sign = asc.sign.lower()
            except Exception:
                rising_sign = "virgo"

            # Calculate aspects
            aspects = self._calculate_aspects(chart, planets)

            # Calculate dominant element and modality
            dominant_element = self._calculate_dominant_element(planet_signs)
            dominant_modality = self._calculate_dominant_modality(planet_signs)

            return ZodiacChart(
                birth_info={
                    "date": birth_date,
                    "time": birth_time,
                    "place": birth_place,
                    "latitude": lat,
                    "longitude": lon,
                },
                sun_sign=sun_sign,
                moon_sign=moon_sign,
                rising_sign=rising_sign,
                planets=planets,
                aspects=aspects,
                dominant_element=dominant_element,
                dominant_modality=dominant_modality,
            )

        except Exception as e:
            logger.error(f"Zodiac calculation failed: {e}")
            return self._demo_chart(birth_date, birth_time, birth_place)

    def calculate_transit(
        self,
        natal_chart: ZodiacChart,
        transit_date: str = None
    ) -> List[Transit]:
        """
        Calculate transits for a given date.

        Args:
            natal_chart: The natal chart to compare against
            transit_date: Date to calculate transits for (default: today)

        Returns:
            List of active transits
        """
        if transit_date is None:
            transit_date = date.today().isoformat()

        if not FLATLIB_AVAILABLE:
            return self._demo_transits(transit_date)

        try:
            # Parse date
            year, month, day = map(int, transit_date.split("-"))
            dt = Datetime(f'{year}/{month:02d}/{day:02d}', '12:00', '+08:00')
            pos = GeoPos(31.2304, 121.4737)  # Default position

            # Create transit chart
            transit_chart = Chart(dt, pos)

            transits = []

            # Check major transits (slow planets to natal positions)
            for transit_planet in [const.JUPITER, const.SATURN, const.URANUS, const.NEPTUNE, const.PLUTO]:
                try:
                    transit_obj = transit_chart.get(transit_planet)
                    transit_sign = transit_obj.sign.lower()

                    # Check aspects to natal Sun and Moon
                    for natal in natal_chart.planets:
                        if natal.planet in ["sun", "moon"]:
                            aspect = self._check_aspect(transit_obj.signlon, natal.degree)
                            if aspect:
                                transits.append(Transit(
                                    planet=transit_planet.lower(),
                                    sign=SIGN_CHINESE.get(transit_sign, transit_sign),
                                    aspect=aspect[1],
                                    natal_planet=PLANET_CHINESE.get(natal.planet, natal.planet),
                                    influence=self._get_aspect_influence(aspect[0]),
                                    description=f"{PLANET_CHINESE.get(transit_planet.lower(), transit_planet)}{aspect[1]}{PLANET_CHINESE.get(natal.planet, natal.planet)}",
                                    start_date=transit_date,
                                    end_date=transit_date,
                                    is_active=True,
                                ))
                except Exception as e:
                    logger.warning(f"Transit calculation error for {transit_planet}: {e}")

            return transits if transits else self._demo_transits(transit_date)

        except Exception as e:
            logger.error(f"Transit calculation failed: {e}")
            return self._demo_transits(transit_date)

    def _get_house(self, chart, obj) -> int:
        """Get house number for an object"""
        try:
            for i in range(1, 13):
                house = chart.get(f'House{i}')
                if house and obj.sign == house.sign:
                    return i
        except Exception:
            pass
        return 1

    def _calculate_aspects(self, chart, planets: List[PlanetPosition]) -> List[Aspect]:
        """Calculate aspects between planets"""
        aspects = []
        orb_tolerance = 8  # degrees

        for i, p1 in enumerate(planets):
            for p2 in planets[i+1:]:
                diff = abs(p1.degree - p2.degree)
                if diff > 180:
                    diff = 360 - diff

                for angle, (aspect_type, aspect_name) in self.ASPECTS.items():
                    orb = abs(diff - angle)
                    if orb <= orb_tolerance:
                        aspects.append(Aspect(
                            planet1=PLANET_CHINESE.get(p1.planet, p1.planet),
                            planet2=PLANET_CHINESE.get(p2.planet, p2.planet),
                            aspect_type=aspect_type,
                            orb=round(orb, 2),
                            description=f"{PLANET_CHINESE.get(p1.planet, p1.planet)}{aspect_name}{PLANET_CHINESE.get(p2.planet, p2.planet)}",
                        ))
                        break

        return aspects

    def _check_aspect(self, degree1: float, degree2: float) -> Optional[tuple]:
        """Check if two degrees form an aspect"""
        diff = abs(degree1 - degree2)
        if diff > 180:
            diff = 360 - diff

        orb_tolerance = 8
        for angle, (aspect_type, aspect_name) in self.ASPECTS.items():
            if abs(diff - angle) <= orb_tolerance:
                return (aspect_type, aspect_name)
        return None

    def _get_aspect_influence(self, aspect_type: str) -> str:
        """Get the influence type of an aspect"""
        if aspect_type in ["trine", "sextile"]:
            return "positive"
        elif aspect_type in ["square", "opposition"]:
            return "challenging"
        return "neutral"

    def _calculate_dominant_element(self, planet_signs: Dict[str, str]) -> str:
        """Calculate dominant element from planet positions"""
        element_count = {e.value: 0 for e in Element}

        # Weight: Sun=3, Moon=3, Rising=2, Others=1
        weights = {"sun": 3, "moon": 3, "mercury": 1, "venus": 1, "mars": 1}

        for planet, sign in planet_signs.items():
            weight = weights.get(planet, 1)
            element = SIGN_ELEMENT.get(sign)
            if element:
                element_count[element.value] += weight

        return max(element_count, key=element_count.get)

    def _calculate_dominant_modality(self, planet_signs: Dict[str, str]) -> str:
        """Calculate dominant modality from planet positions"""
        modality_count = {m.value: 0 for m in Modality}

        for planet, sign in planet_signs.items():
            modality = SIGN_MODALITY.get(sign)
            if modality:
                modality_count[modality.value] += 1

        return max(modality_count, key=modality_count.get)

    def _demo_chart(
        self,
        birth_date: str,
        birth_time: str,
        birth_place: str
    ) -> ZodiacChart:
        """Return demo chart when calculation is not available"""
        return ZodiacChart(
            birth_info={
                "date": birth_date,
                "time": birth_time,
                "place": birth_place,
            },
            sun_sign="taurus",
            moon_sign="cancer",
            rising_sign="virgo",
            planets=[
                PlanetPosition("sun", "taurus", "金牛座", 24.5, 9),
                PlanetPosition("moon", "cancer", "巨蟹座", 15.3, 11),
                PlanetPosition("mercury", "taurus", "金牛座", 28.1, 9),
                PlanetPosition("venus", "gemini", "双子座", 8.7, 10),
                PlanetPosition("mars", "leo", "狮子座", 12.4, 12),
                PlanetPosition("jupiter", "cancer", "巨蟹座", 3.2, 11),
                PlanetPosition("saturn", "capricorn", "摩羯座", 22.8, 5),
            ],
            aspects=[],
            dominant_element="earth",
            dominant_modality="fixed",
        )

    def _demo_transits(self, transit_date: str) -> List[Transit]:
        """Return demo transits"""
        return [
            Transit(
                planet="mercury",
                sign="摩羯座",
                aspect="合相",
                natal_planet="太阳",
                influence="neutral",
                description="水星合相太阳：适合复盘与校对细节，沟通更重逻辑。",
                start_date=transit_date,
                end_date=transit_date,
                is_active=True,
            ),
        ]


# Convenience functions
def calculate_zodiac(
    birth_date: str,
    birth_time: str = "12:00",
    birth_place: str = "Shanghai"
) -> dict:
    """Calculate zodiac chart and return as dict."""
    calculator = ZodiacCalculator()
    chart = calculator.calculate(birth_date, birth_time, birth_place)
    return chart.to_dict()


def calculate_transit(
    birth_date: str,
    birth_time: str = "12:00",
    birth_place: str = "Shanghai",
    transit_date: str = None
) -> List[dict]:
    """Calculate transits and return as list of dicts."""
    calculator = ZodiacCalculator()
    natal = calculator.calculate(birth_date, birth_time, birth_place)
    transits = calculator.calculate_transit(natal, transit_date)
    return [t.to_dict() for t in transits]
