/**
 * Mentis OS v3.0 WebSocket 客户端
 *
 * 功能：
 * - 自动重连（指数退避）
 * - 心跳保活
 * - 频道订阅
 * - 事件监听
 */

export type MessageHandler = (data: unknown) => void;

export interface RealtimeConfig {
  url: string;
  token: string;
  reconnectMaxAttempts?: number;
  reconnectBaseDelay?: number;
  heartbeatInterval?: number;
  onConnected?: () => void;
  onDisconnected?: () => void;
  onError?: (error: Event) => void;
}

export interface RealtimeMessage {
  type: string;
  data?: unknown;
  timestamp?: number;
  channels?: string[];
}

function resolveWsBase(): string {
  const base =
    process.env.NEXT_PUBLIC_API_BASE ||
    (typeof window !== "undefined" ? window.location.origin : "");
  return base.replace(/^http/, "ws");
}

export class MentisRealtime {
  private ws: WebSocket | null = null;
  private config: Required<RealtimeConfig>;
  private handlers: Map<string, Set<MessageHandler>> = new Map();
  private reconnectAttempts = 0;
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
  private heartbeatTimer: ReturnType<typeof setInterval> | null = null;
  private lastPong = Date.now();
  private isIntentionallyClosed = false;
  private subscribedChannels: Set<string> = new Set();

  constructor(config: RealtimeConfig) {
    this.config = {
      reconnectMaxAttempts: 10,
      reconnectBaseDelay: 1000,
      heartbeatInterval: 30000,
      onConnected: () => {},
      onDisconnected: () => {},
      onError: () => {},
      ...config,
    };
  }

  connect(): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      return;
    }

    this.isIntentionallyClosed = false;
    const wsUrl = `${this.config.url}?token=${this.config.token}`;

    try {
      this.ws = new WebSocket(wsUrl);
      this.setupEventHandlers();
    } catch (error) {
      console.error("[Mentis Realtime] Connection error:", error);
      this.scheduleReconnect();
    }
  }

  private setupEventHandlers(): void {
    if (!this.ws) return;

    this.ws.onopen = () => {
      console.log("[Mentis Realtime] Connected");
      this.reconnectAttempts = 0;
      this.lastPong = Date.now();
      this.startHeartbeat();
      this.config.onConnected();

      // 重新订阅之前的频道
      if (this.subscribedChannels.size > 0) {
        this.subscribe([...this.subscribedChannels]);
      }
    };

    this.ws.onclose = (event) => {
      console.log("[Mentis Realtime] Disconnected", event.code, event.reason);
      this.stopHeartbeat();
      this.config.onDisconnected();

      if (!this.isIntentionallyClosed) {
        this.scheduleReconnect();
      }
    };

    this.ws.onerror = (error) => {
      console.error("[Mentis Realtime] Error:", error);
      this.config.onError(error);
    };

    this.ws.onmessage = (event) => {
      try {
        const message: RealtimeMessage = JSON.parse(event.data);
        this.handleMessage(message);
      } catch (error) {
        console.error("[Mentis Realtime] Parse error:", error);
      }
    };
  }

  private handleMessage(message: RealtimeMessage): void {
    const { type, data } = message;

    // 处理心跳
    if (type === "pong") {
      this.lastPong = Date.now();
      return;
    }

    if (type === "ping") {
      this.send({ type: "pong" });
      return;
    }

    // 触发事件处理器
    const handlers = this.handlers.get(type);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(data);
        } catch (error) {
          console.error(`[Mentis Realtime] Handler error for ${type}:`, error);
        }
      });
    }

    // 触发通配符处理器
    const wildcardHandlers = this.handlers.get("*");
    if (wildcardHandlers) {
      wildcardHandlers.forEach((handler) => {
        try {
          handler(message);
        } catch (error) {
          console.error("[Mentis Realtime] Wildcard handler error:", error);
        }
      });
    }
  }

  private startHeartbeat(): void {
    this.stopHeartbeat();
    this.heartbeatTimer = setInterval(() => {
      // 检查上次 pong 时间
      if (Date.now() - this.lastPong > this.config.heartbeatInterval * 3) {
        console.warn("[Mentis Realtime] Heartbeat timeout, reconnecting...");
        this.ws?.close();
        return;
      }

      // 发送 ping
      this.send({ type: "ping" });
    }, this.config.heartbeatInterval);
  }

  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }

  private scheduleReconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }

    if (this.reconnectAttempts >= this.config.reconnectMaxAttempts) {
      console.error("[Mentis Realtime] Max reconnect attempts reached");
      return;
    }

    // 指数退避
    const delay = Math.min(
      this.config.reconnectBaseDelay * Math.pow(2, this.reconnectAttempts),
      30000 // 最大 30 秒
    );

    console.log(
      `[Mentis Realtime] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts + 1})`
    );

    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  private send(message: RealtimeMessage): void {
    if (this.ws?.readyState !== WebSocket.OPEN) {
      console.warn("[Mentis Realtime] Cannot send, not connected");
      return;
    }

    this.ws.send(JSON.stringify(message));
  }

  /**
   * 订阅频道
   */
  subscribe(channels: string[]): void {
    channels.forEach((ch) => this.subscribedChannels.add(ch));
    this.send({ type: "subscribe", channels });
  }

  /**
   * 取消订阅
   */
  unsubscribe(channels: string[]): void {
    channels.forEach((ch) => this.subscribedChannels.delete(ch));
    this.send({ type: "unsubscribe", channels });
  }

  /**
   * 监听事件
   */
  on(type: string, handler: MessageHandler): () => void {
    if (!this.handlers.has(type)) {
      this.handlers.set(type, new Set());
    }
    this.handlers.get(type)!.add(handler);

    // 返回取消监听函数
    return () => {
      this.handlers.get(type)?.delete(handler);
    };
  }

  /**
   * 取消监听
   */
  off(type: string, handler?: MessageHandler): void {
    if (handler) {
      this.handlers.get(type)?.delete(handler);
    } else {
      this.handlers.delete(type);
    }
  }

  /**
   * 请求用户状态
   */
  requestState(): void {
    this.send({ type: "get_state" });
  }

  /**
   * 请求待处理任务
   */
  requestTasks(): void {
    this.send({ type: "get_tasks" });
  }

  /**
   * 关闭连接
   */
  disconnect(): void {
    this.isIntentionallyClosed = true;
    this.stopHeartbeat();

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  /**
   * 获取连接状态
   */
  get isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }

  /**
   * 获取连接状态
   */
  get readyState(): number {
    return this.ws?.readyState ?? WebSocket.CLOSED;
  }
}

// 单例实例
let realtimeInstance: MentisRealtime | null = null;

export function createRealtime(config: RealtimeConfig): MentisRealtime {
  if (realtimeInstance) {
    realtimeInstance.disconnect();
  }
  realtimeInstance = new MentisRealtime(config);
  return realtimeInstance;
}

export function getRealtime(): MentisRealtime | null {
  return realtimeInstance;
}

// 兼容旧 API
export function connectRealtime(
  token: string,
  onMessage: (message: RealtimeMessage) => void
): WebSocket | null {
  if (!token) return null;
  const wsBase = resolveWsBase();
  const ws = new WebSocket(
    `${wsBase}/api/v3/realtime?token=${encodeURIComponent(token)}`
  );
  ws.addEventListener("message", (event) => {
    try {
      const data = JSON.parse(event.data) as RealtimeMessage;
      onMessage(data);
    } catch {
      // ignore malformed payloads
    }
  });
  return ws;
}
