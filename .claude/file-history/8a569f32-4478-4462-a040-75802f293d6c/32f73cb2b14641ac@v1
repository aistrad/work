"""
VibeProfile 真实数据测试 - 基于真实API和真实数据

测试用户:
- TEST_USER_1: 550e8400-e29b-41d4-a716-446655440000 (VB_TEST_001)
- TEST_USER_2: 22817735-e2a4-4c54-ad06-44ce4211751e (VB-G6DP3PQ3)
- TEST_USER_3: 11111111-1111-1111-1111-111111111111 (VIBE-TEST001)
"""
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# 加载环境变量
root_dir = Path(__file__).parent.parent.parent.parent
env_file = root_dir / '.env'
if env_file.exists():
    load_dotenv(env_file, override=True)
os.environ.pop('VIBELIFE_ENV', None)

import pytest
import asyncio
from uuid import UUID
from stores.unified_profile_repo import UnifiedProfileRepository
from stores.db import init_db, close_db

# 真实用户ID
TEST_USER_1 = UUID('550e8400-e29b-41d4-a716-446655440000')
TEST_USER_2 = UUID('22817735-e2a4-4c54-ad06-44ce4211751e')
TEST_USER_3 = UUID('11111111-1111-1111-1111-111111111111')


@pytest.fixture(scope="module", autouse=True)
async def setup_db():
    """初始化数据库"""
    await init_db()
    yield
    try:
        await close_db()
    except:
        pass


@pytest.fixture
def repo():
    """Repository 实例"""
    return UnifiedProfileRepository()


# ═══════════════════════════════════════════════════════════════
# 测试 1: Profile 基础读取
# ═══════════════════════════════════════════════════════════════

class TestProfileRead:
    """测试 Profile 读取功能"""

    @pytest.mark.asyncio
    async def test_01_get_profile_user1(self, repo):
        """测试1: 读取 TEST_USER_1 的 Profile"""
        profile = await repo.get_profile(TEST_USER_1)

        assert profile is not None, "Profile 不应该为 None"
        assert isinstance(profile, dict), "Profile 应该是字典"

        # 记录实际结构
        print(f"\n✅ TEST_USER_1 Profile 存在")
        print(f"   顶层键: {list(profile.keys())}")

    @pytest.mark.asyncio
    async def test_02_get_profile_user2(self, repo):
        """测试2: 读取 TEST_USER_2 的 Profile"""
        profile = await repo.get_profile(TEST_USER_2)

        assert profile is not None, "Profile 不应该为 None"
        print(f"\n✅ TEST_USER_2 Profile 存在")
        print(f"   顶层键: {list(profile.keys())}")

    @pytest.mark.asyncio
    async def test_03_get_profile_user3(self, repo):
        """测试3: 读取 TEST_USER_3 的 Profile"""
        profile = await repo.get_profile(TEST_USER_3)

        assert profile is not None, "Profile 不应该为 None"
        print(f"\n✅ TEST_USER_3 Profile 存在")
        print(f"   顶层键: {list(profile.keys())}")

    @pytest.mark.asyncio
    async def test_04_get_birth_info(self, repo):
        """测试4: 读取出生信息"""
        birth_info = await repo.get_birth_info(TEST_USER_1)

        assert isinstance(birth_info, dict), "birth_info 应该是字典"
        print(f"\n✅ birth_info 读取成功")
        print(f"   内容: {birth_info}")
        print(f"   是否为空: {len(birth_info) == 0}")

    @pytest.mark.asyncio
    async def test_05_get_preferences(self, repo):
        """测试5: 读取用户偏好"""
        preferences = await repo.get_preferences(TEST_USER_1)

        assert isinstance(preferences, dict), "preferences 应该是字典"
        print(f"\n✅ preferences 读取成功")
        print(f"   键: {list(preferences.keys())}")
        if 'subscribed_skills' in preferences:
            print(f"   订阅的 skills: {list(preferences['subscribed_skills'].keys())}")

    @pytest.mark.asyncio
    async def test_06_get_life_context(self, repo):
        """测试6: 读取生活上下文"""
        life_context = await repo.get_life_context(TEST_USER_1)

        assert isinstance(life_context, dict), "life_context 应该是字典"
        print(f"\n✅ life_context 读取成功")
        print(f"   键: {list(life_context.keys())}")

    @pytest.mark.asyncio
    async def test_07_get_skill_data(self, repo):
        """测试7: 读取 Skill 数据"""
        skill_data = await repo.get_skill_data(TEST_USER_1, 'bazi')

        assert isinstance(skill_data, dict), "skill_data 应该是字典"
        print(f"\n✅ skill_data (bazi) 读取成功")
        print(f"   内容: {skill_data if skill_data else '空'}")

    @pytest.mark.asyncio
    async def test_08_get_extracted(self, repo):
        """测试8: 读取提取的信息"""
        extracted = await repo.get_extracted(TEST_USER_1)

        assert isinstance(extracted, dict), "extracted 应该是字典"
        print(f"\n✅ extracted 读取成功")
        print(f"   内容: {extracted if extracted else '空'}")


# ═══════════════════════════════════════════════════════════════
# 测试 2: Skill 订阅管理
# ═══════════════════════════════════════════════════════════════

class TestSkillSubscriptions:
    """测试 Skill 订阅功能"""

    @pytest.mark.asyncio
    async def test_09_get_user_subscriptions(self, repo):
        """测试9: 获取用户订阅列表"""
        subscriptions = await repo.get_user_subscriptions(TEST_USER_1)

        assert isinstance(subscriptions, list), "订阅列表应该是列表"
        print(f"\n✅ 订阅列表读取成功")
        print(f"   订阅数量: {len(subscriptions)}")
        for sub in subscriptions:
            print(f"   - {sub.skill_id}: {sub.status} (push: {sub.push_enabled})")

    @pytest.mark.asyncio
    async def test_10_get_skill_subscription(self, repo):
        """测试10: 获取单个 Skill 订阅状态"""
        # 先获取订阅列表，然后查询第一个
        subscriptions = await repo.get_user_subscriptions(TEST_USER_1)

        if subscriptions:
            skill_id = subscriptions[0].skill_id
            subscription = await repo.get_skill_subscription(TEST_USER_1, skill_id)

            print(f"\n✅ Skill 订阅状态读取成功")
            print(f"   Skill: {skill_id}")
            print(f"   状态: {subscription.status if subscription else 'None'}")
            print(f"   Push: {subscription.push_enabled if subscription else 'N/A'}")
        else:
            print(f"\n⚠️  用户没有订阅")

    @pytest.mark.asyncio
    async def test_11_is_subscribed(self, repo):
        """测试11: 检查是否订阅"""
        subscriptions = await repo.get_user_subscriptions(TEST_USER_1)

        if subscriptions:
            skill_id = subscriptions[0].skill_id
            is_subscribed = await repo.is_subscribed(TEST_USER_1, skill_id)

            assert isinstance(is_subscribed, bool), "is_subscribed 应该返回布尔值"
            print(f"\n✅ 订阅检查成功")
            print(f"   Skill: {skill_id}")
            print(f"   已订阅: {is_subscribed}")

    @pytest.mark.asyncio
    async def test_12_is_push_enabled(self, repo):
        """测试12: 检查推送是否开启"""
        subscriptions = await repo.get_user_subscriptions(TEST_USER_1)

        if subscriptions:
            skill_id = subscriptions[0].skill_id
            is_enabled = await repo.is_push_enabled(TEST_USER_1, skill_id)

            assert isinstance(is_enabled, bool), "is_push_enabled 应该返回布尔值"
            print(f"\n✅ 推送状态检查成功")
            print(f"   Skill: {skill_id}")
            print(f"   推送开启: {is_enabled}")

    @pytest.mark.asyncio
    async def test_13_get_subscribed_skill_ids(self, repo):
        """测试13: 获取订阅的 Skill ID 列表"""
        skill_ids = await repo.get_subscribed_skill_ids(TEST_USER_1)

        assert isinstance(skill_ids, list), "应该返回列表"
        print(f"\n✅ 订阅的 Skill IDs 读取成功")
        print(f"   数量: {len(skill_ids)}")
        print(f"   IDs: {skill_ids}")


# ═══════════════════════════════════════════════════════════════
# 测试 3: Push 设置
# ═══════════════════════════════════════════════════════════════

class TestPushSettings:
    """测试 Push 设置功能"""

    @pytest.mark.asyncio
    async def test_14_get_push_settings(self, repo):
        """测试14: 获取推送设置"""
        settings = await repo.get_push_settings(TEST_USER_1)

        print(f"\n✅ Push 设置读取成功")
        if settings:
            print(f"   默认推送时间: {settings.default_push_hour}")
            print(f"   每日最大推送: {settings.max_daily_pushes}")
            print(f"   免打扰开始: {settings.quiet_start_hour}")
            print(f"   免打扰结束: {settings.quiet_end_hour}")
        else:
            print(f"   Push 设置: None (使用默认值)")

    @pytest.mark.asyncio
    async def test_15_get_push_hour(self, repo):
        """测试15: 获取推送时间"""
        push_hour = await repo.get_push_hour(TEST_USER_1)

        assert isinstance(push_hour, int), "推送时间应该是整数"
        assert 0 <= push_hour <= 23, "推送时间应该在 0-23 之间"
        print(f"\n✅ 推送时间读取成功")
        print(f"   推送时间: {push_hour}:00")

    @pytest.mark.asyncio
    async def test_16_is_in_quiet_hours(self, repo):
        """测试16: 检查是否在免打扰时段"""
        # 测试几个不同时间
        test_hours = [0, 8, 12, 20, 23]

        print(f"\n✅ 免打扰时段检查")
        for hour in test_hours:
            is_quiet = await repo.is_in_quiet_hours(TEST_USER_1, hour)
            print(f"   {hour:02d}:00 -> {'免打扰' if is_quiet else '可推送'}")


# ═══════════════════════════════════════════════════════════════
# 测试 4: Life Context (文件系统API)
# ═══════════════════════════════════════════════════════════════

class TestLifeContext:
    """测试 Life Context 文件系统API"""

    @pytest.mark.asyncio
    async def test_17_list_life_context_paths(self, repo):
        """测试17: 列出所有 life context 路径"""
        paths = await repo.list_life_context_paths(TEST_USER_1)

        assert isinstance(paths, list), "应该返回列表"
        print(f"\n✅ Life context 路径列表")
        print(f"   数量: {len(paths)}")
        if paths:
            for path in paths[:5]:  # 只显示前5个
                print(f"   - {path}")

    @pytest.mark.asyncio
    async def test_18_read_life_context_path(self, repo):
        """测试18: 读取 life context 路径"""
        paths = await repo.list_life_context_paths(TEST_USER_1)

        if paths:
            first_path = paths[0]
            data = await repo.read_life_context_path(TEST_USER_1, first_path)

            print(f"\n✅ Life context 路径读取成功")
            print(f"   路径: {first_path}")
            if data:
                print(f"   版本: {data.version}")
                print(f"   内容大小: {len(str(data.content))} 字符")
        else:
            print(f"\n⚠️  没有 life context 数据")


# ═══════════════════════════════════════════════════════════════
# 测试 5: Profile 写入操作 (事务隔离)
# ═══════════════════════════════════════════════════════════════

class TestProfileWrite:
    """测试 Profile 写入功能 - 使用事务回滚保护真实数据"""

    @pytest.mark.asyncio
    async def test_19_update_preferences(self, repo):
        """测试19: 更新用户偏好"""
        from stores.db import get_connection

        # 读取原始值
        original = await repo.get_preferences(TEST_USER_1)
        original_voice = original.get('voice_mode', 'warm')

        # 使用事务进行更新测试
        async with get_connection() as conn:
            async with conn.transaction():
                # 更新
                new_preferences = {'voice_mode': 'test_mode'}
                await repo.update_preferences(TEST_USER_1, new_preferences)

                # 验证更新
                updated = await repo.get_preferences(TEST_USER_1)

                print(f"\n✅ 偏好更新测试")
                print(f"   原始: voice_mode = {original_voice}")
                print(f"   更新: voice_mode = {updated.get('voice_mode')}")

                # 抛出异常回滚
                raise Exception("回滚测试")

        # 永远不会执行到这里，但如果执行了，验证已回滚
        final = await repo.get_preferences(TEST_USER_1)
        assert final.get('voice_mode') == original_voice

    @pytest.mark.asyncio
    async def test_20_update_birth_info(self, repo):
        """测试20: 更新出生信息"""
        from stores.db import get_connection

        original = await repo.get_birth_info(TEST_USER_1)

        async with get_connection() as conn:
            async with conn.transaction():
                # 更新
                test_birth_info = {
                    'date': '1990-01-01',
                    'time': '12:00:00',
                    'place': '测试城市'
                }
                await repo.update_birth_info(TEST_USER_1, test_birth_info)

                # 验证
                updated = await repo.get_birth_info(TEST_USER_1)

                print(f"\n✅ 出生信息更新测试")
                print(f"   原始: {original}")
                print(f"   更新: {updated}")

                # 回滚
                raise Exception("回滚测试")


# ═══════════════════════════════════════════════════════════════
# 测试 6: 其他功能
# ═══════════════════════════════════════════════════════════════

class TestOtherFeatures:
    """测试其他功能"""

    @pytest.mark.asyncio
    async def test_21_get_blocked_skills(self, repo):
        """测试21: 获取被屏蔽的 Skills"""
        blocked = await repo.get_blocked_skills(TEST_USER_1)

        assert isinstance(blocked, list), "应该返回列表"
        print(f"\n✅ 屏蔽的 Skills")
        print(f"   数量: {len(blocked)}")
        if blocked:
            print(f"   列表: {blocked}")

    @pytest.mark.asyncio
    async def test_22_is_skill_blocked(self, repo):
        """测试22: 检查 Skill 是否被屏蔽"""
        is_blocked = await repo.is_skill_blocked(TEST_USER_1, 'test_skill')

        assert isinstance(is_blocked, bool), "应该返回布尔值"
        print(f"\n✅ Skill 屏蔽检查")
        print(f"   Skill: test_skill")
        print(f"   已屏蔽: {is_blocked}")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
