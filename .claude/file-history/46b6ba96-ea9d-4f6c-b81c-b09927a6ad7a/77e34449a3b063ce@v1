"""
Account Deletion Service - GDPR-compliant account deletion

Implements a 30-day grace period for account deletion:
1. User requests deletion -> account marked as "pending_deletion"
2. User can cancel deletion during grace period
3. After 30 days, background worker hard-deletes all user data

Reference: GDPR Article 17 (Right to erasure)
"""
from datetime import datetime, timedelta
from typing import Optional
from uuid import UUID
import logging

from stores.user_repo import UserRepository
from stores.db import get_connection

logger = logging.getLogger(__name__)


# Grace period before hard deletion (30 days)
DELETION_GRACE_PERIOD_DAYS = 30


class AccountDeletionService:
    """Service for handling account deletion requests"""

    # ─────────────────────────────────────────────────────────────────
    # Request Deletion (Soft Delete)
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def request_deletion(cls, user_id: UUID) -> dict:
        """
        Request account deletion.

        This initiates a soft delete:
        - Account status changes to "pending_deletion"
        - User can still cancel during grace period
        - Hard deletion scheduled for 30 days later

        Returns:
            dict with deletion_scheduled_at
        """
        # Get current user
        user = await UserRepository.get_by_id(user_id)
        if not user:
            raise ValueError("User not found")

        if user.get("status") == "pending_deletion":
            raise ValueError("Account deletion already requested")

        if user.get("status") == "deleted":
            raise ValueError("Account already deleted")

        # Calculate scheduled deletion date
        now = datetime.utcnow()
        scheduled_at = now + timedelta(days=DELETION_GRACE_PERIOD_DAYS)

        # Update user status
        await UserRepository.update(
            user_id,
            status="pending_deletion",
            deletion_requested_at=now,
            deletion_scheduled_at=scheduled_at
        )

        logger.info(f"Account deletion requested for user {user_id}, scheduled for {scheduled_at}")

        return {
            "status": "pending_deletion",
            "deletion_requested_at": now.isoformat(),
            "deletion_scheduled_at": scheduled_at.isoformat(),
            "grace_period_days": DELETION_GRACE_PERIOD_DAYS,
            "message": f"Your account will be permanently deleted on {scheduled_at.strftime('%Y-%m-%d')}. "
                      f"You can cancel this request within {DELETION_GRACE_PERIOD_DAYS} days."
        }

    # ─────────────────────────────────────────────────────────────────
    # Cancel Deletion
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def cancel_deletion(cls, user_id: UUID) -> dict:
        """
        Cancel a pending account deletion request.

        Returns:
            dict confirming cancellation
        """
        # Get current user
        user = await UserRepository.get_by_id(user_id)
        if not user:
            raise ValueError("User not found")

        if user.get("status") != "pending_deletion":
            raise ValueError("No pending deletion request to cancel")

        # Reactivate account
        await UserRepository.update(
            user_id,
            status="active",
            deletion_requested_at=None,
            deletion_scheduled_at=None
        )

        logger.info(f"Account deletion cancelled for user {user_id}")

        return {
            "status": "active",
            "message": "Account deletion request has been cancelled. Your account is now active."
        }

    # ─────────────────────────────────────────────────────────────────
    # Get Deletion Status
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def get_deletion_status(cls, user_id: UUID) -> dict:
        """
        Get current deletion status for a user.

        Returns:
            dict with status and scheduled deletion date if pending
        """
        user = await UserRepository.get_by_id(user_id)
        if not user:
            raise ValueError("User not found")

        status = user.get("status", "active")

        if status == "pending_deletion":
            scheduled_at = user.get("deletion_scheduled_at")
            requested_at = user.get("deletion_requested_at")

            return {
                "status": "pending_deletion",
                "deletion_requested_at": requested_at.isoformat() if requested_at else None,
                "deletion_scheduled_at": scheduled_at.isoformat() if scheduled_at else None,
                "can_cancel": True
            }

        return {
            "status": status,
            "can_cancel": False
        }

    # ─────────────────────────────────────────────────────────────────
    # Hard Delete (Background Worker)
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def process_scheduled_deletions(cls) -> int:
        """
        Process all accounts scheduled for deletion.

        This should be called by a background worker.
        Deletes all user data for accounts past their grace period.

        Returns:
            Number of accounts deleted
        """
        now = datetime.utcnow()
        deleted_count = 0

        async with get_connection() as conn:
            # Find accounts ready for deletion
            rows = await conn.fetch(
                """
                SELECT id, vibe_id FROM vibe_users
                WHERE status = 'pending_deletion'
                  AND deletion_scheduled_at <= $1
                """,
                now
            )

            for row in rows:
                user_id = row["id"]
                vibe_id = row["vibe_id"]

                try:
                    await cls._hard_delete_user(conn, user_id)
                    deleted_count += 1
                    logger.info(f"Hard-deleted user {vibe_id} ({user_id})")
                except Exception as e:
                    logger.error(f"Failed to delete user {vibe_id}: {e}")

        return deleted_count

    @classmethod
    async def _hard_delete_user(cls, conn, user_id: UUID) -> None:
        """
        Permanently delete all user data.

        This removes:
        - User auth records
        - User profile data
        - Conversations and messages
        - Reports
        - Insights
        - Skill profiles
        - Subscriptions (but not payment records for accounting)
        - The user record itself (marks as deleted)

        Payment records are retained for accounting compliance.
        """
        # Delete in order to respect foreign key constraints
        # Note: Many tables have ON DELETE CASCADE, but we'll be explicit

        # 1. Delete authentication records
        await conn.execute(
            "DELETE FROM vibe_user_auth WHERE user_id = $1",
            user_id
        )

        # 2. Delete conversations and messages (cascades)
        await conn.execute(
            "DELETE FROM conversations WHERE user_id = $1",
            user_id
        )

        # 3. Delete reports
        await conn.execute(
            "DELETE FROM reports WHERE user_id = $1",
            user_id
        )

        # 4. Delete insights
        await conn.execute(
            "DELETE FROM insights WHERE user_id = $1",
            user_id
        )

        # 5. Delete skill profiles
        await conn.execute(
            "DELETE FROM skill_profiles WHERE user_id = $1",
            user_id
        )

        # 6. Delete subscriptions
        await conn.execute(
            "DELETE FROM subscriptions WHERE user_id = $1",
            user_id
        )

        # 7. Delete data consents
        await conn.execute(
            "DELETE FROM vibe_data_consents WHERE user_id = $1",
            user_id
        )

        # 8. Delete guest sessions linked to this user
        await conn.execute(
            """
            UPDATE guest_sessions
            SET converted_user_id = NULL
            WHERE converted_user_id = $1
            """,
            user_id
        )

        # 9. Delete relationships
        await conn.execute(
            "DELETE FROM relationships WHERE initiator_id = $1 OR partner_id = $1",
            user_id
        )

        # 10. Anonymize user events (keep for analytics but remove user link)
        await conn.execute(
            "UPDATE user_events SET user_id = NULL WHERE user_id = $1",
            user_id
        )

        # 11. Anonymize payment records (keep for accounting but remove PII)
        await conn.execute(
            "UPDATE payments SET user_id = NULL WHERE user_id = $1",
            user_id
        )

        # 12. Delete unified_profiles record (CASCADE removes all business data)
        await conn.execute(
            "DELETE FROM unified_profiles WHERE user_id = $1",
            user_id
        )

        # 13. Delete authentication records (email/phone are in vibe_user_auth, not vibe_users)
        await conn.execute(
            "DELETE FROM vibe_user_auth WHERE user_id = $1",
            user_id
        )

        # 14. Mark vibe_users as deleted (keep tombstone for audit)
        # Retain: id, vibe_id, status, tier, created_at (for audit trail)
        # Clear: billing data (no longer needed after deletion)
        await conn.execute(
            """
            UPDATE vibe_users
            SET status = 'deleted',
                daily_quota = 0,
                billing_summary = '{}'::jsonb,
                updated_at = NOW()
            WHERE id = $1
            """,
            user_id
        )

        # Note: Week 1-3 migration removes business fields (display_name, avatar_url, etc.)
        # from vibe_users, so no need to NULL them here. They're in unified_profiles which
        # is deleted above.
