"""
Email Authentication Service - Email/Password registration with verification codes

Flow:
1. User submits email/password + Turnstile token
2. Turnstile verified -> 6-digit code sent via Resend
3. User enters code -> Account created -> JWT returned
"""
import os
import secrets
import logging
from datetime import datetime, timedelta, timezone
from typing import Optional

import httpx

from .jwt import JWTService
from stores.db import get_connection
from stores.user_repo import UserRepository, hash_password, verify_password

logger = logging.getLogger(__name__)

# Environment variables
RESEND_API_KEY = os.getenv("RESEND_API_KEY", "")
RESEND_FROM = os.getenv("RESEND_FROM", "VibeLife <noreply@vibelife.app>")
CF_SECRET_KEY = os.getenv("CF_SECRET_KEY", "")


class EmailAuthService:
    """Email authentication with verification codes"""

    CODE_EXPIRY_MINUTES = 10
    MAX_ATTEMPTS = 5

    # ─────────────────────────────────────────────────────────────────
    # Turnstile Verification
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def verify_turnstile(cls, token: str, ip: str) -> bool:
        """
        Verify Cloudflare Turnstile token.
        Returns True in development if CF_SECRET_KEY is not set.
        """
        if not CF_SECRET_KEY:
            logger.warning("Turnstile secret not configured, skipping verification")
            return True

        if not token:
            return False

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    "https://challenges.cloudflare.com/turnstile/v0/siteverify",
                    data={
                        "secret": CF_SECRET_KEY,
                        "response": token,
                        "remoteip": ip
                    }
                )
                result = response.json()
                return result.get("success", False)
        except Exception as e:
            logger.error(f"Turnstile verification failed: {e}")
            return False

    # ─────────────────────────────────────────────────────────────────
    # Registration Step 1: Send Verification Code
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def send_verification_code(
        cls,
        email: str,
        password: str,
        turnstile_token: str,
        ip: str
    ) -> dict:
        """
        Step 1: Send verification code to email.

        Args:
            email: User's email address
            password: User's chosen password
            turnstile_token: Cloudflare Turnstile response token
            ip: Client IP address

        Returns:
            dict with success status and message

        Raises:
            ValueError: If validation fails
        """
        # Validate inputs
        email = email.lower().strip()
        if not email or "@" not in email:
            raise ValueError("Invalid email address")

        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters")

        # Verify Turnstile
        if not await cls.verify_turnstile(turnstile_token, ip):
            raise ValueError("Bot verification failed")

        # Check if email already registered
        existing = await UserRepository.get_auth_by_identifier("email", email)
        if existing:
            raise ValueError("This email is already registered")

        # Also check Google/Apple OAuth
        for auth_type in ["google", "apple"]:
            existing_oauth = await UserRepository.get_auth_by_identifier(auth_type, email)
            if existing_oauth:
                raise ValueError(f"This email is registered via {auth_type.title()}")

        # Generate 6-digit code
        code = "".join([str(secrets.randbelow(10)) for _ in range(6)])
        password_hashed = hash_password(password)
        expires_at = datetime.now(timezone.utc) + timedelta(minutes=cls.CODE_EXPIRY_MINUTES)

        # Store code (upsert to handle resend)
        async with get_connection() as conn:
            await conn.execute("""
                INSERT INTO email_verification_codes (email, code, password_hash, expires_at, attempts)
                VALUES ($1, $2, $3, $4, 0)
                ON CONFLICT (email) DO UPDATE SET
                    code = $2,
                    password_hash = $3,
                    expires_at = $4,
                    attempts = 0
            """, email, code, password_hashed, expires_at)

        # Send email via Resend
        await cls._send_verification_email(email, code)

        return {
            "success": True,
            "message": "Verification code sent",
            "expires_in": cls.CODE_EXPIRY_MINUTES * 60
        }

    @classmethod
    async def _send_verification_email(cls, email: str, code: str) -> None:
        """Send verification code via Resend API"""
        if not RESEND_API_KEY:
            logger.warning(f"Resend not configured. Code for {email}: {code}")
            return

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    "https://api.resend.com/emails",
                    headers={
                        "Authorization": f"Bearer {RESEND_API_KEY}",
                        "Content-Type": "application/json"
                    },
                    json={
                        "from": RESEND_FROM,
                        "to": email,
                        "subject": "VibeLife Verification Code",
                        "html": f"""
                            <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto;">
                                <h2 style="color: #1a1a1a;">Your Verification Code</h2>
                                <p style="font-size: 36px; font-weight: bold; letter-spacing: 8px; color: #6366f1; margin: 24px 0;">
                                    {code}
                                </p>
                                <p style="color: #666;">
                                    This code expires in {cls.CODE_EXPIRY_MINUTES} minutes.
                                </p>
                                <p style="color: #999; font-size: 14px; margin-top: 24px;">
                                    If you didn't request this code, please ignore this email.
                                </p>
                            </div>
                        """
                    }
                )
                if response.status_code != 200:
                    logger.error(f"Resend API error: {response.text}")
                    raise ValueError("Failed to send verification email")
        except httpx.HTTPError as e:
            logger.error(f"Failed to send email: {e}")
            raise ValueError("Failed to send verification email")

    # ─────────────────────────────────────────────────────────────────
    # Registration Step 2: Verify Code and Create Account
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def verify_code_and_register(cls, email: str, code: str) -> dict:
        """
        Step 2: Verify code and create user account.

        Args:
            email: User's email address
            code: 6-digit verification code

        Returns:
            dict with tokens and user info

        Raises:
            ValueError: If verification fails
        """
        email = email.lower().strip()
        code = code.strip()

        # Get stored verification data
        async with get_connection() as conn:
            row = await conn.fetchrow("""
                SELECT code, password_hash, expires_at, attempts
                FROM email_verification_codes
                WHERE email = $1
            """, email)

        if not row:
            raise ValueError("No verification code found. Please register again.")

        # Check expiration
        if row["expires_at"] < datetime.now(timezone.utc):
            await cls._delete_verification(email)
            raise ValueError("Verification code expired. Please register again.")

        # Check attempts
        if row["attempts"] >= cls.MAX_ATTEMPTS:
            await cls._delete_verification(email)
            raise ValueError("Too many failed attempts. Please register again.")

        # Verify code
        if row["code"] != code:
            # Increment attempts
            async with get_connection() as conn:
                await conn.execute("""
                    UPDATE email_verification_codes
                    SET attempts = attempts + 1
                    WHERE email = $1
                """, email)
            remaining = cls.MAX_ATTEMPTS - row["attempts"] - 1
            raise ValueError(f"Invalid code. {remaining} attempts remaining.")

        # Code verified - create user
        password_hash = row["password_hash"]

        # Delete verification record
        await cls._delete_verification(email)

        # Create user account
        user = await UserRepository.create()

        # Create email auth (password already hashed)
        async with get_connection() as conn:
            await conn.execute("""
                INSERT INTO vibe_user_auth (user_id, auth_type, auth_identifier, auth_credential)
                VALUES ($1, 'email', $2, $3)
            """, user["id"], email, password_hash)

        # Generate tokens
        access_token = JWTService.create_access_token(
            str(user["id"]), user["vibe_id"]
        )
        refresh_token = JWTService.create_refresh_token(
            str(user["id"]), user["vibe_id"]
        )

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer",
            "expires_in": JWTService.get_token_expiry(),
            "user": {
                "user_id": str(user["id"]),
                "vibe_id": user["vibe_id"]
            }
        }

    @classmethod
    async def _delete_verification(cls, email: str) -> None:
        """Delete verification record"""
        async with get_connection() as conn:
            await conn.execute(
                "DELETE FROM email_verification_codes WHERE email = $1",
                email
            )

    # ─────────────────────────────────────────────────────────────────
    # Login
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def login(
        cls,
        email: str,
        password: str,
        turnstile_token: str,
        ip: str
    ) -> dict:
        """
        Login with email and password.

        Args:
            email: User's email address
            password: User's password
            turnstile_token: Cloudflare Turnstile response token
            ip: Client IP address

        Returns:
            dict with tokens and user info

        Raises:
            ValueError: If login fails
        """
        email = email.lower().strip()

        # Verify Turnstile
        if not await cls.verify_turnstile(turnstile_token, ip):
            raise ValueError("Bot verification failed")

        # Get auth record
        auth = await UserRepository.get_auth_by_identifier("email", email)
        if not auth:
            raise ValueError("Invalid email or password")

        # Verify password
        if not verify_password(password, auth["auth_credential"]):
            raise ValueError("Invalid email or password")

        # Get user
        user = await UserRepository.get_by_id(auth["user_id"])
        if not user:
            raise ValueError("User not found")

        # Check account status
        if user.get("status") == "pending_deletion":
            # Reactivate on login
            await UserRepository.update(
                user["id"],
                status="active",
                deletion_requested_at=None,
                deletion_scheduled_at=None
            )
        elif user.get("status") != "active":
            raise ValueError("Account is not active")

        # Generate tokens
        access_token = JWTService.create_access_token(
            str(user["id"]), user["vibe_id"]
        )
        refresh_token = JWTService.create_refresh_token(
            str(user["id"]), user["vibe_id"]
        )

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer",
            "expires_in": JWTService.get_token_expiry(),
            "user": {
                "user_id": str(user["id"]),
                "vibe_id": user["vibe_id"],
                "display_name": user.get("display_name")
            }
        }

    # ─────────────────────────────────────────────────────────────────
    # Resend Code
    # ─────────────────────────────────────────────────────────────────

    @classmethod
    async def resend_code(
        cls,
        email: str,
        turnstile_token: str,
        ip: str
    ) -> dict:
        """
        Resend verification code.

        Args:
            email: User's email address
            turnstile_token: Cloudflare Turnstile response token
            ip: Client IP address

        Returns:
            dict with success status

        Raises:
            ValueError: If resend fails
        """
        email = email.lower().strip()

        # Verify Turnstile
        if not await cls.verify_turnstile(turnstile_token, ip):
            raise ValueError("Bot verification failed")

        # Get existing verification
        async with get_connection() as conn:
            row = await conn.fetchrow("""
                SELECT password_hash FROM email_verification_codes
                WHERE email = $1
            """, email)

        if not row:
            raise ValueError("No pending registration found")

        # Generate new code
        code = "".join([str(secrets.randbelow(10)) for _ in range(6)])
        expires_at = datetime.now(timezone.utc) + timedelta(minutes=cls.CODE_EXPIRY_MINUTES)

        # Update with new code
        async with get_connection() as conn:
            await conn.execute("""
                UPDATE email_verification_codes
                SET code = $1, expires_at = $2, attempts = 0
                WHERE email = $3
            """, code, expires_at, email)

        # Send email
        await cls._send_verification_email(email, code)

        return {
            "success": True,
            "message": "Verification code resent",
            "expires_in": cls.CODE_EXPIRY_MINUTES * 60
        }
