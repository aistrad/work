"""
Relationship Service - Core relationship analysis logic
Based on: vibelife spec v3.0, section 2.2.4

Analysis Output:
1. Relationship diagnosis (ä¸€å¥è¯ç»“è®º)
2. Communication style recommendation
3. Action prescriptions (è¯æœ¯æ¨¡æ¿)
4. Compatibility scores (for paid tier)
5. Risk warnings

Privacy-First Design:
- No raw birth data in output
- No explicit type labels
- Focus on actionable advice
"""

import json
import logging
from dataclasses import dataclass, field, asdict
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4
from datetime import datetime
from enum import Enum

from ..vibe_engine import get_llm_service, create_system_message, create_user_message

logger = logging.getLogger(__name__)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Enums and Types
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RelationshipType(str, Enum):
    ROMANTIC = "romantic"      # æ‹çˆ±å…³ç³»
    FAMILY = "family"          # å®¶åº­å…³ç³»
    FRIENDSHIP = "friendship"  # æœ‹å‹å…³ç³»
    WORK = "work"             # å·¥ä½œå…³ç³»
    GENERAL = "general"        # ä¸€èˆ¬å…³ç³»


class CompatibilityDimension(str, Enum):
    COMMUNICATION = "communication"  # æ²Ÿé€š
    VALUES = "values"               # ä»·å€¼è§‚
    EMOTION = "emotion"             # æƒ…æ„Ÿ
    LIFESTYLE = "lifestyle"          # ç”Ÿæ´»æ–¹å¼
    GROWTH = "growth"               # æˆé•¿


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Data Models
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class CompatibilityScore:
    """Score for a compatibility dimension"""
    dimension: CompatibilityDimension
    score: int  # 0-100
    description: str
    is_strength: bool  # True if this is a strong point

    def to_dict(self) -> dict:
        return {
            "dimension": self.dimension.value,
            "score": self.score,
            "description": self.description,
            "is_strength": self.is_strength,
        }


@dataclass
class ActionPrescription:
    """Actionable advice with templates"""
    category: str  # e.g., "å¼€åœºç™½", "åŒ–è§£å†²çª", "è¡¨è¾¾å…³å¿ƒ"
    template: str  # The actual phrase to use
    context: str   # When to use this
    icon: str = "ðŸ’¬"

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class RelationshipAnalysis:
    """Complete relationship analysis result"""
    id: UUID
    user1_id: UUID
    user2_id: Optional[UUID]  # None for single-user mode

    # Core analysis
    relationship_type: RelationshipType
    headline: str           # One-line diagnosis
    communication_style: str  # Recommended approach
    summary: str            # Detailed explanation

    # Scores (premium)
    scores: List[CompatibilityScore] = field(default_factory=list)
    overall_score: Optional[int] = None

    # Action prescriptions
    prescriptions: List[ActionPrescription] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)

    # Metadata
    created_at: datetime = field(default_factory=datetime.now)
    is_mutual: bool = False  # True if both users participated

    def to_dict(self) -> dict:
        return {
            "id": str(self.id),
            "user1_id": str(self.user1_id),
            "user2_id": str(self.user2_id) if self.user2_id else None,
            "relationship_type": self.relationship_type.value,
            "headline": self.headline,
            "communication_style": self.communication_style,
            "summary": self.summary,
            "scores": [s.to_dict() for s in self.scores],
            "overall_score": self.overall_score,
            "prescriptions": [p.to_dict() for p in self.prescriptions],
            "warnings": self.warnings,
            "created_at": self.created_at.isoformat(),
            "is_mutual": self.is_mutual,
        }

    def to_basic_dict(self) -> dict:
        """Return basic version (free tier)"""
        return {
            "id": str(self.id),
            "headline": self.headline,
            "communication_style": self.communication_style,
            "prescriptions": [self.prescriptions[0].to_dict()] if self.prescriptions else [],
            "is_mutual": self.is_mutual,
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Prompts
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RELATIONSHIP_SYSTEM_PROMPT = """ä½ æ˜¯ VibeLife çš„å…³ç³»åˆ†æžä¸“å®¶ã€‚ä½ éœ€è¦åˆ†æžä¸¤ä¸ªäººä¹‹é—´çš„å…³ç³»ï¼Œå¹¶ç»™å‡ºå®žç”¨çš„å»ºè®®ã€‚

æ ¸å¿ƒåŽŸåˆ™ï¼š
1. éšç§ä¼˜å…ˆï¼šç»ä¸åœ¨è¾“å‡ºä¸­åŒ…å«å…·ä½“çš„ç”Ÿæ—¥ã€æ—¶è¾°ã€åœ°ç‚¹ç­‰ä¿¡æ¯
2. ä¸è´´æ ‡ç­¾ï¼šä¸ç›´æŽ¥è¯´å‡ºæ—¥ä¸»ã€ä¸Šå‡æ˜Ÿåº§ã€MBTIç±»åž‹ç­‰
3. è¡ŒåŠ¨å¯¼å‘ï¼šç»™å‡ºå¯ä»¥ç›´æŽ¥ä½¿ç”¨çš„è¯æœ¯å’Œå»ºè®®
4. æ­£å‘å¼•å¯¼ï¼šé¿å…åˆ¶é€ ç„¦è™‘ï¼Œå¼ºè°ƒå¦‚ä½•æ”¹å–„å…³ç³»

è¾“å‡ºè¦æ±‚ï¼š
- headline: ä¸€å¥è¯æ¦‚æ‹¬å…³ç³»ç‰¹ç‚¹ï¼ˆæœ‰ç”»é¢æ„Ÿï¼Œä¸è¶…è¿‡30å­—ï¼‰
- communication_style: æŽ¨èçš„æ²Ÿé€šæ–¹å¼ï¼ˆä¸€å¥è¯ï¼‰
- summary: è¯¦ç»†åˆ†æžï¼ˆ200-300å­—ï¼‰
- prescriptions: 3ä¸ªå…·ä½“çš„è¯æœ¯æ¨¡æ¿
- warnings: 1-2ä¸ªæ³¨æ„äº‹é¡¹

è¾“å‡ºæ ¼å¼ï¼šJSON"""

ANALYSIS_PROMPT_TEMPLATE = """è¯·åˆ†æžä»¥ä¸‹ä¸¤äººçš„å…³ç³»ï¼š

ç”¨æˆ·1ä¿¡æ¯ï¼ˆå‘èµ·è€…ï¼‰ï¼š
{user1_profile}

ç”¨æˆ·2ä¿¡æ¯ï¼ˆå¯¹æ–¹ï¼‰ï¼š
{user2_profile}

å…³ç³»ç±»åž‹ï¼š{relationship_type}

è¯·ä»¥ JSON æ ¼å¼è¾“å‡ºåˆ†æžç»“æžœï¼š
{{
    "headline": "å…³ç³»ä¸€å¥è¯æ¦‚æ‹¬",
    "communication_style": "æŽ¨èæ²Ÿé€šæ–¹å¼",
    "summary": "è¯¦ç»†åˆ†æž...",
    "scores": [
        {{"dimension": "communication", "score": 85, "description": "...", "is_strength": true}},
        {{"dimension": "values", "score": 70, "description": "...", "is_strength": false}},
        {{"dimension": "emotion", "score": 75, "description": "...", "is_strength": true}},
        {{"dimension": "lifestyle", "score": 60, "description": "...", "is_strength": false}},
        {{"dimension": "growth", "score": 80, "description": "...", "is_strength": true}}
    ],
    "prescriptions": [
        {{"category": "å¼€åœºç™½", "template": "...", "context": "é€‚åˆåœ¨...æ—¶ä½¿ç”¨"}},
        {{"category": "åŒ–è§£å†²çª", "template": "...", "context": "å½“...æ—¶ä½¿ç”¨"}},
        {{"category": "è¡¨è¾¾å…³å¿ƒ", "template": "...", "context": "æ—¥å¸¸ä¸­ä½¿ç”¨"}}
    ],
    "warnings": ["æ³¨æ„äº‹é¡¹1", "æ³¨æ„äº‹é¡¹2"]
}}"""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Relationship Service
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RelationshipService:
    """Main service for relationship analysis"""

    def __init__(self):
        self._llm = None

    @property
    def llm(self):
        if self._llm is None:
            self._llm = get_llm_service()
        return self._llm

    async def analyze(
        self,
        user1_id: UUID,
        user1_profile: Dict[str, Any],
        user2_profile: Dict[str, Any],
        relationship_type: str = "general",
        user2_id: Optional[UUID] = None,
    ) -> RelationshipAnalysis:
        """
        Analyze relationship between two people.

        Args:
            user1_id: Initiator's user ID
            user1_profile: Initiator's profile data
            user2_profile: Partner's profile data (can be partial)
            relationship_type: Type of relationship
            user2_id: Partner's user ID (if they participated)

        Returns:
            RelationshipAnalysis with recommendations
        """
        analysis_id = uuid4()
        rel_type = RelationshipType(relationship_type)

        # Sanitize profiles - remove sensitive data from prompt
        safe_profile1 = self._sanitize_profile(user1_profile)
        safe_profile2 = self._sanitize_profile(user2_profile)

        prompt = ANALYSIS_PROMPT_TEMPLATE.format(
            user1_profile=json.dumps(safe_profile1, ensure_ascii=False, indent=2),
            user2_profile=json.dumps(safe_profile2, ensure_ascii=False, indent=2),
            relationship_type=self._get_type_label(rel_type),
        )

        messages = [
            create_system_message(RELATIONSHIP_SYSTEM_PROMPT),
            create_user_message(prompt),
        ]

        try:
            response = await self.llm.chat(messages)

            # Parse response
            content = response.content.strip()
            if content.startswith("```"):
                content = content.split("```")[1]
                if content.startswith("json"):
                    content = content[4:]

            data = json.loads(content)

            # Build analysis object
            scores = [
                CompatibilityScore(
                    dimension=CompatibilityDimension(s["dimension"]),
                    score=s["score"],
                    description=s["description"],
                    is_strength=s["is_strength"],
                )
                for s in data.get("scores", [])
            ]

            prescriptions = [
                ActionPrescription(
                    category=p["category"],
                    template=p["template"],
                    context=p["context"],
                )
                for p in data.get("prescriptions", [])
            ]

            # Calculate overall score
            overall = None
            if scores:
                overall = sum(s.score for s in scores) // len(scores)

            return RelationshipAnalysis(
                id=analysis_id,
                user1_id=user1_id,
                user2_id=user2_id,
                relationship_type=rel_type,
                headline=data.get("headline", ""),
                communication_style=data.get("communication_style", ""),
                summary=data.get("summary", ""),
                scores=scores,
                overall_score=overall,
                prescriptions=prescriptions,
                warnings=data.get("warnings", []),
                is_mutual=user2_id is not None,
            )

        except Exception as e:
            logger.error(f"Relationship analysis failed: {e}")
            # Return fallback analysis
            return self._get_fallback_analysis(
                analysis_id, user1_id, user2_id, rel_type
            )

    def _sanitize_profile(self, profile: Dict[str, Any]) -> Dict[str, Any]:
        """Remove sensitive information from profile for prompting"""
        # Keep only non-identifying information
        basic = profile.get("basic", {})
        life_context = profile.get("life_context", {})

        return {
            "characteristics": {
                "element_tendency": basic.get("element_tendency"),  # e.g., "æœ¨æ—º"
                "personality_traits": life_context.get("personality_traits", []),
                "communication_style": life_context.get("communication_style"),
                "values": life_context.get("values", []),
            },
            "context": {
                "current_phase": life_context.get("current_phase"),
                "main_concerns": life_context.get("main_concerns", []),
            }
        }

    def _get_type_label(self, rel_type: RelationshipType) -> str:
        """Get display label for relationship type"""
        labels = {
            RelationshipType.ROMANTIC: "æ‹çˆ±/ä¼´ä¾£",
            RelationshipType.FAMILY: "å®¶äºº",
            RelationshipType.FRIENDSHIP: "æœ‹å‹",
            RelationshipType.WORK: "åŒäº‹/å·¥ä½œä¼™ä¼´",
            RelationshipType.GENERAL: "ä¸€èˆ¬å…³ç³»",
        }
        return labels.get(rel_type, "ä¸€èˆ¬å…³ç³»")

    def _get_fallback_analysis(
        self,
        analysis_id: UUID,
        user1_id: UUID,
        user2_id: Optional[UUID],
        rel_type: RelationshipType,
    ) -> RelationshipAnalysis:
        """Return fallback analysis when LLM fails"""
        return RelationshipAnalysis(
            id=analysis_id,
            user1_id=user1_id,
            user2_id=user2_id,
            relationship_type=rel_type,
            headline="ä½ ä»¬æœ‰ç‹¬ç‰¹çš„ç›¸å¤„æ¨¡å¼",
            communication_style="è€å¿ƒå€¾å¬ï¼ŒçœŸè¯šè¡¨è¾¾",
            summary="æ¯æ®µå…³ç³»éƒ½æœ‰å…¶ç‹¬ç‰¹ä¹‹å¤„ã€‚å»ºè®®åœ¨æ—¥å¸¸ç›¸å¤„ä¸­å¤šè§‚å¯Ÿå¯¹æ–¹çš„ååº”ï¼Œæ‰¾åˆ°é€‚åˆä½ ä»¬çš„æ²Ÿé€šèŠ‚å¥ã€‚",
            scores=[],
            prescriptions=[
                ActionPrescription(
                    category="å¼€åœºç™½",
                    template="æˆ‘æƒ³å¬å¬ä½ çš„æƒ³æ³•...",
                    context="å½“æƒ³å¼€å¯é‡è¦è¯é¢˜æ—¶",
                ),
            ],
            warnings=["è¯·å®Œå–„åŒæ–¹ä¿¡æ¯ä»¥èŽ·å¾—æ›´å‡†ç¡®çš„åˆ†æž"],
            is_mutual=user2_id is not None,
        )

    async def analyze_with_minimal_info(
        self,
        user1_id: UUID,
        user1_profile: Dict[str, Any],
        partner_info: Dict[str, Any],
        relationship_type: str = "general",
    ) -> RelationshipAnalysis:
        """
        Analyze with minimal partner info (zodiac sign or Chinese zodiac only).

        Args:
            user1_id: Initiator's user ID
            user1_profile: Initiator's profile
            partner_info: Minimal info like {"zodiac": "leo"} or {"chinese_zodiac": "tiger"}
            relationship_type: Type of relationship

        Returns:
            RelationshipAnalysis (less detailed)
        """
        # Build a partial profile from minimal info
        partial_profile = {
            "basic": partner_info,
            "life_context": {},
        }

        return await self.analyze(
            user1_id=user1_id,
            user1_profile=user1_profile,
            user2_profile=partial_profile,
            relationship_type=relationship_type,
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Singleton
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_relationship_service: Optional[RelationshipService] = None


def get_relationship_service() -> RelationshipService:
    """Get singleton relationship service instance"""
    global _relationship_service
    if _relationship_service is None:
        _relationship_service = RelationshipService()
    return _relationship_service
