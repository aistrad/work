"""
Profile Repository - Database operations for user profiles
Based on: vibelife spec v3.0, section 4.4

Profile Structure:
- basic: 基础信息层 (硬数据)
- life_context: 生活上下文层 (软数据)
- ai_insights: AI洞察层
- identity_prism: Identity Prism层
- preferences: 用户偏好
"""
import json
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4
from datetime import datetime
import logging

from .db import get_connection, fetchrow, fetch, execute

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# Default Profile
# ═══════════════════════════════════════════════════════════════════════════

DEFAULT_PROFILE = {
    "version": "1.0",
    "basic": {},
    "life_context": {},
    "ai_insights": {},
    "identity_prism": {},
    "preferences": {
        "voice_mode": "warm",
        "language": "zh-CN"
    }
}


# ═══════════════════════════════════════════════════════════════════════════
# Data Models
# ═══════════════════════════════════════════════════════════════════════════

class ProfileRecord:
    """Profile database record"""

    def __init__(
        self,
        id: UUID,
        user_id: UUID,
        version: int,
        profile: Dict[str, Any],
        created_at: datetime
    ):
        self.id = id
        self.user_id = user_id
        self.version = version
        self.profile = profile
        self.created_at = created_at

    def to_dict(self) -> dict:
        return {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "version": self.version,
            "profile": self.profile,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }

    @classmethod
    def from_row(cls, row: dict) -> "ProfileRecord":
        profile = row.get("profile")
        if isinstance(profile, str):
            profile = json.loads(profile)

        return cls(
            id=row["id"],
            user_id=row["user_id"],
            version=row.get("version", 1),
            profile=profile or DEFAULT_PROFILE.copy(),
            created_at=row.get("created_at"),
        )


# ═══════════════════════════════════════════════════════════════════════════
# Repository Functions
# ═══════════════════════════════════════════════════════════════════════════

async def create_profile(
    user_id: UUID,
    initial_profile: Optional[Dict[str, Any]] = None
) -> ProfileRecord:
    """
    Create a new profile for a user.

    Args:
        user_id: User ID
        initial_profile: Optional initial profile data

    Returns:
        Created ProfileRecord
    """
    profile_id = uuid4()
    profile_data = initial_profile or DEFAULT_PROFILE.copy()

    query = """
        INSERT INTO user_profiles (id, user_id, version, profile)
        VALUES ($1, $2, 1, $3)
        RETURNING *
    """

    try:
        async with get_connection() as conn:
            row = await conn.fetchrow(
                query,
                profile_id,
                user_id,
                json.dumps(profile_data)
            )
            return ProfileRecord.from_row(dict(row))
    except Exception as e:
        logger.error(f"Failed to create profile: {e}")
        raise


async def get_profile(user_id: UUID) -> Optional[ProfileRecord]:
    """Get the latest profile version for a user"""
    query = """
        SELECT * FROM user_profiles
        WHERE user_id = $1
        ORDER BY version DESC
        LIMIT 1
    """

    try:
        row = await fetchrow(query, user_id)
        if row:
            return ProfileRecord.from_row(dict(row))
        return None
    except Exception as e:
        logger.error(f"Failed to get profile: {e}")
        raise


async def get_profile_version(
    user_id: UUID,
    version: int
) -> Optional[ProfileRecord]:
    """Get a specific profile version"""
    query = """
        SELECT * FROM user_profiles
        WHERE user_id = $1 AND version = $2
    """

    try:
        row = await fetchrow(query, user_id, version)
        if row:
            return ProfileRecord.from_row(dict(row))
        return None
    except Exception as e:
        logger.error(f"Failed to get profile version: {e}")
        raise


async def list_profile_versions(
    user_id: UUID,
    limit: int = 10
) -> List[ProfileRecord]:
    """List all profile versions for a user"""
    query = """
        SELECT * FROM user_profiles
        WHERE user_id = $1
        ORDER BY version DESC
        LIMIT $2
    """

    try:
        rows = await fetch(query, user_id, limit)
        return [ProfileRecord.from_row(dict(row)) for row in rows]
    except Exception as e:
        logger.error(f"Failed to list profile versions: {e}")
        raise


async def update_profile(
    user_id: UUID,
    updates: Dict[str, Any],
    create_version: bool = True
) -> ProfileRecord:
    """
    Update a user's profile.

    Args:
        user_id: User ID
        updates: Profile updates to merge
        create_version: If True, create new version; else update in place

    Returns:
        Updated ProfileRecord
    """
    # Get current profile
    current = await get_profile(user_id)

    if not current:
        # Create new profile with updates
        merged = deep_merge(DEFAULT_PROFILE.copy(), updates)
        return await create_profile(user_id, merged)

    # Merge updates
    merged_profile = deep_merge(current.profile, updates)

    if create_version:
        # Create new version
        new_version = current.version + 1
        profile_id = uuid4()

        query = """
            INSERT INTO user_profiles (id, user_id, version, profile)
            VALUES ($1, $2, $3, $4)
            RETURNING *
        """

        try:
            async with get_connection() as conn:
                row = await conn.fetchrow(
                    query,
                    profile_id,
                    user_id,
                    new_version,
                    json.dumps(merged_profile)
                )
                return ProfileRecord.from_row(dict(row))
        except Exception as e:
            logger.error(f"Failed to create profile version: {e}")
            raise
    else:
        # Update in place
        query = """
            UPDATE user_profiles
            SET profile = $2
            WHERE id = $1
            RETURNING *
        """

        try:
            row = await fetchrow(query, current.id, json.dumps(merged_profile))
            if row:
                return ProfileRecord.from_row(dict(row))
            raise Exception("Profile update failed")
        except Exception as e:
            logger.error(f"Failed to update profile: {e}")
            raise


async def get_or_create_profile(user_id: UUID) -> ProfileRecord:
    """Get existing profile or create a default one"""
    profile = await get_profile(user_id)
    if profile:
        return profile
    return await create_profile(user_id)


async def delete_profile(user_id: UUID) -> bool:
    """Delete all profile versions for a user"""
    query = "DELETE FROM user_profiles WHERE user_id = $1"

    try:
        result = await execute(query, user_id)
        return "DELETE" in result
    except Exception as e:
        logger.error(f"Failed to delete profile: {e}")
        raise


# ═══════════════════════════════════════════════════════════════════════════
# Profile Data Access Helpers
# ═══════════════════════════════════════════════════════════════════════════

async def get_profile_data(user_id: UUID) -> Dict[str, Any]:
    """Get just the profile JSON data"""
    profile = await get_profile(user_id)
    if profile:
        return profile.profile
    return DEFAULT_PROFILE.copy()


async def get_basic_info(user_id: UUID) -> Dict[str, Any]:
    """Get basic info section of profile"""
    profile = await get_profile_data(user_id)
    return profile.get("basic", {})


async def get_life_context(user_id: UUID) -> Dict[str, Any]:
    """Get life_context section of profile"""
    profile = await get_profile_data(user_id)
    return profile.get("life_context", {})


async def get_identity_prism(user_id: UUID) -> Dict[str, Any]:
    """Get identity_prism section of profile"""
    profile = await get_profile_data(user_id)
    return profile.get("identity_prism", {})


async def get_preferences(user_id: UUID) -> Dict[str, Any]:
    """Get preferences section of profile"""
    profile = await get_profile_data(user_id)
    return profile.get("preferences", {"voice_mode": "warm", "language": "zh-CN"})


async def update_preferences(
    user_id: UUID,
    voice_mode: Optional[str] = None,
    language: Optional[str] = None,
    notification: Optional[bool] = None
) -> ProfileRecord:
    """Update user preferences"""
    updates = {"preferences": {}}

    if voice_mode:
        updates["preferences"]["voice_mode"] = voice_mode
    if language:
        updates["preferences"]["language"] = language
    if notification is not None:
        updates["preferences"]["notification"] = notification

    return await update_profile(user_id, updates, create_version=False)


# ═══════════════════════════════════════════════════════════════════════════
# Utility Functions
# ═══════════════════════════════════════════════════════════════════════════

def deep_merge(base: Dict, update: Dict) -> Dict:
    """Deep merge update into base dict"""
    result = base.copy()

    for key, value in update.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        elif key in result and isinstance(result[key], list) and isinstance(value, list):
            # For lists, extend without duplicates
            existing = {json.dumps(x, sort_keys=True) for x in result[key] if isinstance(x, dict)}
            existing.update(str(x) for x in result[key] if not isinstance(x, dict))

            for item in value:
                key_val = json.dumps(item, sort_keys=True) if isinstance(item, dict) else str(item)
                if key_val not in existing and item:
                    result[key].append(item)
        else:
            if value is not None:
                result[key] = value

    return result
