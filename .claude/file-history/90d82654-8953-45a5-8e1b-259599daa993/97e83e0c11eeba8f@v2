"""
Conversation Repository - Database operations for conversations
Based on: vibelife spec v3.0 schema (001_v3_schema.sql)
"""
import json
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4
from datetime import datetime
import logging

from .db import get_connection, fetchrow, fetch, execute

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# Data Models
# ═══════════════════════════════════════════════════════════════════════════

class ConversationRecord:
    """Conversation database record"""

    def __init__(
        self,
        id: UUID,
        user_id: Optional[UUID],
        skill: str,
        voice_mode: str,
        title: Optional[str],
        is_active: bool,
        created_at: datetime,
        updated_at: datetime
    ):
        self.id = id
        self.user_id = user_id
        self.skill = skill
        self.voice_mode = voice_mode
        self.title = title
        self.is_active = is_active
        self.created_at = created_at
        self.updated_at = updated_at

    def to_dict(self) -> dict:
        return {
            "id": str(self.id),
            "user_id": str(self.user_id) if self.user_id else None,
            "skill": self.skill,
            "voice_mode": self.voice_mode,
            "title": self.title,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }

    @classmethod
    def from_row(cls, row: dict) -> "ConversationRecord":
        return cls(
            id=row["id"],
            user_id=row.get("user_id"),
            skill=row["skill"],
            voice_mode=row.get("voice_mode", "warm"),
            title=row.get("title"),
            is_active=row.get("is_active", True),
            created_at=row.get("created_at"),
            updated_at=row.get("updated_at"),
        )


# ═══════════════════════════════════════════════════════════════════════════
# Repository Functions
# ═══════════════════════════════════════════════════════════════════════════

async def create_conversation(
    skill: str,
    user_id: Optional[UUID] = None,
    voice_mode: str = "warm",
    title: Optional[str] = None
) -> ConversationRecord:
    """
    Create a new conversation.

    Args:
        skill: bazi or zodiac
        user_id: Optional user ID (None for guests)
        voice_mode: warm or sarcastic
        title: Optional conversation title

    Returns:
        Created ConversationRecord
    """
    conversation_id = uuid4()

    query = """
        INSERT INTO conversations (id, user_id, skill, voice_mode, title)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *
    """

    try:
        async with get_connection() as conn:
            row = await conn.fetchrow(
                query,
                conversation_id,
                user_id,
                skill,
                voice_mode,
                title
            )
            return ConversationRecord.from_row(dict(row))
    except Exception as e:
        logger.error(f"Failed to create conversation: {e}")
        raise


async def get_conversation(conversation_id: UUID) -> Optional[ConversationRecord]:
    """Get a conversation by ID"""
    query = "SELECT * FROM conversations WHERE id = $1"

    try:
        row = await fetchrow(query, conversation_id)
        if row:
            return ConversationRecord.from_row(dict(row))
        return None
    except Exception as e:
        logger.error(f"Failed to get conversation: {e}")
        raise


async def list_conversations(
    user_id: UUID,
    skill: Optional[str] = None,
    is_active: Optional[bool] = None,
    limit: int = 20,
    offset: int = 0
) -> List[ConversationRecord]:
    """
    List conversations for a user.

    Args:
        user_id: User ID
        skill: Optional skill filter
        is_active: Optional active status filter
        limit: Max results
        offset: Pagination offset

    Returns:
        List of ConversationRecord
    """
    conditions = ["user_id = $1"]
    params = [user_id]
    param_idx = 2

    if skill:
        conditions.append(f"skill = ${param_idx}")
        params.append(skill)
        param_idx += 1

    if is_active is not None:
        conditions.append(f"is_active = ${param_idx}")
        params.append(is_active)
        param_idx += 1

    where_clause = " AND ".join(conditions)

    query = f"""
        SELECT * FROM conversations
        WHERE {where_clause}
        ORDER BY updated_at DESC
        LIMIT ${param_idx} OFFSET ${param_idx + 1}
    """
    params.extend([limit, offset])

    try:
        rows = await fetch(query, *params)
        return [ConversationRecord.from_row(dict(row)) for row in rows]
    except Exception as e:
        logger.error(f"Failed to list conversations: {e}")
        raise


async def update_conversation(
    conversation_id: UUID,
    voice_mode: Optional[str] = None,
    title: Optional[str] = None,
    is_active: Optional[bool] = None
) -> Optional[ConversationRecord]:
    """Update a conversation"""
    updates = []
    params = []
    param_idx = 1

    if voice_mode is not None:
        updates.append(f"voice_mode = ${param_idx}")
        params.append(voice_mode)
        param_idx += 1

    if title is not None:
        updates.append(f"title = ${param_idx}")
        params.append(title)
        param_idx += 1

    if is_active is not None:
        updates.append(f"is_active = ${param_idx}")
        params.append(is_active)
        param_idx += 1

    if not updates:
        return await get_conversation(conversation_id)

    params.append(conversation_id)

    query = f"""
        UPDATE conversations
        SET {", ".join(updates)}
        WHERE id = ${param_idx}
        RETURNING *
    """

    try:
        row = await fetchrow(query, *params)
        if row:
            return ConversationRecord.from_row(dict(row))
        return None
    except Exception as e:
        logger.error(f"Failed to update conversation: {e}")
        raise


async def delete_conversation(conversation_id: UUID) -> bool:
    """Delete a conversation (cascades to messages)"""
    query = "DELETE FROM conversations WHERE id = $1"

    try:
        result = await execute(query, conversation_id)
        return "DELETE 1" in result
    except Exception as e:
        logger.error(f"Failed to delete conversation: {e}")
        raise


async def count_conversations(
    user_id: UUID,
    skill: Optional[str] = None
) -> int:
    """Count conversations for a user"""
    conditions = ["user_id = $1"]
    params = [user_id]

    if skill:
        conditions.append("skill = $2")
        params.append(skill)

    query = f"""
        SELECT COUNT(*) FROM conversations
        WHERE {" AND ".join(conditions)}
    """

    try:
        async with get_connection() as conn:
            return await conn.fetchval(query, *params)
    except Exception as e:
        logger.error(f"Failed to count conversations: {e}")
        raise


async def get_latest_conversation(
    user_id: UUID,
    skill: Optional[str] = None
) -> Optional[ConversationRecord]:
    """Get the most recent active conversation"""
    conditions = ["user_id = $1", "is_active = TRUE"]
    params = [user_id]

    if skill:
        conditions.append("skill = $2")
        params.append(skill)

    query = f"""
        SELECT * FROM conversations
        WHERE {" AND ".join(conditions)}
        ORDER BY updated_at DESC
        LIMIT 1
    """

    try:
        row = await fetchrow(query, *params)
        if row:
            return ConversationRecord.from_row(dict(row))
        return None
    except Exception as e:
        logger.error(f"Failed to get latest conversation: {e}")
        raise
