# VibeLife SOP 机制详解

> Standard Operating Procedure - 标准操作流程
> 版本：v10.2
> 日期：2026-01-21

---

## 目录

1. [什么是 SOP](#1-什么是-sop)
2. [为什么需要 SOP](#2-为什么需要-sop)
3. [SOP 的演进历史](#3-sop-的演进历史)
4. [SOP 工作流程](#4-sop-工作流程)
5. [配置驱动设计](#5-配置驱动设计)
6. [代码实现详解](#6-代码实现详解)
7. [案例分析](#7-案例分析)
8. [最佳实践](#8-最佳实践)

---

## 1. 什么是 SOP

### 1.1 定义

**SOP (Standard Operating Procedure)** 是 VibeLife Agent 系统中的**流程指导机制**，通过动态生成的 System Prompt 指引 LLM 按照正确的步骤完成任务。

### 1.2 核心理念

```
传统 Agent                    VibeLife SOP Agent
──────────────                ──────────────────
硬编码逻辑判断              →  LLM 自主决策
if-else 状态机              →  自然语言规则
Python 代码控制流程         →  Prompt 驱动流程
```

**SOP 的哲学**：
- ✅ 把流程控制从代码移到 Prompt
- ✅ 让 LLM 理解"应该做什么"而非"必须做什么"
- ✅ 提供指导而非强制，保留 LLM 的灵活性

### 1.3 SOP 的作用

| 作用 | 说明 | 示例 |
|------|------|------|
| **流程指导** | 告诉 LLM 当前处于哪个阶段 | "需要收集出生信息" → "需要计算命盘" → "可以分析" |
| **工具推荐** | 推荐下一步应该用的工具 | "推荐工具：collect_bazi_info" |
| **状态感知** | 让 LLM 了解当前数据状态 | "已有出生信息：是" / "已生成命盘：否" |
| **边界控制** | 防止 LLM 做出不恰当的操作 | "禁止重复收集数据" / "检查数据后再调用工具" |

---

## 2. 为什么需要 SOP

### 2.1 问题场景

**场景 1：八字分析需要多步骤流程**

```
用户："帮我算命"

需要的步骤：
1. 收集出生信息（日期、时间、地点、性别）
2. 计算八字命盘（排盘）
3. 分析命盘（十神、格局、运势等）
4. 展示结果
```

**问题**：
- ❌ 如果用硬编码 if-else，代码会非常复杂
- ❌ 每个 Skill 都有不同的流程，难以统一
- ❌ LLM 不知道当前处于哪个阶段，可能做出错误决策

### 2.2 没有 SOP 的后果

**情况 1：LLM 跳过必要步骤**

```
用户："帮我算命"
LLM：（直接调用 show_bazi_chart）
系统：❌ 错误：缺少出生信息
```

**情况 2：LLM 重复收集信息**

```
用户："我 1990-01-01 出生"
LLM：调用 request_info（已经保存出生信息后）
用户：❌ 为什么又要我填表？
```

**情况 3：LLM 不知道优先级**

```
数据库有命盘 → LLM 仍然调用 calculate_bazi
浪费计算资源，延长响应时间
```

### 2.3 SOP 的解决方案

**SOP 通过 System Prompt 提供"教练式指导"**：

```yaml
## 当前状态：需要出生信息

**数据状态**：
- 需要出生信息：是
- 已提供：否

**推荐工具**：`collect_bazi_info`

**为什么推荐此工具**：
1. 表单确保信息完整
2. 提供更好的用户体验
3. 减少来回对话次数

**执行方式**：
1. 简短说"让我了解一下你的出生信息～"
2. 调用 collect_bazi_info 工具
3. 等待用户填写表单
```

**LLM 看到这个 Prompt 后**：
- ✅ 知道当前状态："需要出生信息"
- ✅ 知道推荐工具：`collect_bazi_info`
- ✅ 理解为什么要这样做：提供更好体验
- ✅ 知道执行步骤：说话 + 调用工具 + 等待

---

## 3. SOP 的演进历史

### 3.1 v6 之前：硬编码状态机

**设计**：
```python
class BaziWorkflow:
    def execute(self, user_input):
        if not self.has_birth_info():
            return self.request_birth_info()

        if not self.has_chart():
            return self.calculate_chart()

        return self.analyze_chart()
```

**问题**：
- ❌ 每个 Skill 需要单独写流程代码
- ❌ 无法处理复杂的分支逻辑
- ❌ LLM 无法灵活应对用户输入

### 3.2 v7.0 - v7.1：SOPEngine（废弃）

**设计**：
```python
class SOPEngine:
    def compute_phase(self, skill_id, context):
        if skill_requires_birth_info(skill_id):
            if not context.has_birth_info:
                return "P1_COLLECT"

        if skill_requires_compute(skill_id):
            if not context.has_chart:
                return "P2_COMPUTE"

        return "P3_ANALYZE"

    def get_allowed_tools(self, phase):
        if phase == "P1_COLLECT":
            return ["request_info", "collect_bazi_info"]
        elif phase == "P2_COMPUTE":
            return ["calculate_bazi"]
        else:
            return ["show_bazi_chart", "search_db"]
```

**问题**：
- ❌ 仍然是 Python 硬编码逻辑
- ❌ LLM 被限制在特定工具集内，缺乏灵活性
- ❌ 难以处理边界情况（如用户直接提供信息）

### 3.3 v7.2 - 现在：LLM 驱动的 SOP

**核心改变**：
```
从 "限制 LLM 的工具"
  ↓
到 "指导 LLM 的决策"
```

**设计**：
```python
def _build_sop_rules(self, context):
    """生成自然语言的流程指导"""
    status = self._compute_sop_status(context)

    if status["needs_birth_info"] and not status["has_birth_info"]:
        return """
        ## 当前状态：需要出生信息

        **推荐工具**：collect_bazi_info

        **为什么**：表单体验更好，确保信息完整

        **如何做**：
        1. 简短说明
        2. 调用工具
        3. 等待用户填写
        """
```

**优点**：
- ✅ 工具不受限，LLM 可以看到所有工具
- ✅ 自然语言规则，LLM 更容易理解
- ✅ 灵活应对边界情况（如用户直接提供信息）

### 3.4 v10.0：配置驱动

**改进**：
```yaml
# skills/core/config/routing.yaml
sop_templates:
  need_birth_info: |
    ## 当前状态：需要出生信息

    **推荐工具**：{collect_tool}
    ...

  need_compute: |
    ## 当前状态：需要生成命盘

    **推荐工具**：{compute_tool}
    ...
```

**优点**：
- ✅ SOP 规则从代码分离到配置文件
- ✅ 支持动态占位符（如 {collect_tool}）
- ✅ 方便非技术人员调整流程
- ✅ 单一数据源（Single Source of Truth）

---

## 4. SOP 工作流程

### 4.1 完整流程图

```
用户消息
  ↓
CoreAgent.run()
  ↓
[1] 激活 Skill（如果有）
  ↓
[2] 计算 SOP 状态
  ├─ 从 profile 读取数据库状态
  ├─ 从 history 检查历史消息（v10.2）
  └─ 综合判断当前阶段
  ↓
[3] 生成 SOP 规则
  ├─ 根据状态选择模板
  ├─ 填充动态占位符
  └─ 生成自然语言指导
  ↓
[4] 构建 System Prompt
  ├─ Skill 专家身份
  ├─ SOP 规则
  ├─ 用户数据
  └─ 相关案例
  ↓
[5] LLM 调用
  ├─ 看到完整上下文
  ├─ 理解当前状态
  ├─ 根据 SOP 指导决策
  └─ 调用推荐工具或灵活应对
  ↓
[6] 工具执行
  ↓
[7] 更新状态
  └─ 下一轮重新计算 SOP 状态
```

### 4.2 状态计算详解

**核心方法**：`_compute_sop_status`

```python
def _compute_sop_status(self, context: AgentContext) -> Dict[str, Any]:
    """
    计算当前 SOP 状态

    返回：
    {
        "needs_birth_info": bool,      # Skill 是否需要出生信息
        "has_birth_info": bool,         # 是否已有出生信息
        "needs_compute": bool,          # Skill 是否需要计算
        "has_chart_data": bool,         # 是否已有命盘数据
        "ready_for_analysis": bool      # 是否准备好分析
    }
    """
```

**检查逻辑**：

```python
# 1. 读取 Skill 配置
needs_birth = skill_requires_birth_info(skill_id)  # 从 SKILL.md 读取
needs_compute = skill_requires_compute(skill_id)   # 从 SKILL.md 读取

# 2. 检查数据库
identity = context.profile.get("identity", {})
birth_info = identity.get("birth_info", {})
has_birth_db = bool(birth_info.get("birth_date"))

# 3. 检查历史消息（v10.2 新增）
if not has_birth_db and context.history:
    extracted = self._extract_birth_info_from_history(context.history)
    has_birth = bool(extracted and extracted.get("birth_date"))
else:
    has_birth = has_birth_db

# 4. 检查命盘数据
skill_data = context.skill_data.get(skill_id, {})
has_chart = bool(skill_data.get("chart") or skill_data.get("cards"))

# 5. 综合判断
ready_for_analysis = (not needs_birth or has_birth) and (not needs_compute or has_chart)
```

### 4.3 规则生成详解

**核心方法**：`_build_sop_rules`

```python
def _build_sop_rules(self, context: AgentContext) -> str:
    status = self._compute_sop_status(context)

    # 阶段 1：需要收集信息
    if status["needs_birth_info"] and not status["has_birth_info"]:
        template = get_sop_template("need_birth_info")
        return template.format(collect_tool="collect_bazi_info")

    # 阶段 2：需要计算
    elif status["needs_compute"] and not status["has_chart_data"]:
        template = get_sop_template("need_compute")
        chart_summary = self._extract_chart_summary(context)
        return template.format(
            compute_tool="calculate_bazi",
            has_chart=chart_summary
        )

    # 阶段 3：可以分析
    else:
        template = get_sop_template("ready_for_analysis")
        chart_summary = self._extract_chart_summary(context)
        return template.format(chart_summary=chart_summary)
```

**模板占位符**：

| 占位符 | 说明 | 示例 |
|--------|------|------|
| `{collect_tool}` | 收集信息的工具名 | `collect_bazi_info` |
| `{compute_tool}` | 计算工具名 | `calculate_bazi` |
| `{has_chart}` | 是否有命盘 | `"否"` / `"部分数据（日主甲木）"` |
| `{chart_summary}` | 命盘摘要 | `"日主甲木、月令寅月"` |

---

## 5. 配置驱动设计

### 5.1 Skill 配置

**文件**：`skills/bazi/SKILL.md`

```yaml
---
id: bazi
name: 八字命理
requires_birth_info: true    # ← SOP 判断依据
requires_compute: true        # ← SOP 判断依据
compute_tool: calculate_bazi  # ← SOP 推荐工具
collect_tool: collect_bazi_info
---
```

**代码读取**：

```python
def skill_requires_birth_info(skill_id: str) -> bool:
    skill = load_skill(skill_id)
    return skill.requires_birth_info if skill else False

def get_skill_compute_tool(skill_id: str) -> str:
    skill = load_skill(skill_id)
    return skill.compute_tool if skill else None
```

### 5.2 SOP 模板配置

**文件**：`skills/core/config/routing.yaml`

```yaml
sop_templates:
  # P1: 需要收集信息
  need_birth_info: |
    ## 当前状态：需要出生信息

    **数据状态**：
    - 需要出生信息：是
    - 已提供：否

    **推荐工具**：`{collect_tool}`

    **为什么推荐此工具**：
    1. 表单确保信息完整（年月日时 + 时区）
    2. 提供更好的用户体验
    3. 减少来回对话次数

    **重要 - 灵活处理**：
    - 如果用户在对话中直接提供了生日，你可以解析信息并直接进入下一步
    - 如果信息不完整，仍需调用工具收集完整信息
    - 不要用文字问"请问你的生日是？"，直接调用工具

  # P2: 需要计算
  need_compute: |
    ## 当前状态：需要生成命盘

    **数据状态**：
    - 已有出生信息：是
    - 已生成命盘：{has_chart}

    **⚠️ 先检查数据**：
    在调用工具前，请检查下方"## 用户数据"部分：
    - 如果已有 `chart` 或 `cards` 字段 → **跳过计算**，直接分析即可
    - 如果没有这些字段 → 调用 `{compute_tool}` 生成命盘

    **推荐工具**：`{compute_tool}`（仅在无命盘时调用）

  # P3+: 可以分析
  ready_for_analysis: |
    ## 当前状态：可以开始分析

    **数据状态**：
    - 已有出生信息：是
    - 已生成命盘：是
    - 命盘摘要：{chart_summary}

    **⚠️ 重要：不要重复收集数据！**
    - 命盘已经生成完毕，下方"## 用户数据"中已展示完整数据
    - **禁止**再次调用 `collect_xxx` 或 `calculate_xxx` 工具
    - 直接使用现有数据进行分析即可

    **你现在可以**：
    1. 直接分析命盘中的关键特征
    2. 使用 `show_xxx` 工具展示结果（推荐）
    3. 参考知识库（`search_db` 工具）
    4. 回答用户的追问
```

### 5.3 动态占位符系统

**实现**：

```python
def _build_sop_rules(self, context):
    template = get_sop_template("need_compute")

    # 提取动态数据
    chart_summary = self._extract_chart_summary(context)
    has_chart_display = "否" if chart_summary == "无命盘数据" else f"部分数据（{chart_summary}）"

    # 填充占位符
    return template.format(
        compute_tool="calculate_bazi",
        has_chart=has_chart_display
    )
```

**`_extract_chart_summary` 方法**：

```python
def _extract_chart_summary(self, context: AgentContext) -> str:
    """从命盘数据中提取关键摘要"""
    if not context.skill_data:
        return "无命盘数据"

    skill_data = context.skill_data.get(self._active_skill, {})
    if not skill_data:
        return "无命盘数据"

    summary_parts = []

    # 八字：日主、月令
    if "chart" in skill_data:
        chart = skill_data["chart"]
        if "pillars" in chart and len(chart["pillars"]) > 2:
            day_pillar = chart["pillars"][2]
            summary_parts.append(f"日主{day_pillar.get('day_stem', '')}")
        if "month_order" in chart:
            summary_parts.append(f"月令{chart['month_order']}")

    return "、".join(summary_parts) if summary_parts else "已生成命盘"
```

---

## 6. 代码实现详解

### 6.1 核心类：CoreAgent

**文件**：`apps/api/services/agent/core.py`

**关键方法调用链**：

```python
class CoreAgent:
    async def run(self, message: str, context: AgentContext):
        """执行 Agent 循环"""

        # [1] 构建初始消息（包含 SOP）
        messages = await self._build_initial_messages(message, context)

        # [2] 循环调用 LLM
        for iteration in range(self.max_iterations):
            # LLM 调用
            async for chunk in self.llm.stream(messages, tools, ...):
                ...

            # 工具执行
            if tool_calls:
                for tc in tool_calls:
                    result = await self._execute_tool(...)
                    messages.append(tool_result)

        return

    async def _build_initial_messages(self, message, context):
        """构建初始消息"""
        # [1] 构建 System Prompt（包含 SOP）
        system_prompt = await self._build_system_prompt(message, context)

        messages = [LLMMessage(role="system", content=system_prompt)]

        # [2] 添加历史消息
        if context.history:
            filtered_history = self._filter_valid_history(context.history[-10:])
            for msg in filtered_history:
                messages.append(LLMMessage(...))

        # [3] 添加当前消息
        messages.append(LLMMessage(role="user", content=message))

        return messages

    async def _build_system_prompt(self, message, context):
        """构建 System Prompt"""
        parts = []

        if self._active_skill:
            # [1] Skill 专家身份
            base_prompt = build_system_prompt(self._active_skill, ...)
            parts.append(base_prompt)

            # [2] SOP 规则
            sop_rules = self._build_sop_rules(context)
            if sop_rules:
                parts.append(sop_rules)

            # [3] 相关案例
            cases = await self.case_index.get_matched_cases(...)
            if cases:
                parts.append(cases_text)

            # [4] 用户数据
            if context.skill_data:
                parts.append(f"\n## 用户数据\n{json.dumps(skill_data, ...)}")

        return "\n".join(parts)
```

### 6.2 SOP 状态计算

**完整代码**：

```python
def _compute_sop_status(self, context: AgentContext) -> Dict[str, Any]:
    """
    计算 SOP 状态

    v7.2: 从 SOPEngine 迁移到自然语言规则
    v10.2: 增加历史消息检查
    """
    skill_id = self._active_skill

    # [1] 检查是否需要出生信息
    needs_birth = skill_requires_birth_info(skill_id) if skill_id else False

    # [2] 从数据库检查
    identity = context.profile.get("identity", {}) if context.profile else {}
    birth_info = identity.get("birth_info", {})
    has_birth = bool(birth_info.get("birth_date") or birth_info.get("date"))

    # [3] v10.2: 从历史消息提取（补充检查）
    if not has_birth and context.history:
        extracted = self._extract_birth_info_from_history(context.history)
        has_birth = bool(extracted and extracted.get("birth_date"))
        if has_birth:
            logger.info(f"[SOP] Found birth_info in history: {extracted}")

    # [4] 检查是否需要计算
    needs_compute = skill_requires_compute(skill_id) if skill_id else False
    compute_type = get_skill_compute_type(skill_id) if skill_id else None
    actual_compute_type = compute_type or skill_id

    # [5] 检查是否有命盘数据
    has_chart = False
    if context.skill_data and actual_compute_type:
        skill_data = context.skill_data.get(actual_compute_type, {})
        has_chart = bool(skill_data.get("chart") or skill_data.get("cards"))

    # [6] 综合判断
    return {
        "skill_id": skill_id,
        "needs_birth_info": needs_birth,
        "has_birth_info": has_birth,
        "needs_compute": needs_compute,
        "has_chart_data": has_chart,
        "compute_type": actual_compute_type,
        "ready_for_analysis": (not needs_birth or has_birth) and (not needs_compute or has_chart)
    }
```

### 6.3 SOP 规则生成

**完整代码**：

```python
def _build_sop_rules(self, context: AgentContext) -> str:
    """
    构建 SOP 规则（自然语言版）

    v7.2: 从硬编码逻辑改为配置驱动的自然语言规则
    v10.1: 增强版，支持动态占位符
    """
    skill_id = self._active_skill
    if not skill_id:
        return ""

    # [1] 获取配置
    needs_birth = skill_requires_birth_info(skill_id)
    needs_compute = skill_requires_compute(skill_id)

    # [2] 计算当前状态
    status = self._compute_sop_status(context)

    # [3] 如果已经可以分析，使用简洁的状态提示
    if status["ready_for_analysis"]:
        template = get_sop_template("ready_for_analysis")
        if template:
            chart_summary = self._extract_chart_summary(context)
            return template.format(chart_summary=chart_summary)
        # fallback
        return """## 当前状态
用户信息已完整，命盘已生成。你可以开始分析了。"""

    rules_parts = []

    # [4] P1: 需要收集信息
    if needs_birth and not status["has_birth_info"]:
        collect_tool = get_skill_collect_tool(skill_id) or "request_info"
        template = get_sop_template("need_birth_info")
        if template:
            rules_parts.append(template.format(collect_tool=collect_tool))
        else:
            # fallback
            rules_parts.append(f"""## 当前状态
用户还没有告诉你出生信息。
**下一步**：调用 `{collect_tool}` 工具。""")

    # [5] P2: 需要计算
    elif needs_compute and not status["has_chart_data"]:
        compute_type = get_skill_compute_type(skill_id) or skill_id
        compute_tool = get_skill_compute_tool(skill_id) or f"calculate_{compute_type}"

        # 提取数据摘要
        chart_summary = self._extract_chart_summary(context)
        has_chart_display = "否" if chart_summary == "无命盘数据" else f"部分数据（{chart_summary}）"

        template = get_sop_template("need_compute")
        if template:
            rules_parts.append(template.format(
                compute_tool=compute_tool,
                has_chart=has_chart_display
            ))
        else:
            # fallback
            rules_parts.append(f"""## 当前状态
用户已提供出生信息，但还没有生成命盘。
**下一步**：调用 `{compute_tool}` 工具生成命盘数据。""")

    return "\n".join(rules_parts)
```

### 6.4 历史提取（v10.2 新增）

**完整代码**：

```python
def _extract_birth_info_from_history(self, history: List[Dict]) -> Optional[Dict]:
    """
    从历史对话中提取出生信息

    v10.2: 新增，用于从历史消息补充数据
    """
    import re

    if not history:
        return None

    # 只看最近 5 轮对话
    recent_messages = history[-5:]

    birth_info = {}

    for msg in recent_messages:
        if msg.get("role") != "user":
            continue

        content = msg.get("content", "")

        # 提取日期（如 1980-02-11、1980/02/11、1980.02.11）
        date_match = re.search(r'(\d{4})[-/.](\d{1,2})[-/.](\d{1,2})', content)
        if date_match:
            birth_info["birth_date"] = f"{date_match.group(1)}-{date_match.group(2):0>2}-{date_match.group(3):0>2}"

        # 提取时间（如 14:30）
        time_match = re.search(r'(\d{1,2}):(\d{2})', content)
        if time_match:
            birth_info["birth_time"] = f"{time_match.group(1):0>2}:{time_match.group(2)}"

        # 提取地点（简单检测）
        place_match = re.search(r'(beijing|上海|北京|广州|深圳|[\u4e00-\u9fa5]{2,})', content, re.IGNORECASE)
        if place_match:
            birth_info["place"] = place_match.group(1)

        # 提取性别
        if re.search(r'\bmale\b|男', content, re.IGNORECASE):
            birth_info["gender"] = "male"
        elif re.search(r'\bfemale\b|女', content, re.IGNORECASE):
            birth_info["gender"] = "female"

    # 至少要有日期才返回
    if "birth_date" in birth_info:
        return birth_info

    return None
```

---

## 7. 案例分析

### 7.1 案例 1：正常流程

**场景**：用户说"帮我算命"

#### 轮次 1：Phase 2，无数据

**状态计算**：
```python
{
    "needs_birth_info": True,   # bazi requires_birth_info=True
    "has_birth_info": False,     # 数据库无数据
    "needs_compute": True,       # bazi requires_compute=True
    "has_chart_data": False,
    "ready_for_analysis": False
}
```

**生成的 SOP**：
```
## 当前状态：需要出生信息

**数据状态**：
- 需要出生信息：是
- 已提供：否

**推荐工具**：`collect_bazi_info`

**为什么推荐此工具**：表单确保信息完整...
```

**LLM 决策**：
- 看到 SOP：需要出生信息
- 推荐工具：`collect_bazi_info`
- 调用：`collect_bazi_info()`

**用户看到**：出生信息表单

---

#### 轮次 2：用户填写表单

**用户提交**：
```json
{
  "birth_date": "1980-02-11",
  "birth_time": "14:30",
  "birth_location": "beijing",
  "gender": "male"
}
```

**工具返回**：
```json
{
  "status": "success",
  "message": "出生信息已收集"
}
```

**状态计算**（下一轮）：
```python
{
    "needs_birth_info": True,
    "has_birth_info": True,      # ✅ save_birth_info 已保存
    "needs_compute": True,
    "has_chart_data": False,     # 还没计算
    "ready_for_analysis": False
}
```

**生成的 SOP**：
```
## 当前状态：需要生成命盘

**数据状态**：
- 已有出生信息：是
- 已生成命盘：否

**推荐工具**：`calculate_bazi`

**⚠️ 先检查数据**：检查下方"## 用户数据"是否已有 chart...
```

**LLM 决策**：
- 看到 SOP：需要计算
- 推荐工具：`calculate_bazi`
- 检查用户数据：无 chart
- 调用：`calculate_bazi(birth_date="1980-02-11", birth_time="14:30", ...)`

---

#### 轮次 3：计算完成

**工具返回**：
```json
{
  "status": "success",
  "chart": {
    "pillars": [...],
    "day_master": "甲木",
    ...
  }
}
```

**状态计算**（下一轮）：
```python
{
    "needs_birth_info": True,
    "has_birth_info": True,
    "needs_compute": True,
    "has_chart_data": True,      # ✅ 已有命盘
    "ready_for_analysis": True   # ✅ 可以分析
}
```

**生成的 SOP**：
```
## 当前状态：可以开始分析

**数据状态**：
- 已有出生信息：是
- 已生成命盘：是
- 命盘摘要：日主甲木、月令寅月

**⚠️ 重要：不要重复收集数据！**
命盘已经生成完毕，下方"## 用户数据"中已展示完整数据。
**禁止**再次调用 collect_xxx 或 calculate_xxx 工具。

**你现在可以**：
1. 直接分析命盘中的关键特征
2. 使用 show_bazi_chart 工具展示结果
3. 参考知识库（search_db 工具）
```

**LLM 决策**：
- 看到 SOP：可以分析
- 看到用户数据：完整命盘
- 调用：`show_bazi_chart()` 或 `search_db(query="甲木日主 性格特点")`

---

### 7.2 案例 2：边界情况（上下文丢失问题）

**场景**：用户在 Phase 1 提供信息，但没保存，然后激活 Skill

#### 轮次 1：Phase 1

```
用户："1980-02-11 14:30, beijing, male"
Core Skill：（只文字回复，没调用 save_birth_info）
```

#### 轮次 2：激活 Skill

```
用户："八字"
系统：activate_skill(skill='bazi')
```

**状态计算**（v10.1 之前）：
```python
{
    "has_birth_info": False,  # ❌ 数据库没有（Phase 1 没保存）
    # 不检查历史消息
}
```

**生成的 SOP**：
```
## 当前状态：需要出生信息
已提供：否  ← ❌ 错误！
```

**问题**：
- LLM 能看到历史："1980-02-11 14:30, beijing, male"
- 但 SOP 说"已提供：否"
- LLM 优先遵循 SOP，调用 `collect_bazi_info`
- 用户困惑：❓ 我刚才不是说了吗？

---

**状态计算**（v10.2 修复后）：
```python
{
    "has_birth_info": False,  # 数据库没有
}

# v10.2: 补充检查历史
if not has_birth_info and context.history:
    extracted = _extract_birth_info_from_history(history)
    # extracted = {
    #     "birth_date": "1980-02-11",
    #     "birth_time": "14:30",
    #     "place": "beijing",
    #     "gender": "male"
    # }
    has_birth_info = True  # ✅ 从历史提取到了
```

**生成的 SOP**：
```
## 当前状态：需要生成命盘
已有出生信息：是  ← ✅ 正确！
```

**LLM 决策**：
- 看到 SOP：已有信息，需要计算
- 从历史提取参数：`birth_date="1980-02-11", birth_time="14:30", ...`
- 调用：`calculate_bazi(birth_date="1980-02-11", ...)`
- ✅ 用户体验流畅

---

### 7.3 案例 3：工具限制 vs SOP 指导

**v7.1（工具限制）**：
```python
# SOPEngine 限制工具集
if phase == "P1_COLLECT":
    allowed_tools = ["request_info", "collect_bazi_info"]
    # ❌ LLM 看不到 calculate_bazi，即使用户直接提供了信息
```

**v7.2+（SOP 指导）**：
```python
# LLM 可以看到所有工具
tools = ToolRegistry.get_tools_for_skill("bazi")
# tools = [
#     "collect_bazi_info",
#     "calculate_bazi",
#     "show_bazi_chart",
#     ...
# ]

# 但 SOP 提供指导
sop_rules = """
## 当前状态：需要出生信息
**推荐工具**：collect_bazi_info

**重要 - 灵活处理**：
- 如果用户在对话中直接提供了生日，你可以解析信息并直接进入下一步
"""
```

**好处**：
- ✅ LLM 能灵活应对：用户直接提供 → 跳过表单，直接计算
- ✅ 有推荐指引：默认用表单，体验更好
- ✅ 保留灵活性：特殊情况能绕过

---

## 8. 最佳实践

### 8.1 设计 SOP 规则

**原则 1：教练式指导，而非程序化指令**

❌ **不好**：
```
if has_birth_info == false:
    call collect_bazi_info()
else:
    call calculate_bazi()
```

✅ **好**：
```
## 当前状态：需要出生信息

**为什么需要**：
出生信息是八字分析的基础...

**推荐工具**：collect_bazi_info

**灵活处理**：
如果用户已在对话中提供，可以直接提取...
```

---

**原则 2：提供上下文，帮助 LLM 理解**

❌ **不好**：
```
调用 calculate_bazi
```

✅ **好**：
```
**为什么推荐此工具**：
1. 生成命盘是分析的前提
2. 计算过程自动化（约1-2秒）
3. 生成后即可开始专业分析

**执行方式**：
1. 简短说"让我来排个盘～"
2. 调用 calculate_bazi 工具
3. 等待结果（约1-2秒）
4. 收到结果后开始分析
```

---

**原则 3：边界控制，防止错误**

✅ **关键边界**：
```
**⚠️ 重要：不要重复收集数据！**
- 命盘已经生成完毕
- **禁止**再次调用 collect_xxx 或 calculate_xxx 工具
- 直接使用现有数据进行分析即可

**⚠️ 先检查数据**：
在调用工具前，请检查下方"## 用户数据"部分：
- 如果已有 chart 或 cards 字段 → 跳过计算
- 如果没有这些字段 → 调用计算工具
```

---

### 8.2 配置 Skill

**必填字段**：
```yaml
# skills/your_skill/SKILL.md
---
requires_birth_info: true/false  # 是否需要出生信息
requires_compute: true/false      # 是否需要计算
compute_tool: calculate_xxx       # 计算工具名（如需要计算）
collect_tool: collect_xxx_info    # 收集工具名（如需要收集）
---
```

---

### 8.3 调试 SOP

**查看生成的 SOP**：

```python
# 在 _build_sop_rules 方法中添加日志
sop_rules = self._build_sop_rules(context)
logger.info(f"[SOP Rules]\n{sop_rules}")
```

**检查状态计算**：

```python
# 在 _compute_sop_status 方法中添加日志
status = self._compute_sop_status(context)
logger.info(f"[SOP Status] {status}")
```

**查看完整 System Prompt**：

```python
# 在 _build_system_prompt 方法中添加日志
system_prompt = await self._build_system_prompt(message, context)
logger.info(f"[System Prompt]\n{system_prompt}")
```

---

### 8.4 优化 SOP 模板

**技巧 1：使用动态占位符**

```yaml
sop_templates:
  need_compute: |
    **命盘摘要**：{chart_summary}

    # chart_summary 会动态生成："日主甲木、月令寅月"
```

**技巧 2：分层提示（重要 > 次要）**

```yaml
**⚠️ 重要：不要重复收集数据！**  ← 强调
- 命盘已经生成完毕
- 禁止再次调用工具

**你现在可以**：  ← 建议
1. 直接分析命盘
2. 使用 show_xxx 工具
```

**技巧 3：提供示例**

```yaml
**执行方式**：
1. 简短说"让我来排个盘～"  ← 具体示例
2. 调用 calculate_bazi 工具
3. 等待结果
```

---

## 9. 总结

### 核心价值

| 方面 | 传统 Agent | SOP Agent |
|------|-----------|-----------|
| **流程控制** | 硬编码 if-else | 自然语言指导 |
| **灵活性** | 严格限制工具 | 提供推荐，保留灵活性 |
| **可维护性** | 修改代码 | 修改配置文件 |
| **可理解性** | 代码逻辑 | 自然语言规则 |
| **边界控制** | try-catch | Prompt 提示 |

### 关键洞察

> **Prompt 的准确性 > 数据的可见性**
>
> LLM 能看到所有数据，但如果 System Prompt（SOP）给出错误的状态判断，LLM 仍会做出错误决策。

### 设计哲学

1. **指导而非强制**：提供推荐和理由，让 LLM 理解"为什么"
2. **教练式而非程序式**：自然语言规则，而非 if-else 逻辑
3. **配置驱动**：流程控制从代码移到配置文件
4. **容错优先**：检查历史消息，提供边界提示

---

**文档版本**：v10.2
**最后更新**：2026-01-21
**维护者**：VibeLife Core Team
