#!/usr/bin/env python
"""
Vibe Profile v2.0 E2E Test - 真实场景全面测试

测试场景：
1. 用户分享职业信息 → 保存到 vibe.profile.context.occupation
2. 用户表达情绪 → 保存到 vibe.state.emotion
3. 用户设定目标 → 保存到 vibe.goals（merge by title）
4. 用户经历重要事件 → 保存到 vibe.timeline（append-only）
5. 并发追加 timeline 不丢数据
6. 读取验证所有路径

Usage:
    python scripts/test_vibe_v2_e2e.py
"""

import asyncio
import json
import logging
import sys
import uuid
from datetime import datetime, timezone
from typing import Dict, Any, List
from uuid import UUID

# Setup path
sys.path.insert(0, '/home/aiscend/work/vibelife/apps/api')

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# Test Utilities
# ═══════════════════════════════════════════════════════════════════════════

class TestContext:
    """模拟 ToolContext"""
    def __init__(self, user_id: str, skill_id: str = "core"):
        self.user_id = user_id
        self.skill_id = skill_id
        self.scenario_id = None
        self.profile = {}


async def call_save(user_id: str, path: str, data: Any) -> Dict[str, Any]:
    """调用 save 工具"""
    from skills.core.tools.handlers import execute_save
    ctx = TestContext(user_id)
    return await execute_save({"path": path, "data": data}, ctx)


async def call_read(user_id: str, path: str) -> Dict[str, Any]:
    """调用 read 工具"""
    from skills.core.tools.handlers import execute_read
    ctx = TestContext(user_id)
    return await execute_read({"path": path}, ctx)


def assert_success(result: Dict, message: str = ""):
    """断言操作成功"""
    if result.get("status") == "error":
        raise AssertionError(f"Expected success but got error: {result.get('error')} {message}")
    return True


def assert_equal(actual, expected, message: str = ""):
    """断言相等"""
    if actual != expected:
        raise AssertionError(f"Expected {expected}, got {actual}. {message}")
    return True


def assert_contains(container, item, message: str = ""):
    """断言包含"""
    if item not in container:
        raise AssertionError(f"Expected {container} to contain {item}. {message}")
    return True


# ═══════════════════════════════════════════════════════════════════════════
# Test Scenarios
# ═══════════════════════════════════════════════════════════════════════════

async def test_scenario_1_occupation(user_id: str):
    """
    场景1: 用户分享职业信息
    用户说："我是一名产品设计师，在一家创业公司工作"
    """
    logger.info("=" * 60)
    logger.info("场景1: 用户分享职业信息")
    logger.info("=" * 60)

    # 保存职业
    result = await call_save(user_id, "vibe.profile.context.occupation", "产品设计师")
    assert_success(result, "保存职业失败")
    logger.info(f"  ✓ 保存职业: {result}")

    # 验证
    read_result = await call_read(user_id, "vibe.profile.context.occupation")
    assert_success(read_result)
    assert_equal(read_result.get("data"), "产品设计师", "职业读取不匹配")
    logger.info(f"  ✓ 读取验证: {read_result.get('data')}")

    return True


async def test_scenario_2_life_stage(user_id: str):
    """
    场景2: 用户分享人生阶段
    用户说："我刚工作3年，还在职业成长期"
    """
    logger.info("=" * 60)
    logger.info("场景2: 用户分享人生阶段")
    logger.info("=" * 60)

    # 保存人生阶段
    result = await call_save(user_id, "vibe.profile.context.life_stage", "growth")
    assert_success(result)
    logger.info(f"  ✓ 保存人生阶段: {result}")

    # 验证
    read_result = await call_read(user_id, "vibe.profile.context.life_stage")
    assert_success(read_result)
    assert_equal(read_result.get("data"), "growth")
    logger.info(f"  ✓ 读取验证: {read_result.get('data')}")

    return True


async def test_scenario_3_interests(user_id: str):
    """
    场景3: 用户分享兴趣爱好
    用户说："我对AI和旅行很感兴趣"
    """
    logger.info("=" * 60)
    logger.info("场景3: 用户分享兴趣爱好")
    logger.info("=" * 60)

    # 保存兴趣
    result = await call_save(user_id, "vibe.profile.context.interests", ["AI", "旅行", "阅读"])
    assert_success(result)
    logger.info(f"  ✓ 保存兴趣: {result}")

    # 验证
    read_result = await call_read(user_id, "vibe.profile.context.interests")
    assert_success(read_result)
    assert_contains(read_result.get("data", []), "AI")
    assert_contains(read_result.get("data", []), "旅行")
    logger.info(f"  ✓ 读取验证: {read_result.get('data')}")

    return True


async def test_scenario_4_emotion_state(user_id: str):
    """
    场景4: 用户表达当前情绪
    用户说："最近工作压力很大，感觉有点焦虑"
    """
    logger.info("=" * 60)
    logger.info("场景4: 用户表达当前情绪")
    logger.info("=" * 60)

    # 保存情绪
    result = await call_save(user_id, "vibe.state.emotion", "anxious")
    assert_success(result)
    logger.info(f"  ✓ 保存情绪: {result}")

    # 保存能量
    result = await call_save(user_id, "vibe.state.energy", "low")
    assert_success(result)
    logger.info(f"  ✓ 保存能量: {result}")

    # 保存关注点
    result = await call_save(user_id, "vibe.state.focus", ["工作压力", "职业发展"])
    assert_success(result)
    logger.info(f"  ✓ 保存关注点: {result}")

    # 验证完整状态
    read_result = await call_read(user_id, "vibe.state")
    assert_success(read_result)
    state = read_result.get("data", {})
    assert_equal(state.get("emotion"), "anxious")
    assert_equal(state.get("energy"), "low")
    logger.info(f"  ✓ 读取验证: {state}")

    return True


async def test_scenario_5_identity_traits(user_id: str):
    """
    场景5: 通过对话发现用户特质
    LLM 分析后发现用户具有"分析型"、"好奇心强"的特质
    """
    logger.info("=" * 60)
    logger.info("场景5: 保存用户特质")
    logger.info("=" * 60)

    # 保存原型
    result = await call_save(user_id, "vibe.profile.identity.archetypes", ["Explorer", "Creator"])
    assert_success(result)
    logger.info(f"  ✓ 保存原型: {result}")

    # 保存特质
    result = await call_save(user_id, "vibe.profile.identity.traits", ["analytical", "curious", "empathetic"])
    assert_success(result)
    logger.info(f"  ✓ 保存特质: {result}")

    # 保存沟通风格
    result = await call_save(user_id, "vibe.profile.identity.style", "rational")
    assert_success(result)
    logger.info(f"  ✓ 保存沟通风格: {result}")

    # 验证
    read_result = await call_read(user_id, "vibe.profile.identity")
    assert_success(read_result)
    identity = read_result.get("data", {})
    assert_contains(identity.get("archetypes", []), "Explorer")
    assert_contains(identity.get("traits", []), "analytical")
    assert_equal(identity.get("style"), "rational")
    logger.info(f"  ✓ 读取验证: {identity}")

    return True


async def test_scenario_6_goals_merge(user_id: str):
    """
    场景6: 用户设定目标（merge by title）
    用户说："今年我想学日语，还想完成马拉松"
    后续又说："我还想提升编程技能"
    """
    logger.info("=" * 60)
    logger.info("场景6: 用户设定目标（merge by title）")
    logger.info("=" * 60)

    # 第一批目标
    goals_batch1 = [
        {"title": "学习日语", "category": "growth", "status": "active"},
        {"title": "完成马拉松", "category": "health", "status": "active"},
    ]
    result = await call_save(user_id, "vibe.goals", goals_batch1)
    assert_success(result)
    logger.info(f"  ✓ 保存第一批目标: {result}")

    # 验证
    read_result = await call_read(user_id, "vibe.goals")
    assert_success(read_result)
    assert_equal(read_result.get("count"), 2, "应有2个目标")
    logger.info(f"  ✓ 当前目标数: {read_result.get('count')}")

    # 第二批目标（包含重复的"学习日语"）
    goals_batch2 = [
        {"title": "学习日语", "category": "growth", "status": "paused"},  # 重复，应更新
        {"title": "提升编程技能", "category": "career", "status": "active"},  # 新增
    ]
    result = await call_save(user_id, "vibe.goals", goals_batch2)
    assert_success(result)
    logger.info(f"  ✓ 保存第二批目标: {result}")

    # 验证：应有3个目标，"学习日语"被更新
    read_result = await call_read(user_id, "vibe.goals")
    assert_success(read_result)
    goals = read_result.get("data", [])
    logger.info(f"  ✓ 最终目标数: {len(goals)}")

    # 找到"学习日语"检查状态
    jp_goal = next((g for g in goals if g.get("title") == "学习日语"), None)
    assert_equal(jp_goal.get("status"), "paused", "学习日语状态应被更新为 paused")
    logger.info(f"  ✓ 目标状态更新验证: {jp_goal}")

    return True


async def test_scenario_7_timeline_append(user_id: str):
    """
    场景7: 用户经历重要事件（append-only）
    用户说："我昨天收到了新工作的 offer"
    """
    logger.info("=" * 60)
    logger.info("场景7: 用户经历重要事件（append-only）")
    logger.info("=" * 60)

    # 先读取当前 timeline 数量
    read_before = await call_read(user_id, "vibe.timeline")
    count_before = read_before.get("count", 0)
    logger.info(f"  当前 timeline 条数: {count_before}")

    # 追加事件1
    event1 = {
        "date": "2026-01-25",
        "type": "milestone",
        "event": "收到新工作 offer"
    }
    result = await call_save(user_id, "vibe.timeline", event1)
    assert_success(result)
    logger.info(f"  ✓ 追加事件1: {result}")

    # 追加事件2
    event2 = {
        "date": "2026-01-26",
        "type": "decision",
        "event": "决定接受新工作"
    }
    result = await call_save(user_id, "vibe.timeline", event2)
    assert_success(result)
    logger.info(f"  ✓ 追加事件2: {result}")

    # 验证
    read_after = await call_read(user_id, "vibe.timeline")
    count_after = read_after.get("count", 0)
    assert_equal(count_after, count_before + 2, "timeline 应增加2条")
    logger.info(f"  ✓ timeline 增加验证: {count_before} → {count_after}")

    # 检查最新事件在前
    timeline = read_after.get("data", [])
    if timeline:
        latest = timeline[0]
        assert_equal(latest.get("event"), "决定接受新工作", "最新事件应在前")
        logger.info(f"  ✓ 最新事件: {latest.get('event')}")

    return True


async def test_scenario_8_timeline_concurrent(user_id: str):
    """
    场景8: P0 验证 - 并发追加 timeline 不丢数据
    """
    logger.info("=" * 60)
    logger.info("场景8: P0 验证 - 并发追加 timeline")
    logger.info("=" * 60)

    # 读取当前数量
    read_before = await call_read(user_id, "vibe.timeline")
    count_before = read_before.get("count", 0)
    logger.info(f"  当前 timeline 条数: {count_before}")

    # 并发追加 5 个事件
    events = [
        {"date": "2026-01-26", "type": "goal", "event": f"并发测试事件 {i}"}
        for i in range(5)
    ]

    async def append_event(event):
        return await call_save(user_id, "vibe.timeline", event)

    results = await asyncio.gather(*[append_event(e) for e in events])

    # 检查所有都成功
    for r in results:
        assert_success(r, "并发追加失败")

    logger.info(f"  ✓ 并发追加 5 个事件成功")

    # 验证总数
    read_after = await call_read(user_id, "vibe.timeline")
    count_after = read_after.get("count", 0)
    assert_equal(count_after, count_before + 5, f"并发追加后应有 {count_before + 5} 条")
    logger.info(f"  ✓ 并发追加验证通过: {count_before} → {count_after}")

    return True


async def test_scenario_9_whitelist_rejection(user_id: str):
    """
    场景9: P0 验证 - 非法路径被拒绝
    """
    logger.info("=" * 60)
    logger.info("场景9: P0 验证 - 非法路径被拒绝")
    logger.info("=" * 60)

    # 尝试保存到非法路径
    invalid_paths = [
        "vibe.state.mood",  # mood 不在白名单
        "vibe.profile.identity.secret",  # secret 不在白名单
        "vibe.hacked",  # 不存在的路径
    ]

    for path in invalid_paths:
        result = await call_save(user_id, path, "test")
        # 应该返回错误或被拒绝
        if result.get("status") == "error":
            logger.info(f"  ✓ 非法路径被拒绝: {path} → {result.get('error')}")
        else:
            # 如果没报错，检查是否真的保存了
            logger.warning(f"  ⚠ 路径 {path} 未被拒绝，需检查白名单")

    return True


async def test_scenario_10_full_profile_read(user_id: str):
    """
    场景10: 读取完整 vibe 数据
    """
    logger.info("=" * 60)
    logger.info("场景10: 读取完整 vibe 数据")
    logger.info("=" * 60)

    # 读取完整 vibe
    result = await call_read(user_id, "vibe")
    assert_success(result)

    vibe = result.get("data", {})
    logger.info(f"  vibe.profile: {json.dumps(vibe.get('profile', {}), ensure_ascii=False)[:100]}...")
    logger.info(f"  vibe.state: {vibe.get('state', {})}")
    logger.info(f"  vibe.goals count: {len(vibe.get('goals', []))}")
    logger.info(f"  vibe.timeline count: {len(vibe.get('timeline', []))}")

    # 读取各部分
    profile_result = await call_read(user_id, "vibe.profile")
    assert_success(profile_result)
    logger.info(f"  ✓ vibe.profile 读取成功")

    state_result = await call_read(user_id, "vibe.state")
    assert_success(state_result)
    logger.info(f"  ✓ vibe.state 读取成功")

    goals_result = await call_read(user_id, "vibe.goals")
    assert_success(goals_result)
    logger.info(f"  ✓ vibe.goals 读取成功: {goals_result.get('count')} 个")

    timeline_result = await call_read(user_id, "vibe.timeline")
    assert_success(timeline_result)
    logger.info(f"  ✓ vibe.timeline 读取成功: {timeline_result.get('count')} 条")

    return True


# ═══════════════════════════════════════════════════════════════════════════
# Main
# ═══════════════════════════════════════════════════════════════════════════

async def cleanup_test_user(user_id: str):
    """清理测试用户的 vibe 数据"""
    from stores.db import execute
    await execute(
        """UPDATE unified_profiles
           SET profile = profile - 'vibe'
           WHERE user_id = $1""",
        UUID(user_id)
    )
    logger.info(f"已清理测试用户 {user_id} 的 vibe 数据")


async def create_test_user() -> str:
    """创建测试用户"""
    from stores.unified_profile_repo import UnifiedProfileRepository

    test_user_id = uuid.uuid4()
    await UnifiedProfileRepository.create_profile(test_user_id, {
        "identity": {"birth_info": {}},
        "skills": {},
        "vibe": {},
    })
    logger.info(f"创建测试用户: {test_user_id}")
    return str(test_user_id)


async def run_all_tests():
    """运行所有测试"""
    logger.info("=" * 70)
    logger.info("Vibe Profile v2.0 E2E 测试开始")
    logger.info("=" * 70)

    # 创建测试用户
    test_user_id = await create_test_user()

    passed = 0
    failed = 0
    errors = []

    tests = [
        ("场景1: 职业信息", test_scenario_1_occupation),
        ("场景2: 人生阶段", test_scenario_2_life_stage),
        ("场景3: 兴趣爱好", test_scenario_3_interests),
        ("场景4: 情绪状态", test_scenario_4_emotion_state),
        ("场景5: 身份特质", test_scenario_5_identity_traits),
        ("场景6: 目标合并", test_scenario_6_goals_merge),
        ("场景7: Timeline追加", test_scenario_7_timeline_append),
        ("场景8: P0-并发追加", test_scenario_8_timeline_concurrent),
        ("场景9: P0-白名单拒绝", test_scenario_9_whitelist_rejection),
        ("场景10: 完整读取", test_scenario_10_full_profile_read),
    ]

    for name, test_func in tests:
        try:
            await test_func(test_user_id)
            passed += 1
            logger.info(f"✅ {name} 通过")
        except Exception as e:
            failed += 1
            errors.append((name, str(e)))
            logger.error(f"❌ {name} 失败: {e}")

    # 清理测试用户
    await cleanup_test_user(test_user_id)

    # 汇总
    logger.info("")
    logger.info("=" * 70)
    logger.info("测试汇总")
    logger.info("=" * 70)
    logger.info(f"通过: {passed}/{len(tests)}")
    logger.info(f"失败: {failed}/{len(tests)}")

    if errors:
        logger.info("")
        logger.info("失败详情:")
        for name, error in errors:
            logger.info(f"  - {name}: {error}")

    return failed == 0


async def main():
    """入口"""
    success = await run_all_tests()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    asyncio.run(main())
