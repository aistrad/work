"""
Unified Skill Gateway - ç»Ÿä¸€ Skill API å…¥å£

æ‰€æœ‰ Skill æ•°æ®æœåŠ¡é€šè¿‡æ­¤è·¯ç”±è®¿é—®:
- POST /api/v1/skills/{skill_id}/{action}
- GET /api/v1/skills/{skill_id}/services
- GET /api/v1/skills

v7.4 æ–°å¢è®¢é˜…ç®¡ç†ç«¯ç‚¹:
- GET /api/v1/skills/subscriptions
- POST /api/v1/skills/{skill_id}/subscribe
- POST /api/v1/skills/{skill_id}/unsubscribe
- POST /api/v1/skills/{skill_id}/push
- GET /api/v1/skills/recommendations
- GET /api/v1/skills/featured

v7.5 æ–°å¢:
- æ•°æ®åº“ä¼˜å…ˆå…ƒæ•°æ®åŠ è½½ï¼ˆskill_catalog è¡¨ï¼‰
- async å‡½æ•°æ”¯æŒï¼ŒSKILL.md ä½œä¸º fallback

ç¤ºä¾‹:
- POST /api/v1/skills/bazi/chart
- POST /api/v1/skills/zodiac/fortune
- POST /api/v1/skills/tarot/draw
"""
import logging
from datetime import datetime, timezone
from typing import Optional, Dict, Any, List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Header, Query
from pydantic import BaseModel, Field

from services.identity import get_optional_user, get_current_user, CurrentUser
from services.agent.skill_service_registry import (
    SkillServiceRegistry, ServiceContext
)
# v7.5: ä¼˜å…ˆä½¿ç”¨ async å‡½æ•°ï¼ˆæ•°æ®åº“ä¼˜å…ˆï¼‰ï¼Œsync å‡½æ•°ä½œä¸º fallback
from services.agent.skill_loader import (
    load_skill_metadata, get_all_skill_metadata, get_skills_by_category,
    load_skill_metadata_async, get_all_skill_metadata_async, get_skills_by_category_async,
    get_featured_skills_async, get_skill_categories_summary_async,
)
from stores.profile_cache import get_cached_profile_with_skill
# v7.6: ä½¿ç”¨ UnifiedProfileRepository æ›¿ä»£åˆ†æ•£çš„ Repository
from stores.unified_profile_repo import UnifiedProfileRepository

router = APIRouter(prefix="/skills", tags=["Skills"])
logger = logging.getLogger(__name__)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Request/Response Models
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SkillRequest(BaseModel):
    """é€šç”¨ Skill è¯·æ±‚"""
    args: Dict[str, Any] = Field(default_factory=dict, description="æœåŠ¡å‚æ•°")


class SkillResponse(BaseModel):
    """é€šç”¨ Skill å“åº”"""
    status: str = "success"
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


class ServiceInfo(BaseModel):
    """æœåŠ¡ä¿¡æ¯"""
    skill_id: str
    action: str
    description: str = ""
    auth_required: bool = True
    entitlement: Optional[str] = None


# v7.4: è®¢é˜…ç®¡ç†ç›¸å…³æ¨¡å‹
class SubscribeRequest(BaseModel):
    """è®¢é˜…è¯·æ±‚"""
    push_enabled: bool = True


class PushToggleRequest(BaseModel):
    """æ¨é€å¼€å…³è¯·æ±‚"""
    enabled: bool


class SkillUserStatus(BaseModel):
    """ç”¨æˆ·å¯¹ Skill çš„çŠ¶æ€"""
    subscribed: bool = False
    push_enabled: bool = False
    trial_messages_used: int = 0
    trial_messages_remaining: Optional[int] = None


class SkillWithStatus(BaseModel):
    """å¸¦ç”¨æˆ·çŠ¶æ€çš„ Skill ä¿¡æ¯"""
    id: str
    name: str
    description: str
    icon: str = "ğŸ’¡"
    color: str = "#6B7280"
    category: str
    pricing: Dict[str, Any]
    features: List[Dict[str, Any]] = []
    showcase: Dict[str, Any] = {}
    triggers: List[str] = []
    user_status: Optional[SkillUserStatus] = None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Helper Functions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def build_service_context(
    user_id: Optional[UUID],
    skill_id: str,
    user_tier: str = "free"
) -> ServiceContext:
    """æ„å»ºæœåŠ¡ä¸Šä¸‹æ–‡"""
    profile = {}
    skill_data = {}

    if user_id:
        try:
            result = await get_cached_profile_with_skill(user_id, skill_id)
            profile = result.get("profile", {})
            skill_data = result.get("skill_data", {})
        except Exception as e:
            logger.warning(f"Failed to get user context: {e}")

    return ServiceContext(
        user_id=str(user_id) if user_id else None,
        user_tier=user_tier,
        profile=profile,
        skill_data=skill_data
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Endpoints
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("")
async def list_skills(
    category: Optional[str] = Query(None, description="æŒ‰åˆ†ç±»ç­›é€‰: core, default, professional"),
    subscribed: Optional[bool] = Query(None, description="åªè¿”å›å·²è®¢é˜…çš„ Skill"),
    current_user: Optional[CurrentUser] = Depends(get_optional_user),
):
    """
    è·å–æ‰€æœ‰ Skill åˆ—è¡¨ï¼ˆå¸¦å…ƒæ•°æ®å’Œè®¢é˜…çŠ¶æ€ï¼‰

    v7.5: ä½¿ç”¨æ•°æ®åº“ä¼˜å…ˆåŠ è½½ï¼Œæ”¯æŒåŠ¨æ€é…ç½®

    Args:
        category: æŒ‰åˆ†ç±»ç­›é€‰ (core/default/professional)
        subscribed: åªè¿”å›å·²è®¢é˜…çš„ Skill

    Returns:
        skills: Skill åˆ—è¡¨ï¼ŒåŒ…å«å…ƒæ•°æ®å’Œç”¨æˆ·è®¢é˜…çŠ¶æ€
        categories: åˆ†ç±»ç»Ÿè®¡
        total: æ€»æ•°
    """
    # v7.5: ä½¿ç”¨ async å‡½æ•°ï¼ˆæ•°æ®åº“ä¼˜å…ˆï¼‰
    if category:
        all_metadata = await get_skills_by_category_async(category)
    else:
        all_metadata = await get_all_skill_metadata_async()

    # è·å–ç”¨æˆ·è®¢é˜…çŠ¶æ€
    user_statuses = {}
    if current_user:
        subscriptions = await UnifiedProfileRepository.get_user_subscriptions(current_user.user_id)
        user_statuses = {s.skill_id: s for s in subscriptions}

    # æ„å»ºå“åº”
    skills = []
    for metadata in all_metadata:
        skill_dict = metadata.to_dict()
        sub = user_statuses.get(metadata.id)

        # è®¡ç®—è¯•ç”¨å‰©ä½™æ¬¡æ•°
        trial_limit = metadata.pricing.trial_messages if metadata.pricing.type != "free" else None
        trial_used = sub.trial_messages_used if sub else 0

        skill_dict["user_status"] = {
            "subscribed": sub.status == "subscribed" if sub else False,
            "push_enabled": sub.push_enabled if sub else False,
            "trial_messages_used": trial_used,
            "trial_messages_remaining": (trial_limit - trial_used) if trial_limit else None,
        }

        # ç­›é€‰å·²è®¢é˜…
        if subscribed is not None:
            is_subscribed = skill_dict["user_status"]["subscribed"]
            if subscribed and not is_subscribed:
                continue
            if not subscribed and is_subscribed:
                continue

        skills.append(skill_dict)

    # v7.5: ä½¿ç”¨ async å‡½æ•°è·å–åˆ†ç±»ç»Ÿè®¡
    categories = await get_skill_categories_summary_async()

    return {"skills": skills, "categories": categories, "total": len(skills)}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è®¢é˜…ç®¡ç†ç«¯ç‚¹ (v7.4)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("/subscriptions")
async def get_subscriptions(current_user: CurrentUser = Depends(get_current_user)):
    """
    è·å–ç”¨æˆ·è®¢é˜…åˆ—è¡¨

    v7.5: ä½¿ç”¨æ•°æ®åº“ä¼˜å…ˆåŠ è½½

    Returns:
        subscriptions: æ‰€æœ‰ Skill çš„è®¢é˜…çŠ¶æ€åˆ—è¡¨
        summary: ç»Ÿè®¡æ‘˜è¦
    """
    subscriptions = await UnifiedProfileRepository.get_user_subscriptions(current_user.user_id)
    # v7.5: ä½¿ç”¨ async å‡½æ•°
    all_skills = await get_all_skill_metadata_async()

    result = []
    for skill in all_skills:
        sub = next((s for s in subscriptions if s.skill_id == skill.id), None)
        result.append({
            "skill_id": skill.id,
            "skill_name": skill.name,
            "status": sub.status if sub else "not_subscribed",
            "push_enabled": sub.push_enabled if sub else False,
            "subscribed_at": sub.subscribed_at.isoformat() if sub and sub.subscribed_at else None,
            "can_unsubscribe": skill.subscription.can_unsubscribe,
            "trial_messages_used": sub.trial_messages_used if sub else 0,
        })

    return {
        "subscriptions": result,
        "summary": {
            "total_subscribed": len([s for s in result if s["status"] == "subscribed"]),
            "total_available": len(all_skills),
            "push_enabled_count": len([s for s in result if s["push_enabled"]]),
        }
    }


@router.get("/recommendations")
async def get_recommendations(
    limit: int = Query(default=3, le=10, description="è¿”å›æ•°é‡"),
    context: Optional[str] = Query(None, description="å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡"),
    current_user: CurrentUser = Depends(get_current_user),
):
    """
    è·å–æ¨è Skill

    v7.5: ä½¿ç”¨æ•°æ®åº“ä¼˜å…ˆåŠ è½½

    åŸºäºç”¨æˆ·æ¡£æ¡ˆã€ä½¿ç”¨å†å²å’Œå¯¹è¯ä¸Šä¸‹æ–‡æ¨è Skillã€‚

    Args:
        limit: è¿”å›æ•°é‡ï¼Œé»˜è®¤ 3ï¼Œæœ€å¤§ 10
        context: å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡ï¼ˆå…³é”®è¯ï¼‰

    Returns:
        recommendations: æ¨è Skill åˆ—è¡¨
    """
    # è·å–ç”¨æˆ·å·²è®¢é˜…å’Œå·²å±è”½çš„ Skill
    subscribed_ids = await UnifiedProfileRepository.get_subscribed_skill_ids(current_user.user_id)
    blocked_ids = await UnifiedProfileRepository.get_blocked_skills(current_user.user_id)

    # v7.5: ä½¿ç”¨ async å‡½æ•°
    all_skills = await get_all_skill_metadata_async()

    # è¿‡æ»¤ï¼šæœªè®¢é˜… + æœªå±è”½ + é core
    candidates = [
        s for s in all_skills
        if s.id not in subscribed_ids
        and s.id not in blocked_ids
        and s.category != "core"
    ]

    recommendations = []
    for skill in candidates[:limit]:
        # ç®€å•æ¨èé€»è¾‘ï¼šåŸºäºè§¦å‘è¯åŒ¹é…
        reason = "featured"
        context_text = f"è¯•è¯•ã€Œ{skill.name}ã€ï¼Œ{skill.showcase.tagline or skill.description}"

        if context:
            # æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦åŒ¹é…è§¦å‘è¯
            for trigger in skill.triggers:
                if trigger in context:
                    reason = "based_on_conversation"
                    context_text = f"ä½ æåˆ°äº†ã€Œ{trigger}ã€ï¼Œ{skill.name} å¯ä»¥å¸®åŠ©ä½ ã€‚"
                    break

        # è·å–è¯•ç”¨æ¬¡æ•°
        trial_used = await UnifiedProfileRepository.get_trial_usage(current_user.user_id, skill.id)
        trial_remaining = skill.pricing.trial_messages - trial_used if skill.pricing.type != "free" else None

        recommendations.append({
            "skill_id": skill.id,
            "skill": {
                "id": skill.id,
                "name": skill.name,
                "icon": skill.icon,
                "color": skill.color,
                "tagline": skill.showcase.tagline,
            },
            "reason": reason,
            "context": context_text,
            "score": 0.8,
            "trial_messages_remaining": trial_remaining,
        })

    return {
        "recommendations": recommendations,
        "generated_at": datetime.now(timezone.utc).isoformat(),
    }


@router.get("/featured")
async def get_featured():
    """
    è·å–ç²¾é€‰ Skillï¼ˆç”¨äºé¦–é¡µè½®æ’­ç­‰ï¼‰

    v7.5: ä»æ•°æ®åº“ skill_catalog è¯»å– is_featured=true çš„è®°å½•

    Returns:
        featured: ç²¾é€‰ Skill åˆ—è¡¨
    """
    # v7.5: ä½¿ç”¨ async å‡½æ•°ä»æ•°æ®åº“è·å–ç²¾é€‰åˆ—è¡¨
    featured_skills = await get_featured_skills_async()

    featured = []
    for idx, metadata in enumerate(featured_skills):
        featured.append({
            "skill_id": metadata.id,
            "skill": {
                "id": metadata.id,
                "name": metadata.name,
                "icon": metadata.icon,
                "color": metadata.color,
                "tagline": metadata.showcase.tagline,
                "preview_image": metadata.showcase.preview_image,
            },
            "position": idx + 1,
            "campaign": None,  # å¯æ‰©å±•ä¸ºä» featured_campaign å­—æ®µè¯»å–
        })

    return {"featured": featured}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SkillIntroCard ç«¯ç‚¹ (v7.6)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UpdateSettingsRequest(BaseModel):
    """æ›´æ–°è®¾ç½®è¯·æ±‚"""
    voice_mode: Optional[str] = None
    reminder_hour: Optional[int] = None
    push_enabled: Optional[bool] = None


@router.get("/{skill_id}/intro")
async def get_skill_intro(
    skill_id: str,
    current_user: Optional[CurrentUser] = Depends(get_optional_user),
):
    """
    è·å– Skill ä»‹ç»å¡ç‰‡æ•°æ®

    ç”¨äº SkillIntroCard ç»„ä»¶ï¼ŒåŒ…å«å®Œæ•´çš„ Skill å…ƒæ•°æ®å’Œç”¨æˆ·çŠ¶æ€ã€‚

    Args:
        skill_id: Skill ID

    Returns:
        skill: Skill å®Œæ•´å…ƒæ•°æ®
        subscription: ç”¨æˆ·è®¢é˜…çŠ¶æ€
        settings: ç”¨æˆ·è®¾ç½®
        is_first_use: æ˜¯å¦é¦–æ¬¡ä½¿ç”¨
    """
    # åŠ è½½ Skill å…ƒæ•°æ®
    metadata = await load_skill_metadata_async(skill_id)
    if not metadata:
        raise HTTPException(status_code=404, detail="Skill not found")

    skill_dict = metadata.to_dict()

    # æ·»åŠ  settings é…ç½®ï¼ˆä» SKILL.md è¯»å–ï¼‰
    # TODO: ä» SKILL.md frontmatter è¯»å– settings é…ç½®
    skill_dict["settings"] = [
        {
            "key": "push_enabled",
            "name": "æ¯æ—¥æé†’",
            "type": "toggle",
            "default": True,
            "description": "æ¥æ”¶æ¯æ—¥ç­¾åˆ°å’Œå¤ç›˜æé†’"
        },
        {
            "key": "voice_mode",
            "name": "è¯­éŸ³æ¨¡å¼",
            "type": "select",
            "default": "warm",
            "options": [
                {"value": "warm", "label": "ğŸŒ æ¸©æš–æ”¯æŒ"},
                {"value": "sarcastic", "label": "ğŸ˜ˆ ç›´æ¥æŒ‘æˆ˜"},
                {"value": "wise", "label": "ğŸ§™ ç¿æ™ºå¯¼å¸ˆ"}
            ]
        },
        {
            "key": "reminder_hour",
            "name": "æé†’æ—¶é—´",
            "type": "time",
            "default": "08:00",
            "description": "æ¯æ—¥æé†’çš„å‘é€æ—¶é—´"
        }
    ]

    # æ·»åŠ  intro_card é…ç½®
    skill_dict["intro_card"] = {
        "default_sections": ["header", "features", "quickstart", "pricing"],
        "show_on_first_use": True,
        "cta_text": "å¼€å§‹ä½ çš„æˆé•¿ä¹‹æ—…"
    }

    # è·å–ç”¨æˆ·çŠ¶æ€
    subscription = None
    settings = None
    is_first_use = True

    if current_user:
        # è·å–è®¢é˜…çŠ¶æ€
        sub = await UnifiedProfileRepository.get_skill_subscription(current_user.user_id, skill_id)
        if sub:
            trial_limit = metadata.pricing.trial_messages if metadata.pricing.type != "free" else None
            subscription = {
                "skill_id": skill_id,
                "status": sub.status,
                "push_enabled": sub.push_enabled,
                "subscribed_at": sub.subscribed_at.isoformat() if sub.subscribed_at else None,
                "trial_messages_used": sub.trial_messages_used,
                "trial_messages_remaining": (trial_limit - sub.trial_messages_used) if trial_limit else None,
            }

        # è·å–ç”¨æˆ·è®¾ç½®
        profile = await UnifiedProfileRepository.get_profile(current_user.user_id)
        if profile:
            preferences = profile.get("preferences", {})
            push_settings = preferences.get("push_settings", {})
            settings = {
                "skill_id": skill_id,
                "voice_mode": preferences.get("voice_mode", "warm"),
                "reminder_hour": push_settings.get("default_push_hour", 8),
                "custom_settings": {},
            }

            # æ£€æŸ¥æ˜¯å¦é¦–æ¬¡ä½¿ç”¨
            meta = profile.get("_meta", {})
            first_use_key = f"first_use_{skill_id}"
            is_first_use = not meta.get(first_use_key, False)

    return {
        "skill": skill_dict,
        "subscription": subscription,
        "settings": settings,
        "is_first_use": is_first_use,
    }


@router.patch("/{skill_id}/settings")
async def update_skill_settings(
    skill_id: str,
    request: UpdateSettingsRequest,
    current_user: CurrentUser = Depends(get_current_user),
):
    """
    æ›´æ–° Skill è®¾ç½®

    Args:
        skill_id: Skill ID
        request: è®¾ç½®æ›´æ–°è¯·æ±‚

    Returns:
        success: æ˜¯å¦æˆåŠŸ
        settings: æ›´æ–°åçš„è®¾ç½®
        subscription: æ›´æ–°åçš„è®¢é˜…çŠ¶æ€
    """
    metadata = await load_skill_metadata_async(skill_id)
    if not metadata:
        raise HTTPException(status_code=404, detail="Skill not found")

    # æ›´æ–° voice_mode
    if request.voice_mode is not None:
        await UnifiedProfileRepository.update_preferences(
            user_id=current_user.user_id,
            updates={"voice_mode": request.voice_mode}
        )

    # æ›´æ–° push_enabled
    if request.push_enabled is not None:
        await UnifiedProfileRepository.update_skill_subscription(
            user_id=current_user.user_id,
            skill_id=skill_id,
            updates={"push_enabled": request.push_enabled}
        )

    # æ›´æ–° reminder_hour
    if request.reminder_hour is not None:
        await UnifiedProfileRepository.update_push_settings(
            user_id=current_user.user_id,
            updates={"default_push_hour": request.reminder_hour}
        )

    # è·å–æ›´æ–°åçš„çŠ¶æ€
    profile = await UnifiedProfileRepository.get_profile(current_user.user_id)
    preferences = profile.get("preferences", {}) if profile else {}
    push_settings = preferences.get("push_settings", {})

    settings = {
        "skill_id": skill_id,
        "voice_mode": preferences.get("voice_mode", "warm"),
        "reminder_hour": push_settings.get("default_push_hour", 8),
        "custom_settings": {},
    }

    sub = await UnifiedProfileRepository.get_skill_subscription(current_user.user_id, skill_id)
    subscription = None
    if sub:
        trial_limit = metadata.pricing.trial_messages if metadata.pricing.type != "free" else None
        subscription = {
            "skill_id": skill_id,
            "status": sub.status,
            "push_enabled": sub.push_enabled,
            "subscribed_at": sub.subscribed_at.isoformat() if sub.subscribed_at else None,
            "trial_messages_used": sub.trial_messages_used,
            "trial_messages_remaining": (trial_limit - sub.trial_messages_used) if trial_limit else None,
        }

    return {
        "success": True,
        "settings": settings,
        "subscription": subscription,
    }


@router.post("/{skill_id}/first-use")
async def mark_first_use(
    skill_id: str,
    current_user: CurrentUser = Depends(get_current_user),
):
    """
    æ ‡è®°é¦–æ¬¡ä½¿ç”¨

    Args:
        skill_id: Skill ID

    Returns:
        success: æ˜¯å¦æˆåŠŸ
        is_first_use: æ˜¯å¦é¦–æ¬¡ä½¿ç”¨ï¼ˆæ ‡è®°åä¸º Falseï¼‰
        first_used_at: é¦–æ¬¡ä½¿ç”¨æ—¶é—´
    """
    metadata = await load_skill_metadata_async(skill_id)
    if not metadata:
        raise HTTPException(status_code=404, detail="Skill not found")

    first_use_key = f"first_use_{skill_id}"
    first_used_at = datetime.now(timezone.utc).isoformat()

    await UnifiedProfileRepository.update_meta(
        user_id=current_user.user_id,
        updates={first_use_key: True, f"{first_use_key}_at": first_used_at}
    )

    return {
        "success": True,
        "is_first_use": False,
        "first_used_at": first_used_at,
    }


@router.get("/{skill_id}")
async def get_skill_detail(
    skill_id: str,
    current_user: Optional[CurrentUser] = Depends(get_optional_user),
):
    """
    è·å–å•ä¸ª Skill è¯¦æƒ…

    v7.5: ä½¿ç”¨æ•°æ®åº“ä¼˜å…ˆåŠ è½½

    Args:
        skill_id: Skill ID

    Returns:
        skill: Skill å®Œæ•´è¯¦æƒ…
        user_status: ç”¨æˆ·è®¢é˜…çŠ¶æ€ï¼ˆå¦‚å·²ç™»å½•ï¼‰
    """
    # v7.5: ä½¿ç”¨ async å‡½æ•°
    metadata = await load_skill_metadata_async(skill_id)
    if not metadata:
        raise HTTPException(status_code=404, detail="Skill not found")

    skill_dict = metadata.to_dict()

    # è·å–æœåŠ¡åˆ—è¡¨
    services = SkillServiceRegistry.list_services(skill_id)
    skill_dict["services"] = services or []

    # è·å–ç”¨æˆ·çŠ¶æ€
    user_status = None
    if current_user:
        sub = await UnifiedProfileRepository.get_skill_subscription(current_user.user_id, skill_id)
        if sub:
            trial_limit = metadata.pricing.trial_messages if metadata.pricing.type != "free" else None
            user_status = {
                "subscribed": sub.status == "subscribed",
                "push_enabled": sub.push_enabled,
                "subscribed_at": sub.subscribed_at.isoformat() if sub.subscribed_at else None,
                "trial_messages_used": sub.trial_messages_used,
                "trial_messages_remaining": (trial_limit - sub.trial_messages_used) if trial_limit else None,
            }

    return {"skill": skill_dict, "user_status": user_status}


@router.post("/{skill_id}/subscribe")
async def subscribe_skill(
    skill_id: str,
    request: SubscribeRequest,
    current_user: CurrentUser = Depends(get_current_user),
):
    """
    è®¢é˜… Skill

    v7.5: ä½¿ç”¨æ•°æ®åº“ä¼˜å…ˆåŠ è½½
    v7.6: æ·»åŠ  Premium æ£€æŸ¥

    Args:
        skill_id: Skill ID
        request: è®¢é˜…è¯·æ±‚ï¼ˆpush_enabledï¼‰

    Returns:
        success: æ˜¯å¦æˆåŠŸ
        subscription: è®¢é˜…çŠ¶æ€
        message: æç¤ºæ¶ˆæ¯
    """
    # v7.5: ä½¿ç”¨ async å‡½æ•°
    metadata = await load_skill_metadata_async(skill_id)
    if not metadata:
        raise HTTPException(status_code=404, detail="Skill not found")

    # æ£€æŸ¥æ˜¯å¦å·²è®¢é˜…
    existing = await UnifiedProfileRepository.get_skill_subscription(current_user.user_id, skill_id)
    if existing and existing.status == "subscribed":
        raise HTTPException(status_code=400, detail="Already subscribed")

    # v7.6: Premium æ£€æŸ¥
    if metadata.pricing.type == "premium":
        trial_used = existing.trial_messages_used if existing else 0
        trial_limit = metadata.pricing.trial_messages

        if trial_used >= trial_limit:
            # è¯•ç”¨å·²ç”¨å®Œï¼Œæ£€æŸ¥ Premium çŠ¶æ€
            from services.entitlement import EntitlementService
            entitlements = await EntitlementService.get_entitlements(current_user.user_id)

            if entitlements.get("tier") != "paid":
                raise HTTPException(
                    status_code=402,
                    detail={
                        "code": "PREMIUM_REQUIRED",
                        "message": f"è®¢é˜…ã€Œ{metadata.name}ã€éœ€è¦ Premium ä¼šå‘˜",
                        "skill_id": skill_id,
                        "trial_exhausted": True,
                        "trial_used": trial_used,
                        "trial_limit": trial_limit,
                    }
                )

    # åˆ›å»º/æ›´æ–°è®¢é˜…
    subscription = await UnifiedProfileRepository.subscribe(
        user_id=current_user.user_id,
        skill_id=skill_id,
        push_enabled=request.push_enabled,
    )

    return {
        "success": True,
        "subscription": subscription.to_dict(),
        "message": f"å·²æˆåŠŸè®¢é˜…ã€Œ{metadata.name}ã€",
    }


@router.post("/{skill_id}/unsubscribe")
async def unsubscribe_skill(
    skill_id: str,
    current_user: CurrentUser = Depends(get_current_user),
):
    """
    å–æ¶ˆè®¢é˜… Skill

    v7.5: ä½¿ç”¨æ•°æ®åº“ä¼˜å…ˆåŠ è½½

    Args:
        skill_id: Skill ID

    Returns:
        success: æ˜¯å¦æˆåŠŸ
        subscription: è®¢é˜…çŠ¶æ€
        message: æç¤ºæ¶ˆæ¯
    """
    # v7.5: ä½¿ç”¨ async å‡½æ•°
    metadata = await load_skill_metadata_async(skill_id)
    if not metadata:
        raise HTTPException(status_code=404, detail="Skill not found")

    # Core Skill ä¸å¯å–æ¶ˆ
    if not metadata.subscription.can_unsubscribe:
        raise HTTPException(status_code=400, detail="This skill cannot be unsubscribed")

    # æ£€æŸ¥æ˜¯å¦å·²è®¢é˜…
    existing = await UnifiedProfileRepository.get_skill_subscription(current_user.user_id, skill_id)
    if not existing or existing.status != "subscribed":
        raise HTTPException(status_code=400, detail="Not subscribed")

    # å–æ¶ˆè®¢é˜…
    subscription = await UnifiedProfileRepository.unsubscribe(current_user.user_id, skill_id)

    return {
        "success": True,
        "subscription": subscription.to_dict(),
        "message": f"å·²å–æ¶ˆè®¢é˜…ã€Œ{metadata.name}ã€",
    }


@router.post("/{skill_id}/push")
async def toggle_push(
    skill_id: str,
    request: PushToggleRequest,
    current_user: CurrentUser = Depends(get_current_user),
):
    """
    åˆ‡æ¢æ¨é€å¼€å…³

    v7.5: ä½¿ç”¨æ•°æ®åº“ä¼˜å…ˆåŠ è½½

    Args:
        skill_id: Skill ID
        request: æ¨é€å¼€å…³è¯·æ±‚

    Returns:
        success: æ˜¯å¦æˆåŠŸ
        subscription: è®¢é˜…çŠ¶æ€
        message: æç¤ºæ¶ˆæ¯
    """
    # v7.5: ä½¿ç”¨ async å‡½æ•°
    metadata = await load_skill_metadata_async(skill_id)
    if not metadata:
        raise HTTPException(status_code=404, detail="Skill not found")

    # æ£€æŸ¥æ˜¯å¦å·²è®¢é˜…
    existing = await UnifiedProfileRepository.get_skill_subscription(current_user.user_id, skill_id)
    if not existing or existing.status != "subscribed":
        raise HTTPException(status_code=400, detail="Not subscribed")

    # æ›´æ–°æ¨é€çŠ¶æ€
    subscription = await UnifiedProfileRepository.update_push(
        user_id=current_user.user_id,
        skill_id=skill_id,
        enabled=request.enabled,
    )

    action = "å¼€å¯" if request.enabled else "å…³é—­"
    return {
        "success": True,
        "subscription": subscription.to_dict() if subscription else None,
        "message": f"å·²{action}ã€Œ{metadata.name}ã€çš„æ¨é€é€šçŸ¥",
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åŸæœ‰æœåŠ¡ç«¯ç‚¹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@router.get("/{skill_id}/services")
async def list_skill_services(skill_id: str):
    """
    åˆ—å‡º Skill çš„æ‰€æœ‰æœåŠ¡

    Args:
        skill_id: Skill æ ‡è¯† (bazi, zodiac, tarot, career)

    Returns:
        services: æœåŠ¡åˆ—è¡¨
    """
    services = SkillServiceRegistry.list_services(skill_id)
    if not services:
        raise HTTPException(
            status_code=404,
            detail=f"No services found for skill: {skill_id}"
        )
    return {"skill_id": skill_id, "services": services}


@router.post("/{skill_id}/{action}")
async def execute_skill_service(
    skill_id: str,
    action: str,
    request: SkillRequest,
    current_user: Optional[CurrentUser] = Depends(get_optional_user),
    x_test_tier: Optional[str] = Header(None, alias="x-test-tier")
):
    """
    æ‰§è¡Œ Skill æœåŠ¡

    Args:
        skill_id: Skill æ ‡è¯† (bazi, zodiac, tarot, career)
        action: æœåŠ¡åŠ¨ä½œ (chart, fortune, draw, etc.)
        request: è¯·æ±‚å‚æ•°

    Returns:
        æœåŠ¡æ‰§è¡Œç»“æœ

    Examples:
        POST /api/v1/skills/bazi/chart
        {"args": {"birth_date": "1990-01-01", "birth_time": "12:00"}}

        POST /api/v1/skills/zodiac/fortune
        {"args": {"date": "2026-01-15"}}
    """
    # æ£€æŸ¥æœåŠ¡æ˜¯å¦å­˜åœ¨
    if not SkillServiceRegistry.has_service(skill_id, action):
        raise HTTPException(
            status_code=404,
            detail=f"Service not found: {skill_id}/{action}"
        )

    # è·å–æœåŠ¡å®šä¹‰
    service_def = SkillServiceRegistry.get_service(skill_id, action)

    # æ£€æŸ¥è®¤è¯è¦æ±‚
    if service_def.auth_required and not current_user:
        raise HTTPException(
            status_code=401,
            detail="Authentication required"
        )

    # ç¡®å®šç”¨æˆ·ç­‰çº§
    user_id = current_user.user_id if current_user else None
    user_tier = "free"

    # æµ‹è¯•æ¨¡å¼: å…è®¸é€šè¿‡ header è¦†ç›– tier
    if x_test_tier and x_test_tier in ("free", "paid", "vip", "guest"):
        user_tier = x_test_tier
        logger.info(f"Test mode: using tier={x_test_tier}")
    elif user_id:
        try:
            from services.entitlement import EntitlementService
            entitlements = await EntitlementService.get_entitlements(user_id)
            user_tier = entitlements.get("tier", "free")
        except Exception as e:
            logger.warning(f"Failed to get entitlements: {e}")

    # æ£€æŸ¥æƒç›Šè¦æ±‚
    if service_def.entitlement:
        # TODO: å®ç°æƒç›Šæ£€æŸ¥
        pass

    # æ„å»ºä¸Šä¸‹æ–‡
    context = await build_service_context(user_id, skill_id, user_tier)

    # æ‰§è¡ŒæœåŠ¡
    result = await SkillServiceRegistry.execute(skill_id, action, request.args, context)

    # æ£€æŸ¥é”™è¯¯
    if "error" in result and result.get("status") in ("error", "not_found"):
        status_code = 404 if result.get("status") == "not_found" else 400
        raise HTTPException(status_code=status_code, detail=result["error"])

    return result


@router.get("/{skill_id}/{action}")
async def get_skill_service_info(skill_id: str, action: str):
    """
    è·å–æœåŠ¡ä¿¡æ¯

    Args:
        skill_id: Skill æ ‡è¯†
        action: æœåŠ¡åŠ¨ä½œ

    Returns:
        æœåŠ¡å®šä¹‰ä¿¡æ¯
    """
    service_def = SkillServiceRegistry.get_service(skill_id, action)
    if not service_def:
        raise HTTPException(
            status_code=404,
            detail=f"Service not found: {skill_id}/{action}"
        )

    return {
        "skill_id": service_def.skill_id,
        "action": service_def.action,
        "description": service_def.description,
        "auth_required": service_def.auth_required,
        "entitlement": service_def.entitlement
    }
