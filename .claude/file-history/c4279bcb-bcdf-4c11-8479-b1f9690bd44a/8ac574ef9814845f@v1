/**
 * Chat Page Object Model
 *
 * 封装 Chat 页面的所有交互逻辑，用于 Skill 端到端测试
 */

import { Page, Locator } from '@playwright/test'

export type SkillId =
  | 'bazi'
  | 'zodiac'
  | 'jungastro'
  | 'tarot'
  | 'psych'
  | 'mindfulness'
  | 'synastry'
  | 'vibe_id'
  | 'lifecoach'
  | 'career'

export interface ChatMessage {
  role: 'user' | 'assistant'
  content: string
  toolCalls?: string[]
}

export class ChatPage {
  readonly page: Page

  // Chat UI Locators
  readonly chatContainer: Locator
  readonly chatInput: Locator
  readonly sendButton: Locator
  readonly messages: Locator
  readonly userMessages: Locator
  readonly assistantMessages: Locator
  readonly thinkingIndicator: Locator
  readonly toolCards: Locator

  // Sidebar Locators
  readonly skillSelector: Locator
  readonly skillOptions: Locator
  readonly conversationList: Locator
  readonly newChatButton: Locator

  // Dashboard Locators
  readonly greetingCard: Locator
  readonly suggestionChips: Locator
  readonly quickActions: Locator

  constructor(page: Page) {
    this.page = page

    // Chat UI
    this.chatContainer = page.locator('[data-testid="chat-container"], .chat-container, main')
    this.chatInput = page.locator('textarea, input[placeholder*="输入"], input[placeholder*="发送"]').last()
    this.sendButton = page.locator('button[type="submit"], button[aria-label*="send"], button[aria-label*="发送"]').first()
    this.messages = page.locator('[data-testid="chat-message"], .chat-message, [data-role]')
    this.userMessages = page.locator('[data-role="user"], .user-message')
    this.assistantMessages = page.locator('[data-role="assistant"], .assistant-message')
    this.thinkingIndicator = page.locator('[data-testid="thinking"], .thinking-indicator, .loading-dots')
    this.toolCards = page.locator('[data-testid="tool-card"], .tool-card, [data-tool-id]')

    // Sidebar
    this.skillSelector = page.locator('[data-testid="skill-selector"], .skill-selector')
    this.skillOptions = page.locator('[data-testid="skill-option"], .skill-option')
    this.conversationList = page.locator('[data-testid="conversation-list"], .conversation-list')
    this.newChatButton = page.locator('button[aria-label*="新对话"], button:has-text("新对话")')

    // Dashboard
    this.greetingCard = page.locator('[data-testid="greeting-card"], .greeting-card')
    this.suggestionChips = page.locator('[data-testid="suggestion-chip"], .suggestion-chip')
    this.quickActions = page.locator('[data-testid="quick-action"], .quick-action')
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // 导航方法
  // ═══════════════════════════════════════════════════════════════════════════

  async goto() {
    await this.page.goto('/chat')
    await this.page.waitForLoadState('networkidle')
    await this.page.waitForTimeout(1000)
  }

  async gotoWithSkill(skillId: SkillId) {
    await this.page.goto(`/chat?skill=${skillId}`)
    await this.page.waitForLoadState('networkidle')
    await this.page.waitForTimeout(1000)
  }

  async gotoConversation(conversationId: string) {
    await this.page.goto(`/chat/${conversationId}`)
    await this.page.waitForLoadState('networkidle')
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // 消息发送方法
  // ═══════════════════════════════════════════════════════════════════════════

  async sendMessage(message: string): Promise<void> {
    await this.chatInput.waitFor({ state: 'visible', timeout: 5000 })
    await this.chatInput.fill(message)
    await this.chatInput.press('Enter')
  }

  async sendMessageAndWait(message: string, timeout = 30000): Promise<void> {
    const initialCount = await this.assistantMessages.count()
    await this.sendMessage(message)
    await this.waitForNewAssistantMessage(initialCount, timeout)
  }

  async waitForNewAssistantMessage(initialCount: number, timeout = 30000): Promise<void> {
    // 等待 thinking 指示器出现
    await this.thinkingIndicator.waitFor({ state: 'visible', timeout: 5000 }).catch(() => {})

    // 等待新消息出现
    await this.page.waitForFunction(
      (initial) => {
        const messages = document.querySelectorAll('[data-role="assistant"], .assistant-message')
        return messages.length > initial
      },
      initialCount,
      { timeout }
    )

    // 等待 thinking 指示器消失
    await this.thinkingIndicator.waitFor({ state: 'hidden', timeout }).catch(() => {})
  }

  async waitForResponse(timeout = 30000): Promise<void> {
    // 等待 thinking 结束
    await this.thinkingIndicator.waitFor({ state: 'visible', timeout: 5000 }).catch(() => {})
    await this.thinkingIndicator.waitFor({ state: 'hidden', timeout }).catch(() => {})
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // 消息获取方法
  // ═══════════════════════════════════════════════════════════════════════════

  async getMessageCount(): Promise<number> {
    return await this.messages.count()
  }

  async getLastAssistantMessage(): Promise<string | null> {
    const count = await this.assistantMessages.count()
    if (count > 0) {
      return await this.assistantMessages.nth(count - 1).textContent()
    }
    return null
  }

  async getAllMessages(): Promise<ChatMessage[]> {
    const messages: ChatMessage[] = []
    const count = await this.messages.count()

    for (let i = 0; i < count; i++) {
      const msg = this.messages.nth(i)
      const role = await msg.getAttribute('data-role')
      const content = await msg.textContent()

      if (role && content) {
        messages.push({
          role: role as 'user' | 'assistant',
          content: content.trim(),
        })
      }
    }

    return messages
  }

  async hasToolCard(toolId?: string): Promise<boolean> {
    if (toolId) {
      return await this.page.locator(`[data-tool-id="${toolId}"]`).isVisible()
    }
    return await this.toolCards.first().isVisible().catch(() => false)
  }

  async getToolCards(): Promise<string[]> {
    const toolIds: string[] = []
    const count = await this.toolCards.count()

    for (let i = 0; i < count; i++) {
      const toolId = await this.toolCards.nth(i).getAttribute('data-tool-id')
      if (toolId) {
        toolIds.push(toolId)
      }
    }

    return toolIds
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // Skill 交互方法
  // ═══════════════════════════════════════════════════════════════════════════

  async selectSkill(skillId: SkillId): Promise<void> {
    await this.skillSelector.click()
    await this.page.locator(`[data-skill-id="${skillId}"]`).click()
  }

  async getCurrentSkill(): Promise<string | null> {
    const url = this.page.url()
    const skillMatch = url.match(/skill=(\w+)/)
    return skillMatch ? skillMatch[1] : null
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // Dashboard 交互方法
  // ═══════════════════════════════════════════════════════════════════════════

  async clickSuggestion(index: number): Promise<void> {
    const chip = this.suggestionChips.nth(index)
    if (await chip.isVisible()) {
      await chip.click()
    }
  }

  async getSuggestionTexts(): Promise<string[]> {
    const texts: string[] = []
    const count = await this.suggestionChips.count()

    for (let i = 0; i < count; i++) {
      const text = await this.suggestionChips.nth(i).textContent()
      if (text) {
        texts.push(text.trim())
      }
    }

    return texts
  }

  async startNewChat(): Promise<void> {
    if (await this.newChatButton.isVisible()) {
      await this.newChatButton.click()
      await this.page.waitForTimeout(1000)
    }
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // 工具方法
  // ═══════════════════════════════════════════════════════════════════════════

  async screenshot(name: string): Promise<void> {
    await this.page.screenshot({
      path: `test-results/${name}.png`,
      fullPage: true,
    })
  }

  async isChatReady(): Promise<boolean> {
    try {
      await this.chatInput.waitFor({ state: 'visible', timeout: 5000 })
      return await this.chatInput.isEnabled()
    } catch {
      return false
    }
  }

  async isThinking(): Promise<boolean> {
    return await this.thinkingIndicator.isVisible().catch(() => false)
  }

  async waitForChatReady(timeout = 10000): Promise<void> {
    await this.chatInput.waitFor({ state: 'visible', timeout })
    await this.chatInput.waitFor({ state: 'enabled', timeout: 5000 })
  }
}
