/**
 * VibeLife API Client
 * All API calls go through Next.js API routes to avoid exposing backend URLs
 */

const API_BASE = "/api";

// ─────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
  expires_in: number;
  user: {
    user_id: string;
    vibe_id: string;
    display_name?: string;
  };
}

export interface ChatRequest {
  message: string;
  skill: string;           // Changed from skill_id to match backend
  conversation_id?: string;
  voice_mode?: string;     // Added voice mode support
}

export interface ChatResponse {
  content: string;
  conversation_id: string;
  intent?: string;
  tools_used?: string[];
  knowledge_used: boolean;
  insight?: {
    id: string;
    insight_type: string;
    title: string;
    content: string;
  };
  suggestions?: string[];
}

// ─────────────────────────────────────────────────────────────────
// Token Management
// ─────────────────────────────────────────────────────────────────

let accessToken: string | null = null;
let refreshToken: string | null = null;

export function setTokens(access: string, refresh: string) {
  accessToken = access;
  refreshToken = refresh;
  if (typeof window !== "undefined") {
    localStorage.setItem("access_token", access);
    localStorage.setItem("refresh_token", refresh);
  }
}

export function getTokens() {
  if (typeof window !== "undefined") {
    accessToken = localStorage.getItem("access_token");
    refreshToken = localStorage.getItem("refresh_token");
  }
  return { accessToken, refreshToken };
}

export function clearTokens() {
  accessToken = null;
  refreshToken = null;
  if (typeof window !== "undefined") {
    localStorage.removeItem("access_token");
    localStorage.removeItem("refresh_token");
    localStorage.removeItem("user");
  }
}

// ─────────────────────────────────────────────────────────────────
// API Helpers
// ─────────────────────────────────────────────────────────────────

async function fetchAPI(
  endpoint: string,
  options: RequestInit = {}
): Promise<Response> {
  const { accessToken } = getTokens();

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...options.headers as Record<string, string>,
  };

  if (accessToken) {
    headers["Authorization"] = `Bearer ${accessToken}`;
  }

  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...options,
    headers,
  });

  // Handle 401 - try to refresh token
  if (response.status === 401) {
    const { refreshToken } = getTokens();
    if (refreshToken) {
      const refreshed = await refreshAccessToken();
      if (refreshed) {
        // IMPORTANT: Get fresh token after refresh
        const { accessToken: newAccessToken } = getTokens();
        const newHeaders = {
          ...headers,
          "Authorization": `Bearer ${newAccessToken}`,
        };
        return fetch(`${API_BASE}${endpoint}`, { ...options, headers: newHeaders });
      }
    }
  }

  return response;
}

async function refreshAccessToken(): Promise<boolean> {
  try {
    const { refreshToken: currentRefreshToken } = getTokens();
    if (!currentRefreshToken) {
      return false;
    }

    const response = await fetch("/api/auth/refresh", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ refresh_token: currentRefreshToken }),
    });

    if (response.ok) {
      const data: TokenResponse = await response.json();
      setTokens(data.access_token, data.refresh_token);
      return true;
    }
  } catch (error) {
    console.error("Token refresh failed:", error);
  }

  clearTokens();
  return false;
}

// ─────────────────────────────────────────────────────────────────
// Auth API (OAuth only - no password authentication)
// ─────────────────────────────────────────────────────────────────

export async function logout(): Promise<void> {
  try {
    await fetchAPI("/auth/logout", { method: "POST" });
  } finally {
    clearTokens();
  }
}

export async function getMe() {
  const response = await fetchAPI("/auth/me");
  if (!response.ok) throw new Error("Failed to get user");
  return response.json();
}

// ─────────────────────────────────────────────────────────────────
// Chat API
// ─────────────────────────────────────────────────────────────────

export async function sendMessage(request: ChatRequest): Promise<ChatResponse> {
  const response = await fetchAPI("/chat/", {
    method: "POST",
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || "Chat failed");
  }

  return response.json();
}

export async function sendGuestMessage(
  message: string,
  skill: string
): Promise<{ content: string; is_guest: boolean; suggestion: string }> {
  const response = await fetch("/api/proxy?endpoint=/api/v1/chat/guest", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message, skill }),
  });

  if (!response.ok) {
    throw new Error("Chat failed");
  }

  return response.json();
}

export interface StreamChatResult {
  conversation_id?: string;
  skill?: string;
  voice_mode?: string;
}

export async function streamChat(
  request: ChatRequest,
  onChunk: (chunk: string) => void,
  onDone: (result: StreamChatResult) => void,
  onError: (error: Error) => void
): Promise<void> {
  const { accessToken } = getTokens();

  try {
    const response = await fetch("/api/chat", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...(accessToken && { Authorization: `Bearer ${accessToken}` }),
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ detail: "Stream failed" }));
      onError(new Error(error.detail || "Stream failed"));
      return;
    }

    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    if (!reader) {
      onError(new Error("No response body"));
      return;
    }

    let buffer = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";

      for (const line of lines) {
        if (line.startsWith("data: ")) {
          const dataStr = line.slice(6).trim();
          if (!dataStr) continue;

          try {
            const data = JSON.parse(dataStr);
            if (data.type === "chunk") {
              onChunk(data.content);
            } else if (data.type === "done") {
              onDone({
                conversation_id: data.conversation_id,
                skill: data.skill,
                voice_mode: data.voice_mode,
              });
              return;
            } else if (data.type === "error") {
              onError(new Error(data.message));
              return;
            }
          } catch {
            // Skip malformed JSON
          }
        }
      }
    }

    onDone({});
  } catch (error) {
    onError(error instanceof Error ? error : new Error(String(error)));
  }
}

// ─────────────────────────────────────────────────────────────────
// User API
// ─────────────────────────────────────────────────────────────────

export async function getProfile() {
  const response = await fetchAPI("/users/me/profile");
  if (!response.ok) throw new Error("Failed to get profile");
  return response.json();
}

export async function updateProfile(data: Record<string, unknown>) {
  const response = await fetchAPI("/users/me/profile", {
    method: "PUT",
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error("Failed to update profile");
  return response.json();
}

export async function getSubscriptionStatus() {
  const response = await fetchAPI("/users/me/subscription");
  if (!response.ok) throw new Error("Failed to get subscription");
  return response.json();
}

// ─────────────────────────────────────────────────────────────────
// Guest Tool API (Landing page direct tool invocation)
// ─────────────────────────────────────────────────────────────────

export interface GuestToolRequest {
  skill: string;           // Changed from skill_id
  tool: string;
  birth_date: string;
  birth_time?: string;
  gender?: string;
  birth_location?: string;
}

export interface GuestToolResponse {
  success: boolean;
  tool: string;
  skill: string;           // Changed from skill_id
  raw_result?: string;
  chart_data?: Record<string, unknown>;
  interpretation?: string;
  is_guest: boolean;
  suggestion?: string;
  error?: string;
}

export async function invokeGuestTool(
  request: GuestToolRequest
): Promise<GuestToolResponse> {
  const response = await fetch("/api/proxy?endpoint=/api/v1/chat/guest/tool", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Tool invocation failed" }));
    throw new Error(error.detail || "Tool invocation failed");
  }

  return response.json();
}

// ─────────────────────────────────────────────────────────────────
// SSO API
// ─────────────────────────────────────────────────────────────────

export interface SSOGenerateResponse {
  sso_token: string;
  redirect_url: string;
  expires_in: number;
}

export async function generateSSOToken(targetSite: string): Promise<SSOGenerateResponse> {
  const response = await fetchAPI("/auth/sso/generate", {
    method: "POST",
    body: JSON.stringify({ target_site: targetSite }),
  });

  if (!response.ok) {
    throw new Error("Failed to generate SSO token");
  }

  return response.json();
}

export async function exchangeSSOToken(
  token: string,
  site: string
): Promise<TokenResponse> {
  const response = await fetch("/api/auth/sso/callback", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ token, site }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "SSO exchange failed" }));
    throw new Error(error.detail || "SSO exchange failed");
  }

  const data: TokenResponse = await response.json();
  setTokens(data.access_token, data.refresh_token);

  if (typeof window !== "undefined") {
    localStorage.setItem("user", JSON.stringify(data.user));
  }

  return data;
}

/**
 * Redirect to another VibeLife site with SSO
 */
export async function ssoRedirect(targetSite: string): Promise<void> {
  const response = await generateSSOToken(targetSite);
  if (response.redirect_url) {
    window.location.href = response.redirect_url;
  }
}

// ─────────────────────────────────────────────────────────────────
// Guest Session API
// ─────────────────────────────────────────────────────────────────

export interface GuestSession {
  session_id: string;
  birth_datetime?: string;
  birth_location?: string;
  gender?: string;
  voice_mode?: string;
  skill?: string;
  interview_responses?: Record<string, unknown>;
  focus_areas?: string[];
  expires_at: string;
}

export interface OnboardingData {
  birth_datetime?: string;
  birth_location?: string;
  gender?: string;
  voice_mode?: string;
  skill?: string;
  interview_responses?: Record<string, unknown>;
  focus_areas?: string[];
}

export async function createGuestSession(): Promise<GuestSession> {
  const response = await fetch("/api/guest/session", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
  });

  if (!response.ok) {
    throw new Error("Failed to create guest session");
  }

  return response.json();
}

export async function getGuestSession(): Promise<GuestSession | null> {
  try {
    const response = await fetch("/api/guest/session", {
      credentials: "include",
    });

    if (!response.ok) {
      return null;
    }

    return response.json();
  } catch {
    return null;
  }
}

export async function saveOnboardingData(data: OnboardingData): Promise<GuestSession> {
  const response = await fetch("/api/proxy?endpoint=/api/v1/guest/session/onboarding", {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify(data),
  });

  if (!response.ok) {
    throw new Error("Failed to save onboarding data");
  }

  return response.json();
}

// ─────────────────────────────────────────────────────────────────
// OAuth API
// ─────────────────────────────────────────────────────────────────

export async function googleAuth(
  idToken: string,
  onboarding?: OnboardingData
): Promise<TokenResponse> {
  const response = await fetch("/api/auth/oauth/google", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify({ id_token: idToken, onboarding }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Google auth failed" }));
    throw new Error(error.detail || "Google auth failed");
  }

  const data: TokenResponse = await response.json();
  setTokens(data.access_token, data.refresh_token);

  if (typeof window !== "undefined") {
    localStorage.setItem("user", JSON.stringify(data.user));
  }

  return data;
}

export async function appleAuth(
  idToken: string,
  userName?: string,
  onboarding?: OnboardingData
): Promise<TokenResponse> {
  const response = await fetch("/api/auth/oauth/apple", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify({ id_token: idToken, user_name: userName, onboarding }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Apple auth failed" }));
    throw new Error(error.detail || "Apple auth failed");
  }

  const data: TokenResponse = await response.json();
  setTokens(data.access_token, data.refresh_token);

  if (typeof window !== "undefined") {
    localStorage.setItem("user", JSON.stringify(data.user));
  }

  return data;
}

// ─────────────────────────────────────────────────────────────────
// WeChat OAuth API
// ─────────────────────────────────────────────────────────────────

export interface WechatQRCodeResponse {
  scene_id: string;
  qrcode_url: string;
  expires_at: string;
}

export interface WechatStatusResponse {
  status: "pending" | "scanned" | "confirmed" | "expired";
  message?: string;
  access_token?: string;
  refresh_token?: string;
  token_type?: string;
  expires_in?: number;
  user?: {
    user_id: string;
    vibe_id: string;
    display_name?: string;
  };
}

export async function getWechatQRCode(redirectUri: string): Promise<WechatQRCodeResponse> {
  const response = await fetch("/api/auth/oauth/wechat/qrcode", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ redirect_uri: redirectUri }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Failed to generate QR code" }));
    throw new Error(error.detail || "Failed to generate QR code");
  }

  return response.json();
}

export async function pollWechatStatus(sceneId: string): Promise<WechatStatusResponse> {
  const response = await fetch(`/api/auth/oauth/wechat/status/${sceneId}`);

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Failed to poll status" }));
    throw new Error(error.detail || "Failed to poll status");
  }

  const data: WechatStatusResponse = await response.json();

  // If confirmed, store tokens
  if (data.status === "confirmed" && data.access_token && data.refresh_token) {
    setTokens(data.access_token, data.refresh_token);

    if (typeof window !== "undefined" && data.user) {
      localStorage.setItem("user", JSON.stringify(data.user));
    }
  }

  return data;
}

// ─────────────────────────────────────────────────────────────────
// Account Deletion API
// ─────────────────────────────────────────────────────────────────

export interface DeletionStatusResponse {
  status: string;
  deletion_requested_at?: string;
  deletion_scheduled_at?: string;
  grace_period_days?: number;
  can_cancel: boolean;
  message?: string;
}

export async function requestAccountDeletion(): Promise<DeletionStatusResponse> {
  const response = await fetchAPI("/auth/delete-account", {
    method: "POST",
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Request failed" }));
    throw new Error(error.detail || "Failed to request account deletion");
  }

  return response.json();
}

export async function cancelAccountDeletion(): Promise<DeletionStatusResponse> {
  const response = await fetchAPI("/auth/cancel-deletion", {
    method: "POST",
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Request failed" }));
    throw new Error(error.detail || "Failed to cancel deletion");
  }

  return response.json();
}

export async function getAccountDeletionStatus(): Promise<DeletionStatusResponse> {
  const response = await fetchAPI("/auth/deletion-status");

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Request failed" }));
    throw new Error(error.detail || "Failed to get deletion status");
  }

  return response.json();
}

// ─────────────────────────────────────────────────────────────────
// API Client (axios-like interface)
// ─────────────────────────────────────────────────────────────────

interface ApiClientResponse<T = unknown> {
  data: T;
  status: number;
}

interface ApiClientRequestConfig {
  params?: Record<string, unknown>;
  headers?: Record<string, string>;
}

function buildUrlWithParams(url: string, params?: Record<string, unknown>): string {
  if (!params) return url;

  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    if (value !== undefined && value !== null) {
      searchParams.append(key, String(value));
    }
  }

  const queryString = searchParams.toString();
  if (!queryString) return url;

  return url + (url.includes('?') ? '&' : '?') + queryString;
}

async function apiRequest<T>(
  method: string,
  url: string,
  data?: unknown,
  config?: ApiClientRequestConfig
): Promise<ApiClientResponse<T>> {
  const fullUrl = buildUrlWithParams(url, config?.params);

  const response = await fetchAPI(fullUrl, {
    method,
    headers: config?.headers,
    body: data ? JSON.stringify(data) : undefined,
  });

  const responseData = await response.json().catch(() => ({}));

  if (!response.ok) {
    const error = new Error((responseData as { detail?: string }).detail || 'Request failed') as Error & {
      response: { status: number; data: unknown };
    };
    error.response = { status: response.status, data: responseData };
    throw error;
  }

  return { data: responseData as T, status: response.status };
}

export const apiClient = {
  get<T = unknown>(url: string, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
    return apiRequest<T>('GET', url, undefined, config);
  },

  post<T = unknown>(url: string, data?: unknown, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
    return apiRequest<T>('POST', url, data, config);
  },

  put<T = unknown>(url: string, data?: unknown, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
    return apiRequest<T>('PUT', url, data, config);
  },

  patch<T = unknown>(url: string, data?: unknown, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
    return apiRequest<T>('PATCH', url, data, config);
  },

  delete<T = unknown>(url: string, config?: ApiClientRequestConfig): Promise<ApiClientResponse<T>> {
    return apiRequest<T>('DELETE', url, undefined, config);
  },
};
