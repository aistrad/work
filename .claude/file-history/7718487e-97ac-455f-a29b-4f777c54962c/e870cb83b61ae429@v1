"use client";

/**
 * LifeCoachProvider - V8 人生仪表盘状态管理
 *
 * 提供 LifeCoach 数据的全局状态管理:
 * - 北极星愿景
 * - 核心目标
 * - 周大石头
 * - 每日杠杆
 * - 进度统计
 */

import {
  createContext,
  useContext,
  useState,
  useCallback,
  useMemo,
  useEffect,
  type ReactNode,
} from "react";
import type {
  LifeCoachState,
  NorthStar,
  Goal,
  Role,
  Identity,
  WeeklyRocks,
  DailyLevers,
  MonthlyBoss,
  Progress,
  CheckinRequest,
  LifeCoachSection,
} from "@/types/lifecoach";
import {
  readDashboardState,
  readState as apiReadState,
  checkin as apiCheckin,
  completeLever as apiCompleteLever,
  completeRock as apiCompleteRock,
  skipLever as apiSkipLever,
} from "@/lib/lifecoach-api";
import { useAuth } from "./AuthProvider";

// ═══════════════════════════════════════════════════════════════════════════
// Context Types
// ═══════════════════════════════════════════════════════════════════════════

interface LifeCoachContextValue extends LifeCoachState {
  // Actions
  loadLifeCoachData: () => Promise<void>;
  updateSection: (section: LifeCoachSection, data: unknown) => Promise<boolean>;
  checkin: (params?: CheckinRequest) => Promise<boolean>;
  completeLever: (leverId: string, notes?: string) => Promise<boolean>;
  completeRock: (rockId: string, reflection?: string) => Promise<boolean>;
  skipLever: (leverId: string, reason?: string) => Promise<boolean>;
  refresh: () => Promise<void>;
  // Computed
  todayCheckedIn: boolean;
  hasNorthStar: boolean;
  hasIdentity: boolean;
  activeGoalsCount: number;
  todayLeversCount: number;
  todayLeversCompleted: number;
}

const LifeCoachContext = createContext<LifeCoachContextValue | null>(null);

// ═══════════════════════════════════════════════════════════════════════════
// Provider Component
// ═══════════════════════════════════════════════════════════════════════════

interface LifeCoachProviderProps {
  children: ReactNode;
}

export function LifeCoachProvider({ children }: LifeCoachProviderProps) {
  const { isSignedIn: isAuthenticated } = useAuth();

  // State
  const [northStar, setNorthStar] = useState<NorthStar | null>(null);
  const [goals, setGoals] = useState<Goal[]>([]);
  const [roles, setRoles] = useState<Role[]>([]);
  const [identity, setIdentity] = useState<Identity | null>(null);
  const [currentWeek, setCurrentWeek] = useState<WeeklyRocks | null>(null);
  const [currentDaily, setCurrentDaily] = useState<DailyLevers | null>(null);
  const [currentMonth, setCurrentMonth] = useState<MonthlyBoss | null>(null);
  const [progress, setProgress] = useState<Progress | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Load data from API
  const loadLifeCoachData = useCallback(async () => {
    if (!isAuthenticated) {
      setIsInitialized(true);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const data = await readDashboardState();

      if (data.north_star) setNorthStar(data.north_star);
      if (data.goals) setGoals(data.goals);
      if (data.roles) setRoles(data.roles);
      if (data.identity) setIdentity(data.identity);
      if (data.weekly_rocks) setCurrentWeek(data.weekly_rocks);
      if (data.daily_levers) setCurrentDaily(data.daily_levers);
      if (data.monthly_boss) setCurrentMonth(data.monthly_boss);
      if (data.progress) setProgress(data.progress);

      setIsInitialized(true);
    } catch (err) {
      const message = err instanceof Error ? err.message : "Failed to load data";
      setError(message);
      console.error("LifeCoach data load error:", err);
    } finally {
      setIsLoading(false);
    }
  }, [isAuthenticated]);

  // Checkin action
  const checkin = useCallback(async (params?: CheckinRequest): Promise<boolean> => {
    try {
      const result = await apiCheckin(params);

      if (result.success) {
        // Update progress with new streak
        setProgress((prev) =>
          prev
            ? {
                ...prev,
                current_streak: result.streak,
                today_checked_in: true,
                last_checkin_date: new Date().toISOString().split("T")[0],
              }
            : null
        );

        // Update daily levers if returned
        if (result.daily_levers) {
          setCurrentDaily(result.daily_levers);
        }

        return true;
      }
      return false;
    } catch (err) {
      console.error("Checkin error:", err);
      return false;
    }
  }, []);

  // Update section action - 通用更新方法
  const updateSection = useCallback(
    async (section: LifeCoachSection, data: unknown): Promise<boolean> => {
      try {
        // 根据 section 更新对应的本地状态
        switch (section) {
          case "north_star":
            setNorthStar(data as NorthStar);
            break;
          case "goals":
            setGoals(data as Goal[]);
            break;
          case "roles":
            setRoles(data as Role[]);
            break;
          case "identity":
            setIdentity(data as Identity);
            break;
          case "weekly_rocks":
            setCurrentWeek(data as WeeklyRocks);
            break;
          case "daily_levers":
            setCurrentDaily(data as DailyLevers);
            break;
          case "monthly_boss":
            setCurrentMonth(data as MonthlyBoss);
            break;
          case "progress":
            setProgress(data as Progress);
            break;
        }

        // 重新从服务器获取最新数据以确保同步
        const freshData = await apiReadState([section]);

        // 更新对应状态
        if (freshData.north_star && section === "north_star") setNorthStar(freshData.north_star);
        if (freshData.goals && section === "goals") setGoals(freshData.goals);
        if (freshData.roles && section === "roles") setRoles(freshData.roles);
        if (freshData.identity && section === "identity") setIdentity(freshData.identity);
        if (freshData.weekly_rocks && section === "weekly_rocks") setCurrentWeek(freshData.weekly_rocks);
        if (freshData.daily_levers && section === "daily_levers") setCurrentDaily(freshData.daily_levers);
        if (freshData.monthly_boss && section === "monthly_boss") setCurrentMonth(freshData.monthly_boss);
        if (freshData.progress && section === "progress") setProgress(freshData.progress);

        return true;
      } catch (err) {
        console.error("Update section error:", err);
        return false;
      }
    },
    []
  );

  // Complete lever action
  const completeLever = useCallback(
    async (leverId: string, notes?: string): Promise<boolean> => {
      try {
        const result = await apiCompleteLever({ lever_id: leverId, notes });

        if (result.success) {
          // Optimistically update local state
          setCurrentDaily((prev) => {
            if (!prev) return prev;
            const updatedLevers = prev.levers.map((lever) =>
              lever.id === leverId
                ? { ...lever, status: "completed" as const, completed_at: new Date().toISOString() }
                : lever
            );
            const completed = updatedLevers.filter((l) => l.status === "completed").length;
            return {
              ...prev,
              levers: updatedLevers,
              stats: {
                total: updatedLevers.length,
                completed,
                completion_rate: Math.round((completed / updatedLevers.length) * 100),
              },
            };
          });

          // Update progress if returned
          if (result.progress) {
            setProgress(result.progress);
          }

          return true;
        }
        return false;
      } catch (err) {
        console.error("Complete lever error:", err);
        return false;
      }
    },
    []
  );

  // Complete rock action
  const completeRock = useCallback(
    async (rockId: string, reflection?: string): Promise<boolean> => {
      try {
        const result = await apiCompleteRock({ rock_id: rockId, reflection });

        if (result.success) {
          // Optimistically update local state
          setCurrentWeek((prev) => {
            if (!prev) return prev;
            const updatedRocks = prev.rocks.map((rock) =>
              rock.id === rockId
                ? { ...rock, status: "completed" as const, progress: 100 }
                : rock
            );
            const completed = updatedRocks.filter((r) => r.status === "completed").length;
            const inProgress = updatedRocks.filter((r) => r.status === "in_progress").length;
            return {
              ...prev,
              rocks: updatedRocks,
              stats: {
                total: updatedRocks.length,
                completed,
                in_progress: inProgress,
                completion_rate: Math.round((completed / updatedRocks.length) * 100),
              },
            };
          });

          // Update progress if returned
          if (result.progress) {
            setProgress(result.progress);
          }

          return true;
        }
        return false;
      } catch (err) {
        console.error("Complete rock error:", err);
        return false;
      }
    },
    []
  );

  // Skip lever action
  const skipLever = useCallback(
    async (leverId: string, reason?: string): Promise<boolean> => {
      try {
        const result = await apiSkipLever(leverId, reason);

        if (result.success) {
          // Optimistically update local state
          setCurrentDaily((prev) => {
            if (!prev) return prev;
            return {
              ...prev,
              levers: prev.levers.map((lever) =>
                lever.id === leverId
                  ? { ...lever, status: "skipped" as const }
                  : lever
              ),
            };
          });

          return true;
        }
        return false;
      } catch (err) {
        console.error("Skip lever error:", err);
        return false;
      }
    },
    []
  );

  // Refresh data
  const refresh = useCallback(async () => {
    await loadLifeCoachData();
  }, [loadLifeCoachData]);

  // Auto-load on auth change
  useEffect(() => {
    if (isAuthenticated && !isInitialized) {
      loadLifeCoachData();
    }
  }, [isAuthenticated, isInitialized, loadLifeCoachData]);

  // Computed values
  const todayCheckedIn = progress?.today_checked_in ?? false;
  const hasNorthStar = Boolean(northStar?.vision_scene || northStar?.identity_statement);
  const hasIdentity = Boolean(identity?.target);
  const activeGoalsCount = goals.filter((g) => g.status === "active").length;
  const todayLeversCount = currentDaily?.levers.length ?? 0;
  const todayLeversCompleted =
    currentDaily?.levers.filter((l) => l.status === "completed").length ?? 0;

  // Memoized context value
  const contextValue = useMemo<LifeCoachContextValue>(
    () => ({
      // State
      northStar,
      goals,
      roles,
      identity,
      currentWeek,
      currentDaily,
      currentMonth,
      progress,
      isLoading,
      isInitialized,
      error,
      // Actions
      loadLifeCoachData,
      updateSection,
      checkin,
      completeLever,
      completeRock,
      skipLever,
      refresh,
      // Computed
      todayCheckedIn,
      hasNorthStar,
      hasIdentity,
      activeGoalsCount,
      todayLeversCount,
      todayLeversCompleted,
    }),
    [
      northStar,
      goals,
      roles,
      identity,
      currentWeek,
      currentDaily,
      currentMonth,
      progress,
      isLoading,
      isInitialized,
      error,
      loadLifeCoachData,
      updateSection,
      checkin,
      completeLever,
      completeRock,
      skipLever,
      refresh,
      todayCheckedIn,
      hasNorthStar,
      hasIdentity,
      activeGoalsCount,
      todayLeversCount,
      todayLeversCompleted,
    ]
  );

  return (
    <LifeCoachContext.Provider value={contextValue}>
      {children}
    </LifeCoachContext.Provider>
  );
}

// ═══════════════════════════��═══════════════════════════════════════════════
// Hook
// ═══════════════════════════════════════════════════════════════════════════

export function useLifeCoach(): LifeCoachContextValue {
  const context = useContext(LifeCoachContext);
  if (!context) {
    throw new Error("useLifeCoach must be used within LifeCoachProvider");
  }
  return context;
}

// Convenience hooks for specific data
export function useNorthStar() {
  const { northStar, hasNorthStar, isLoading } = useLifeCoach();
  return { northStar, hasNorthStar, isLoading };
}

export function useGoals() {
  const { goals, activeGoalsCount, isLoading } = useLifeCoach();
  return { goals, activeGoalsCount, isLoading };
}

export function useWeeklyRocks() {
  const { currentWeek, completeRock, isLoading } = useLifeCoach();
  return { currentWeek, completeRock, isLoading };
}

export function useDailyLevers() {
  const { currentDaily, completeLever, skipLever, isLoading } = useLifeCoach();
  return { currentDaily, completeLever, skipLever, isLoading };
}

export function useProgress() {
  const { progress, todayCheckedIn, checkin, isLoading } = useLifeCoach();
  return { progress, todayCheckedIn, checkin, isLoading };
}
