"""
Unified Tool Registry v6 - 统一工具注册表

解决工具注册的硬编码问题：
1. 从 YAML 加载工具定义 (Single Source of Truth)
2. 使用 @tool_handler 装饰器动态注册执行器
3. 消除 if-elif 分发，使用注册表查找

V6.1 更新：
- 全局工具从 skills/core/tools/ 加载
- 移除对 GLOBAL_TOOLS 硬编码的依赖

新增工具只需修改 2 处：
1. skills/{skill_id}/tools/tools.yaml - 工具定义
2. skills/{skill_id}/tools/handlers.py - @tool_handler 执行器

用法：
    from services.agent.tool_registry import tool_handler, ToolRegistry

    @tool_handler("show_bazi_chart")
    async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:
        return {"chart": ...}

    # CoreAgent 中使用
    tools = ToolRegistry.get_tools_for_skill("bazi")
    result = await ToolRegistry.execute("show_bazi_chart", args, context)
"""
import logging
import importlib
import asyncio
from pathlib import Path
from typing import Dict, Any, List, Optional, Callable, Awaitable, Union
from dataclasses import dataclass, field
from functools import wraps

from .tool_schema import ToolDef, load_skill_tools, get_global_tools

logger = logging.getLogger(__name__)

SKILLS_DIR = Path(__file__).parent.parent.parent / "skills"


@dataclass
class ToolContext:
    """工具执行上下文"""
    user_id: str
    user_tier: str = "free"
    profile: Dict[str, Any] = field(default_factory=dict)
    skill_data: Dict[str, Any] = field(default_factory=dict)
    skill_id: Optional[str] = None
    scenario_id: Optional[str] = None
    conversation_id: Optional[str] = None


# 工具执行器类型: 同步或异步函数
ToolHandler = Callable[[Dict[str, Any], ToolContext], Union[Dict[str, Any], Awaitable[Dict[str, Any]]]]


class UnifiedToolRegistry:
    """
    统一工具注册表

    - 工具定义从 YAML 加载
    - 执行器通过 @tool_handler 装饰器注册
    - 支持全局工具和 Skill 专属工具
    """

    # 工具定义缓存: {tool_name: ToolDef}
    _tool_defs: Dict[str, ToolDef] = {}

    # 工具执行器: {tool_name: handler_function}
    _handlers: Dict[str, ToolHandler] = {}

    # 已加载的 Skill
    _loaded_skills: set = set()

    # 是否已初始化
    _initialized: bool = False

    @classmethod
    def initialize(cls):
        """初始化注册表，加载全局工具"""
        if cls._initialized:
            return

        # 从 core skill 加载全局工具定义
        global_tools = get_global_tools()
        for tool in global_tools:
            tool.is_global = True
            cls._tool_defs[tool.name] = tool

        # 加载 core skill 的 handlers
        cls._load_handlers_module("core")

        # 自动发现并加载所有 Skill 的工具
        cls._auto_discover_skills()

        cls._initialized = True
        logger.info(f"ToolRegistry initialized: {len(cls._tool_defs)} tools, {len(cls._handlers)} handlers")

    @classmethod
    def _auto_discover_skills(cls):
        """自动发现并加载所有 Skill"""
        if not SKILLS_DIR.exists():
            logger.warning(f"Skills directory not found: {SKILLS_DIR}")
            return

        for skill_dir in SKILLS_DIR.iterdir():
            if skill_dir.is_dir() and skill_dir.name != "__pycache__":
                skill_id = skill_dir.name
                cls.load_skill(skill_id)

    @classmethod
    def load_skill(cls, skill_id: str):
        """加载 Skill 的工具定义和执行器"""
        if skill_id in cls._loaded_skills:
            return

        # 1. 从 YAML 加载工具定义
        tools = load_skill_tools(skill_id)
        for tool in tools:
            tool.skill_id = skill_id  # 标记所属 Skill
            cls._tool_defs[tool.name] = tool

        # 2. 尝试加载执行器模块
        cls._load_handlers_module(skill_id)

        cls._loaded_skills.add(skill_id)
        logger.debug(f"Loaded skill '{skill_id}': {len(tools)} tools")

    @classmethod
    def _load_handlers_module(cls, skill_id: str):
        """加载 Skill 的 handlers 模块"""
        handlers_path = SKILLS_DIR / skill_id / "tools" / "handlers.py"
        if not handlers_path.exists():
            logger.debug(f"No handlers module for skill '{skill_id}'")
            return

        try:
            module_name = f"skills.{skill_id}.tools.handlers"
            importlib.import_module(module_name)
            logger.debug(f"Loaded handlers module: {module_name}")
        except ImportError as e:
            logger.warning(f"Failed to import handlers for '{skill_id}': {e}")

    @classmethod
    def register_handler(cls, tool_name: str, handler: ToolHandler):
        """注册工具执行器"""
        cls._handlers[tool_name] = handler
        logger.debug(f"Registered handler: {tool_name}")

    @classmethod
    def get_tool_def(cls, tool_name: str) -> Optional[ToolDef]:
        """获取工具定义"""
        cls.initialize()
        return cls._tool_defs.get(tool_name)

    @classmethod
    def get_tools_for_skill(cls, skill_id: str) -> List[Dict[str, Any]]:
        """获取 Skill 的所有工具 (OpenAI 格式)

        V6.2 更新：按需加载全局工具
        - 如果 SKILL.md 中声明了 global_tools，只加载声明的全局工具
        - 如果没有声明，加载所有全局工具（向后兼容）
        """
        cls.initialize()

        tools = []

        # 获取 Skill 声明需要的全局工具
        from .skill_loader import get_skill_global_tools
        declared_global_tools = get_skill_global_tools(skill_id)

        # 全局工具（从 core skill 加载）
        all_global_tools = get_global_tools()
        for tool in all_global_tools:
            # 如果声明了 global_tools，只加载声明的；否则加载全部
            if declared_global_tools:
                if tool.name in declared_global_tools:
                    tools.append(tool.to_openai_format())
            else:
                # 向后兼容：没有声明则加载全部
                tools.append(tool.to_openai_format())

        # Skill 专属工具（跳过 core，因为已经加载了）
        if skill_id != "core":
            for name, tool in cls._tool_defs.items():
                if getattr(tool, 'skill_id', None) == skill_id:
                    tools.append(tool.to_openai_format())

        # v7.3: 外部工具（从其他 skill 导入）
        from .skill_loader import get_skill_external_tools
        external_tool_names = get_skill_external_tools(skill_id)
        if external_tool_names:
            for name, tool in cls._tool_defs.items():
                if name in external_tool_names:
                    tools.append(tool.to_openai_format())

        return tools

    @classmethod
    def get_all_tools(cls) -> List[Dict[str, Any]]:
        """获取所有已注册的工具 (OpenAI 格式)"""
        cls.initialize()
        return [tool.to_openai_format() for tool in cls._tool_defs.values()]

    @classmethod
    def get_card_type(cls, tool_name: str) -> Optional[str]:
        """获取工具对应的卡片类型"""
        tool = cls.get_tool_def(tool_name)
        return tool.card_type if tool else None

    @classmethod
    def has_handler(cls, tool_name: str) -> bool:
        """检查是否有注册的执行器"""
        cls.initialize()
        return tool_name in cls._handlers

    @classmethod
    async def execute(
        cls,
        tool_name: str,
        args: Dict[str, Any],
        context: ToolContext
    ) -> Dict[str, Any]:
        """执行工具"""
        cls.initialize()

        if tool_name not in cls._handlers:
            logger.warning(f"No handler for tool: {tool_name}")
            return {"error": f"Tool handler not found: {tool_name}"}

        handler = cls._handlers[tool_name]

        try:
            # 支持同步和异步处理器
            result = handler(args, context)
            if asyncio.iscoroutine(result):
                result = await result
            return result
        except Exception as e:
            logger.error(f"Tool execution failed: {tool_name}, error: {e}")
            return {"error": str(e)}

    @classmethod
    def get_schema(cls, skill_id: Optional[str] = None) -> Dict[str, Any]:
        """获取工具 Schema (用于前端)"""
        cls.initialize()

        global_tool_names = {t.name for t in get_global_tools()}

        # v7.3: 获取外部工具名
        external_tool_names = set()
        if skill_id:
            from .skill_loader import get_skill_external_tools
            external_tool_names = set(get_skill_external_tools(skill_id))

        tools = []
        for name, tool in cls._tool_defs.items():
            if skill_id and getattr(tool, 'skill_id', None) != skill_id:
                if name not in global_tool_names and name not in external_tool_names:
                    continue

            tools.append({
                "name": tool.name,
                "description": tool.description,
                "tool_type": tool.tool_type,
                "card_type": tool.card_type,
                "fallback_type": tool.fallback_type,  # V7.1: 降级类型
                "card_props": tool.card_props,  # 新增: 表单配置等
                "parameters": [
                    {
                        "name": p.name,
                        "type": p.type,
                        "required": p.required,
                        "description": p.description,
                        "enum": p.enum,
                        "default": p.default,
                    }
                    for p in tool.parameters
                ],
                "when_to_call": tool.when_to_call,
            })

        return {
            "version": "7.1",
            "skill_id": skill_id,
            "tools": tools,
        }

    @classmethod
    def clear(cls):
        """清除所有注册 (用于测试)"""
        cls._tool_defs.clear()
        cls._handlers.clear()
        cls._loaded_skills.clear()
        cls._initialized = False


def tool_handler(tool_name: str):
    """
    工具执行器装饰器

    用法:
        @tool_handler("show_bazi_chart")
        async def execute_show_bazi_chart(args: Dict, context: ToolContext) -> Dict:
            return {"chart": ...}
    """
    def decorator(func: ToolHandler) -> ToolHandler:
        @wraps(func)
        async def wrapper(args: Dict[str, Any], context: ToolContext) -> Dict[str, Any]:
            result = func(args, context)
            if asyncio.iscoroutine(result):
                return await result
            return result

        # 注册到 Registry
        UnifiedToolRegistry.register_handler(tool_name, wrapper)
        return wrapper

    return decorator


# 便捷别名
ToolRegistry = UnifiedToolRegistry
