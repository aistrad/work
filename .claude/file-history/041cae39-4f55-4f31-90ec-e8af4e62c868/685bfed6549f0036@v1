"""
Zodiac Calculator - Western Astrology Calculations
Based on: vibelife spec v3.0

Uses pyswisseph (Swiss Ephemeris) for accurate astronomical calculations.
Install: pip install pyswisseph

References:
- https://www.astro.com/swisseph/
- https://github.com/astrorigin/pyswisseph
"""

import logging
from dataclasses import dataclass, field, asdict
from typing import Dict, Any, Optional, List
from datetime import datetime, date
from enum import Enum
import math

logger = logging.getLogger(__name__)

# Try to import swisseph
try:
    import swisseph as swe
    FLATLIB_AVAILABLE = True  # Keep name for backward compatibility

    # Set ephemeris path (optional, uses built-in Moshier ephemeris if not available)
    try:
        swe.set_ephe_path('/usr/share/ephe')
    except Exception:
        pass  # Use built-in ephemeris

except ImportError:
    FLATLIB_AVAILABLE = False
    swe = None
    logger.error("pyswisseph not installed. Install with: pip install pyswisseph")


class ZodiacSign(str, Enum):
    """Zodiac Signs (黄道十二宫)"""
    ARIES = "aries"           # 白羊座
    TAURUS = "taurus"         # 金牛座
    GEMINI = "gemini"         # 双子座
    CANCER = "cancer"         # 巨蟹座
    LEO = "leo"               # 狮子座
    VIRGO = "virgo"           # 处女座
    LIBRA = "libra"           # 天秤座
    SCORPIO = "scorpio"       # 天蝎座
    SAGITTARIUS = "sagittarius"  # 射手座
    CAPRICORN = "capricorn"   # 摩羯座
    AQUARIUS = "aquarius"     # 水瓶座
    PISCES = "pisces"         # 双鱼座


class Planet(str, Enum):
    """Planets (行星)"""
    SUN = "sun"           # 太阳
    MOON = "moon"         # 月亮
    MERCURY = "mercury"   # 水星
    VENUS = "venus"       # 金星
    MARS = "mars"         # 火星
    JUPITER = "jupiter"   # 木星
    SATURN = "saturn"     # 土星
    URANUS = "uranus"     # 天王星
    NEPTUNE = "neptune"   # 海王星
    PLUTO = "pluto"       # 冥王星


class Element(str, Enum):
    """Elements (元素)"""
    FIRE = "fire"     # 火象
    EARTH = "earth"   # 土象
    AIR = "air"       # 风象
    WATER = "water"   # 水象


class Modality(str, Enum):
    """Modalities (模式)"""
    CARDINAL = "cardinal"   # 本位
    FIXED = "fixed"         # 固定
    MUTABLE = "mutable"     # 变动


# Sign mappings
SIGN_LIST = ["aries", "taurus", "gemini", "cancer", "leo", "virgo",
             "libra", "scorpio", "sagittarius", "capricorn", "aquarius", "pisces"]

SIGN_CHINESE = {
    "aries": "白羊座", "taurus": "金牛座", "gemini": "双子座",
    "cancer": "巨蟹座", "leo": "狮子座", "virgo": "处女座",
    "libra": "天秤座", "scorpio": "天蝎座", "sagittarius": "射手座",
    "capricorn": "摩羯座", "aquarius": "水瓶座", "pisces": "双鱼座",
}

SIGN_ELEMENT = {
    "aries": Element.FIRE, "leo": Element.FIRE, "sagittarius": Element.FIRE,
    "taurus": Element.EARTH, "virgo": Element.EARTH, "capricorn": Element.EARTH,
    "gemini": Element.AIR, "libra": Element.AIR, "aquarius": Element.AIR,
    "cancer": Element.WATER, "scorpio": Element.WATER, "pisces": Element.WATER,
}

SIGN_MODALITY = {
    "aries": Modality.CARDINAL, "cancer": Modality.CARDINAL,
    "libra": Modality.CARDINAL, "capricorn": Modality.CARDINAL,
    "taurus": Modality.FIXED, "leo": Modality.FIXED,
    "scorpio": Modality.FIXED, "aquarius": Modality.FIXED,
    "gemini": Modality.MUTABLE, "virgo": Modality.MUTABLE,
    "sagittarius": Modality.MUTABLE, "pisces": Modality.MUTABLE,
}

PLANET_CHINESE = {
    "sun": "太阳", "moon": "月亮", "mercury": "水星",
    "venus": "金星", "mars": "火星", "jupiter": "木星",
    "saturn": "土星", "uranus": "天王星", "neptune": "海王星", "pluto": "冥王星",
}

# Swiss Ephemeris planet IDs
SWE_PLANETS = {
    "sun": 0,      # swe.SUN
    "moon": 1,     # swe.MOON
    "mercury": 2,  # swe.MERCURY
    "venus": 3,    # swe.VENUS
    "mars": 4,     # swe.MARS
    "jupiter": 5,  # swe.JUPITER
    "saturn": 6,   # swe.SATURN
    "uranus": 7,   # swe.URANUS
    "neptune": 8,  # swe.NEPTUNE
    "pluto": 9,    # swe.PLUTO
}

# City coordinates for birth place
CITY_COORDS = {
    "shanghai": (31.2304, 121.4737, 8),
    "beijing": (39.9042, 116.4074, 8),
    "guangzhou": (23.1291, 113.2644, 8),
    "shenzhen": (22.5431, 114.0579, 8),
    "hong kong": (22.3193, 114.1694, 8),
    "hongkong": (22.3193, 114.1694, 8),
    "taipei": (25.0330, 121.5654, 8),
    "new york": (40.7128, -74.0060, -5),
    "newyork": (40.7128, -74.0060, -5),
    "los angeles": (34.0522, -118.2437, -8),
    "losangeles": (34.0522, -118.2437, -8),
    "london": (51.5074, -0.1278, 0),
    "tokyo": (35.6762, 139.6503, 9),
    "paris": (48.8566, 2.3522, 1),
    "singapore": (1.3521, 103.8198, 8),
    "sydney": (-33.8688, 151.2093, 10),
    "default": (31.2304, 121.4737, 8),  # Default to Shanghai
}


@dataclass
class PlanetPosition:
    """Planet position in the chart"""
    planet: str
    sign: str
    sign_chinese: str
    degree: float
    house: int
    retrograde: bool = False

    def to_dict(self) -> dict:
        return {
            "planet": self.planet,
            "planet_chinese": PLANET_CHINESE.get(self.planet, self.planet),
            "sign": self.sign,
            "sign_chinese": self.sign_chinese,
            "degree": round(self.degree, 2),
            "house": self.house,
            "retrograde": self.retrograde,
        }


@dataclass
class Aspect:
    """Aspect between two planets"""
    planet1: str
    planet2: str
    aspect_type: str  # "conjunction", "opposition", "trine", "square", "sextile"
    orb: float
    description: str = ""

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class Transit:
    """Transit event"""
    planet: str
    sign: str
    aspect: str
    natal_planet: str
    influence: str  # "positive", "challenging", "neutral"
    description: str
    start_date: str
    end_date: str
    is_active: bool = True

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class ZodiacChart:
    """Complete Zodiac Chart (星盘)"""
    birth_info: Dict[str, Any]
    sun_sign: str
    moon_sign: str
    rising_sign: str
    planets: List[PlanetPosition]
    aspects: List[Aspect]
    dominant_element: str
    dominant_modality: str

    def to_dict(self) -> dict:
        return {
            "birth_info": self.birth_info,
            "sun_sign": self.sun_sign,
            "sun_sign_chinese": SIGN_CHINESE.get(self.sun_sign, self.sun_sign),
            "moon_sign": self.moon_sign,
            "moon_sign_chinese": SIGN_CHINESE.get(self.moon_sign, self.moon_sign),
            "rising_sign": self.rising_sign,
            "rising_sign_chinese": SIGN_CHINESE.get(self.rising_sign, self.rising_sign),
            "planets": [p.to_dict() for p in self.planets],
            "aspects": [a.to_dict() for a in self.aspects],
            "dominant_element": self.dominant_element,
            "dominant_modality": self.dominant_modality,
        }


def longitude_to_sign(longitude: float) -> tuple:
    """Convert ecliptic longitude to zodiac sign and degree within sign."""
    sign_idx = int(longitude / 30) % 12
    degree = longitude % 30
    return SIGN_LIST[sign_idx], degree


class ZodiacCalculator:
    """
    Zodiac (Western Astrology) Calculator

    Uses Swiss Ephemeris for accurate astronomical calculations.

    Usage:
        calculator = ZodiacCalculator()
        chart = calculator.calculate(
            birth_date="1990-05-15",
            birth_time="08:00",
            birth_place="Shanghai"
        )
    """

    # Aspect definitions: (angle, name_en, name_cn, orb_tolerance)
    ASPECTS = {
        0: ("conjunction", "合相", 8),
        60: ("sextile", "六分相", 6),
        90: ("square", "刑相", 8),
        120: ("trine", "三分相", 8),
        180: ("opposition", "冲相", 8),
    }

    def __init__(self):
        if not FLATLIB_AVAILABLE:
            raise RuntimeError("pyswisseph not installed. Install with: pip install pyswisseph")

    def calculate(
        self,
        birth_date: str,  # "YYYY-MM-DD"
        birth_time: str = "12:00",  # "HH:MM"
        birth_place: str = "Shanghai"
    ) -> ZodiacChart:
        """
        Calculate complete zodiac chart from birth information.

        Args:
            birth_date: Date in "YYYY-MM-DD" format
            birth_time: Time in "HH:MM" format
            birth_place: City name for coordinates

        Returns:
            ZodiacChart with all calculations
        """
        # Parse date and time
        year, month, day = map(int, birth_date.split("-"))
        hour, minute = map(int, birth_time.split(":"))

        # Get coordinates and timezone
        place_lower = birth_place.lower().replace(" ", "")
        lat, lon, tz = CITY_COORDS.get(place_lower, CITY_COORDS["default"])

        # Convert local time to UTC
        local_hour = hour + minute / 60.0
        utc_hour = local_hour - tz

        # Handle day overflow
        utc_day = day
        if utc_hour < 0:
            utc_hour += 24
            utc_day -= 1
        elif utc_hour >= 24:
            utc_hour -= 24
            utc_day += 1

        # Calculate Julian Day
        jd = swe.julday(year, month, utc_day, utc_hour)

        # Calculate planet positions
        planets = []
        planet_signs = {}
        planet_lons = {}

        for planet_name, planet_id in SWE_PLANETS.items():
            try:
                # Calculate planet position (ecliptic longitude)
                result = swe.calc_ut(jd, planet_id)
                longitude = result[0][0]
                speed = result[0][3]  # Daily motion (negative = retrograde)

                sign, degree = longitude_to_sign(longitude)
                planet_signs[planet_name] = sign
                planet_lons[planet_name] = longitude

                # Determine house (simplified - use whole sign houses from Ascendant)
                house = 1  # Will be calculated after we have Ascendant

                planets.append(PlanetPosition(
                    planet=planet_name,
                    sign=sign,
                    sign_chinese=SIGN_CHINESE.get(sign, sign),
                    degree=degree,
                    house=house,
                    retrograde=speed < 0,
                ))
            except Exception as e:
                logger.warning(f"Failed to calculate {planet_name}: {e}")

        # Calculate Ascendant (Rising Sign)
        try:
            houses = swe.houses(jd, lat, lon, b'P')  # Placidus house system
            asc_longitude = houses[1][0]  # Ascendant
            rising_sign, _ = longitude_to_sign(asc_longitude)
        except Exception as e:
            logger.warning(f"Failed to calculate Ascendant: {e}")
            # Fallback: use approximate calculation based on birth time
            rising_sign = self._approximate_rising(hour, planet_signs.get("sun", "aries"))

        # Update house positions (whole sign houses)
        asc_sign_idx = SIGN_LIST.index(rising_sign)
        for planet in planets:
            planet_sign_idx = SIGN_LIST.index(planet.sign)
            planet.house = ((planet_sign_idx - asc_sign_idx) % 12) + 1

        # Get sun and moon signs
        sun_sign = planet_signs.get("sun", "aries")
        moon_sign = planet_signs.get("moon", "cancer")

        # Calculate aspects
        aspects = self._calculate_aspects(planets, planet_lons)

        # Calculate dominant element and modality
        dominant_element = self._calculate_dominant_element(planet_signs)
        dominant_modality = self._calculate_dominant_modality(planet_signs)

        return ZodiacChart(
            birth_info={
                "date": birth_date,
                "time": birth_time,
                "place": birth_place,
                "latitude": lat,
                "longitude": lon,
                "timezone": tz,
            },
            sun_sign=sun_sign,
            moon_sign=moon_sign,
            rising_sign=rising_sign,
            planets=planets,
            aspects=aspects,
            dominant_element=dominant_element,
            dominant_modality=dominant_modality,
        )

    def calculate_transit(
        self,
        natal_chart: ZodiacChart,
        transit_date: str = None
    ) -> List[Transit]:
        """
        Calculate transits for a given date.

        Args:
            natal_chart: The natal chart to compare against
            transit_date: Date to calculate transits for (default: today)

        Returns:
            List of active transits
        """
        if transit_date is None:
            transit_date = date.today().isoformat()

        # Parse date
        year, month, day = map(int, transit_date.split("-"))
        jd = swe.julday(year, month, day, 12.0)  # Noon UTC

        transits = []

        # Check transits from slow-moving planets to natal Sun and Moon
        transit_planets = ["jupiter", "saturn", "uranus", "neptune", "pluto"]
        natal_targets = ["sun", "moon"]

        for transit_planet in transit_planets:
            try:
                # Get transit planet position
                result = swe.calc_ut(jd, SWE_PLANETS[transit_planet])
                transit_lon = result[0][0]
                transit_sign, _ = longitude_to_sign(transit_lon)

                # Check aspects to natal planets
                for natal in natal_chart.planets:
                    if natal.planet in natal_targets:
                        # Get natal planet longitude
                        natal_lon = self._sign_degree_to_longitude(natal.sign, natal.degree)

                        # Check for aspects
                        aspect = self._check_aspect(transit_lon, natal_lon)
                        if aspect:
                            aspect_type, aspect_name, orb = aspect
                            transits.append(Transit(
                                planet=PLANET_CHINESE.get(transit_planet, transit_planet),
                                sign=SIGN_CHINESE.get(transit_sign, transit_sign),
                                aspect=aspect_name,
                                natal_planet=PLANET_CHINESE.get(natal.planet, natal.planet),
                                influence=self._get_aspect_influence(aspect_type),
                                description=f"{PLANET_CHINESE.get(transit_planet, transit_planet)}{aspect_name}{PLANET_CHINESE.get(natal.planet, natal.planet)}",
                                start_date=transit_date,
                                end_date=transit_date,
                                is_active=True,
                            ))
            except Exception as e:
                logger.warning(f"Transit calculation error for {transit_planet}: {e}")

        return transits

    def _sign_degree_to_longitude(self, sign: str, degree: float) -> float:
        """Convert sign and degree to ecliptic longitude."""
        sign_idx = SIGN_LIST.index(sign)
        return sign_idx * 30 + degree

    def _approximate_rising(self, birth_hour: int, sun_sign: str) -> str:
        """Approximate rising sign based on birth time (simplified)."""
        # Each 2 hours = 1 sign advancement from sun sign
        sun_idx = SIGN_LIST.index(sun_sign)
        # Sunrise (6am) = Sun on Ascendant
        hours_from_sunrise = (birth_hour - 6) % 24
        sign_offset = int(hours_from_sunrise / 2)
        rising_idx = (sun_idx + sign_offset) % 12
        return SIGN_LIST[rising_idx]

    def _calculate_aspects(self, planets: List[PlanetPosition], planet_lons: Dict[str, float]) -> List[Aspect]:
        """Calculate aspects between planets."""
        aspects = []
        planet_list = list(planet_lons.keys())

        for i, p1_name in enumerate(planet_list):
            for p2_name in planet_list[i+1:]:
                lon1 = planet_lons[p1_name]
                lon2 = planet_lons[p2_name]

                # Calculate angular difference
                diff = abs(lon1 - lon2)
                if diff > 180:
                    diff = 360 - diff

                # Check each aspect type
                for angle, (aspect_type, aspect_name, orb_tolerance) in self.ASPECTS.items():
                    orb = abs(diff - angle)
                    if orb <= orb_tolerance:
                        aspects.append(Aspect(
                            planet1=PLANET_CHINESE.get(p1_name, p1_name),
                            planet2=PLANET_CHINESE.get(p2_name, p2_name),
                            aspect_type=aspect_type,
                            orb=round(orb, 2),
                            description=f"{PLANET_CHINESE.get(p1_name, p1_name)}{aspect_name}{PLANET_CHINESE.get(p2_name, p2_name)}",
                        ))
                        break

        return aspects

    def _check_aspect(self, lon1: float, lon2: float) -> Optional[tuple]:
        """Check if two longitudes form an aspect."""
        diff = abs(lon1 - lon2)
        if diff > 180:
            diff = 360 - diff

        for angle, (aspect_type, aspect_name, orb_tolerance) in self.ASPECTS.items():
            orb = abs(diff - angle)
            if orb <= orb_tolerance:
                return (aspect_type, aspect_name, orb)
        return None

    def _get_aspect_influence(self, aspect_type: str) -> str:
        """Get the influence type of an aspect."""
        if aspect_type in ["trine", "sextile"]:
            return "positive"
        elif aspect_type in ["square", "opposition"]:
            return "challenging"
        return "neutral"

    def _calculate_dominant_element(self, planet_signs: Dict[str, str]) -> str:
        """Calculate dominant element from planet positions."""
        element_count = {e.value: 0 for e in Element}

        # Weight: Sun=3, Moon=3, Mercury=2, Venus=2, Mars=2, Others=1
        weights = {"sun": 3, "moon": 3, "mercury": 2, "venus": 2, "mars": 2}

        for planet, sign in planet_signs.items():
            weight = weights.get(planet, 1)
            element = SIGN_ELEMENT.get(sign)
            if element:
                element_count[element.value] += weight

        return max(element_count, key=element_count.get)

    def _calculate_dominant_modality(self, planet_signs: Dict[str, str]) -> str:
        """Calculate dominant modality from planet positions."""
        modality_count = {m.value: 0 for m in Modality}

        for planet, sign in planet_signs.items():
            modality = SIGN_MODALITY.get(sign)
            if modality:
                modality_count[modality.value] += 1

        return max(modality_count, key=modality_count.get)


# Convenience functions
def calculate_zodiac(
    birth_date: str,
    birth_time: str = "12:00",
    birth_place: str = "Shanghai"
) -> dict:
    """Calculate zodiac chart and return as dict."""
    calculator = ZodiacCalculator()
    chart = calculator.calculate(birth_date, birth_time, birth_place)
    return chart.to_dict()


def calculate_transit(
    birth_date: str,
    birth_time: str = "12:00",
    birth_place: str = "Shanghai",
    transit_date: str = None
) -> List[dict]:
    """Calculate transits and return as list of dicts."""
    calculator = ZodiacCalculator()
    natal = calculator.calculate(birth_date, birth_time, birth_place)
    transits = calculator.calculate_transit(natal, transit_date)
    return [t.to_dict() for t in transits]
