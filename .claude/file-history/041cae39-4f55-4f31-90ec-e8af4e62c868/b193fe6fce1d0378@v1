"""
Bazi Calculator - Chinese Four Pillars of Destiny
Based on: vibelife spec v3.0

Uses lunar-python library for accurate calendar conversions.
Install: pip install lunar-python

References:
- https://github.com/6tail/lunar-python
"""

import logging
from dataclasses import dataclass, field, asdict
from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum

logger = logging.getLogger(__name__)

# Try to import lunar-python
try:
    from lunar_python import Lunar, Solar
    LUNAR_AVAILABLE = True
except ImportError:
    LUNAR_AVAILABLE = False
    logger.warning("lunar-python not installed. Install with: pip install lunar-python")


class Element(str, Enum):
    """Five Elements (五行)"""
    WOOD = "wood"    # 木
    FIRE = "fire"    # 火
    EARTH = "earth"  # 土
    METAL = "metal"  # 金
    WATER = "water"  # 水


class Stem(str, Enum):
    """Ten Heavenly Stems (天干)"""
    JIA = "甲"    # 木阳
    YI = "乙"     # 木阴
    BING = "丙"   # 火阳
    DING = "丁"   # 火阴
    WU = "戊"     # 土阳
    JI = "己"     # 土阴
    GENG = "庚"   # 金阳
    XIN = "辛"    # 金阴
    REN = "壬"    # 水阳
    GUI = "癸"    # 水阴


class Branch(str, Enum):
    """Twelve Earthly Branches (地支)"""
    ZI = "子"     # 鼠
    CHOU = "丑"   # 牛
    YIN = "寅"    # 虎
    MAO = "卯"    # 兔
    CHEN = "辰"   # 龙
    SI = "巳"     # 蛇
    WU = "午"     # 马
    WEI = "未"    # 羊
    SHEN = "申"   # 猴
    YOU = "酉"    # 鸡
    XU = "戌"     # 狗
    HAI = "亥"    # 猪


# Stem to Element mapping
STEM_ELEMENT = {
    "甲": Element.WOOD, "乙": Element.WOOD,
    "丙": Element.FIRE, "丁": Element.FIRE,
    "戊": Element.EARTH, "己": Element.EARTH,
    "庚": Element.METAL, "辛": Element.METAL,
    "壬": Element.WATER, "癸": Element.WATER,
}

# Branch hidden stems (地支藏干)
BRANCH_HIDDEN_STEMS = {
    "子": ["癸"],
    "丑": ["己", "癸", "辛"],
    "寅": ["甲", "丙", "戊"],
    "卯": ["乙"],
    "辰": ["戊", "乙", "癸"],
    "巳": ["丙", "庚", "戊"],
    "午": ["丁", "己"],
    "未": ["己", "丁", "乙"],
    "申": ["庚", "壬", "戊"],
    "酉": ["辛"],
    "戌": ["戊", "辛", "丁"],
    "亥": ["壬", "甲"],
}


@dataclass
class Pillar:
    """A single pillar (柱) with stem and branch"""
    stem: str
    branch: str
    stem_element: str = ""
    hidden_stems: List[str] = field(default_factory=list)

    def __post_init__(self):
        if not self.stem_element and self.stem in STEM_ELEMENT:
            self.stem_element = STEM_ELEMENT[self.stem].value
        if not self.hidden_stems and self.branch in BRANCH_HIDDEN_STEMS:
            self.hidden_stems = BRANCH_HIDDEN_STEMS[self.branch]

    def to_dict(self) -> dict:
        return {
            "stem": self.stem,
            "branch": self.branch,
            "stem_element": self.stem_element,
            "hidden_stems": self.hidden_stems,
        }


@dataclass
class DayMaster:
    """Day Master (日主) information"""
    stem: str
    element: str
    polarity: str  # "yang" or "yin"
    description: str = ""

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class TenGod:
    """Ten Gods (十神) relationship"""
    name: str        # e.g., "正财", "偏印"
    stem: str        # The stem it refers to
    pillar: str      # Which pillar: "year", "month", "day", "hour"
    description: str = ""

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class BaziChart:
    """Complete Bazi Chart (八字命盘)"""
    birth_info: Dict[str, Any]  # date, time, gender
    four_pillars: Dict[str, Pillar]  # year, month, day, hour
    day_master: DayMaster
    five_elements: Dict[str, int]  # element counts
    ten_gods: List[TenGod]
    pattern: Dict[str, str]  # name, description

    def to_dict(self) -> dict:
        return {
            "birth_info": self.birth_info,
            "four_pillars": {k: v.to_dict() for k, v in self.four_pillars.items()},
            "day_master": self.day_master.to_dict(),
            "five_elements": self.five_elements,
            "ten_gods": [g.to_dict() for g in self.ten_gods],
            "pattern": self.pattern,
        }


class BaziCalculator:
    """
    Bazi (Four Pillars) Calculator

    Usage:
        calculator = BaziCalculator()
        chart = calculator.calculate(
            birth_date="1990-05-15",
            birth_time="08:00",
            gender="male"
        )
    """

    # Day Master descriptions
    DAY_MASTER_DESC = {
        "甲": "甲木日主，如参天大树，正直刚强，重视成长与原则。",
        "乙": "乙木日主，如花草藤蔓，柔韧灵活，善于适应环境。",
        "丙": "丙火日主，如太阳之火，热情开朗，具有领导魅力。",
        "丁": "丁火日主，如烛光星火，温柔细腻，洞察力强。",
        "戊": "戊土日主，如高山大地，稳重包容，信守承诺。",
        "己": "己土日主，如田园沃土，务实谨慎，善于耕耘。",
        "庚": "庚金日主，如刀剑器皿，果断刚毅，重视效率。",
        "辛": "辛金日主，如珠玉首饰，精致敏感，追求完美。",
        "壬": "壬水日主，如江河大海，智慧深沉，变通灵活。",
        "癸": "癸水日主，如雨露溪流，温润内敛，直觉敏锐。",
    }

    def __init__(self):
        if not LUNAR_AVAILABLE:
            logger.warning("lunar-python not available, calculations will be limited")

    def calculate(
        self,
        birth_date: str,  # "YYYY-MM-DD"
        birth_time: str = "12:00",  # "HH:MM"
        gender: str = "unknown"
    ) -> BaziChart:
        """
        Calculate complete Bazi chart from birth information.

        Args:
            birth_date: Date in "YYYY-MM-DD" format
            birth_time: Time in "HH:MM" format (default noon if unknown)
            gender: "male", "female", or "unknown"

        Returns:
            BaziChart with all calculations
        """
        if not LUNAR_AVAILABLE:
            raise RuntimeError("lunar-python not installed. Install with: pip install lunar-python")

        try:
            # Parse date and time
            year, month, day = map(int, birth_date.split("-"))
            hour, minute = map(int, birth_time.split(":"))

            # Create Solar date
            solar = Solar.fromYmdHms(year, month, day, hour, minute, 0)
            lunar = solar.getLunar()

            # Get Eight Characters (四柱八字)
            eight_char = lunar.getEightChar()

            # Build four pillars
            four_pillars = {
                "year": Pillar(stem=eight_char.getYearGan(), branch=eight_char.getYearZhi()),
                "month": Pillar(stem=eight_char.getMonthGan(), branch=eight_char.getMonthZhi()),
                "day": Pillar(stem=eight_char.getDayGan(), branch=eight_char.getDayZhi()),
                "hour": Pillar(stem=eight_char.getTimeGan(), branch=eight_char.getTimeZhi()),
            }

            # Get day master
            day_stem = eight_char.getDayGan()
            day_master = DayMaster(
                stem=day_stem,
                element=STEM_ELEMENT.get(day_stem, Element.WOOD).value,
                polarity="yang" if day_stem in "甲丙戊庚壬" else "yin",
                description=self.DAY_MASTER_DESC.get(day_stem, ""),
            )

            # Calculate five elements distribution
            five_elements = self._count_elements(four_pillars)

            # Calculate ten gods
            ten_gods = self._calculate_ten_gods(eight_char, day_stem)

            # Determine pattern
            pattern = self._determine_pattern(eight_char, day_master, ten_gods)

            return BaziChart(
                birth_info={
                    "date": birth_date,
                    "time": birth_time,
                    "gender": gender,
                    "lunar_date": f"{lunar.getYearInChinese()}年{lunar.getMonthInChinese()}月{lunar.getDayInChinese()}",
                },
                four_pillars=four_pillars,
                day_master=day_master,
                five_elements=five_elements,
                ten_gods=ten_gods,
                pattern=pattern,
            )

        except Exception as e:
            logger.error(f"Bazi calculation failed: {e}")
            return self._demo_chart(birth_date, birth_time, gender)

    def _count_elements(self, pillars: Dict[str, Pillar]) -> Dict[str, int]:
        """Count five elements from all stems and branches"""
        counts = {e.value: 0 for e in Element}

        for pillar in pillars.values():
            # Count stem element
            if pillar.stem in STEM_ELEMENT:
                counts[STEM_ELEMENT[pillar.stem].value] += 1

            # Count hidden stem elements
            for hidden in pillar.hidden_stems:
                if hidden in STEM_ELEMENT:
                    counts[STEM_ELEMENT[hidden].value] += 0.5  # Hidden stems count less

        # Round to integers
        return {k: int(v) for k, v in counts.items()}

    def _calculate_ten_gods(self, eight_char, day_stem: str) -> List[TenGod]:
        """Calculate ten gods relationships"""
        ten_gods = []

        # This is a simplified implementation
        # Full implementation would use the lunar-python library's built-in methods
        try:
            # Get month stem ten god
            month_gan = eight_char.getMonthGan()
            ten_god_name = eight_char.getMonthShiShenGan()
            if ten_god_name:
                ten_gods.append(TenGod(
                    name=ten_god_name,
                    stem=month_gan,
                    pillar="month",
                ))

            # Get year stem ten god
            year_gan = eight_char.getYearGan()
            ten_god_name = eight_char.getYearShiShenGan()
            if ten_god_name:
                ten_gods.append(TenGod(
                    name=ten_god_name,
                    stem=year_gan,
                    pillar="year",
                ))

        except Exception as e:
            logger.warning(f"Ten gods calculation error: {e}")

        return ten_gods

    def _determine_pattern(
        self,
        eight_char,
        day_master: DayMaster,
        ten_gods: List[TenGod]
    ) -> Dict[str, str]:
        """Determine the pattern/structure (格局)"""
        # This is a simplified implementation
        # Full pattern determination is very complex
        try:
            # Check for common patterns based on month branch ten god
            month_ten_god = next((g for g in ten_gods if g.pillar == "month"), None)
            if month_ten_god:
                pattern_name = f"{month_ten_god.name}格"
                return {
                    "name": pattern_name,
                    "description": f"月令透出{month_ten_god.name}，以{month_ten_god.name}为用神。",
                }
        except Exception:
            pass

        return {
            "name": "普通格局",
            "description": "需要综合分析八字整体来确定格局。",
        }

    def _demo_chart(
        self,
        birth_date: str,
        birth_time: str,
        gender: str
    ) -> BaziChart:
        """Return demo chart when calculation is not available"""
        return BaziChart(
            birth_info={
                "date": birth_date,
                "time": birth_time,
                "gender": gender,
            },
            four_pillars={
                "year": Pillar(stem="庚", branch="午"),
                "month": Pillar(stem="戊", branch="子"),
                "day": Pillar(stem="甲", branch="辰"),
                "hour": Pillar(stem="甲", branch="寅"),
            },
            day_master=DayMaster(
                stem="甲",
                element="wood",
                polarity="yang",
                description=self.DAY_MASTER_DESC["甲"],
            ),
            five_elements={"wood": 3, "fire": 2, "earth": 2, "metal": 1, "water": 2},
            ten_gods=[],
            pattern={
                "name": "演示命盘",
                "description": "请安装 lunar-python 库以获取真实计算结果。",
            },
        )


# Convenience function
def calculate_bazi(
    birth_date: str,
    birth_time: str = "12:00",
    gender: str = "unknown"
) -> dict:
    """
    Calculate Bazi chart and return as dict.

    Args:
        birth_date: "YYYY-MM-DD"
        birth_time: "HH:MM"
        gender: "male", "female", or "unknown"

    Returns:
        Dict with all bazi information
    """
    calculator = BaziCalculator()
    chart = calculator.calculate(birth_date, birth_time, gender)
    return chart.to_dict()
