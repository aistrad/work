# Protocol 流程设计

> Version: 1.0 | 2026-01-20
> 多步骤协议（如 Dan Koe 快速重置）的实现方案

---

## 1. 问题背景

### 1.1 什么是 Protocol

Protocol（协议）是一种结构化的多轮对话流程，用于引导用户完成特定目标。

典型场景：
- **Dan Koe 快速重置**：6 个问题，帮助用户设计人生愿景
- **周复盘**：引导用户回顾本周完成情况
- **卡点突破**：帮助用户识别和突破障碍

### 1.2 Protocol 的特点

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Protocol 特点                                           │
└─────────────────────────────────────────────────────────────────────────────────────┘

1. 有序的问题序列
   - 问题 1 → 问题 2 → ... → 问题 N
   - 每个问题收集特定信息

2. 需要记住之前的回答
   - 后续问题可能引用之前的回答
   - 最终总结需要汇总所有信息

3. 支持追问
   - 如果用户回答模糊，需要追问细节
   - 追问后继续当前问题

4. 支持中断恢复
   - 用户可能中途离开
   - 回来后能继续未完成的流程

5. 最终生成结果
   - 保存收集的数据
   - 展示总结卡片
```

---

## 2. 方案对比

### 2.1 方案概览

| 方案 | 核心思想 | 复杂度 | 推荐度 |
|------|----------|--------|--------|
| 方案 A | Protocol Session，后端状态管理 | 高 | ⭐⭐ |
| 方案 B | 单次请求，多轮 Agentic Loop | 高 | ⭐ |
| 方案 C | Protocol as Tool，复用现有架构 | 中 | ⭐⭐⭐ |
| **方案 D** | **纯 Prompt 驱动，最简实现** | **低** | **⭐⭐⭐⭐⭐** |

### 2.2 方案 D：纯 Prompt 驱动（推荐）

#### 核心洞察

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              核心洞察                                                │
└─────────────────────────────────────────────────────────────────────────────────────┘

LLM 本身就擅长：
- 记住对话历史
- 按顺序问问题
- 判断回答是否完整
- 生成总结

我们真正需要的只是：
1. 告诉 LLM 要问什么问题（Rule 文件）
2. 最后保存结果（一个工具）

不需要：
- protocol 状态追踪
- step 计数器
- start_protocol / protocol_step 工具
- 前端传参数
```

#### 设计原则

```
Protocol = Rule + 一个保存工具

1. Rule 文件：skills/lifecoach/rules/dankoe.md
   - 包含完整的协议流程
   - LLM 按照 Rule 自己驱动对话

2. 工具：save_skill_data
   - 协议完成后调用
   - 保存所有收集的数据到 VibeProfile
```

---

## 3. 方案 D 详细设计

### 3.1 Rule 文件示例

```markdown
# skills/lifecoach/rules/dankoe.md

---
id: dankoe
name: Dan Koe 快速重置
triggers: 人生重置, 设计人生, 快速重置, 一日重置, dankoe
---

# Dan Koe 快速重置协议

你正在引导用户完成一个 10 分钟的人生重置流程。

## 流程概述

这个流程有 6 个问题，按顺序完成：

1. **持续的不满** - 识别用户习惯忍受的不舒服
2. **反愿景场景** - 描绘不改变的未来
3. **愿景场景** - 描绘理想的未来
4. **放弃的身份** - 识别要放弃的旧身份
5. **新身份宣言** - 定义新的身份
6. **本周行动** - 确定具体行动

## 执行规则

### 开场
当用户表达想要"重置"、"设计人生"时，说：
> "好的，我们来做一次快速重置。整个过程大约10分钟，我会问你6个问题。准备好了吗？"

用户确认后，开始第一个问题。

### 问题 1: 持续的不满
**问**：过去一年，你学会忍受的、持续的不满是什么？

**回应指南**：
- 简短确认（1-2句）
- 可以追问"这个不满持续多久了？"
- 不要分析，不要给建议

### 问题 2: 反愿景场景
**问**：如果接下来5年什么都不改变，描述一个普通的周二。

**回应指南**：
- 简短确认画面
- 如果太抽象，追问具体细节

### 问题 3: 愿景场景
**问**：如果3年后你过上完全不同的生活，一个普通的周二会是什么样？

**回应指南**：
- 积极但不夸张地确认
- 总结对比：反愿景 vs 愿景

### 问题 4: 放弃的身份
**问**：要真正改变，你必须放弃什么身份？用"我是那种会..."来描述。

### 问题 5: 新身份宣言
**问**：你想成为什么样的人？用"我是那种..."来填空。

### 问题 6: 本周行动
**问**：如果你已经是那个人，这周你会做什么？1-3件具体的事。

## 完成协议

当 6 个问题都回答完毕后：

1. 生成总结
2. 调用 `save_skill_data` 工具保存数据
3. 调用 `show_journey_card` 展示结果卡片

## 中断处理

如果用户中途离开再回来，从对话历史判断进度，继续未完成的问题。
```

### 3.2 完整流程图

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                    方案 D 流程（纯 Prompt 驱动）                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘

用户: "我想做一次人生重置"
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│ CoreAgent                                                                            │
│                                                                                      │
│ 1. use_skill → skill = "lifecoach"                                                  │
│ 2. 场景路由 → scenario = "dankoe" (根据触发词)                                       │
│ 3. 加载 rules/dankoe.md 到 System Prompt                                            │
│                                                                                      │
│ System Prompt 包含：                                                                 │
│ - 完整的 6 个问题                                                                    │
│ - 每个问题的回应指南                                                                 │
│ - 完成后的总结模板                                                                   │
│ - save_skill_data 工具说明                                                           │
└─────────────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│ LLM 自己驱动对话                                                                     │
│                                                                                      │
│ LLM: "好的，我们来做一次快速重置。准备好了吗？"                                       │
│ 用户: "准备好了"                                                                     │
│ LLM: "第一个问题：过去一年，你持续的不满是什么？"                                     │
│ 用户: "工作没意义"                                                                   │
│ LLM: "这个感觉持续多久了？"  ← LLM 自己决定追问                                      │
│ 用户: "两年了"                                                                       │
│ LLM: "两年了，确实很长。下一个问题：如果5年后什么都不改变..."                         │
│ ...                                                                                  │
│ (LLM 按照 Rule 中的指南，自己控制节奏)                                               │
│ ...                                                                                  │
│ LLM: "你的人生游戏已经设定好了..."                                                   │
│                                                                                      │
│ Tool Call: save_skill_data({                                                        │
│   data: {                                                                           │
│     north_star: {pain_points, anti_vision, vision},                                 │
│     identity: {old, new},                                                           │
│     current: {week: {rocks: [...]}}                                                 │
│   }                                                                                 │
│ })                                                                                  │
│                                                                                      │
│ Tool Call: show_journey_card({data: {...}})                                         │
└─────────────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
            完成！
```

### 3.3 工具设计

```yaml
# skills/core/tools/tools.yaml（全局工具）

- name: save_skill_data
  description: |
    保存当前 Skill 的数据到 VibeProfile。

    这是一个通用工具，所有 Skill 都可以使用。
    数据会保存到 VibeProfile.skill_data.{当前skill_id}

    调用时机：
    - 完成一个协议/流程后
    - 用户提供了重要信息需要记住
    - 状态发生变化需要持久化

  tool_type: action
  parameters:
    - name: data
      type: object
      required: true
      description: 要保存的数据
    - name: replace
      type: boolean
      default: false
      description: 是否完全替换（而非合并）
```

### 3.4 工具处理器

```python
# skills/core/tools/handlers.py

@tool_handler("save_skill_data")
async def handle_save_skill_data(args: Dict, context: ToolContext) -> Dict:
    """
    通用的 Skill 数据保存工具
    """
    data = args.get("data", {})
    replace = args.get("replace", False)
    skill_id = context.skill_id

    if not skill_id:
        return {"error": "No active skill"}

    user_uuid = UUID(context.user_id)

    if replace:
        new_data = data
    else:
        # 深度合并
        current = await UnifiedProfileRepository.get_skill_data(user_uuid, skill_id)
        new_data = deep_merge(current, data)

    # 自动添加 _meta
    new_data["_meta"] = {
        "version": new_data.get("_meta", {}).get("version", 0) + 1,
        "updated_at": datetime.utcnow().isoformat()
    }

    # 保存
    await UnifiedProfileRepository.update_skill_data(user_uuid, skill_id, new_data)

    return {"status": "saved", "skill_id": skill_id}
```

---

## 4. 方案对比

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              方案对比                                                │
└──────────────────────────────��──────────────────────────────────────────────────────┘

                    当前方案      方案 A        方案 C        方案 D
                    ────────      ──────        ──────        ──────
新增工具数量         0            3             2             0 (复用)
新增代码行数         ~200         ~500          ~200          ~50
数据库改动           无           需要          无            无
状态管理             前端+后端    后端          后端          无（LLM记忆）
前端改动             需要         需要          无            无
复杂度               中           高            中            低

方案 D 的核心优势：
─────────────────────

1. 最少代码
   - 只需要 1 个 Rule 文件
   - 复用现有的 save_skill_data 工具

2. 无状态管理
   - 不需要追踪 current_step
   - LLM 从对话历史自己判断进度
   - 中断恢复靠对话历史

3. 最大灵活性
   - LLM 可以自由追问
   - 可以跳过不相关的问题
   - 可以根据用户情况调整节奏

4. 易于扩展
   - 新协议 = 新 Rule 文件
   - 不需要改代码
```

---

## 5. 实施清单

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              实施清单（方案 D）                                       │
└────────────────────────────────���────────────────────────────────────────────────────┘

Step 1: 创建 Rule 文件
────────────────────
文件: apps/api/skills/lifecoach/rules/dankoe.md
- 完整的协议流程
- 6 个问题 + 回应指南
- 完成后的工具调用说明

Step 2: 确保工具可用
────────────────────
确认 save_skill_data 工具已注册到 lifecoach skill

Step 3: 清理旧代码（可选）
────────────────────
文件: apps/api/routes/chat_v5.py
- 删除 ProtocolRequest 类
- 删除 protocol 相关的处理逻辑
- 简化为正常的 chat 流程

Step 4: 测试
────────────────────
- 测试协议启动（触发词识别）
- 测试追问流程
- 测试中断恢复
- 测试协议完成和数据保存

完成！总改动量 < 100 行代码
```

---

## 6. 潜在问题与解决

### Q1: 对话历史被截断怎么办？

当前 history 限制 10 条，6 个问题 + 回答 = 12 条

**解决方案**：
- 协议对话时增加 history 限制到 20 条
- 或者在 Rule 中指导 LLM 在回应中总结之前的关键信息

### Q2: LLM 忘记问某个问题怎么办？

**解决方案**：
- Rule 中明确列出"必须按顺序完成所有 6 个问题"
- save_skill_data 工具要求所有字段必填，缺失时返回错误

### Q3: 用户中途离开再回来？

**解决方案**：
- LLM 从对话历史判断进度
- Rule 中加入"中断处理"指南
- LLM 会说"我们上次聊到了 X，继续吗？"

### Q4: 如何支持多种协议？

**解决方案**：
- 每种协议一个 Rule 文件
- 通过触发词自动路由到对应 Rule
- 例如：
  - `rules/dankoe.md` - 快速重置
  - `rules/weekly-review.md` - 周复盘
  - `rules/stuck-breakthrough.md` - 卡点突破
