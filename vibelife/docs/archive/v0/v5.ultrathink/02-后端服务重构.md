# 后端服务重构方案

## 概述

基于战略蓝图的"统一理解引擎"和"六阶段用户旅程"要求，后端服务需要从"技能驱动"重构为"用户旅程驱动"。

---

## 1. 服务架构升级

### 1.1 现有架构

```
routes/
├── auth.py          # 认证
├── users.py         # 用户管理
├── chat.py          # 对话
├── bazi.py          # 八字服务
├── zodiac.py        # 星座服务
├── report.py        # 报告
├── relationship.py  # 关系分析
├── fortune.py       # 运势
└── ...

services/
├── agent/           # AI Agent
├── vibe_engine/     # 核心引擎
├── knowledge/       # 知识服务
├── bazi/            # 八字计算
├── zodiac/          # 星座计算
└── ...
```

### 1.2 目标架构

```
routes/
├── auth.py              # 认证 (保持)
├── users.py             # 用户管理 (增强)
├── chat.py              # 统一对话入口 (重构)
├── identity.py          # Identity Prism API (新增)
├── rituals.py           # 每日仪式 API (新增)
├── journey.py           # 用户旅程 API (新增)
├── memories.py          # 记忆系统 API (新增)
├── events.py            # 生活事件 API (新增)
├── dimensions/          # 维度服务 (重组)
│   ├── bazi.py
│   ├── zodiac.py
│   └── mbti.py
└── ...

services/
├── understanding_engine/  # 统一理解引擎 (新增)
│   ├── context_orchestrator.py
│   ├── dimension_fusion.py
│   └── insight_generator.py
├── memory_engine/         # 记忆引擎 (新增)
│   ├── extractor.py
│   ├── retriever.py
│   └── consolidator.py
├── ritual_engine/         # 仪式引擎 (新增)
│   ├── morning_oracle.py
│   ├── midday_mirror.py
│   └── night_whisper.py
├── journey_engine/        # 旅程引擎 (新增)
│   ├── stage_tracker.py
│   └── transition_handler.py
└── ... (保留现有服务)
```

---

## 2. 统一理解引擎 (Understanding Engine)

### 2.1 Context Orchestrator

```python
# services/understanding_engine/context_orchestrator.py

from dataclasses import dataclass
from typing import Optional
from models.user import VibeUser
from stores.profile_repo import ProfileRepo
from stores.memory_repo import MemoryRepo

@dataclass
class ConversationContext:
    """对话上下文快照"""
    user: VibeUser
    identity_prism: dict           # 身份棱镜摘要
    active_dimensions: list[str]   # 已解锁的维度
    recent_memories: list[dict]    # 相关记忆
    upcoming_events: list[dict]    # 即将发生的事件
    current_fortune: dict          # 当日运势
    journey_stage: str             # 旅程阶段
    emotional_baseline: dict       # 情绪基线

class ContextOrchestrator:
    """上下文编排器 - 为每次对话构建完整上下文"""

    def __init__(self, profile_repo: ProfileRepo, memory_repo: MemoryRepo):
        self.profile_repo = profile_repo
        self.memory_repo = memory_repo

    async def build_context(
        self,
        user_id: str,
        user_message: str,
        conversation_id: Optional[str] = None
    ) -> ConversationContext:
        """构建对话上下文"""

        # 并行获取各类上下文数据
        user, prism, memories, events, fortune = await asyncio.gather(
            self._get_user(user_id),
            self._get_identity_prism(user_id),
            self._get_relevant_memories(user_id, user_message),
            self._get_upcoming_events(user_id),
            self._get_daily_fortune(user_id)
        )

        return ConversationContext(
            user=user,
            identity_prism=prism,
            active_dimensions=prism.get('source_dimensions', []),
            recent_memories=memories,
            upcoming_events=events,
            current_fortune=fortune,
            journey_stage=user.journey_stage,
            emotional_baseline=await self._get_emotional_baseline(user_id)
        )

    async def _get_relevant_memories(
        self,
        user_id: str,
        query: str,
        limit: int = 5
    ) -> list[dict]:
        """基于语义相似度检索相关记忆"""
        return await self.memory_repo.search_by_embedding(
            user_id=user_id,
            query=query,
            limit=limit
        )
```

### 2.2 Dimension Fusion

```python
# services/understanding_engine/dimension_fusion.py

class DimensionFusion:
    """维度融合器 - 将多维度洞察融合为统一理解"""

    DIMENSION_WEIGHTS = {
        'bazi': {'core': 0.4, 'inner': 0.3, 'outer': 0.3},
        'zodiac': {'core': 0.3, 'inner': 0.4, 'outer': 0.3},
        'mbti': {'core': 0.2, 'inner': 0.3, 'outer': 0.5},
    }

    async def generate_identity_prism(
        self,
        user_id: str,
        dimension_profiles: list[dict]
    ) -> dict:
        """生成 Identity Prism"""

        core_insights = []
        inner_insights = []
        outer_insights = []

        for profile in dimension_profiles:
            dim_type = profile['dimension_type']
            weights = self.DIMENSION_WEIGHTS.get(dim_type, {})

            if profile.get('core_contribution'):
                core_insights.append({
                    'source': dim_type,
                    'weight': weights.get('core', 0.33),
                    'insight': profile['core_contribution']
                })
            # ... inner, outer 同理

        # 使用 LLM 融合各维度洞察
        prism = await self._llm_fusion(core_insights, inner_insights, outer_insights)

        return {
            'core_essence': prism['core'],
            'inner_self': prism['inner'],
            'outer_expression': prism['outer'],
            'source_dimensions': [p['dimension_type'] for p in dimension_profiles],
            'confidence': self._calculate_confidence(dimension_profiles)
        }

    async def _llm_fusion(self, core: list, inner: list, outer: list) -> dict:
        """使用 LLM 融合多维度洞察"""
        prompt = f"""
        基于以下多维度分析结果，生成用户的身份棱镜摘要：

        Core (本质驱动力) 来源:
        {json.dumps(core, ensure_ascii=False)}

        Inner (内在自我) 来源:
        {json.dumps(inner, ensure_ascii=False)}

        Outer (外在表现) 来源:
        {json.dumps(outer, ensure_ascii=False)}

        请融合这些洞察，生成简洁有力的三维身份摘要。
        """
        # ... LLM 调用
```

---

## 3. 记忆引擎 (Memory Engine)

### 3.1 Memory Extractor

```python
# services/memory_engine/extractor.py

class MemoryExtractor:
    """从对话中提取记忆"""

    EXTRACTION_PROMPT = """
    分析以下对话，提取值得记住的信息：

    对话内容:
    {conversation}

    请提取以下类型的信息（如果存在）：
    1. life_event: 生活事件（面试、约会、考试等）
    2. personality_trait: 性格特征
    3. emotional_pattern: 情绪模式
    4. preference: 偏好习惯
    5. concern: 关注点/困扰
    6. relationship: 人际关系
    7. growth_milestone: 成长里程碑

    返回 JSON 格式:
    [
      {
        "type": "life_event",
        "content": "下周三有重要面试",
        "event_time": "2026-01-15",
        "is_future": true,
        "importance": 0.8,
        "follow_up_date": "2026-01-16"
      }
    ]
    """

    async def extract(
        self,
        conversation_id: str,
        messages: list[dict]
    ) -> list[dict]:
        """从对话中提取记忆"""

        conversation_text = self._format_conversation(messages)

        response = await self.llm.generate(
            self.EXTRACTION_PROMPT.format(conversation=conversation_text)
        )

        memories = json.loads(response)

        # 为每个记忆生成 embedding
        for memory in memories:
            memory['embedding'] = await self.embedding_service.embed(memory['content'])
            memory['source_conversation_id'] = conversation_id

        return memories
```

### 3.2 Memory Retriever

```python
# services/memory_engine/retriever.py

class MemoryRetriever:
    """记忆检索器"""

    async def retrieve_for_context(
        self,
        user_id: str,
        query: str,
        context_type: str = 'conversation'
    ) -> list[dict]:
        """为特定上下文检索相关记忆"""

        # 语义检索
        semantic_memories = await self._semantic_search(user_id, query, limit=3)

        # 时间相关检索（即将发生的事件）
        temporal_memories = await self._get_upcoming_events(user_id, days=7)

        # 情绪相关检索
        emotional_memories = await self._get_emotional_patterns(user_id)

        return self._merge_and_rank(semantic_memories, temporal_memories, emotional_memories)

    async def get_follow_up_items(self, user_id: str) -> list[dict]:
        """获取需要跟进的事项"""
        return await self.memory_repo.get_by_follow_up_date(
            user_id=user_id,
            date=date.today()
        )
```

---

## 4. 仪式引擎 (Ritual Engine)

### 4.1 Morning Oracle

```python
# services/ritual_engine/morning_oracle.py

class MorningOracle:
    """晨谕生成器"""

    async def generate(self, user_id: str) -> dict:
        """生成今日晨谕"""

        # 获取用户上下文
        context = await self.context_orchestrator.build_context(user_id, "")

        # 获取今日运势
        fortune = await self._get_daily_fortune(user_id, context)

        # 获取需要跟进的事项
        follow_ups = await self.memory_retriever.get_follow_up_items(user_id)

        # 生成晨谕
        oracle = await self._generate_oracle(context, fortune, follow_ups)

        return {
            'energy_theme': oracle['theme'],
            'prediction': oracle['prediction'],
            'advice': oracle['advice'],
            'follow_up_reminder': oracle.get('follow_up'),
            'generated_at': datetime.utcnow().isoformat()
        }

    async def _generate_oracle(self, context, fortune, follow_ups) -> dict:
        prompt = f"""
        为用户生成今日晨谕。

        用户身份棱镜:
        - 核心本质: {context.identity_prism.get('core_essence', {}).get('summary')}
        - 内在自我: {context.identity_prism.get('inner_self', {}).get('summary')}

        今日运势:
        {json.dumps(fortune, ensure_ascii=False)}

        需要跟进的事项:
        {json.dumps(follow_ups, ensure_ascii=False)}

        请生成:
        1. 今日能量主题（2-3个字）
        2. 今日预测（可能遇到的情况）
        3. 应对建议（如果发生了该怎么做）
        4. 跟进提醒（如果有需要跟进的事项）

        风格要求：温暖、具体、有洞察力，像一个了解你的朋友。
        """
        # ... LLM 调用
```

### 4.2 Midday Mirror

```python
# services/ritual_engine/midday_mirror.py

class MiddayMirror:
    """午照生成器"""

    async def generate(self, user_id: str) -> dict:
        """生成午间反思"""

        # 获取今日晨谕
        morning_oracle = await self._get_today_oracle(user_id)

        # 生成午照
        mirror = await self._generate_mirror(user_id, morning_oracle)

        return {
            'check_in_question': mirror['question'],
            'morning_reference': mirror['reference'],
            'generated_at': datetime.utcnow().isoformat()
        }

    async def process_response(self, user_id: str, response: str) -> dict:
        """处理用户对午照的回复"""

        # 提取记忆
        memories = await self.memory_extractor.extract_from_text(response)

        # 生成 AI 跟进
        follow_up = await self._generate_follow_up(user_id, response)

        return {
            'ai_follow_up': follow_up,
            'extracted_memories': memories
        }
```

### 4.3 Night Whisper

```python
# services/ritual_engine/night_whisper.py

class NightWhisper:
    """夜语生成器"""

    async def generate(self, user_id: str) -> dict:
        """生成晚间夜语"""

        # 获取今日互动摘要
        today_summary = await self._get_today_summary(user_id)

        # 获取明日预览
        tomorrow_preview = await self._get_tomorrow_preview(user_id)

        # 生成夜语
        whisper = await self._generate_whisper(user_id, today_summary, tomorrow_preview)

        return {
            'day_summary': whisper['summary'],
            'tomorrow_preview': whisper['preview'],
            'closing_message': whisper['closing'],
            'generated_at': datetime.utcnow().isoformat()
        }
```

---

## 5. 旅程引擎 (Journey Engine)

### 5.1 Stage Tracker

```python
# services/journey_engine/stage_tracker.py

class JourneyStageTracker:
    """用户旅程阶段追踪器"""

    STAGE_CRITERIA = {
        'encounter': {
            'max_days': 0,
            'next_stage': 'first_sight'
        },
        'first_sight': {
            'min_conversations': 1,
            'max_days': 1,
            'next_stage': 'understanding'
        },
        'understanding': {
            'min_conversations': 3,
            'min_days': 2,
            'next_stage': 'trust'
        },
        'trust': {
            'min_conversations': 10,
            'min_days': 7,
            'has_paid': True,
            'next_stage': 'dependence'
        },
        'dependence': {
            'min_conversations': 30,
            'min_days': 30,
            'consecutive_days': 7,
            'next_stage': 'symbiosis'
        },
        'symbiosis': {
            'min_days': 60,
            'consecutive_days': 14
        }
    }

    async def check_transition(self, user_id: str) -> Optional[str]:
        """检查用户是否应该进入下一阶段"""

        user = await self.user_repo.get(user_id)
        current_stage = user.journey_stage
        criteria = self.STAGE_CRITERIA.get(current_stage, {})

        if not criteria.get('next_stage'):
            return None  # 已是最终阶段

        # 检查各项条件
        stats = await self._get_user_stats(user_id)

        if self._meets_criteria(stats, criteria):
            return criteria['next_stage']

        return None

    async def transition(self, user_id: str, new_stage: str):
        """执行阶段转换"""

        await self.user_repo.update(user_id, {'journey_stage': new_stage})

        # 触发转换事件
        await self.event_bus.publish('journey_stage_changed', {
            'user_id': user_id,
            'new_stage': new_stage,
            'timestamp': datetime.utcnow().isoformat()
        })

        # 发送阶段转换消息
        await self._send_transition_message(user_id, new_stage)
```

---

## 6. API 路由升级

### 6.1 统一对话入口

```python
# routes/chat.py (重构)

@router.post("/chat")
async def chat(
    request: ChatRequest,
    user: VibeUser = Depends(get_current_user)
):
    """统一对话入口 - 支持多维度融合对话"""

    # 1. 构建上下文
    context = await context_orchestrator.build_context(
        user_id=user.vibe_id,
        user_message=request.message,
        conversation_id=request.conversation_id
    )

    # 2. 检查旅程阶段转换
    new_stage = await journey_tracker.check_transition(user.vibe_id)
    if new_stage:
        await journey_tracker.transition(user.vibe_id, new_stage)

    # 3. 生成回复
    response = await understanding_engine.generate_response(
        context=context,
        message=request.message,
        skill=request.skill  # 可选，指定特定技能
    )

    # 4. 异步提取记忆
    asyncio.create_task(
        memory_extractor.extract_and_save(
            user_id=user.vibe_id,
            conversation_id=response.conversation_id,
            messages=[request.message, response.content]
        )
    )

    return response
```

### 6.2 Identity Prism API

```python
# routes/identity.py (新增)

@router.get("/identity/prism")
async def get_identity_prism(user: VibeUser = Depends(get_current_user)):
    """获取用户的 Identity Prism"""
    prism = await identity_service.get_prism(user.vibe_id)
    return prism

@router.post("/identity/prism/regenerate")
async def regenerate_prism(user: VibeUser = Depends(get_current_user)):
    """重新生成 Identity Prism"""
    prism = await identity_service.regenerate_prism(user.vibe_id)
    return prism

@router.get("/identity/dimensions")
async def get_dimensions(user: VibeUser = Depends(get_current_user)):
    """获取用户已解锁的维度"""
    dimensions = await identity_service.get_dimensions(user.vibe_id)
    return dimensions
```

### 6.3 Rituals API

```python
# routes/rituals.py (新增)

@router.get("/rituals/today")
async def get_today_rituals(user: VibeUser = Depends(get_current_user)):
    """获取今日仪式"""
    rituals = await ritual_service.get_today(user.vibe_id)
    return rituals

@router.post("/rituals/midday/respond")
async def respond_to_midday(
    request: MiddayResponse,
    user: VibeUser = Depends(get_current_user)
):
    """回复午照"""
    result = await ritual_service.process_midday_response(
        user.vibe_id,
        request.response
    )
    return result

@router.put("/rituals/preferences")
async def update_ritual_preferences(
    request: RitualPreferences,
    user: VibeUser = Depends(get_current_user)
):
    """更新仪式偏好"""
    await ritual_service.update_preferences(user.vibe_id, request)
    return {"status": "ok"}
```

### 6.4 Events API

```python
# routes/events.py (新增)

@router.get("/events")
async def get_events(
    upcoming: bool = True,
    limit: int = 10,
    user: VibeUser = Depends(get_current_user)
):
    """获取用户事件"""
    events = await event_service.get_events(
        user.vibe_id,
        upcoming=upcoming,
        limit=limit
    )
    return events

@router.post("/events")
async def create_event(
    request: CreateEventRequest,
    user: VibeUser = Depends(get_current_user)
):
    """创建事件"""
    event = await event_service.create(user.vibe_id, request)
    return event

@router.put("/events/{event_id}/feedback")
async def add_event_feedback(
    event_id: str,
    request: EventFeedback,
    user: VibeUser = Depends(get_current_user)
):
    """添加事件反馈"""
    await event_service.add_feedback(event_id, request.feedback)
    return {"status": "ok"}
```

---

## 7. 后台任务

### 7.1 仪式调度器

```python
# workers/ritual_scheduler.py

class RitualScheduler:
    """仪式调度器 - 定时生成和发送仪式"""

    async def run(self):
        """主循环"""
        while True:
            await self._process_morning_oracles()
            await self._process_midday_mirrors()
            await self._process_night_whispers()
            await asyncio.sleep(60)  # 每分钟检查一次

    async def _process_morning_oracles(self):
        """处理晨谕"""
        users = await self._get_users_for_ritual('morning_oracle')

        for user in users:
            try:
                oracle = await self.morning_oracle.generate(user.vibe_id)
                await self._save_and_send(user.vibe_id, 'morning_oracle', oracle)
            except Exception as e:
                logger.error(f"Failed to generate morning oracle for {user.vibe_id}: {e}")
```

### 7.2 记忆整合器

```python
# workers/memory_consolidator.py

class MemoryConsolidator:
    """记忆整合器 - 定期整合和更新用户记忆"""

    async def consolidate(self, user_id: str):
        """整合用户记忆"""

        # 获取最近的记忆
        recent_memories = await self.memory_repo.get_recent(user_id, days=7)

        # 识别重复或相关的记忆
        clusters = await self._cluster_memories(recent_memories)

        # 合并相关记忆
        for cluster in clusters:
            if len(cluster) > 1:
                merged = await self._merge_memories(cluster)
                await self._save_merged_memory(user_id, merged, cluster)

        # 更新 AI 洞察
        await self._update_insights(user_id)
```

---

## 8. 实施检查清单

- [ ] 创建 understanding_engine 服务目录
- [ ] 实现 ContextOrchestrator
- [ ] 实现 DimensionFusion
- [ ] 创建 memory_engine 服务目录
- [ ] 实现 MemoryExtractor
- [ ] 实现 MemoryRetriever
- [ ] 创建 ritual_engine 服务目录
- [ ] 实现 MorningOracle
- [ ] 实现 MiddayMirror
- [ ] 实现 NightWhisper
- [ ] 创建 journey_engine 服务目录
- [ ] 实现 JourneyStageTracker
- [ ] 重构 chat.py 路由
- [ ] 新增 identity.py 路由
- [ ] 新增 rituals.py 路由
- [ ] 新增 events.py 路由
- [ ] 实现 RitualScheduler worker
- [ ] 实现 MemoryConsolidator worker

---

*下一步: [03-AI引擎升级](./03-AI引擎升级.md)*
