# AI 引擎升级方案

## 概述

将现有的"技能驱动"AI对话升级为"统一理解引擎"，实现多维度融合、长期记忆和主动关怀。

---

## 1. 现有 AI 架构分析

### 1.1 当前架构

```
services/
├── agent/
│   ├── persona.py      # 人格定义
│   ├── router.py       # 技能路由
│   └── runtime.py      # Agent 运行时
├── vibe_engine/
│   ├── llm.py          # LLM 调用
│   ├── emotion.py      # 情感引擎
│   ├── insight.py      # 洞察生成
│   ├── memory.py       # 基础记忆
│   └── profile.py      # 用户画像
└── knowledge/
    ├── embedding.py    # 向量嵌入
    ├── rag.py          # RAG 检索
    └── retrieval.py    # 知识检索
```

### 1.2 当前问题

| 问题 | 影响 |
|------|------|
| 技能隔离 | 八字/星座/MBTI 各自独立，无法融合洞察 |
| 短期记忆 | 只记住当前对话，不记得用户历史 |
| 被动响应 | 只能等用户发起，无法主动关怀 |
| 单一人格 | 固定风格，无法适应用户偏好 |

---

## 2. 目标架构

```
services/
├── understanding_engine/     # 统一理解引擎
│   ├── core/
│   │   ├── orchestrator.py   # 上下文编排
│   │   ├── fusion.py         # 维度融合
│   │   └── generator.py      # 回复生成
│   ├── memory/
│   │   ├── extractor.py      # 记忆提取
│   │   ├── retriever.py      # 记忆检索
│   │   └── consolidator.py   # 记忆整合
│   ├── persona/
│   │   ├── adapter.py        # 人格适配
│   │   └── styles.py         # 风格定义
│   └── proactive/
│       ├── trigger.py        # 主动触发
│       └── generator.py      # 主动消息生成
```

---

## 3. 核心组件设计

### 3.1 Prompt 架构

```python
# services/understanding_engine/core/prompts.py

SYSTEM_PROMPT_TEMPLATE = """
你是 VibeLife，一个真正了解用户的 AI 伴侣。

## 关于 {user_name}

### 身份棱镜 (Identity Prism)
- 核心本质 (Core): {core_essence}
- 内在自我 (Inner): {inner_self}
- 外在表现 (Outer): {outer_expression}

### 已解锁维度
{unlocked_dimensions}

### 相关记忆
{relevant_memories}

### 即将发生的事件
{upcoming_events}

### 今日运势
{daily_fortune}

### 旅程阶段
当前阶段: {journey_stage}
阶段特征: {stage_characteristics}

## 对话风格
{persona_style}

## 重要原则
1. 你真正了解这个人，不是泛泛而谈
2. 引用具体的记忆和洞察，让用户感到被理解
3. 在合适的时机主动关心用户的重要事件
4. 根据用户的维度数据提供个性化建议
5. 保持温暖但不过度，像一个了解你的朋友
"""

MEMORY_EXTRACTION_PROMPT = """
分析以下对话，提取值得长期记住的信息。

对话内容:
{conversation}

提取规则:
1. 生活事件: 面试、约会、考试、旅行等具体事件
2. 性格特征: 用户展现的性格特点
3. 情绪模式: 反复出现的情绪状态
4. 偏好习惯: 喜好、习惯、价值观
5. 关注困扰: 用户关心或困扰的事情
6. 人际关系: 提到的重要人物
7. 成长里程碑: 重要的成长时刻

输出 JSON 格式:
[
  {{
    "type": "life_event",
    "content": "下周三有重要面试",
    "event_time": "2026-01-15",
    "is_future": true,
    "importance": 0.8,
    "follow_up_date": "2026-01-16"
  }}
]

只提取明确的信息，不要推测。如果没有值得记住的内容，返回空数组。
"""

DIMENSION_FUSION_PROMPT = """
基于用户的多维度分析结果，生成统一的身份理解。

## 八字分析
{bazi_analysis}

## 星座分析
{zodiac_analysis}

## MBTI 分析
{mbti_analysis}

请融合以上分析，生成:

1. Core (核心本质) - 驱动这个人的根本力量是什么？
2. Inner (内在自我) - 这个人内心真正想要什么？
3. Outer (外在表现) - 别人眼中的这个人是什么样的？

要求:
- 找出各维度的共同点和互补点
- 用简洁有力的语言描述
- 避免泛泛而谈，要具体
"""
```

### 3.2 上下文编排器

```python
# services/understanding_engine/core/orchestrator.py

class ContextOrchestrator:
    """上下文编排器 - 为每次对话构建完整上下文"""

    def __init__(
        self,
        identity_service: IdentityService,
        memory_service: MemoryService,
        fortune_service: FortuneService,
        event_service: EventService
    ):
        self.identity = identity_service
        self.memory = memory_service
        self.fortune = fortune_service
        self.events = event_service

    async def build_system_prompt(
        self,
        user_id: str,
        user_message: str,
        persona_style: str = "warm_friend"
    ) -> str:
        """构建完整的系统提示词"""

        # 并行获取所有上下文数据
        user, prism, memories, events, fortune, stage = await asyncio.gather(
            self._get_user(user_id),
            self.identity.get_prism(user_id),
            self.memory.retrieve_relevant(user_id, user_message),
            self.events.get_upcoming(user_id, days=7),
            self.fortune.get_today(user_id),
            self._get_journey_stage(user_id)
        )

        return SYSTEM_PROMPT_TEMPLATE.format(
            user_name=user.display_name or "朋友",
            core_essence=prism.get('core_essence', {}).get('summary', '尚未解锁'),
            inner_self=prism.get('inner_self', {}).get('summary', '尚未解锁'),
            outer_expression=prism.get('outer_expression', {}).get('summary', '尚未解锁'),
            unlocked_dimensions=self._format_dimensions(prism.get('source_dimensions', [])),
            relevant_memories=self._format_memories(memories),
            upcoming_events=self._format_events(events),
            daily_fortune=self._format_fortune(fortune),
            journey_stage=stage['name'],
            stage_characteristics=stage['characteristics'],
            persona_style=PERSONA_STYLES[persona_style]
        )

    def _format_memories(self, memories: list) -> str:
        if not memories:
            return "暂无相关记忆"

        lines = []
        for m in memories[:5]:
            time_str = m.get('event_time', m.get('created_at', ''))[:10]
            lines.append(f"- [{time_str}] {m['content']}")
        return "\n".join(lines)

    def _format_events(self, events: list) -> str:
        if not events:
            return "近期无重要事件"

        lines = []
        for e in events[:3]:
            lines.append(f"- {e['event_date']}: {e['title']}")
        return "\n".join(lines)
```

### 3.3 回复生成器

```python
# services/understanding_engine/core/generator.py

class ResponseGenerator:
    """回复生成器 - 生成个性化回复"""

    def __init__(
        self,
        llm_service: LLMService,
        orchestrator: ContextOrchestrator,
        knowledge_service: KnowledgeService
    ):
        self.llm = llm_service
        self.orchestrator = orchestrator
        self.knowledge = knowledge_service

    async def generate(
        self,
        user_id: str,
        message: str,
        conversation_history: list[dict],
        skill: Optional[str] = None
    ) -> dict:
        """生成回复"""

        # 1. 构建系统提示词
        system_prompt = await self.orchestrator.build_system_prompt(
            user_id=user_id,
            user_message=message
        )

        # 2. 如果指定了技能，增强知识检索
        if skill:
            knowledge_context = await self.knowledge.retrieve(
                query=message,
                skill=skill,
                limit=3
            )
            system_prompt += f"\n\n## 相关知识\n{knowledge_context}"

        # 3. 构建消息列表
        messages = [{"role": "system", "content": system_prompt}]
        messages.extend(conversation_history[-10:])  # 最近10轮对话
        messages.append({"role": "user", "content": message})

        # 4. 调用 LLM
        response = await self.llm.generate(
            messages=messages,
            temperature=0.7,
            max_tokens=1000
        )

        # 5. 检测是否需要提取记忆
        should_extract = await self._should_extract_memory(message, response)

        return {
            "content": response,
            "should_extract_memory": should_extract,
            "skill_used": skill
        }

    async def _should_extract_memory(self, user_msg: str, ai_response: str) -> bool:
        """判断是否需要提取记忆"""
        # 简单规则：消息长度超过50字符，或包含时间相关词汇
        time_keywords = ['明天', '下周', '下个月', '面试', '约会', '考试', '旅行', '搬家']
        combined = user_msg + ai_response

        if len(user_msg) > 50:
            return True

        for keyword in time_keywords:
            if keyword in combined:
                return True

        return False
```

### 3.4 人格适配器

```python
# services/understanding_engine/persona/adapter.py

PERSONA_STYLES = {
    "warm_friend": """
    你是一个温暖的朋友。
    - 语气亲切自然，像老朋友聊天
    - 适当使用口语化表达
    - 在用户困难时给予支持和鼓励
    - 分享洞察时温和而不说教
    """,

    "tough_friend": """
    你是一个直率的朋友。
    - 说话直接，不绕弯子
    - 在用户需要时给予真诚的批评
    - 推动用户面对问题而不是逃避
    - 但始终出于关心，不是刻薄
    """,

    "life_mentor": """
    你是一个智慧的导师。
    - 语气沉稳有深度
    - 善于用问题引导用户思考
    - 分享人生智慧和哲理
    - 帮助用户看到更大的图景
    """
}

class PersonaAdapter:
    """人格适配器 - 根据用户偏好和场景调整人格"""

    async def get_persona_style(
        self,
        user_id: str,
        context: Optional[str] = None
    ) -> str:
        """获取适合的人格风格"""

        # 获取用户偏好
        preferences = await self.preference_repo.get(user_id)
        preferred = preferences.get('preferred_persona', 'warm_friend')

        # 根据上下文微调
        if context:
            # 如果用户在困难时期，使用更温暖的风格
            if await self._detect_difficulty(context):
                return "warm_friend"

            # 如果用户在逃避问题，可能需要直率的风格
            if await self._detect_avoidance(context):
                return "tough_friend"

        return preferred
```

---

## 4. 记忆系统设计

### 4.1 记忆提取器

```python
# services/understanding_engine/memory/extractor.py

class MemoryExtractor:
    """从对话中提取长期记忆"""

    async def extract(
        self,
        user_id: str,
        conversation_id: str,
        messages: list[dict]
    ) -> list[dict]:
        """提取记忆"""

        # 格式化对话
        conversation_text = self._format_conversation(messages)

        # 调用 LLM 提取
        response = await self.llm.generate(
            messages=[
                {"role": "system", "content": MEMORY_EXTRACTION_PROMPT.format(
                    conversation=conversation_text
                )}
            ],
            temperature=0.3  # 低温度，更精确
        )

        try:
            memories = json.loads(response)
        except json.JSONDecodeError:
            return []

        # 为每个记忆生成 embedding
        for memory in memories:
            memory['embedding'] = await self.embedding.embed(memory['content'])
            memory['source_conversation_id'] = conversation_id
            memory['user_id'] = user_id

        return memories

    async def save(self, memories: list[dict]):
        """保存记忆到数据库"""
        for memory in memories:
            await self.memory_repo.create(memory)

            # 如果是未来事件，创建事件记录
            if memory.get('is_future') and memory.get('event_time'):
                await self._create_life_event(memory)
```

### 4.2 记忆检索器

```python
# services/understanding_engine/memory/retriever.py

class MemoryRetriever:
    """记忆检索器"""

    async def retrieve_relevant(
        self,
        user_id: str,
        query: str,
        limit: int = 5
    ) -> list[dict]:
        """检索相关记忆"""

        # 1. 语义检索
        query_embedding = await self.embedding.embed(query)
        semantic_memories = await self.memory_repo.search_by_embedding(
            user_id=user_id,
            embedding=query_embedding,
            limit=limit
        )

        # 2. 时间相关检索
        temporal_memories = await self._get_temporal_memories(user_id)

        # 3. 合并去重
        all_memories = self._merge_memories(semantic_memories, temporal_memories)

        # 4. 按重要性排序
        return sorted(all_memories, key=lambda m: m.get('importance', 0.5), reverse=True)[:limit]

    async def _get_temporal_memories(self, user_id: str) -> list[dict]:
        """获取时间相关的记忆"""
        today = date.today()

        # 需要跟进的事项
        follow_ups = await self.memory_repo.get_by_follow_up_date(user_id, today)

        # 即将发生的事件
        upcoming = await self.memory_repo.get_upcoming_events(user_id, days=7)

        return follow_ups + upcoming
```

---

## 5. 主动触发系统

### 5.1 触发器

```python
# services/understanding_engine/proactive/trigger.py

class ProactiveTrigger:
    """主动触发器 - 决定何时主动联系用户"""

    TRIGGER_RULES = [
        {
            'name': 'morning_oracle',
            'condition': lambda ctx: ctx['time'].hour == ctx['preferences']['morning_oracle_time'].hour,
            'priority': 1
        },
        {
            'name': 'event_reminder',
            'condition': lambda ctx: any(e['event_date'] == date.today() for e in ctx['events']),
            'priority': 2
        },
        {
            'name': 'follow_up',
            'condition': lambda ctx: len(ctx['follow_ups']) > 0,
            'priority': 3
        },
        {
            'name': 'inactive_check',
            'condition': lambda ctx: ctx['days_since_last_active'] >= 3,
            'priority': 4
        }
    ]

    async def check_triggers(self, user_id: str) -> list[dict]:
        """检查所有触发条件"""

        context = await self._build_trigger_context(user_id)
        triggered = []

        for rule in self.TRIGGER_RULES:
            if rule['condition'](context):
                triggered.append({
                    'name': rule['name'],
                    'priority': rule['priority'],
                    'context': context
                })

        return sorted(triggered, key=lambda t: t['priority'])
```

### 5.2 主动消息生成器

```python
# services/understanding_engine/proactive/generator.py

class ProactiveMessageGenerator:
    """主动消息生成器"""

    async def generate(self, trigger: dict, user_id: str) -> str:
        """根据触发类型生成主动消息"""

        if trigger['name'] == 'event_reminder':
            return await self._generate_event_reminder(user_id, trigger['context'])

        elif trigger['name'] == 'follow_up':
            return await self._generate_follow_up(user_id, trigger['context'])

        elif trigger['name'] == 'inactive_check':
            return await self._generate_inactive_check(user_id, trigger['context'])

        return ""

    async def _generate_event_reminder(self, user_id: str, context: dict) -> str:
        """生成事件提醒"""
        events = [e for e in context['events'] if e['event_date'] == date.today()]

        if not events:
            return ""

        event = events[0]
        prism = await self.identity.get_prism(user_id)

        prompt = f"""
        用户今天有一个重要事件: {event['title']}

        用户的核心本质: {prism.get('core_essence', {}).get('summary', '')}

        请生成一条温暖的提醒消息，包含:
        1. 对事件的关心
        2. 基于用户特质的鼓励
        3. 一个具体的小建议

        保持简短，不超过100字。
        """

        return await self.llm.generate([{"role": "user", "content": prompt}])

    async def _generate_follow_up(self, user_id: str, context: dict) -> str:
        """生成跟进消息"""
        follow_up = context['follow_ups'][0]

        prompt = f"""
        之前用户提到: {follow_up['content']}
        今天是跟进的日子。

        请生成一条自然的跟进消息，询问事情的进展。
        不要太正式，像朋友关心一样。
        保持简短，不超过50字。
        """

        return await self.llm.generate([{"role": "user", "content": prompt}])
```

---

## 6. 模型路由优化

### 6.1 智能模型选择

```python
# services/understanding_engine/model_router.py

class IntelligentModelRouter:
    """智能模型路由 - 根据任务选择最优模型"""

    MODEL_CONFIGS = {
        'conversation': {
            'primary': 'glm-4-plus',
            'fallback': 'claude-3-5-sonnet',
            'max_tokens': 1000
        },
        'memory_extraction': {
            'primary': 'glm-4-flash',
            'fallback': 'claude-3-5-haiku',
            'max_tokens': 500
        },
        'dimension_fusion': {
            'primary': 'claude-3-5-sonnet',
            'fallback': 'glm-4-plus',
            'max_tokens': 2000
        },
        'ritual_generation': {
            'primary': 'glm-4-plus',
            'fallback': 'claude-3-5-sonnet',
            'max_tokens': 500
        }
    }

    async def route(self, task_type: str, messages: list[dict]) -> str:
        """路由到最优模型"""

        config = self.MODEL_CONFIGS.get(task_type, self.MODEL_CONFIGS['conversation'])

        try:
            return await self._call_model(config['primary'], messages, config['max_tokens'])
        except Exception as e:
            logger.warning(f"Primary model failed: {e}, falling back")
            return await self._call_model(config['fallback'], messages, config['max_tokens'])
```

---

## 7. 实施检查清单

- [ ] 创建 understanding_engine 目录结构
- [ ] 实现 ContextOrchestrator
- [ ] 实现 ResponseGenerator
- [ ] 实现 PersonaAdapter
- [ ] 实现 MemoryExtractor
- [ ] 实现 MemoryRetriever
- [ ] 实现 ProactiveTrigger
- [ ] 实现 ProactiveMessageGenerator
- [ ] 实现 IntelligentModelRouter
- [ ] 编写 Prompt 模板
- [ ] 集成测试
- [ ] 性能优化

---

*下一步: [04-前端体验重构](./04-前端体验重构.md)*
