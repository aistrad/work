# 订阅系统设计

## 概述

将现有的一次性购买模式升级为 L0-L3 四层订阅模型，实现"关系订阅"而非"功能订阅"。

---

## 1. 订阅层级设计

### 1.1 层级定义

| 层级 | 名称 | 价格 | 定位 |
|------|------|------|------|
| L0 | Free | ¥0 | 体验层 - 让用户感受价值 |
| L1 | The Letter | ¥29 一次性 | 入门层 - 获得完整报告 |
| L2 | The Companion | ¥39/月 | 陪伴层 - 日常陪伴 |
| L3 | The Sanctuary | ¥299/年 | 深度层 - 全方位支持 |

### 1.2 权益对比

| 功能 | L0 | L1 | L2 | L3 |
|------|----|----|----|----|
| 完整信件 | ✅ | ✅ | ✅ | ✅ |
| PDF 报告 | ❌ | ✅ | ✅ | ✅ |
| Identity Prism | ❌ | ✅ | ✅ | ✅ |
| 每日对话次数 | 3次 | 10次 | 无限 | 无限 |
| 每日仪式 | ❌ | ❌ | ✅ | ✅ |
| 周运势 | ❌ | ❌ | ✅ | ✅ |
| 关系分析 | ❌ | ❌ | 1次/月 | 无限 |
| 季度报告 | ❌ | ❌ | ❌ | ✅ |
| 年度回顾 | ❌ | ❌ | ❌ | ✅ |
| 维度数量 | 1 | 2 | 4 | 全部 |

---

## 2. 数据模型

### 2.1 订阅计划表

```sql
-- 更新 subscription_plans 表
CREATE TABLE subscription_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL,
    tier VARCHAR(10) NOT NULL,  -- L0, L1, L2, L3
    plan_type VARCHAR(20) NOT NULL,  -- free, one_time, monthly, yearly

    -- 价格
    price DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'CNY',
    stripe_price_id VARCHAR(100),

    -- 权益配置
    features JSONB NOT NULL,
    -- {
    --   "daily_conversations": 3,
    --   "dimensions": ["bazi"],
    --   "rituals": false,
    --   "relationship_analyses": 0,
    --   "pdf_report": false,
    --   "identity_prism": false
    -- }

    -- 状态
    is_active BOOLEAN DEFAULT true,
    display_order INTEGER DEFAULT 0,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 初始化计划数据
INSERT INTO subscription_plans (name, tier, plan_type, price, features) VALUES
('免费体验', 'L0', 'free', 0, '{
    "daily_conversations": 3,
    "dimensions": ["bazi"],
    "rituals": false,
    "relationship_analyses": 0,
    "pdf_report": false,
    "identity_prism": false,
    "weekly_fortune": false
}'),
('The Letter', 'L1', 'one_time', 29, '{
    "daily_conversations": 10,
    "dimensions": ["bazi", "zodiac"],
    "rituals": false,
    "relationship_analyses": 0,
    "pdf_report": true,
    "identity_prism": true,
    "weekly_fortune": false
}'),
('The Companion', 'L2', 'monthly', 39, '{
    "daily_conversations": -1,
    "dimensions": ["bazi", "zodiac", "mbti", "tarot"],
    "rituals": true,
    "relationship_analyses": 1,
    "pdf_report": true,
    "identity_prism": true,
    "weekly_fortune": true
}'),
('The Sanctuary', 'L3', 'yearly', 299, '{
    "daily_conversations": -1,
    "dimensions": "all",
    "rituals": true,
    "relationship_analyses": -1,
    "pdf_report": true,
    "identity_prism": true,
    "weekly_fortune": true,
    "quarterly_report": true,
    "annual_review": true
}');
```

### 2.2 用户权益表

```sql
-- 用户当前权益 (实时计算)
CREATE TABLE user_entitlements (
    user_id UUID PRIMARY KEY REFERENCES vibe_users(vibe_id),

    -- 当前层级
    current_tier VARCHAR(10) DEFAULT 'L0',
    subscription_id UUID REFERENCES subscriptions(id),

    -- 使用量追踪
    daily_conversations_used INTEGER DEFAULT 0,
    daily_conversations_reset_at DATE DEFAULT CURRENT_DATE,
    monthly_relationship_analyses_used INTEGER DEFAULT 0,
    monthly_reset_at DATE DEFAULT DATE_TRUNC('month', CURRENT_DATE),

    -- 解锁的维度
    unlocked_dimensions TEXT[] DEFAULT ARRAY['bazi'],

    -- 特殊权益
    has_pdf_report BOOLEAN DEFAULT false,
    has_identity_prism BOOLEAN DEFAULT false,
    has_rituals BOOLEAN DEFAULT false,

    -- 有效期
    tier_expires_at TIMESTAMP,

    updated_at TIMESTAMP DEFAULT NOW()
);

-- 每日重置触发器
CREATE OR REPLACE FUNCTION reset_daily_usage()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.daily_conversations_reset_at < CURRENT_DATE THEN
        NEW.daily_conversations_used := 0;
        NEW.daily_conversations_reset_at := CURRENT_DATE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_reset_daily_usage
    BEFORE UPDATE ON user_entitlements
    FOR EACH ROW
    EXECUTE FUNCTION reset_daily_usage();
```

### 2.3 订阅记录表

```sql
-- 升级现有 subscriptions 表
ALTER TABLE subscriptions ADD COLUMN tier VARCHAR(10);
ALTER TABLE subscriptions ADD COLUMN auto_renew BOOLEAN DEFAULT true;
ALTER TABLE subscriptions ADD COLUMN cancelled_at TIMESTAMP;
ALTER TABLE subscriptions ADD COLUMN cancel_reason TEXT;

-- 订阅历史表 (用于分析)
CREATE TABLE subscription_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),

    event_type VARCHAR(20) NOT NULL,
    -- subscribe, upgrade, downgrade, cancel, renew, expire

    from_tier VARCHAR(10),
    to_tier VARCHAR(10),

    -- 关联数据
    subscription_id UUID,
    payment_id UUID,

    -- 元数据
    metadata JSONB,

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sub_history_user ON subscription_history(user_id);
CREATE INDEX idx_sub_history_event ON subscription_history(event_type);
```

---

## 3. 后端服务

### 3.1 权益服务

```python
# services/entitlement/service.py

class EntitlementService:
    """用户权益服务"""

    async def get_entitlements(self, user_id: str) -> UserEntitlements:
        """获取用户当前权益"""

        entitlements = await self.entitlement_repo.get(user_id)

        if not entitlements:
            # 新用户，创建默认权益
            entitlements = await self._create_default_entitlements(user_id)

        # 检查是否需要重置每日使用量
        entitlements = await self._check_and_reset_usage(entitlements)

        return entitlements

    async def check_can_chat(self, user_id: str) -> tuple[bool, str]:
        """检查用户是否可以对话"""

        entitlements = await self.get_entitlements(user_id)

        # 无限对话
        if entitlements.current_tier in ['L2', 'L3']:
            return True, ""

        # 检查每日限额
        plan = await self._get_plan(entitlements.current_tier)
        daily_limit = plan.features.get('daily_conversations', 3)

        if entitlements.daily_conversations_used >= daily_limit:
            return False, f"今日对话次数已用完 ({daily_limit}次)，升级解锁无限对话"

        return True, ""

    async def consume_conversation(self, user_id: str):
        """消耗一次对话次数"""

        entitlements = await self.get_entitlements(user_id)

        if entitlements.current_tier not in ['L2', 'L3']:
            await self.entitlement_repo.increment_daily_conversations(user_id)

    async def check_can_use_dimension(self, user_id: str, dimension: str) -> bool:
        """检查用户是否可以使用某个维度"""

        entitlements = await self.get_entitlements(user_id)

        if entitlements.current_tier == 'L3':
            return True  # L3 解锁所有维度

        return dimension in entitlements.unlocked_dimensions

    async def upgrade_tier(self, user_id: str, new_tier: str, subscription_id: str):
        """升级用户层级"""

        old_entitlements = await self.get_entitlements(user_id)
        plan = await self._get_plan(new_tier)

        # 更新权益
        await self.entitlement_repo.update(user_id, {
            'current_tier': new_tier,
            'subscription_id': subscription_id,
            'unlocked_dimensions': plan.features.get('dimensions', ['bazi']),
            'has_pdf_report': plan.features.get('pdf_report', False),
            'has_identity_prism': plan.features.get('identity_prism', False),
            'has_rituals': plan.features.get('rituals', False),
            'tier_expires_at': self._calculate_expiry(plan)
        })

        # 记录历史
        await self._record_history(user_id, 'upgrade', old_entitlements.current_tier, new_tier)

        # 触发升级事件
        await self.event_bus.publish('tier_upgraded', {
            'user_id': user_id,
            'from_tier': old_entitlements.current_tier,
            'to_tier': new_tier
        })
```

### 3.2 订阅服务

```python
# services/subscription/service.py

class SubscriptionService:
    """订阅服务"""

    async def create_subscription(
        self,
        user_id: str,
        plan_id: str,
        payment_method: str
    ) -> Subscription:
        """创建订阅"""

        plan = await self.plan_repo.get(plan_id)

        # 创建 Stripe 订阅 (如果是周期性订阅)
        if plan.plan_type in ['monthly', 'yearly']:
            stripe_sub = await self._create_stripe_subscription(
                user_id, plan, payment_method
            )
            stripe_subscription_id = stripe_sub.id
        else:
            stripe_subscription_id = None

        # 创建本地订阅记录
        subscription = await self.subscription_repo.create({
            'user_id': user_id,
            'plan_id': plan_id,
            'tier': plan.tier,
            'status': 'active',
            'stripe_subscription_id': stripe_subscription_id,
            'current_period_start': datetime.utcnow(),
            'current_period_end': self._calculate_period_end(plan),
            'auto_renew': plan.plan_type != 'one_time'
        })

        # 更新用户权益
        await self.entitlement_service.upgrade_tier(
            user_id, plan.tier, subscription.id
        )

        return subscription

    async def cancel_subscription(self, user_id: str, reason: str = None):
        """取消订阅"""

        subscription = await self.subscription_repo.get_active(user_id)

        if not subscription:
            raise ValueError("No active subscription")

        # 取消 Stripe 订阅
        if subscription.stripe_subscription_id:
            await self._cancel_stripe_subscription(subscription.stripe_subscription_id)

        # 更新本地记录
        await self.subscription_repo.update(subscription.id, {
            'status': 'cancelled',
            'cancelled_at': datetime.utcnow(),
            'cancel_reason': reason,
            'auto_renew': False
        })

        # 记录历史
        await self._record_history(user_id, 'cancel', subscription.tier, None)

    async def handle_webhook(self, event: dict):
        """处理 Stripe Webhook"""

        event_type = event['type']

        if event_type == 'invoice.paid':
            await self._handle_invoice_paid(event['data']['object'])

        elif event_type == 'invoice.payment_failed':
            await self._handle_payment_failed(event['data']['object'])

        elif event_type == 'customer.subscription.deleted':
            await self._handle_subscription_deleted(event['data']['object'])

    async def _handle_invoice_paid(self, invoice: dict):
        """处理发票支付成功"""

        subscription_id = invoice['subscription']
        subscription = await self.subscription_repo.get_by_stripe_id(subscription_id)

        if subscription:
            # 更新订阅周期
            await self.subscription_repo.update(subscription.id, {
                'current_period_start': datetime.fromtimestamp(invoice['period_start']),
                'current_period_end': datetime.fromtimestamp(invoice['period_end']),
                'status': 'active'
            })

            # 记录续费
            await self._record_history(subscription.user_id, 'renew', subscription.tier, subscription.tier)
```

### 3.3 支付服务

```python
# services/payment/service.py

class PaymentService:
    """支付服务"""

    async def create_checkout_session(
        self,
        user_id: str,
        plan_id: str,
        success_url: str,
        cancel_url: str
    ) -> str:
        """创建 Stripe Checkout Session"""

        plan = await self.plan_repo.get(plan_id)
        user = await self.user_repo.get(user_id)

        # 获取或创建 Stripe Customer
        customer_id = await self._get_or_create_customer(user)

        # 创建 Checkout Session
        session = stripe.checkout.Session.create(
            customer=customer_id,
            payment_method_types=['card', 'alipay', 'wechat_pay'],
            line_items=[{
                'price': plan.stripe_price_id,
                'quantity': 1
            }],
            mode='subscription' if plan.plan_type in ['monthly', 'yearly'] else 'payment',
            success_url=success_url,
            cancel_url=cancel_url,
            metadata={
                'user_id': user_id,
                'plan_id': plan_id
            }
        )

        return session.url

    async def create_one_time_payment(
        self,
        user_id: str,
        plan_id: str
    ) -> dict:
        """创建一次性支付"""

        plan = await self.plan_repo.get(plan_id)

        # 创建支付意图
        intent = stripe.PaymentIntent.create(
            amount=int(plan.price * 100),
            currency=plan.currency.lower(),
            metadata={
                'user_id': user_id,
                'plan_id': plan_id
            }
        )

        return {
            'client_secret': intent.client_secret,
            'payment_intent_id': intent.id
        }
```

---

## 4. API 路由

### 4.1 订阅路由

```python
# routes/subscription.py

@router.get("/plans")
async def get_plans():
    """获取所有订阅计划"""
    plans = await plan_service.get_active_plans()
    return {"plans": plans}

@router.get("/current")
async def get_current_subscription(user: VibeUser = Depends(get_current_user)):
    """获取当前订阅状态"""
    subscription = await subscription_service.get_active(user.vibe_id)
    entitlements = await entitlement_service.get_entitlements(user.vibe_id)

    return {
        "subscription": subscription,
        "entitlements": entitlements
    }

@router.post("/checkout")
async def create_checkout(
    request: CheckoutRequest,
    user: VibeUser = Depends(get_current_user)
):
    """创建结账会话"""
    checkout_url = await payment_service.create_checkout_session(
        user_id=user.vibe_id,
        plan_id=request.plan_id,
        success_url=request.success_url,
        cancel_url=request.cancel_url
    )
    return {"checkout_url": checkout_url}

@router.post("/cancel")
async def cancel_subscription(
    request: CancelRequest,
    user: VibeUser = Depends(get_current_user)
):
    """取消订阅"""
    await subscription_service.cancel_subscription(
        user.vibe_id,
        reason=request.reason
    )
    return {"status": "cancelled"}

@router.post("/webhook")
async def stripe_webhook(request: Request):
    """Stripe Webhook"""
    payload = await request.body()
    sig_header = request.headers.get('stripe-signature')

    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, settings.STRIPE_WEBHOOK_SECRET
        )
    except ValueError:
        raise HTTPException(400, "Invalid payload")
    except stripe.error.SignatureVerificationError:
        raise HTTPException(400, "Invalid signature")

    await subscription_service.handle_webhook(event)
    return {"received": True}
```

### 4.2 权益检查中间件

```python
# middleware/entitlement.py

class EntitlementMiddleware:
    """权益检查中间件"""

    async def check_chat_entitlement(
        self,
        user: VibeUser = Depends(get_current_user)
    ):
        """检查对话权益"""
        can_chat, message = await entitlement_service.check_can_chat(user.vibe_id)

        if not can_chat:
            raise HTTPException(
                status_code=402,
                detail={
                    "error": "conversation_limit_reached",
                    "message": message,
                    "upgrade_url": "/subscription/plans"
                }
            )

        return user

    async def check_dimension_entitlement(
        self,
        dimension: str,
        user: VibeUser = Depends(get_current_user)
    ):
        """检查维度权益"""
        can_use = await entitlement_service.check_can_use_dimension(
            user.vibe_id, dimension
        )

        if not can_use:
            raise HTTPException(
                status_code=402,
                detail={
                    "error": "dimension_locked",
                    "message": f"升级解锁 {dimension} 维度",
                    "upgrade_url": "/subscription/plans"
                }
            )

        return user
```

---

## 5. 前端组件

### 5.1 订阅页面

```tsx
// app/subscription/page.tsx

export default function SubscriptionPage() {
  const { plans } = usePlans()
  const { subscription, entitlements } = useSubscription()

  return (
    <div className="min-h-screen bg-slate-900 p-4">
      <header className="mb-8 text-center">
        <h1 className="text-2xl font-bold text-white">选择你的旅程</h1>
        <p className="text-slate-400 mt-2">
          不是购买功能，而是开启一段关系
        </p>
      </header>

      {/* 当前状态 */}
      {subscription && (
        <CurrentSubscriptionCard
          subscription={subscription}
          entitlements={entitlements}
        />
      )}

      {/* 计划列表 */}
      <div className="space-y-4 mt-6">
        {plans.map((plan) => (
          <PlanCard
            key={plan.id}
            plan={plan}
            isCurrentPlan={subscription?.tier === plan.tier}
            onSelect={() => handleSelectPlan(plan)}
          />
        ))}
      </div>

      {/* FAQ */}
      <SubscriptionFAQ />
    </div>
  )
}
```

### 5.2 计划卡片

```tsx
// components/subscription/PlanCard.tsx

interface PlanCardProps {
  plan: SubscriptionPlan
  isCurrentPlan: boolean
  onSelect: () => void
}

export function PlanCard({ plan, isCurrentPlan, onSelect }: PlanCardProps) {
  const tierColors = {
    L0: 'from-slate-600 to-slate-700',
    L1: 'from-blue-600 to-blue-700',
    L2: 'from-purple-600 to-purple-700',
    L3: 'from-amber-600 to-amber-700'
  }

  return (
    <motion.div
      className={`rounded-2xl p-6 bg-gradient-to-br ${tierColors[plan.tier]}`}
      whileHover={{ scale: 1.02 }}
    >
      <div className="flex justify-between items-start">
        <div>
          <span className="text-white/60 text-sm">{plan.tier}</span>
          <h3 className="text-xl font-bold text-white">{plan.name}</h3>
        </div>
        <div className="text-right">
          <span className="text-2xl font-bold text-white">¥{plan.price}</span>
          {plan.plan_type === 'monthly' && (
            <span className="text-white/60 text-sm">/月</span>
          )}
          {plan.plan_type === 'yearly' && (
            <span className="text-white/60 text-sm">/年</span>
          )}
        </div>
      </div>

      {/* 权益列表 */}
      <ul className="mt-4 space-y-2">
        {Object.entries(FEATURE_LABELS).map(([key, label]) => {
          const hasFeature = plan.features[key]
          return (
            <li
              key={key}
              className={`flex items-center gap-2 text-sm ${
                hasFeature ? 'text-white' : 'text-white/40'
              }`}
            >
              {hasFeature ? (
                <CheckIcon className="h-4 w-4" />
              ) : (
                <XIcon className="h-4 w-4" />
              )}
              {label}
            </li>
          )
        })}
      </ul>

      {/* 操作按钮 */}
      <button
        onClick={onSelect}
        disabled={isCurrentPlan}
        className={`w-full mt-6 py-3 rounded-lg font-medium ${
          isCurrentPlan
            ? 'bg-white/20 text-white/60 cursor-not-allowed'
            : 'bg-white text-slate-900 hover:bg-white/90'
        }`}
      >
        {isCurrentPlan ? '当前计划' : '选择此计划'}
      </button>
    </motion.div>
  )
}
```

### 5.3 升级提示组件

```tsx
// components/subscription/UpgradePrompt.tsx

interface UpgradePromptProps {
  feature: string
  currentTier: string
  requiredTier: string
}

export function UpgradePrompt({
  feature,
  currentTier,
  requiredTier
}: UpgradePromptProps) {
  const router = useRouter()

  return (
    <motion.div
      className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
    >
      <motion.div
        className="bg-slate-800 rounded-2xl p-6 max-w-sm w-full"
        initial={{ scale: 0.9 }}
        animate={{ scale: 1 }}
      >
        <div className="text-center">
          <LockIcon className="h-12 w-12 text-amber-500 mx-auto" />
          <h3 className="text-xl font-bold text-white mt-4">
            解锁 {feature}
          </h3>
          <p className="text-slate-400 mt-2">
            升级到 {requiredTier} 即可使用此功能
          </p>
        </div>

        <div className="mt-6 space-y-3">
          <button
            onClick={() => router.push('/subscription')}
            className="w-full py-3 bg-indigo-600 text-white rounded-lg font-medium"
          >
            查看升级选项
          </button>
          <button
            onClick={() => router.back()}
            className="w-full py-3 text-slate-400"
          >
            稍后再说
          </button>
        </div>
      </motion.div>
    </motion.div>
  )
}
```

---

## 6. 转化优化

### 6.1 付费时机设计

```
用户旅程中的付费触发点:

1. 完整信件阅读后 (L0 → L1)
   - 展示 PDF 报告预览
   - "保存你的完整分析"

2. 第3次对话后 (L0 → L1/L2)
   - 展示对话次数限制
   - "继续深入了解自己"

3. 尝试使用高级维度 (L0/L1 → L2)
   - 展示维度锁定
   - "解锁更多维度"

4. 连续活跃3天后 (L1 → L2)
   - 展示每日仪式预览
   - "让我每天陪伴你"

5. 关系分析需求 (L1/L2 → L2/L3)
   - 展示关系分析功能
   - "了解你们的关系"
```

### 6.2 转化追踪

```python
# services/analytics/conversion.py

class ConversionTracker:
    """转化追踪服务"""

    async def track_event(self, user_id: str, event: str, metadata: dict = None):
        """追踪转化事件"""

        await self.event_repo.create({
            'user_id': user_id,
            'event_type': event,
            'metadata': metadata,
            'timestamp': datetime.utcnow()
        })

    async def get_conversion_funnel(self, start_date: date, end_date: date) -> dict:
        """获取转化漏斗数据"""

        return {
            'signup': await self._count_events('signup', start_date, end_date),
            'first_chat': await self._count_events('first_chat', start_date, end_date),
            'letter_read': await self._count_events('letter_read', start_date, end_date),
            'l1_purchase': await self._count_events('l1_purchase', start_date, end_date),
            'l2_subscribe': await self._count_events('l2_subscribe', start_date, end_date),
            'l3_subscribe': await self._count_events('l3_subscribe', start_date, end_date)
        }
```

---

## 7. 实施检查清单

- [ ] 更新 subscription_plans 表结构
- [ ] 创建 user_entitlements 表
- [ ] 创建 subscription_history 表
- [ ] 实现 EntitlementService
- [ ] 实现 SubscriptionService
- [ ] 实现 PaymentService
- [ ] 配置 Stripe 产品和价格
- [ ] 实现订阅 API 路由
- [ ] 实现权益检查中间件
- [ ] 创建订阅页面
- [ ] 实现 PlanCard 组件
- [ ] 实现 UpgradePrompt ���件
- [ ] 配置 Stripe Webhook
- [ ] 实现转化追踪
- [ ] 测试完整订阅流程

---

*下一步: [06-推送与仪式系统](./06-推送与仪式系统.md)*
