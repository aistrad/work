# 推送与仪式系统

## 概述

实现蓝图中的"晨谕/午照/夜语"三仪式系统，以及主动推送能力，让 AI 从被动工具升级为主动的"数字存在"。

---

## 1. 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                    推送与仪式系统                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │ 仪式调度器   │    │ 仪式生成器   │    │ 推送服务    │ │
│  │ Scheduler   │───▶│ Generator   │───▶│ Push        │ │
│  └─────────────┘    └─────────────┘    └─────────────┘ │
│         │                  │                  │         │
│         ▼                  ▼                  ▼         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │ 用户偏好    │    │ 上下文编排   │    │ 多渠道分发  │ │
│  │ Preferences │    │ Context     │    │ Channels    │ │
│  └─────────────┘    └─────────────┘    └─────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 仪式调度器

### 2.1 调度服务

```python
# services/ritual/scheduler.py

import asyncio
from datetime import datetime, time
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

class RitualScheduler:
    """仪式调度器 - 管理每日三仪式的定时触发"""

    def __init__(
        self,
        ritual_generator: RitualGenerator,
        push_service: PushService,
        user_repo: UserRepo
    ):
        self.generator = ritual_generator
        self.push = push_service
        self.user_repo = user_repo
        self.scheduler = AsyncIOScheduler()

    def start(self):
        """启动调度器"""
        # 每分钟检查需要发送仪式的用户
        self.scheduler.add_job(
            self._process_morning_oracles,
            CronTrigger(minute='*'),
            id='morning_oracle_check'
        )
        self.scheduler.add_job(
            self._process_midday_mirrors,
            CronTrigger(minute='*'),
            id='midday_mirror_check'
        )
        self.scheduler.add_job(
            self._process_night_whispers,
            CronTrigger(minute='*'),
            id='night_whisper_check'
        )

        self.scheduler.start()

    async def _process_morning_oracles(self):
        """处理晨谕"""
        current_time = datetime.now()
        users = await self._get_users_for_ritual('morning_oracle', current_time)

        for user in users:
            try:
                await self._send_morning_oracle(user)
            except Exception as e:
                logger.error(f"Failed morning oracle for {user.vibe_id}: {e}")

    async def _get_users_for_ritual(self, ritual_type: str, current_time: datetime) -> list:
        """获取当前时间需要接收仪式的用户"""
        current_hour = current_time.hour
        current_minute = current_time.minute

        # 查询偏好时间匹配的用户
        return await self.user_repo.get_users_by_ritual_time(
            ritual_type=ritual_type,
            hour=current_hour,
            minute=current_minute
        )

    async def _send_morning_oracle(self, user):
        """发送晨谕"""
        # 检查今日是否已发送
        if await self._already_sent_today(user.vibe_id, 'morning_oracle'):
            return

        # 生成晨谕
        oracle = await self.generator.generate_morning_oracle(user.vibe_id)

        # 保存到数据库
        await self._save_ritual(user.vibe_id, 'morning_oracle', oracle)

        # 发送推送
        await self.push.send(
            user_id=user.vibe_id,
            title="☀️ 今日晨谕",
            body=f"今日能量: {oracle['energy_theme']}",
            data={'type': 'morning_oracle', 'ritual_id': oracle['id']}
        )
```

### 2.2 批量处理优化

```python
# services/ritual/batch_processor.py

class RitualBatchProcessor:
    """批量处理仪式生成，提高效率"""

    BATCH_SIZE = 100

    async def process_batch(self, ritual_type: str, users: list):
        """批量处理用户仪式"""

        # 分批处理
        for i in range(0, len(users), self.BATCH_SIZE):
            batch = users[i:i + self.BATCH_SIZE]

            # 并行生成仪式
            tasks = [
                self._generate_and_send(user, ritual_type)
                for user in batch
            ]

            results = await asyncio.gather(*tasks, return_exceptions=True)

            # 记录失败
            for user, result in zip(batch, results):
                if isinstance(result, Exception):
                    logger.error(f"Ritual failed for {user.vibe_id}: {result}")

            # 批次间短暂休息，避免过载
            await asyncio.sleep(0.5)
```

---

## 3. 仪式生成器

### 3.1 晨谕生成

```python
# services/ritual/generators/morning_oracle.py

class MorningOracleGenerator:
    """晨谕生成器"""

    PROMPT_TEMPLATE = """
你是 VibeLife，正在为用户生成今日晨谕。

## 用户信息
- 名字: {user_name}
- 核心本质: {core_essence}
- 内在自我: {inner_self}

## 今日运势
{daily_fortune}

## 需要跟进的事项
{follow_ups}

## 即将发生的事件
{upcoming_events}

请生成今日晨谕，包含:

1. **能量主题** (2-3个字，如"突破"、"沉淀"、"连接")
2. **今日预测** (可能遇到的情况，具体且有洞察力)
3. **应对建议** (如果发生了该怎么做)
4. **跟进提醒** (如果有需要跟进的事项，自然地提及)

风格要求:
- 温暖但不腻，像一个了解你的朋友
- 具体而非泛泛，基于用户的特质
- 简洁有力，总字数不超过150字

输出 JSON 格式:
{{
    "energy_theme": "...",
    "prediction": "...",
    "advice": "...",
    "follow_up_reminder": "..." // 可选
}}
"""

    async def generate(self, user_id: str) -> dict:
        """生成晨谕"""

        # 获取用户上下文
        user = await self.user_repo.get(user_id)
        prism = await self.identity_service.get_prism(user_id)
        fortune = await self.fortune_service.get_daily(user_id)
        follow_ups = await self.memory_service.get_follow_ups(user_id)
        events = await self.event_service.get_upcoming(user_id, days=3)

        # 构建 prompt
        prompt = self.PROMPT_TEMPLATE.format(
            user_name=user.display_name or "朋友",
            core_essence=prism.get('core_essence', {}).get('summary', '尚未解锁'),
            inner_self=prism.get('inner_self', {}).get('summary', '尚未解锁'),
            daily_fortune=self._format_fortune(fortune),
            follow_ups=self._format_follow_ups(follow_ups),
            upcoming_events=self._format_events(events)
        )

        # 调用 LLM
        response = await self.llm.generate(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7
        )

        oracle = json.loads(response)
        oracle['generated_at'] = datetime.utcnow().isoformat()

        return oracle
```

### 3.2 午照生成

```python
# services/ritual/generators/midday_mirror.py

class MiddayMirrorGenerator:
    """午照生成器"""

    PROMPT_TEMPLATE = """
你是 VibeLife，正在为用户生成午间反思。

## 今日晨谕
能量主题: {morning_theme}
预测: {morning_prediction}

## 用户特质
{user_traits}

请生成午照内容:

1. **反思问题** (询问上午的情况，自然地引用晨谕)
2. **晨谕回顾** (简短提及早上的预测)

风格要求:
- 像朋友中午发来的关心消息
- 自然、轻松，不要太正式
- 总字数不超过50字

输出 JSON 格式:
{{
    "check_in_question": "...",
    "morning_reference": "..."
}}
"""

    async def generate(self, user_id: str) -> dict:
        """生成午照"""

        # 获取今日晨谕
        today_ritual = await self.ritual_repo.get_today(user_id)
        morning_oracle = today_ritual.get('morning_oracle', {})

        if not morning_oracle:
            # 如果没有晨谕，生成通用午照
            return await self._generate_generic_midday(user_id)

        # 获取用户特质
        prism = await self.identity_service.get_prism(user_id)

        prompt = self.PROMPT_TEMPLATE.format(
            morning_theme=morning_oracle.get('energy_theme', ''),
            morning_prediction=morning_oracle.get('prediction', ''),
            user_traits=prism.get('core_essence', {}).get('summary', '')
        )

        response = await self.llm.generate(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7
        )

        mirror = json.loads(response)
        mirror['generated_at'] = datetime.utcnow().isoformat()

        return mirror

    async def process_response(self, user_id: str, response: str) -> dict:
        """处理用户对午照的回复"""

        # 提取记忆
        memories = await self.memory_extractor.extract_from_text(
            user_id, response
        )

        # 生成 AI 跟进
        follow_up = await self._generate_follow_up(user_id, response)

        return {
            'ai_follow_up': follow_up,
            'extracted_memories': memories
        }
```

### 3.3 夜语生成

```python
# services/ritual/generators/night_whisper.py

class NightWhisperGenerator:
    """夜语生成器"""

    PROMPT_TEMPLATE = """
你是 VibeLife，正在为用户生成晚间夜语。

## 今日互动摘要
{today_summary}

## 今日晨谕回顾
能量主题: {morning_theme}
预测: {morning_prediction}

## 明日运势预览
{tomorrow_preview}

## 用户特质
{user_traits}

请生成夜语内容:

1. **今日总结** (温暖地回顾今天，如果有互动则提及)
2. **明日预览** (简短预告明天的能量)
3. **晚安寄语** (温暖的结束语，可以用用户的名字)

风格要求:
- 温暖、治愈，像睡前的轻声细语
- 让用户感到被关心和理解
- 总字数不超过100字

输出 JSON 格式:
{{
    "day_summary": "...",
    "tomorrow_preview": "...",
    "closing_message": "..."
}}
"""

    async def generate(self, user_id: str) -> dict:
        """生成夜语"""

        user = await self.user_repo.get(user_id)
        today_ritual = await self.ritual_repo.get_today(user_id)
        morning_oracle = today_ritual.get('morning_oracle', {})

        # 获取今日互动摘要
        today_summary = await self._get_today_summary(user_id)

        # 获取明日运势预览
        tomorrow_preview = await self.fortune_service.get_preview(user_id, days=1)

        # 获取用户特质
        prism = await self.identity_service.get_prism(user_id)

        prompt = self.PROMPT_TEMPLATE.format(
            today_summary=today_summary,
            morning_theme=morning_oracle.get('energy_theme', ''),
            morning_prediction=morning_oracle.get('prediction', ''),
            tomorrow_preview=tomorrow_preview,
            user_traits=prism.get('core_essence', {}).get('summary', '')
        )

        response = await self.llm.generate(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7
        )

        whisper = json.loads(response)
        whisper['generated_at'] = datetime.utcnow().isoformat()
        whisper['user_name'] = user.display_name

        return whisper
```

---

## 4. 推送服务

### 4.1 多渠道推送

```python
# services/push/service.py

class PushService:
    """多渠道推送服务"""

    def __init__(
        self,
        web_push: WebPushProvider,
        apns: APNSProvider,
        fcm: FCMProvider,
        wechat: WeChatProvider
    ):
        self.providers = {
            'web': web_push,
            'ios': apns,
            'android': fcm,
            'wechat': wechat
        }

    async def send(
        self,
        user_id: str,
        title: str,
        body: str,
        data: dict = None,
        channels: list = None
    ):
        """发送推送通知"""

        # 获取用户的推送订阅
        subscriptions = await self.subscription_repo.get_by_user(user_id)

        if not subscriptions:
            logger.info(f"No push subscriptions for user {user_id}")
            return

        # 过滤渠道
        if channels:
            subscriptions = [s for s in subscriptions if s.channel in channels]

        # 发送到各渠道
        for sub in subscriptions:
            provider = self.providers.get(sub.channel)
            if provider:
                try:
                    await provider.send(
                        subscription=sub,
                        title=title,
                        body=body,
                        data=data
                    )
                except Exception as e:
                    logger.error(f"Push failed for {sub.channel}: {e}")
                    # 标记失败的订阅
                    await self._handle_push_failure(sub, e)
```

### 4.2 Web Push Provider

```python
# services/push/providers/web_push.py

from pywebpush import webpush, WebPushException

class WebPushProvider:
    """Web Push 推送提供者"""

    def __init__(self, vapid_private_key: str, vapid_claims: dict):
        self.vapid_private_key = vapid_private_key
        self.vapid_claims = vapid_claims

    async def send(
        self,
        subscription: PushSubscription,
        title: str,
        body: str,
        data: dict = None
    ):
        """发送 Web Push"""

        payload = json.dumps({
            'title': title,
            'body': body,
            'data': data or {},
            'icon': '/icons/vibe-icon-192.png',
            'badge': '/icons/vibe-badge.png',
            'tag': data.get('type', 'notification'),
            'actions': self._get_actions(data)
        })

        try:
            webpush(
                subscription_info=subscription.subscription_info,
                data=payload,
                vapid_private_key=self.vapid_private_key,
                vapid_claims=self.vapid_claims
            )
        except WebPushException as e:
            if e.response.status_code == 410:
                # 订阅已失效
                raise SubscriptionExpiredError(subscription.id)
            raise

    def _get_actions(self, data: dict) -> list:
        """根据通知类型返回操作按钮"""

        notification_type = data.get('type', '')

        if notification_type == 'morning_oracle':
            return [
                {'action': 'view', 'title': '查看详情'},
                {'action': 'chat', 'title': '开始对话'}
            ]
        elif notification_type == 'midday_mirror':
            return [
                {'action': 'respond', 'title': '回复'}
            ]
        elif notification_type == 'event_reminder':
            return [
                {'action': 'view', 'title': '查看'},
                {'action': 'chat', 'title': '聊聊'}
            ]

        return []
```

### 4.3 微信推送 Provider

```python
# services/push/providers/wechat.py

class WeChatProvider:
    """微信模板消息推送"""

    TEMPLATE_IDS = {
        'morning_oracle': 'TEMPLATE_ID_MORNING',
        'midday_mirror': 'TEMPLATE_ID_MIDDAY',
        'night_whisper': 'TEMPLATE_ID_NIGHT',
        'event_reminder': 'TEMPLATE_ID_EVENT'
    }

    async def send(
        self,
        subscription: PushSubscription,
        title: str,
        body: str,
        data: dict = None
    ):
        """发送微信模板消息"""

        template_id = self.TEMPLATE_IDS.get(data.get('type'), 'TEMPLATE_ID_DEFAULT')

        message = {
            'touser': subscription.wechat_openid,
            'template_id': template_id,
            'url': f"{settings.WEB_URL}/ritual/{data.get('ritual_id', '')}",
            'data': {
                'first': {'value': title},
                'keyword1': {'value': body},
                'remark': {'value': '点击查看详情'}
            }
        }

        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token={await self._get_access_token()}",
                json=message
            )
            result = response.json()

            if result.get('errcode') != 0:
                raise WeChatPushError(result.get('errmsg'))
```

---

## 5. 推送订阅管理

### 5.1 数据模型

```sql
-- 推送订阅表
CREATE TABLE push_subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),

    -- 渠道信息
    channel VARCHAR(20) NOT NULL,  -- web, ios, android, wechat
    device_id VARCHAR(255),

    -- 订阅信息 (各渠道不同)
    subscription_info JSONB NOT NULL,
    -- web: {endpoint, keys: {p256dh, auth}}
    -- ios: {device_token}
    -- android: {fcm_token}
    -- wechat: {openid}

    -- 状态
    is_active BOOLEAN DEFAULT true,
    last_used_at TIMESTAMP,
    failure_count INTEGER DEFAULT 0,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),

    UNIQUE(user_id, channel, device_id)
);

CREATE INDEX idx_push_sub_user ON push_subscriptions(user_id);
CREATE INDEX idx_push_sub_active ON push_subscriptions(is_active) WHERE is_active = true;
```

### 5.2 订阅 API

```python
# routes/push.py

@router.post("/subscribe")
async def subscribe(
    request: SubscribeRequest,
    user: VibeUser = Depends(get_current_user)
):
    """订阅推送"""

    subscription = await push_service.subscribe(
        user_id=user.vibe_id,
        channel=request.channel,
        subscription_info=request.subscription_info,
        device_id=request.device_id
    )

    return {"subscription_id": subscription.id}

@router.post("/unsubscribe")
async def unsubscribe(
    request: UnsubscribeRequest,
    user: VibeUser = Depends(get_current_user)
):
    """取消订阅"""

    await push_service.unsubscribe(
        user_id=user.vibe_id,
        subscription_id=request.subscription_id
    )

    return {"status": "unsubscribed"}

@router.get("/subscriptions")
async def get_subscriptions(user: VibeUser = Depends(get_current_user)):
    """获取用户的推送订阅"""

    subscriptions = await push_service.get_subscriptions(user.vibe_id)
    return {"subscriptions": subscriptions}
```

---

## 6. 仪式 API

### 6.1 路由定义

```python
# routes/rituals.py

@router.get("/today")
async def get_today_rituals(user: VibeUser = Depends(get_current_user)):
    """获取今日仪式"""

    ritual = await ritual_service.get_today(user.vibe_id)
    return ritual

@router.post("/midday/respond")
async def respond_to_midday(
    request: MiddayResponseRequest,
    user: VibeUser = Depends(get_current_user)
):
    """回复午照"""

    result = await ritual_service.process_midday_response(
        user_id=user.vibe_id,
        response=request.response
    )

    return result

@router.put("/preferences")
async def update_preferences(
    request: RitualPreferencesRequest,
    user: VibeUser = Depends(get_current_user)
):
    """更新仪式偏好"""

    await ritual_service.update_preferences(
        user_id=user.vibe_id,
        preferences=request.dict()
    )

    return {"status": "updated"}

@router.get("/history")
async def get_ritual_history(
    days: int = 7,
    user: VibeUser = Depends(get_current_user)
):
    """获取仪式历史"""

    history = await ritual_service.get_history(user.vibe_id, days=days)
    return {"history": history}
```

---

## 7. 前端集成

### 7.1 Service Worker

```javascript
// public/sw.js

self.addEventListener('push', (event) => {
  const data = event.data.json()

  const options = {
    body: data.body,
    icon: data.icon || '/icons/vibe-icon-192.png',
    badge: data.badge || '/icons/vibe-badge.png',
    tag: data.tag,
    data: data.data,
    actions: data.actions || [],
    vibrate: [100, 50, 100],
    requireInteraction: data.tag === 'midday_mirror'
  }

  event.waitUntil(
    self.registration.showNotification(data.title, options)
  )
})

self.addEventListener('notificationclick', (event) => {
  event.notification.close()

  const data = event.notification.data
  let url = '/'

  if (event.action === 'respond' || event.action === 'chat') {
    url = '/chat'
  } else if (event.action === 'view') {
    url = `/ritual/${data.ritual_id || 'today'}`
  } else if (data.type === 'morning_oracle') {
    url = '/home'
  }

  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      for (const client of clientList) {
        if (client.url.includes(self.location.origin) && 'focus' in client) {
          client.navigate(url)
          return client.focus()
        }
      }
      return clients.openWindow(url)
    })
  )
})
```

### 7.2 推送订阅 Hook

```tsx
// hooks/usePushNotifications.ts

export function usePushNotifications() {
  const [permission, setPermission] = useState<NotificationPermission>('default')
  const [isSubscribed, setIsSubscribed] = useState(false)

  useEffect(() => {
    if ('Notification' in window) {
      setPermission(Notification.permission)
    }
    checkSubscription()
  }, [])

  const checkSubscription = async () => {
    if ('serviceWorker' in navigator) {
      const registration = await navigator.serviceWorker.ready
      const subscription = await registration.pushManager.getSubscription()
      setIsSubscribed(!!subscription)
    }
  }

  const subscribe = async () => {
    // 请求权限
    const permission = await Notification.requestPermission()
    setPermission(permission)

    if (permission !== 'granted') {
      throw new Error('Notification permission denied')
    }

    // 获取 Service Worker
    const registration = await navigator.serviceWorker.ready

    // 订阅推送
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(
        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!
      )
    })

    // 发送到服务器
    await api.post('/api/v1/push/subscribe', {
      channel: 'web',
      subscription_info: subscription.toJSON()
    })

    setIsSubscribed(true)
  }

  const unsubscribe = async () => {
    const registration = await navigator.serviceWorker.ready
    const subscription = await registration.pushManager.getSubscription()

    if (subscription) {
      await subscription.unsubscribe()
      await api.post('/api/v1/push/unsubscribe')
    }

    setIsSubscribed(false)
  }

  return {
    permission,
    isSubscribed,
    subscribe,
    unsubscribe,
    isSupported: 'Notification' in window && 'serviceWorker' in navigator
  }
}
```

---

## 8. 实施检查清单

- [ ] 创建 push_subscriptions 表
- [ ] 实现 RitualScheduler
- [ ] 实现 MorningOracleGenerator
- [ ] 实现 MiddayMirrorGenerator
- [ ] 实现 NightWhisperGenerator
- [ ] 实现 PushService
- [ ] 实现 WebPushProvider
- [ ] 实现 WeChatProvider (可选)
- [ ] 创建仪式 API 路由
- [ ] 创建推送 API 路由
- [ ] 配置 VAPID 密钥
- [ ] 实现 Service Worker
- [ ] 实现 usePushNotifications hook
- [ ] 测试完整仪式流程
- [ ] 配置生产环境调度

---

*下一步: [07-迁移与部署](./07-迁移与部署.md)*
