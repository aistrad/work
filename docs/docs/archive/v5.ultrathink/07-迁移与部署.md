# 迁移与部署方案

## 概述

本文档描述如何将现有系统平滑迁移到 v5 架构，确保零停机升级和数据完整性。

---

## 1. 迁移策略

### 1.1 总体原则

- **渐进式迁移**: 分阶段上线，每阶段可独立回滚
- **双写双读**: 新旧系统并行运行，逐步切换流量
- **数据兼容**: 新系统兼容旧数据格式
- **功能开关**: 使用 Feature Flag 控制新功能上线

### 1.2 迁移阶段

```
Phase 1: 数据层升级 (Week 1-2)
├── 创建新表
├── 添加新字段
└── 数据回填

Phase 2: 服务层升级 (Week 3-4)
├── 部署新服务
├── 双写模式
└── 流量切换

Phase 3: 前端升级 (Week 5-6)
├── 新页面上线
├── A/B 测试
└── 全量发布

Phase 4: 清理 (Week 7)
├── 移除旧代码
├── 数据清理
└── 文档更新
```

---

## 2. 数据库迁移

### 2.1 迁移脚本

```sql
-- migrations/v5/001_create_new_tables.sql

-- 1. 用户偏好表
CREATE TABLE IF NOT EXISTS user_preferences (
    user_id UUID PRIMARY KEY REFERENCES vibe_users(vibe_id),
    preferred_persona VARCHAR(50) DEFAULT 'warm_friend',
    morning_oracle_enabled BOOLEAN DEFAULT true,
    morning_oracle_time TIME DEFAULT '07:00',
    midday_mirror_enabled BOOLEAN DEFAULT true,
    midday_mirror_time TIME DEFAULT '12:30',
    night_whisper_enabled BOOLEAN DEFAULT true,
    night_whisper_time TIME DEFAULT '21:30',
    allow_memory_storage BOOLEAN DEFAULT true,
    allow_insight_extraction BOOLEAN DEFAULT true,
    timezone VARCHAR(50) DEFAULT 'Asia/Shanghai',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 2. Identity Prism 表
CREATE TABLE IF NOT EXISTS identity_prism (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),
    core_essence JSONB,
    inner_self JSONB,
    outer_expression JSONB,
    source_dimensions JSONB,
    version INTEGER DEFAULT 1,
    generated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, version)
);

-- 3. 维度档案表
CREATE TABLE IF NOT EXISTS dimension_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),
    dimension_type VARCHAR(20) NOT NULL,
    raw_data JSONB NOT NULL,
    interpretation JSONB,
    core_contribution JSONB,
    inner_contribution JSONB,
    outer_contribution JSONB,
    is_unlocked BOOLEAN DEFAULT false,
    unlocked_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, dimension_type)
);

-- 4. 用户记忆表
CREATE TABLE IF NOT EXISTS user_memories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),
    memory_type VARCHAR(30) NOT NULL,
    content TEXT NOT NULL,
    context JSONB,
    source_conversation_id UUID,
    source_message_id UUID,
    extraction_confidence FLOAT,
    event_time TIMESTAMP,
    is_future_event BOOLEAN DEFAULT false,
    follow_up_date DATE,
    is_active BOOLEAN DEFAULT true,
    importance_score FLOAT DEFAULT 0.5,
    embedding vector(1024),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 5. 生活事件表
CREATE TABLE IF NOT EXISTS life_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),
    event_type VARCHAR(30) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    event_date DATE NOT NULL,
    event_time TIME,
    is_all_day BOOLEAN DEFAULT true,
    pre_event_message TEXT,
    day_of_message TEXT,
    post_event_follow_up TEXT,
    status VARCHAR(20) DEFAULT 'upcoming',
    user_feedback TEXT,
    source VARCHAR(20) DEFAULT 'user_input',
    source_memory_id UUID REFERENCES user_memories(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 6. 每日仪式表
CREATE TABLE IF NOT EXISTS daily_rituals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),
    ritual_date DATE NOT NULL,
    morning_oracle JSONB,
    midday_mirror JSONB,
    night_whisper JSONB,
    daily_fortune JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, ritual_date)
);

-- 7. 用户权益表
CREATE TABLE IF NOT EXISTS user_entitlements (
    user_id UUID PRIMARY KEY REFERENCES vibe_users(vibe_id),
    current_tier VARCHAR(10) DEFAULT 'L0',
    subscription_id UUID,
    daily_conversations_used INTEGER DEFAULT 0,
    daily_conversations_reset_at DATE DEFAULT CURRENT_DATE,
    monthly_relationship_analyses_used INTEGER DEFAULT 0,
    monthly_reset_at DATE DEFAULT DATE_TRUNC('month', CURRENT_DATE),
    unlocked_dimensions TEXT[] DEFAULT ARRAY['bazi'],
    has_pdf_report BOOLEAN DEFAULT false,
    has_identity_prism BOOLEAN DEFAULT false,
    has_rituals BOOLEAN DEFAULT false,
    tier_expires_at TIMESTAMP,
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 8. 推送订阅表
CREATE TABLE IF NOT EXISTS push_subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES vibe_users(vibe_id),
    channel VARCHAR(20) NOT NULL,
    device_id VARCHAR(255),
    subscription_info JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true,
    last_used_at TIMESTAMP,
    failure_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, channel, device_id)
);
```

### 2.2 字段升级

```sql
-- migrations/v5/002_alter_existing_tables.sql

-- 升级 vibe_users 表
ALTER TABLE vibe_users ADD COLUMN IF NOT EXISTS journey_stage VARCHAR(20) DEFAULT 'encounter';
ALTER TABLE vibe_users ADD COLUMN IF NOT EXISTS journey_started_at TIMESTAMP;
ALTER TABLE vibe_users ADD COLUMN IF NOT EXISTS last_active_at TIMESTAMP;
ALTER TABLE vibe_users ADD COLUMN IF NOT EXISTS consecutive_active_days INTEGER DEFAULT 0;
ALTER TABLE vibe_users ADD COLUMN IF NOT EXISTS total_conversations INTEGER DEFAULT 0;

-- 升级 conversations 表
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS context_snapshot JSONB;
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS dimensions_used TEXT[] DEFAULT ARRAY[]::TEXT[];
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS emotional_arc JSONB;

-- 升级 messages 表
ALTER TABLE messages ADD COLUMN IF NOT EXISTS extracted_memories UUID[];
ALTER TABLE messages ADD COLUMN IF NOT EXISTS emotional_state JSONB;
ALTER TABLE messages ADD COLUMN IF NOT EXISTS dimensions_referenced TEXT[];

-- 升级 subscription_plans 表
ALTER TABLE subscription_plans ADD COLUMN IF NOT EXISTS tier VARCHAR(10);
```

### 2.3 数据回填

```python
# scripts/migrate/backfill_v5.py

import asyncio
from datetime import datetime, timedelta

async def backfill_journey_stages():
    """回填用户旅程阶段"""
    users = await db.fetch_all("SELECT * FROM vibe_users")

    for user in users:
        # 计算活跃天数
        active_days = await calculate_active_days(user['vibe_id'])

        # 检查付费记录
        has_paid = await check_payment_history(user['vibe_id'])

        # 推断阶段
        if active_days >= 60 and has_paid:
            stage = 'symbiosis'
        elif active_days >= 14 and has_paid:
            stage = 'dependence'
        elif active_days >= 3:
            stage = 'trust'
        elif active_days >= 1:
            stage = 'understanding'
        else:
            stage = 'first_sight'

        await db.execute(
            """UPDATE vibe_users
               SET journey_stage = $1,
                   journey_started_at = created_at,
                   last_active_at = $2
               WHERE vibe_id = $3""",
            stage, datetime.utcnow(), user['vibe_id']
        )

async def backfill_user_entitlements():
    """回填用户权益"""
    users = await db.fetch_all("SELECT * FROM vibe_users")

    for user in users:
        # 检查现有订阅
        subscription = await db.fetch_one(
            "SELECT * FROM subscriptions WHERE user_id = $1 AND status = 'active'",
            user['vibe_id']
        )

        if subscription:
            tier = 'L2' if subscription['plan_type'] == 'monthly' else 'L3'
        else:
            # 检查一次性购买
            payment = await db.fetch_one(
                "SELECT * FROM payments WHERE user_id = $1 AND status = 'completed'",
                user['vibe_id']
            )
            tier = 'L1' if payment else 'L0'

        await db.execute(
            """INSERT INTO user_entitlements (user_id, current_tier)
               VALUES ($1, $2)
               ON CONFLICT (user_id) DO UPDATE SET current_tier = $2""",
            user['vibe_id'], tier
        )

async def backfill_dimension_profiles():
    """回填维度档案"""
    profiles = await db.fetch_all("SELECT * FROM user_profiles")

    for profile in profiles:
        data = profile['profile_data']

        # 提取八字数据
        if 'bazi' in data:
            await db.execute(
                """INSERT INTO dimension_profiles
                   (user_id, dimension_type, raw_data, is_unlocked, unlocked_at)
                   VALUES ($1, 'bazi', $2, true, $3)
                   ON CONFLICT (user_id, dimension_type) DO NOTHING""",
                profile['user_id'], data['bazi'], profile['created_at']
            )

        # 提取星座数据
        if 'zodiac' in data:
            await db.execute(
                """INSERT INTO dimension_profiles
                   (user_id, dimension_type, raw_data, is_unlocked, unlocked_at)
                   VALUES ($1, 'zodiac', $2, true, $3)
                   ON CONFLICT (user_id, dimension_type) DO NOTHING""",
                profile['user_id'], data['zodiac'], profile['created_at']
            )

if __name__ == '__main__':
    asyncio.run(backfill_journey_stages())
    asyncio.run(backfill_user_entitlements())
    asyncio.run(backfill_dimension_profiles())
```

---

## 3. 服务部署

### 3.1 Docker 配置更新

```yaml
# docker-compose.v5.yml

version: '3.8'

services:
  api:
    build:
      context: ./apps/api
      dockerfile: Dockerfile
    environment:
      - VIBELIFE_DB_URL=${VIBELIFE_DB_URL}
      - FEATURE_V5_RITUALS=${FEATURE_V5_RITUALS:-false}
      - FEATURE_V5_MEMORY=${FEATURE_V5_MEMORY:-false}
      - FEATURE_V5_PRISM=${FEATURE_V5_PRISM:-false}
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis

  ritual-scheduler:
    build:
      context: ./apps/api
      dockerfile: Dockerfile.worker
    command: python -m workers.ritual_scheduler
    environment:
      - VIBELIFE_DB_URL=${VIBELIFE_DB_URL}
      - REDIS_URL=${REDIS_URL}
    depends_on:
      - db
      - redis

  memory-consolidator:
    build:
      context: ./apps/api
      dockerfile: Dockerfile.worker
    command: python -m workers.memory_consolidator
    environment:
      - VIBELIFE_DB_URL=${VIBELIFE_DB_URL}
    depends_on:
      - db

  web:
    build:
      context: ./apps/web
      dockerfile: Dockerfile
    environment:
      - NEXT_PUBLIC_API_BASE=${NEXT_PUBLIC_API_BASE}
      - NEXT_PUBLIC_FEATURE_V5=${NEXT_PUBLIC_FEATURE_V5:-false}
    ports:
      - "3000:3000"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  redis_data:
```

### 3.2 Kubernetes 配置

```yaml
# k8s/v5/ritual-scheduler.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: ritual-scheduler
  namespace: vibelife
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ritual-scheduler
  template:
    metadata:
      labels:
        app: ritual-scheduler
    spec:
      containers:
      - name: ritual-scheduler
        image: vibelife/api:v5
        command: ["python", "-m", "workers.ritual_scheduler"]
        envFrom:
        - configMapRef:
            name: vibelife-config
        - secretRef:
            name: vibelife-secrets
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
```

---

## 4. Feature Flags

### 4.1 配置

```python
# config/feature_flags.py

from enum import Enum
import os

class FeatureFlag(Enum):
    V5_RITUALS = "v5_rituals"
    V5_MEMORY = "v5_memory"
    V5_PRISM = "v5_prism"
    V5_JOURNEY = "v5_journey"
    V5_SUBSCRIPTION = "v5_subscription"

class FeatureFlagService:
    """Feature Flag 服务"""

    def __init__(self):
        self._flags = {
            FeatureFlag.V5_RITUALS: os.getenv('FEATURE_V5_RITUALS', 'false') == 'true',
            FeatureFlag.V5_MEMORY: os.getenv('FEATURE_V5_MEMORY', 'false') == 'true',
            FeatureFlag.V5_PRISM: os.getenv('FEATURE_V5_PRISM', 'false') == 'true',
            FeatureFlag.V5_JOURNEY: os.getenv('FEATURE_V5_JOURNEY', 'false') == 'true',
            FeatureFlag.V5_SUBSCRIPTION: os.getenv('FEATURE_V5_SUBSCRIPTION', 'false') == 'true',
        }

    def is_enabled(self, flag: FeatureFlag, user_id: str = None) -> bool:
        """检查功能是否启用"""
        # 全局开关
        if not self._flags.get(flag, False):
            return False

        # 用户级别开关 (可选)
        if user_id:
            return self._check_user_flag(flag, user_id)

        return True

    def _check_user_flag(self, flag: FeatureFlag, user_id: str) -> bool:
        """检查用户级别的功能开关"""
        # 可以基于用户 ID 的哈希值进行灰度发布
        # 例如: 只对 10% 的用户开启
        return True

feature_flags = FeatureFlagService()
```

### 4.2 使用示例

```python
# routes/chat.py

@router.post("/chat")
async def chat(request: ChatRequest, user: VibeUser = Depends(get_current_user)):
    # 检查是否启用 v5 记忆功能
    if feature_flags.is_enabled(FeatureFlag.V5_MEMORY, user.vibe_id):
        # 使用新的记忆系统
        context = await context_orchestrator.build_context(user.vibe_id, request.message)
    else:
        # 使用旧的上下文构建
        context = await legacy_context_builder.build(user.vibe_id)

    # ... 其余逻辑
```

---

## 5. 灰度发布

### 5.1 发布策略

```
阶段 1: 内部测试 (1%)
├── 团队成员
└── 测试账号

阶段 2: 早期用户 (5%)
├── 活跃用户
└── 付费用户

阶段 3: 扩大范围 (20%)
├── 新注册用户
└── 部分老用户

阶段 4: 全量发布 (100%)
└── 所有用户
```

### 5.2 灰度控制

```python
# services/rollout.py

class RolloutService:
    """灰度发布服务"""

    async def get_rollout_percentage(self, feature: str) -> int:
        """获取功能的灰度百分比"""
        return await self.redis.get(f"rollout:{feature}") or 0

    async def set_rollout_percentage(self, feature: str, percentage: int):
        """设置功能的灰度百分比"""
        await self.redis.set(f"rollout:{feature}", percentage)

    def is_user_in_rollout(self, user_id: str, percentage: int) -> bool:
        """检查用户是否在灰度范围内"""
        # 基于用户 ID 的哈希值确定
        hash_value = int(hashlib.md5(user_id.encode()).hexdigest(), 16)
        return (hash_value % 100) < percentage
```

---

## 6. 监控与告警

### 6.1 关键指标

```python
# monitoring/metrics.py

from prometheus_client import Counter, Histogram, Gauge

# 仪式相关指标
ritual_generated = Counter(
    'vibelife_ritual_generated_total',
    'Total rituals generated',
    ['ritual_type']
)

ritual_sent = Counter(
    'vibelife_ritual_sent_total',
    'Total rituals sent',
    ['ritual_type', 'channel']
)

ritual_generation_duration = Histogram(
    'vibelife_ritual_generation_seconds',
    'Ritual generation duration',
    ['ritual_type']
)

# 记忆相关指标
memory_extracted = Counter(
    'vibelife_memory_extracted_total',
    'Total memories extracted'
)

memory_retrieval_duration = Histogram(
    'vibelife_memory_retrieval_seconds',
    'Memory retrieval duration'
)

# 用户旅程指标
journey_stage_transitions = Counter(
    'vibelife_journey_transition_total',
    'Journey stage transitions',
    ['from_stage', 'to_stage']
)

active_users_by_stage = Gauge(
    'vibelife_active_users_by_stage',
    'Active users by journey stage',
    ['stage']
)
```

### 6.2 告警规则

```yaml
# monitoring/alerts.yaml

groups:
- name: vibelife-v5
  rules:
  - alert: RitualGenerationFailure
    expr: rate(vibelife_ritual_generated_total{status="error"}[5m]) > 0.1
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Ritual generation failure rate high"

  - alert: MemoryExtractionSlow
    expr: histogram_quantile(0.95, vibelife_memory_retrieval_seconds) > 2
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "Memory retrieval is slow"

  - alert: PushDeliveryFailure
    expr: rate(vibelife_ritual_sent_total{status="failed"}[5m]) > 0.2
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "Push notification delivery failure rate high"
```

---

## 7. 回滚方案

### 7.1 快速回滚

```bash
#!/bin/bash
# scripts/rollback_v5.sh

echo "Rolling back to v4..."

# 1. 关闭 v5 功能开关
kubectl set env deployment/api \
  FEATURE_V5_RITUALS=false \
  FEATURE_V5_MEMORY=false \
  FEATURE_V5_PRISM=false

# 2. 停止 v5 workers
kubectl scale deployment/ritual-scheduler --replicas=0
kubectl scale deployment/memory-consolidator --replicas=0

# 3. 回滚前端
kubectl rollout undo deployment/web

echo "Rollback complete"
```

### 7.2 数据回滚

```sql
-- 如果需要回滚数据变更
-- 注意: 新表数据不会丢失，只是不再使用

-- 恢复 vibe_users 表
ALTER TABLE vibe_users DROP COLUMN IF EXISTS journey_stage;
ALTER TABLE vibe_users DROP COLUMN IF EXISTS journey_started_at;
-- ... 其他字段

-- 注意: 不要删除新表，保留数据以便后续重新启用
```

---

## 8. 实施检查清单

### Phase 1: 数据层
- [ ] 备份现有数据库
- [ ] 执行 001_create_new_tables.sql
- [ ] 执行 002_alter_existing_tables.sql
- [ ] 运行 backfill_v5.py
- [ ] 验证数据完整性

### Phase 2: 服务层
- [ ] 部署新服务代码
- [ ] 启动 ritual-scheduler
- [ ] 启动 memory-consolidator
- [ ] 配置 Feature Flags
- [ ] 内部测试验证

### Phase 3: 前端
- [ ] 部署新前端代码
- [ ] 配置前端 Feature Flags
- [ ] A/B 测试配置
- [ ] 灰度发布 (1% → 5% → 20% → 100%)

### Phase 4: 清理
- [ ] 移除旧代码
- [ ] 清理无用数据
- [ ] 更新文档
- [ ] 关闭 Feature Flags (全量启用)

---

## 9. 成功标准

| 指标 | 目标 |
|------|------|
| 迁移成功率 | 100% |
| 数据完整性 | 100% |
| 服务可用性 | 99.9% |
| 错误率 | < 0.1% |
| 用户投诉 | < 10 |

---

*文档版本: v5.ultrathink*
*创建日期: 2026-01-10*
