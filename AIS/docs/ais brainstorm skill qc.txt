系统总体架构设计

在综合上述理念后，我们设计了本系统的总体架构。整个系统分为数据层、AI分析层和用户应用层三大部分，各部分通过Claude Skills引擎贯通协同。

图：系统架构示意图 - 数据来源、Claude Skills引擎与用户界面层次结构。左下方为数据源，包括外部市场数据/新闻和内部研究资料；中间为Claude Skills AI引擎，划分宏观、行业、基本面、量化等技能模块（虚线框表示）；上方为用户界面与协作层，不同角色通过统一界面与AI交互。

如上图所示：

数据层（底部）：汇集外部数据与内部知识两大来源。一方面，系统接入权威的外部数据源，包括市场行情、财务数据库、经济指标、新闻资讯、研究报告等；另一方面，整合公司内部积累的研究资料和数据，如自有行业研究报告、财务模型、投资笔记、资讯订阅等。数据层通过一个数据中台/知识库实现结构化存储和语义索引，方便上层AI检索利用。这类似AlphaSense的做法，将内容统一接入并打上标签，支持跨内容类型的查询
alpha-sense.com
。

AI分析层（中部）：由Claude Skills引擎构成，是系统的核心智能单元。Claude大模型作为底座，加载一系列定制的Skills模块，每个模块对应特定分析任务域（宏观、行业、公司基本面、量化等）。这些技能模块可以看作多个专职AI分析助理，在Claude平台内并行存在。它们既能独立完成各自任务，又能通过Claude共享的上下文和规划机制协同工作，实现复杂任务的分解与配合
kavout.com
。Skills引擎具备以下机制：

指令路由与自动激活：当用户在界面提出请求时，Claude首先解析意图，然后将任务分配给最相关的技能模块处理（或同时激活多个模块协作）。例如，输入一个自然语言问题涉及某公司财务数据和行业前景，则“基本面分析”技能和“行业分析”技能都会被触发，各自返回结果后由Claude整合。

技能内部工作流：每个Skill模块都有一套内部定义的提示模板和多步流程。例如，“估值建模”技能会先获取财务预测数据，再按照DCF模型公式计算结果，最后由大模型生成对估值结果的解释。这类似Superpowers中每个Skill封装一套workflow
github.com
github.com
。

工具与数据接口：Skills引擎可以调用特定工具或API获取信息，如访问数据库、运行计算脚本、生成图表等。比如“量化回测”技能或许会调用Python或R模型运行回测计算，再将结果总结给Claude进行报告编写。通过工具整合，AI可以读写数据甚至执行代码，从而增强分析的准确性与深度
visualping.io
。

上下文记忆与知识共享：Claude大模型允许在对话中持续积累上下文，因而各个技能产出的信息可以汇总在共享的上下文中，供其它技能引用。这确保了多技能协同的一致性：如宏观分析得出的结论可被公司分析技能引用到估值中。这样的多Agent协作思想正是Kavout模式的核心
kavout.com
。

用户应用层（顶层）：为研究团队提供统一的交互界面与协作工具。我们设计一个AI助理界面，结合聊天问答与仪表板功能。研究员可以像与助手对话一样提出研究问题、下达分析指令，也可以在界面上查看数据图表、模型结果和报告草稿。界面支持角色定制：宏观分析师可以看到宏观经济仪表盘和相关技能推荐，行业分析师界面上则突出行业新闻和比较工具等。这一层还包括报告协作与知识管理功能，例如多人可以共享AI生成的研究笔记，对其进行修改标注，并将最终报告存档到内部知识库中。此外，应用层也提供通知和自动提醒：当AI监测到某关注领域出现重大变化（如监控的宏观指标异动或某持仓公司突发新闻），会主动提醒相关分析师处理，类似Bloomberg Terminal中Alerts和AlphaSense智能监测的结合
visualping.io
visualping.io
。

整个架构以Claude Skills引擎为智能核心，实现了数据-AI-人的闭环：数据层提供原料，AI分析层加工提炼，用户层消化协作并指导AI进一步工作。在安全方面，内部部署Claude模型或通过安全隔离的API调用，保证敏感研究数据不泄露；同时对模型输出进行监控，避免不当内容。这套架构确保AI始终作为助手嵌入业务流，而不是一个黑箱工具：研究人员可以随时追溯AI引用的数据和推理依据，以确保合规和可信赖。

研究角色模块及Skills体系

基于上述架构，我们按照典型研究角色划分了系统模块，并为每个模块设计了细化的Skills（技能）集合。每个角色模块对应团队中的一种专业分工，包含若干技能来支持其日常工作。这些Skills既可以被对应角色直接调用，也能在跨领域任务中协同工作。

宏观研究模块

模块定位：服务于宏观策略师、经济学家等角色，关注宏观经济环境和跨资产趋势，对应顶层资产配置和市场研判任务。

核心Skills设计：

宏观数据分析 Skill：连接宏观经济数据库与市场行情数据，对关键宏观指标进行分析。研究员可以询问例如“美国最近的通胀趋势如何？”系统将自动提取通胀率、利率、GDP增长等数据并生成图表，给出趋势解读。【例如，Bloomberg终端允许用自然语言查询经济数据并立即获得结果【14†L347-L355】。】该Skill还能根据要求做国际比较或历史回溯，迅速产出宏观分析报告的素材。

政策动向解读 Skill：针对宏观政策、央行动态、地缘政治事件等提供智能摘要与解读。它利用NLP从新闻和专家报告中提炼政策要点和市场影响分析，并做情绪判断
bloomberg.com
bloomberg.com
。例如美联储会议纪要发布后，技能会总结主要内容、市场反应，并标注分析师观点（如哪些分析师认为偏鹰派）。Bloomberg的新闻AI摘要和主题聚类功能类似地帮助用户快速抓取政策相关资讯
bloomberg.com
bloomberg.com
。

宏观假设检验 Skill：协助宏观研究员验证投资假设或进行情景分析。例如假设“若未来一年联储加息次数超预期，会对股市产生何种影响？”，技能可以调用历史数据进行回归或情景模拟，输出分析结果和信心水平。该Skill也与量化模块联动，如用计量经济模型测试宏观因子与资产回报的关系，再用自然语言解释结果。对于宏观策略常见的“因果推断”问题，此技能可极大降低分析门槛。

IB 接口调用效率与兼容性差异

QuantConnect Lean 本地引擎： Lean 引擎对接 IB (Interactive Brokers) 接口采用的是官方 API 封装，经过 QuantConnect 团队长期优化，具有较高的性能与可靠性。Lean 在与 IB 通信时由 C# 实现底层连接（Lean 的 BrokerConnector 模块），其多线程异步架构能够有效处理 IB 的消息流和订单反馈。由于 IB 提供了专门的 C# API，Lean 引擎可以直接利用这一高性能接口，相比纯 Python 调用具有速度优势。Lean 支持 IB 实盘交易时，可以订阅实时行情、下单、查询账户等全部功能，并兼容 IB 提供的各种订单类型（限价、市价、止损等）和有效时长等属性。QuantConnect 官方列出了 IB 接口的完整支持清单，包括支持股票、期货、期权、外汇等多类别资产的交易与数据订阅
lean.io
lean.io
。Lean 对 IB 最新版本API 保持兼容：由于QuantConnect 有众多付费用户使用 IB券商，官方会及时更新 Lean 中的 IB 接口适配。如果 IB 更改了接口版本或新增功能，Lean 的维护团队通常很快发布更新以确保兼容。这意味着使用 Lean 本地引擎的用户可较少担心 IB 升级带来的中断。在调用效率方面，Lean 由于核心由 C#/Mono 编译执行，处理IB的消息（如逐笔行情推送、订单回报）具有接近本地编译语言的性能。对于需要同时跟踪大量合约或高频下单的策略，Lean 的 IB接口能够更稳健地支撑。比如 IB 有每秒行情消息处理上限，Lean 可以在靠近极限的负载下仍保持较低的消息延迟和稳定性，而 Python 由于单线程解释可能更容易出现消息堆积。另外，Lean 在IB实盘时内置了断线重连和同步机制。IB网关每日会有例行断线维护，Lean 提供 Reconciliation 流程用于重新连接后同步账户状态


。Lean 还具备根据 IB 场景定制的 BrokerModel，可以模拟 IB 特有的行为和规则（例如不同市场的下单细节），并在回测时就考虑这些因素
lean.io
。兼容性上，Lean 甚至支持 IB 的 Financial Advisor 扩展——例如在单账户控制多个子账户下单

。Lean CLI 本地部署连接 IB 也相当方便：只需在 Lean 的 config.json 中填入 IB 网关的地址、端口、帐号等配置，即可使用 lean live 命令启动与 IB 对接的算法


。QuantConnect 提供了详细步骤指导用户本地对接 IB（包括登录 IB Gateway、配置 2FA 等）


。需要注意的是，如果没有购买 QuantConnect 平台订阅，Lean 本地使用 IB 实盘时不能使用QuantConnect的云数据下载功能，但可以改为直接通过 IB 获取实时和历史数据


。总的来说，Lean 对 IB 接口的支持可以用成熟、快速、兼容广泛来概括。其高效的事件驱动架构确保 IB 的行情和交易指令处理低延迟且高吞吐，官方维护保证与 IB 同步升级，对各种 IB 账户类型和特殊功能都有相应支持。

Claude Skills 框架下多策略模块调度的适配性

QuantConnect Lean 本地引擎： 在 Lean 系统中，策略的各模块（数据、信号、风控、下单）基本都在 Lean 引擎内部以同步流程执行，外部系统对其细粒度控制的可能性有限。Lean 主要通过编写算法代码来配置模块调用顺序和逻辑，一旦算法启动，整个调度由 Lean 内部驱动（事件驱动机制）完成。如果将 Anthropic Claude 的“Skills”架构比作一个外部智能调度者，那么对于 Lean，它更多只能在启动前或停止时进行交互配置，而无法深入介入算法运行过程的每一步。Claude Skills 框架下，AI Agent 可以具备不同的子技能模块，各司其职地处理任务。如果想把 Lean 集成进去，Claude 可能需要将Lean 算法视为一个独立技能，通过调用 Lean CLI 或 API 来启动/停止策略、调整参数等宏观操作。例如，Claude Code 生成 Lean 算法配置文件（如 config.json 以及算法源代码）后，可以调用 Lean CLI 命令执行实盘交易。这相当于 Claude 负责策略生成和过程编排，Lean 负责具体交易执行。然而，这种集成粒度较粗：Claude 无法在 Lean 算法运行中每次信号生成时插手调度，因为 Lean 算法不会对外暴露逐笔信号或订单事件的API接口。Lean 虽提供了一些Live Controls（如暂停、继续算法，或发送自定义命令）


，但这些命令的功能有限，通常也只是触发预定义行为，无法让外部AI直接改变算法内部决策流程。Claude Skills 倡导的是 AI 主导工作流，各子技能完成特定子任务。然而 Lean 的设计是假定算法内部自己完成整个决策链（从数据到下单）。因此在 Claude 框架中使用 Lean，会出现调度嵌套的情况：Claude 可以调度多个 Lean 策略实例（把不同策略作为不同技能单元），但对每个实例内部的模块（风控、交易等）无法细致安排。进一步来说，如果用户通过 Claude Skills 管理数十个策略组合，Lean 层面可能需要启动数十个算法进程。Claude 可以通过并行调用 Lean CLI 来实现“多算法并发”，但要注意协调每个 Lean 实例的资源和账户使用。例如 Claude 需要确保不同 Lean 实例的 IB 客户端ID或账户设置正确，避免互相抢占连接

。这种场景下，Claude Skills 更多扮演上层编排者：决定什么时候启动哪个策略算法、何时停止、以及读取 Lean 输出的报告（盈亏、风险指标）来做决策。Lean 本身不为这种 AI 调度做特别优化，因此Claude和Lean的交互主要通过文件和进程层面：Claude Code 生成策略代码->调用Lean运行->监控日志或结果->再通过Lean命令调整。这种集成方式相对间接和粗粒度，但可行。Claude Skills 也许可以利用 Lean 算法的日志输出或 结果文件，作为反馈环来分析策略表现，从而决定下一步行动。然而 Lean 并不会主动以结构化数据形式输出内部状态给外部AI（除了在云平台上QuantConnect提供的结果API，在本地CLI模式下需要自行解析日志/回测结果文件）。因此，Claude 若要获取实时的 Lean 组合状态，可能需要通过 Lean 提供的 Live Algorithm接口定期查询（如果有）或者解析 IB 帐户信息。而Lean对外通信并非为AI设计，不像一些交互式平台可以通过socket或API实时交互。

另一方面，如果在 Lean 内部实现多策略Alpha合并，由 Lean 内部负责调度各模块，则Claude Skills 更难深入其中改变调度顺序。例如 Lean 固定地先运行Alpha模型产生信号，再由Portfolio Construction汇总，再风控调整、最后执行。Claude 如果想改变某一步（比如在风控后再插入一个AI决策步骤）是无法实现的，除非修改Lean源码或算法代码流程。总的来说，在Claude Skills框架中，Lean 能作为一个封装良好的交易执行技能使用，但不太适合作为细粒度的子技能参与复杂对话流程。Claude Skills 的优势在于可将任务拆解给多个代理并行处理，但 Lean 算法本身就是单个整体代理，占用了整个任务流程。

系统部署、运行维护成本与代码集成复杂度

QuantConnect Lean 本地引擎： 部署 Lean 本地引擎涉及安装其运行环境（.NET Core或Mono）以及 Lean CLI 工具。QuantConnect 官方提供了预配置的 Docker 镜像和 CLI，用户可按文档快速搭建本地环境
lean.io
lean.io
。部署成本对于有经验的开发者来说并不高——在 Windows、Linux 或 macOS 上安装 .NET 和 Lean，配置好 config.json 即可运行。然而，需要注意 Lean 的本地引擎体积较大（包含完整的 Lean Engine 框架和众多依赖包），相对于一个轻量的 Python 脚本而言，它占用的磁盘和内存资源更多。运行成本方面，如果用户计划同时运行数十个策略，每个策略一个 Lean 实例，那么会有数十个独立进程，每个进程加载 Lean 引擎。这对 CPU 和内存是较大的开销。Lean 虽然支持在单一进程里运行单算法的多线程操作，但不支持一个进程内跑多个独立算法，因此无法通过线程复用来减少资源占用


。每个 Lean 进程启动时需要加载全部框架（包括事件循环、调度、历史数据订阅等），如果策略数量很多，系统资源占用线性增加。另外，在操作系统级别管理众多 Lean 实例也稍显复杂，可能需要编写脚本或使用 orchestrator 来启动/停止这些进程并监控其状态。Lean CLI 提供了一些方便的功能（如 lean cloud 相关指令在QuantConnect云上部署），但在本地多实例情况下主要还是靠用户脚本。维护成本方面，Lean 作为一个活跃的开源项目，官方会定期更新版本
lean.io
lean.io
。这些更新包括新特性、性能改进和bug修复。用户需要跟进这些更新以保持系统可靠。例如 IB API 升级或数据格式调整时，新版 Lean 会相应修改。如果长期不升级，可能出现兼容性问题或错过重要修补。因此维护 Lean 引擎意味着定期关注官方仓库，执行升级测试。升级过程需要谨慎：Lean 引擎非常庞大，定制过的用户需合并自己的修改，这可能很麻烦。如果用户完全不修改 Lean 源码，只使用其API，则升级较容易，只需替换引擎版本并跑回测验证策略行为是否一致。但若用户对 Lean 引擎做了本地修改（比如增加自定义的数据源支持、调整撮合逻辑等），将来每次Pull官方更新都要手动合并冲突和重新测试。Lean 代码主要是 C#，这对主要使用 Python 的量化开发者来说在调试和修改上增加了门槛。假如 Lean 内部出现bug或需要新功能，用户可能需要懂 C# 来解决，或者在社区提出等待官方修复。

在代码集成复杂度方面，Lean 封装了几乎所有交易系统功能，用户只需在其框架规定的接口内编写策略逻辑，即可与各种模块对接。这降低了开发复杂度，但也意味着代码必须符合 Lean 框架的结构。对于简单策略，这种约束不是问题，但对于一些非典型需求，Lean 的框架可能显得束缚。例如 Lean 有固定的回测结果统计方式，如果用户想添加特殊的自定义统计，可能需要深入修改 Lean 统计模块或在算法中自行记录。另外，Lean 为安全考虑，对算法使用的第三方库有所限制（在QuantConnect云端须审核库清单

；本地使用则可任意安装库，但需确保与 Lean 的Python环境兼容）。所以在 Lean 环境下集成一些Python库可能遇到冲突，需要调试环境。例如安装 PyPortfolioOpt 在 Lean Python 算法中使用，就要确保 Lean 的 CLI 环境安装了该库并且没有版本冲突。Lean CLI 提供 **“包环境”**管理，可添加 pip 包


，但若出现比如C库依赖问题，则需要用户自己解决。

数据部署与维护也是 Lean 本地运行要考虑的成本。Lean 在回测时需要数据源支持。QuantConnect 提供了统一格式的数据，如果本地有订阅可以下载使用，否则用户需要自己准备历史数据并转换成 Lean 识别格式（如 Lean 的 zip 压缩格式按日期/资产存放）。这对多策略支持多市场来说是一项庞大工作：需要维持一个数据仓库并定期更新。如果使用自建数据，与 Lean 集成会涉及实现 IDataProvider 接口或者配置数据路径。相反，在自建 Backtrader 系统中，通常可以直接读取 CSV 或 Pandas DataFrame，无需复杂的预处理。因此 Lean 为了高性能和一致性牺牲了一定易用性，需要一定运维投入来管理数据。

故障维护方面，Lean 引擎具有日志和错误输出，但当出现崩溃或死循环等问题时，调试难度可能较大。特别是如果因为策略Bug导致整个 Lean 进程挂掉，除了解析日志，很难从外部介入检查。而自建Python系统可以在IDE下逐步调试，或加入丰富的日志。Lean 虽然也能本地调试（可在本地IDE中附加调试器调试C#或Python算法），但涉及跨语言，调试体验相对复杂。

跨资产关联分析 Skill：宏观研究常需要关注股票、债券、汇率、大宗商品的联动。本技能可在后台获取多种资产数据，用AI找出关联模式。例如当油价大幅波动时，它会提示对通胀及相关行业股的影响；或当某国货币贬值时，分析出口型行业股票表现。这类似于让AI做一个24/7的跨市场观察者，主动关联宏观与资产线索
kavout.com
kavout.com
。

模块特点：宏观模块的技能注重广泛的数据获取和趋势总结。输出通常以图表、要点摘要形式呈现，并附带数据来源（例如引用官方统计或相关新闻出处）。这些技能减轻了宏观研究员搜集数据、阅读长篇报告的负担，使其更专注于策略思考。

行业研究模块

模块定位：服务于行业分析师或研究员，聚焦特定行业或主题的深入分析，包括行业趋势、竞争格局和公司比较等。

核心Skills设计：

行业趋势监测 Skill：实时监控指定行业的新闻、报告和数据，提炼出趋势洞见。该技能每日/每周自动扫瞄行业相关新闻和卖方研报，通过NLP分类主题（例如需求、监管、技术创新）并进行情感分析
bloomberg.com
visualping.io
。然后生成一份行业动态简报，包含本期主要主题及相关公司的动态摘要。用户也可查询特定主题，例如“过去半年电动车行业的主要趋势”，技能将从新闻和报告中总结要点并提供引用来源
alpha-sense.com
。

竞争格局分析 Skill：针对某行业内的主要竞争者，汇总其业务动态、市场份额和优劣势比较。技能会收集各公司最近的财报要点、产品发布、管理层发言等信息，形成对比表格或SWOT要点
visualping.io
visualping.io
。例如，在半导体行业分析中，它能列出主要厂商最新营收增长、毛利率、研发投入，并用AI高亮各自的竞争优势（如技术领先）和风险（如供应链问题）。这类似AlphaSense的Generative Grid功能，将多家公司信息按预设维度汇总对比
alpha-sense.com
alpha-sense.com
。

财报解读 Skill：很多行业分析师需要解读公司财报、电话会议以判断行业景气度。本技能可批量读取行业内多家公司的财报电话会记录，用生成式AI提炼共同关心的话题和管理层观点。例如检测“原材料成本”“需求前景”等关键词出现频率和语境情绪，从而判断整个行业的景气变化。AlphaSense提供的“earnings smart summaries”正是类似思路，通过AI迅速概括同行公司电话会的关键信息
alpha-sense.com
。有了该技能，分析师可以快速形成对行业当前痛点和亮点的判断。

行业预测与估值 Skill：基于行业宏观和公司数据，帮助分析师建立行业模型和估值参考。它可整合宏观模块给出的经济预测和公司模块的财务预测，生成行业总体的增长预期、平均估值水平等。例如，在分析半导体行业时，技能会结合全球手机出货预测（宏观数据）和主要芯片公司营收预测，估算行业未来规模，并提供当前行业平均PE、PB等估值比较。同时，该技能还能跟踪行业ETF或指数表现，作为行业多空情绪的参考。

模块特点：行业模块强调主题归纳和比较分析。AI善于从繁杂的信息中找出模式，这正好契合行业分析师需要提炼共性与发现差异的需求。通过这些技能，行业研判可由传统的逐篇阅读研报转变为AI聚合洞察：分析师可以更快获得全景式的行业快照和竞争情报，从而投入更多时间验证核心假设、与公司管理层交流等高价值活动。

公司基本面分析模块

模块定位：面向基本面分析师或公司研究员，深入一家公司的财务、经营、估值分析，是传统“卖方/买方分析师”工作的AI辅助。

核心Skills设计：

财务报表解析 Skill：自动读取和解析公司财报（年报、季报）中的关键数据和指标趋势。分析师上传或指定公司财报文件后，技能利用OCR和自然语言处理提取财务表格数据（营收、利润、资产负债等），并计算同比环比增速、利润率等指标变化。一些工具（如Sentieo的Table Explorer）已展示出这种表格数据智能提取的能力
visualping.io
。提取后，AI会用自然语言生成财务简报，如“本季度营收X亿元，同比+Y%，主要因某业务增长；毛利率Z%，较去年提升N个百分点，得益于…”，并引用报告中的具体数字来源
visualping.io
。这样分析师可迅速掌握财报要点而无需手动翻阅计算。

研报与公告阅读 Skill：通过AI快速阅读长篇的公告、研报或电话会议记录并抓取关键信息。分析师可让技能针对特定问题在文档中寻找答案。例如“管理层对下一季度指引是什么？”“风险因素里提到了哪些新风险？”技能将定位相关段落并总结答案，同时附上原文引用以便核查
alpha-sense.com
。FactSet的Transcript Assistant类似地支持对电话会记录的交互式问答
institutionalinvestor.com
institutionalinvestor.com
。我们的技能可扩展到任何长文档：无论监管公告、投资者日演示还是券商研报，都能快速对问答。这极大提升了处理信息的效率。

估值建模 Skill：辅助分析师进行公司估值建模和假设测试。分析师可以与AI一同构建财务模型，例如指定营收增长假设、利润率假设，技能会生成未来财务预测表并计算估值（如DCF模型得出内在价值，或相对估值的PE/PB比较）。AI可以调用现有数据和宏观假设填充参数，或者根据历史数据提出合理区间供分析师参考（如提示过去5年公司营收CAGR、行业平均增长）。计算完成后，技能生成估值结论的文字说明，包括关键驱动因素、敏感性分析（若假设变动对估值的影响）等。这类似GPT-5被用于搭建财务模型、给出多情景分析的应用
visualping.io
visualping.io
。重要的是，模型计算透明可检验，分析师可以下载模型或查看公式，确保对结果有信心。

投资假设验证 Skill：帮助分析师验证其对公司的投资逻辑。例如分析师假设“新产品线推出将使公司明年毛利率提升5个百分点”，技能可以从多方面搜集证据：查找历史上该公司或同行推出类似产品后的毛利率变化、检索管理层关于成本改进的表述、甚至联系量化模块查看市场对这一事件的反应（股价相对基准超额收益）。AI最后给出验证结果，如“有一定佐证：公司曾表示新产品毛利率高于平均5%，且竞争对手推出类似产品后毛利率提升了4%，市场预期积极
kavout.com
kavout.com
。”或者提示风险点。通过这种证据收集与推理，技能相当于一个研究员助手，帮助找出支持或反驳投资论点的材料，让最终结论更加客观有依据。

模块特点：基本面模块的技能着重深入具体细节，从定量财务到定性信息都覆盖。AI承担大量机械工作（数据提取、计算、检索），而分析师可以专注于判断质量、调整假设。所有输出都有数据或文本依据支持，便于分析师审阅。不论是快速阅读长报告还是搭建详细模型，AI都能显著提升速度并降低出错风险。这使得分析师可以在更短时间内完成更全面的公司研究。

量化研究模块

模块定位：服务于量化分析师、数据科学家等角色，关注数量化的选股策略、因子研究、风险模型和技术面分析等。

核心Skills设计：

因子分析与选股 Skill：支持对各种选股因子进行测试和评价。量化研究员可要求AI分析某财务指标或技术指标是否具有预测超额收益的能力。技能会自动从数据库提取历史因子数据和股票回报，进行横截面回归或分组排序测试（IC值、分位组合收益等），然后给出结论
visualping.io
visualping.io
。例如“高研发费用率是否带来超额收益？”AI可能返回：“过去5年，高研发费用率股票平均超额年化收益+3%，显著优于低研发组，IC=0.05，具有一定正向预测力
visualping.io
。”并提供统计显著性指标。如果因子无效，则说明未发现显著关系。这让分析师快速筛选出有效因子组合。技能还能进一步结合多因子，进行多元回归确定独立贡献，从而帮助构建因子模型。

量化策略回测 Skill：允许研究员定义策略逻辑，由AI调用历史数据自动回测绩效。分析师用接近自然语言的方式描述策略，例如：“每月月底买入市盈率最低的10%股票，持有1个月”等，技能将解析策略规则，从数据库获取所需数据，模拟每期选股和投资组合变化，计算回测指标（年化收益、夏普比率、最大回撤等）。输出包括策略收益曲线图和性能摘要，由AI生成文字说明“策略在1990-2025年年化收益X%，跑赢基准Y个百分点，但最大回撤Z%，在金融危机期间表现不佳”等。这类似许多量化平台的回测功能，但通过自然语言接口使非程序员也能使用。这样的技能对于快速验证交易想法非常有用，减少了编写繁琐代码的时间。

市场技术监控 Skill：提供类似Kavout中技术分析代理和交易信号代理的功能
kavout.com
。技能实时分析市场价格数据和技术指标，为关注的股票或指数产生技术信号解读。例如，它会监控股票形成的形态（均线金叉、MACD背离等）并在检测到重要信号时通知分析师。同时技能赋予这些信号一定的置信度或历史胜率。例如：“股票A出现MACD金叉信号，过去类似形态后1月平均上涨+4%，有统计优势”。再如结合Kavout的Trade Spotter思想，该技能会综合多指标寻找高概率交易机会
kavout.com
。对于量化和技术策略团队，这个AI“技术面助手”可帮助持续扫描海量证券，发现人工难以及时捕捉的机会。

风险管理与归因 Skill：协助量化研究进行投资组合的风险暴露分析和业绩归因。技能可以接收一个投资组合清单，计算其相对于基准的因子暴露（如大小、价值、动量等），以及行业权重偏离情况。如果风险超标（如单一因子敞口过高），技能会给出警示并建议对冲方法。此外，在投资组合过一段时间后，技能可以分析业绩来源：例如告诉用户超额收益主要来自于动量因子的贡献和行业配置，而在价值因子上有所损失。AI能够快速处理复杂的归因模型并用直观语言解释结果，使得投资经理了解组合运作机制并据此调整策略。这类似Bloomberg的PORT功能结合AI解释，或者BlackRock Aladdin等系统的因子归因报告，但我们让AI生成定制化的文字分析。

模块特点：量化模块的技能特点是数据和计算密集，并需要高度准确性。我们通过在安全环境中让AI调用成熟的金融计算库或内部模型，保证结果可靠，同时利用AI的语言生成能力使输出易于理解。量化技能的引入使得数据分析不再是孤立的编码工作，而是可以与基本面、宏观技能互动：例如量化发现某因子有效，可以提示基本面分析师关注这些高因子得分的公司，从定性角度验证；反过来基本面观点也可交由量化技能检验历史有效性。这种定量与定性结合是投研中非常有价值的创新。

投资组合与决策模块

模块定位：服务于投资经理、组合经理或投研团队主管，将各领域研究结果汇总为最终的投资决策支持，包括组合构建、报告生成和投资建议。

核心Skills设计：

研报自动生成 Skill：根据分析师在上述各模块的工作成果，自动撰写格式完整的研究报告初稿。技能会按照预定模板（比如宏观背景、行业分析、公司分析、估值与建议等章节）汇集相应内容：宏观模块的结论、行业模块的趋势、公司模块的财务和估值要点、量化模块的风险分析等。然后用连贯的报告行文串联起来。例如在公司深度报告中，AI会写道：“宏观方面，目前经济环境…（引自宏观结论）。行业层面，公司所处的半导体行业…（引入行业趋势）。公司基本面上，本季财报显示…估值上，经DCF模型测算目标价X元…”。所有数据和事实都会附注来源
institutionalinvestor.com
或在内部引用分析师笔记。这一技能类似于自动化的投资备忘录/推介材料生成器。FactSet最近推出的AI Pitchbook Creator就是相近思路：通过自然语言提示快速生成投资建议书
investor.factset.com
factset.com
。我们的技能让研究员从繁琐的文档编制中解放，将精力集中于内容本身的审阅和完善。

投资组合建议 Skill：为投资组合构建和调整提供智能建议。基于宏观和量化分析，它可以推荐资产配置比例，以及精选的股票名单和权重。比如宏观视角下建议提高某行业配置，量化模型提供潜力股票清单，AI汇总成组合草案。同时，技能会估算该组合的预期收益和风险指标，并与当前组合或基准对比。如果组合有需要调整的仓位，AI会建议买入卖出操作及理由（如“减持股票A，因为基本面恶化且风险暴露过高，增持股票B，因为估值低且动量趋势向好”）。这有点类似Kavout的Buy/Sell Rating Agent给出明确操作指引
kavout.com
，但在组合层面更注重平衡和风险控制。Skill的建议可供投资委员讨论，而非强制执行。

决策会议支持 Skill：针对投资决策会议场景，整合不同分析师和AI模块的信息，生成要点PPT或提纲。在会议前，AI根据议程自动整理相关股票的最新数据、各分析师观点摘要、以及AI自己的分析洞见，形成简报材料。会上如果有新的问题，如董事会问“这只股票在不同经济情景下表现如何？”，AI可以快速查询先前宏观和量化分析的结果，现场提供数据支持。这相当于让AI作为会议助手，确保决策层拿到及时、全面的信息。Bloomberg的即时问答和AlphaSense的内部知识检索都表明了这种需求的重要性
bloomberg.com
alpha-sense.com
。

模块特点：组合与决策模块是系统面向最终投资动作的环节，强调综合性和行动导向。AI在这里扮演“参谋”和“撰稿人”的角色，用高度凝练的方式呈现多方面信息，并提出可行方案。不过最终决策仍由人做出——AI的作用是让决策者知情且高效。这一模块需要与前面所有模块无缝衔接，利用他们产出的所有信息。因此，它也体现了Claude Skills体系的协同效应：只有各模块产出标准化、可追溯，最终综合的报告和建议才能准确可靠。

典型使用场景与AI-人协作流程

为展示上述系统如何应用于实际工作流，下面通过几个典型场景，说明AI技能模块与研究人员协同工作的流程设计。这些场景体现了AI在整个投研过程中充当助手和增效器的角色，人机配合共同完成复杂任务。

场景一：宏观主题驱动的选股流程

背景：假设宏观研究员观察到全球“能源转型”趋势加速，判断清洁能源产业未来几年将高速增长。团队决定从宏观主题出发，寻找相关投资机会。

流程：

宏观分析（人工发起）：宏观研究员在AI界面询问：“全球清洁能源投资的增长趋势如何？主要驱动力是什么？”。
AI执行：宏观数据分析Skill提取世界银行、IEA等数据，生成清洁能源投资额历年增长图，并总结：“近5年复合增长15%，主要受政策支持和技术进步驱动
alpha-sense.com
。”同时政策解读Skill汇总各国新能源政策要点和近期扶持力度，提示目前政策环境极为有利。
人操作：宏观研究员阅读AI提供的摘要与图表，确认能源转型是强劲趋势，并在对话中追问：“这可能利好哪些行业？”
AI执行：宏观假设检验Skill查找历史数据，回应：“过去，当可再生能源投资增速提升时，太阳能设备制造、储能电池等行业股票取得显著超额收益。”并引用相关统计。

行业筛选（AI辅助）：根据宏观提示，行业分析师聚焦“太阳能设备”行业。在系统中调用行业趋势监测Skill，要求“给出全球太阳能设备行业的现状与前景摘要”。
AI执行：Skill汇总近期行业报告和新闻，生成：“全球太阳能装机容量创新高，行业营收增速预计未来3年保持20%以上
visualping.io
。竞争格局：中国厂商市占率提升，美国政策（如IRA法案）刺激本土生产。”并列出主要公司名单。
人操作：行业分析师让AI进一步深挖，使用竞争格局分析Skill，对名单中Top5公司进行横向比较。AI输出表格：“公司A市占30%、技术领先；公司B垂直一体化成本低；公司C主攻海外市场增长最快…”并附上各公司最近营收增长率和毛利率供比较。

公司深度研究（人机协同）：团队选定其中两家最具潜力的公司A和B做深度研究。基本面分析师首先对公司A使用财务报表解析Skill。
AI执行：Skill读取公司A近几年的财报数据，生成关键财务趋势：收入连续增长25%，毛利率稳步提升至35%，债务率下降等，并指出现金流充裕，支持扩产。
人操作：分析师对亮点满意，又用研报阅读Skill阅读公司A最新的投资者大会纪要，特别询问：“管理层对未来订单和产能的指引？”。AI从纪要中摘取回答：“管理层预计明年订单增长40%，已规划新建两座工厂提高产能。”这些信息进一步验证了公司A将直接受益行业高景气。
对公司B，也经过类似分析。如果发现公司B毛利率下滑或有其他隐忧，AI会提示如“B公司近期毛利率从30%降至25%，管理层归因于原材料成本上涨”，为分析师敲响警钟。

估值与验证（人机协同）：基本面分析师使用估值建模Skill，分别为A和B建立DCF模型。
AI执行：Skill自动载入宏观模块提供的行业增长预期20%，将其转化为两家公司未来营收增长假设（考虑各自市占率）。并预填当前毛利率和费用率，假设改善趋势延续。模型计算得出公司A的内在价值明显高于现股价（有30%上涨空间），而B公司由于利润率压力，内在价值仅略高于现价。AI给出结论：“A公司估值有吸引力，B公司相对充分反映基本面。”
人操作：分析师审阅模型核心假设，对A公司乐观假设做敏感性测试（如把增长降为15%）。AI迅速计算并反馈即使较保守情景A公司仍有约15%上涨空间，结论稳健。分析师因此倾向选择A公司作为投资标的。

量化验证（AI辅助）：量化分析师加入，使用因子分析Skill验证A公司的量化特征是否也支持投资决策。
AI执行：Skill检查A公司在价值、成长、动量等常用因子上的分数，报告：“A公司估值相对行业偏低（PB分位20%），成长性高（过去3年盈利增速分位90%），且近期动量强势
visualping.io
。类似特征组合的股票历史上未来3个月平均超额收益+5%。”这为投资提供了量化背书。
同时，量化模块的风险Skill分析如果把A公司加入当前组合，整体行业权重和因子暴露变化不大，风险可控。

决策与执行（人决策，AI记录）：团队在投资决策会上讨论该机会。宏观研究员引用AI给出的能源转型数据
alpha-sense.com
强调大环境，行业分析师展示AI汇总的行业对比表，基本面分析师阐述对公司A的投资逻辑，量化分析师补充量化观点。最终团队决定投资公司A。
AI执行：决策模块的研报生成Skill即时将以上分析整合，生成一份完整的投资建议报告，包含宏观背景、行业趋势、公司A基本面亮点与估值、风险因素以及投资建议（买入多少仓位，目标价等）。报告附有关键数据和出处引用，供内部存档和后续跟踪。

结果：通过这一流程，AI协助团队从宏观主题挖掘出具体投资标的，大幅加快了各环节分析：宏观趋势和行业信息在几分钟内由AI整理完毕，财务模型和估值在几小时内构建，最终报告实时生成。这比传统手工研读数据、写报告节省了大量时间。同时AI提供了多维验证（宏观、基本面、量化）使决策更有依据。人类研究员运用了AI加速认知过程，但仍对关键假设和最终决策进行把关，确保专业判断和AI结果相结合。

场景二：公司突发事件的深度研究流程

背景：假设研究员跟踪的一家上市公司C突然发布盈利预警，股价大跌。团队需要在短时间内摸清原因、评估影响并决定应对策略。

流程：

紧急信息获取（AI辅助）：消息传出后，研究员立刻在AI界面输入：“公司C盈利预警内容是什么，市场反应如何？”。
AI执行：新闻情绪Skill迅速抓取公司公告摘要：“预警因原材料成本激增导致利润低于预期20%”，并抓取媒体报道和卖方点评，综合为要点：“分析师担忧成本压力或持续两个季度
kavout.com
。”情绪分析显示新闻舆论90%偏负面。股价实时下跌15%，交易量放大。AI将这些关键信息推送给研究员。
人操作：研究员很快了解基本情况，将重点转向分析原因和影响深度。

原因分析（人机协同）：分析师调用财务报表解析Skill查看公司C最近几个季度毛利率和成本项变化。
AI执行：Skill提取显示：“原材料占成本比例从60%升至75%，毛利率从40%降至30%。预警提到的原材料为锂等大宗商品价格上涨所致。”AI引用财报数据支撑这一点。
人操作：分析师进一步用研报阅读Skill搜索年报风险因子，提问：“公司以前有没有提示过原材料风险？”AI找到年报中风险章节：“公司提示锂价波动将影响生产成本，如2021年锂价每上涨10%，毛利率影响约-2%。”这说明成本风险早有迹象。
分析师现在对预警原因（原料涨价）及其量化影响有了清晰认识。

同行比较（AI辅助）：为了判断这是公司特有问题还是行业普遍现象，分析师让行业比较Skill查看同行公司毛利率近期变化。
AI执行：Skill调取行业内另外3家公司最近财报数据，发现：“同行D和E毛利率也下降约5个百分点，唯有F公司基本持平因其有上游矿山布局。”AI总结行业普遍受到锂价上涨冲击，但垂直整合者受影响较小。
人操作：这让分析师意识到公司C的问题在行业中不孤立，但其受冲击程度可能更大，因为没有上游资源。

预测调整（人机协同）：分析师使用估值建模Skill调整公司C盈利预测。在模型中将未来两年原材料成本率提高，模拟不同锂价情景。
AI执行：Skill快速计算：在锂价维持高位情况下，公司C明后两年净利要较之前预期下调30%，公允价值估算比之前降低25%。只有锂价回落情景下盈利才能恢复。
人操作：分析师与AI讨论可能的情景概率，AI基于宏观模块信息指出当前锂供需可能两年内仍偏紧（参考宏观商品分析数据）。分析师据此倾向保守假设。模型结果支持股价下跌的合理性，甚至可能还未 fully price in 最坏情况。

对策研判（人工决策）：现在基本结论是公司C短期盈利承压。投资经理需要决定是减持、观望还是反向加仓博反弹。
AI辅助：投资组合建议Skill提供两种方案的分析：

方案1：减持/卖出：列出理由：“基本面恶化，短期无明显催化剂，继续下跌风险存在。”并提示可考虑将资金转入同行F公司（因其抗原料风险能力强）。

方案2：趁低增持：列出理由：“市场可能过度反应，如果锂价回落则业绩弹性大。”并警示这是逆势策略，需承受波动。
AI同时更新组合风险：若大幅减持C公司，组合的新能源行业权重降至较低，要注意跟踪行业后续表现；若加仓则需监控风险。
人操作：团队讨论后决定暂时减持一半仓位降低风险，同时密切跟踪锂价走势。这个决策兼顾了控制风险和保留一定仓位待观察。

执行反馈（AI协同）：决策做出后，AI研报生成Skill即时总结此次分析过程和决策理由，形成一份内部记录，供日后复盘使用。报告写道：“由于原材料锂价飙升，公司C盈利大幅低于预期，行业普遍受冲击。本团队调整盈利预测下调30%。决策：减持50%仓位，以降低风险，待价格趋势明朗再评估
kavout.com
。”报告附有关键数据图表和引用原始公告及财报的出处。
此外，AI监控Skill将锂价和公司C动态加入特别关注列表，设置阈值报警（如锂价下跌超过20%或公司推出成本转嫁举措则通知团队）。

结果：在这个突发事件场景中，AI显著提升了响应速度和分析深度。传统情况下，分析师可能需要数天调研同行、重做模型。而借助AI，几个小时内就完成了对事件的全面剖析：AI从公告中提炼关键信息，快速提供同行比较和历史风险提示，协助调整模型并产出决策建议。团队因此得以及时调整仓位，将损失和风险控制在更可控范围。同时，通过AI生成的文档，团队留下了完整的分析轨迹，可用于未来学习改进。整个过程中，AI就像一个全能助手，在信息搜集、计算分析方面无人可比的迅速准确，而人负责判断决策与承担责任，充分体现了AI-human协作的价值。

场景三：量化策略开发与验证流程

背景：量化研究员计划开发一套新的多因子选股策略，结合价值和动量信号。他希望利用AI加速策略研究，从因子选择、模型训练到结果解释的流程。

流程：

因子初筛（AI辅助）：研究员首先脑暴可能用到的因子，例如PE、市值、3个月动量等，并询问AI：“哪些因子组合在过去表现良好？是否存在交互效果？”。
AI执行：因子分析Skill调取过去10年数据，对单因子效果排名，并测试价值+动量组合。AI回答：“历史上市盈率（PE）最低组超额收益年化5%，3个月价差动量因子年化8%。两者相关性低，组合后信息比率提高
visualping.io
visualping.io
。”这表明价值和动量搭配有效。AI还提到：“注意市值因子与PE因子相关度高（小市值股票倾向低PE），可能需要控制大小偏差。”
人操作：研究员据此确定用PE和动量为主因子，并加入市值作为控制。

策略模型训练（人机协同）：研究员使用量化策略回测Skill定义策略规则：每季度按PE从低到高选取前30%股票，再在其中选动量排名前50%的股票构建组合，等权持有，季度调仓。
AI执行：Skill解析规则，利用历史数据从例如2000年至2025年进行回测。输出结果：“策略年化收益12%，同期基准（市场指数）8%，年化超额4%。夏普比率0.8，最大回撤 -30%。胜率（超额为正年份）75%。”并生成累计超额收益曲线图。
AI还自动计算了不同子区间的表现和因子敞口，指出：“策略在2000s价值股领跑时期表现突出，在2010年代动量盛行时略有跑输，但总体稳健。”
人操作：研究员查看回测曲线，确认策略长周期有效。不过注意到2008年金融危机时策略回撤较大，于是要求AI：“针对2008年那次巨亏，能分析原因吗？”
AI执行：AI深度分析发现，当时价值因子选出的多为金融股，动量因子也未能及时剔除下跌趋势，导致组合集中暴露于次贷危机板块。它解释：“2008年组合金融股权重达50%且持有至雷曼破产时，回撤高达50%。”
人决策：研究员据此考虑在策略中加入行业中性或者风险控制条件。

策略改进（AI辅助）：研究员调整策略规则，增加约束：在选股时对行业中性，避免过度集中。同时将仓位做风险平衡（如对波动率高的股票少配）。
AI执行：AI重新回测改进后的策略，结果显示2008年回撤缩小至-35%，总体夏普提升到0.85。但同时收益也略降至11.5%。AI提示收益-风险权衡情况，让研究员决定是否接受。
人操作：研究员认为稳健性重要，接受改进方案。接下来他们希望向投资团队展示策略。

策略报告生成（AI协同）：研究员调用研报生成Skill，要求AI整理一份策略说明文档，包括策略逻辑、回测绩效、风险分析。
AI执行：Skill汇总先前因子分析结论、回测数据和图表，生成报告：“本策略结合价值（低PE）和动量选股，在历史上取得稳健超额收益
visualping.io
。年化超额约4%，信息比率0.5-0.6。最大回撤发生在2008年，为-35%，经行业中性改进后风险有所降低。主要Alpha来源于估值均值回归和趋势延续的共同作用。未来风险包括价值因子失效或动量突然反转等。”报告中引用了回测统计表格和曲线图出处。
人审阅：研究员检查报告内容准确性，特别是数字和结论是否一致，与AI讨论细节。确认后将报告交给投资委员会审阅。

决策与部署（人工主导）：投资委员会阅读报告，对策略表示兴趣。会上有人提问：“该策略当前选出的股票有哪些？与我们现有组合重叠度高吗？”。
AI辅助：投资经理在会上登录系统，即时询问AI界面。组合建议Skill实时列出当前策略选股清单及行业分布，标明与现组合重复的股票和仓位差异。AI说明重复度20%，新增标的多集中在被低估的小盘股。
这些信息帮助委员会评估实施可行性。最终决定拨给量化团队一定资金试运行该策略。

结果：在整个策略开发过程中，AI成为量化研究员的强力助手：它提供了丰富的历史分析支撑因子选择，又快速完成大规模数据回测和优化，使研究员能在几天内开发出可行策略（传统上可能耗费数周编程和调试）。AI还自动生成了专业的策略报告，降低了交流成本。值得注意的是，人仍牢牢把控关键决定：如策略规则设计、风险偏好取舍等。但AI大幅降低了门槛，使得复杂量化方法更透明易懂，也让非量化决策者更容易接受策略，因为有详尽的AI解释和验证
visualping.io
visualping.io
。这体现了AI在量化投资中赋能而非神秘化的作用。

通过以上场景演示，我们看到本系统的Claude Skills如何在不同投研环节与人配合：信息提取、分析计算、报告撰写等由AI高效完成，人类专家则专注于提问、判断和决策。AI能够全天候工作、处理海量信息并保持系统化的方法论，而人能够提供创造力、经验和责任感，两者互为补充。这种AI-human协作流程将极大提升投资研究的效率与质量，同时确保研究结论有据可查、经得起推敲
alpha-sense.com
。对于基金公司来说，这不仅意味着更快的响应和更深入的洞察，也有助于知识沉淀和团队新人培训——新人可以通过AI生成的分析和报告快速学习成熟分析师的思路，从而整体提升投研能力。

总结

本方案详细阐述了一个基于Claude Skills的股票研究系统如何为基金公司内部投研团队提供端到端的智能支持。通过模块化的AI技能体系，我们将研究工作按角色和方法领域分解，打造出宏观、行业、基本面、量化到投资决策各环节的AI助手。这些助手借鉴了业内领先平台的最佳实践：如Bloomberg/FactSet的智能搜索与摘要确保信息获取迅捷且有据可依
institutionalinvestor.com
；AlphaSense/Sentieo的语义分析和内部知识整合保证研究视野广阔且不遗漏关键信息
visualping.io
；Kavout的多代理协同赋予系统全局视角，自动综合多维观点
kavout.com
kavout.com
；Numerai的群智模型理念则启发我们充分利用集体智慧和数据来提升预测能力
wired.com
。系统架构上，我们设计了清晰的三层结构，并通过Claude大模型将各模块衔接，使之成为一个有机整体
finitup.com
。在具体功能上，各技能模块各展所长又能互动协同，为典型场景提供了前所未有的效率提升和洞察深度。

对于基金公司而言，引入这样的AI投研系统有多重价值：首先，研究效率显著提高——繁琐的信息搜集、整理、计算由AI完成，分析师可以在相同时间内覆盖更多领域、更深入分析；其次，研究质量更有保障——AI流程化的方法减少了人为遗漏和偏差，并通过自动引用确保每个结论都有依据
alpha-sense.com
；再次，团队协作更加紧密——统一的平台让各角色无缝对接，AI汇集观点减少信息孤岛，使投研过程透明化；最后，知识沉淀与培训获益——AI技能库本身是最佳实践的载体，新人可以在使用中学习标准流程，沉淀的报告和分析也形成了机构记忆。

需要强调的是，AI再强大也不是万能，“人机协作”而非“AI替代人”是我们的基本出发点。系统在人类监督和引导下运行：研究人员提出正确的问题、审慎地验证AI提供的结论并作出最终决策。这符合当前业界对AI的共识：将AI作为辅助工具，增强而非替代人类决策
institutionalinvestor.com
。通过专业培训和内部实践，团队成员将逐步掌握如何高效利用Claude Skills，与AI形成默契、高效的合作关系。

本方案文档旨在为基金公司内部规划AI投研系统提供全面蓝图。配合系统架构图、技能说明和场景演示，我们希望读者对如何部署Claude Skills于投研流程有清晰认识。在后续的实施阶段，可以根据本方案逐步开发各模块功能并进行试点。随着系统投入使用，我们也将持续完善Skills库（例如加入新的AI模型、调整提示以适应新市场情况），确保系统始终保持业内领先水平。展望未来，伴随AI技术演进，我们可以预期投资研究将越来越智能化和高效，而本系统的搭建将为公司赢得这一领域的先发优势，培养出“人机共研”的新型投研文化，为投资决策创造更大价值。

完全本地部署的自动化基本面策略研究与执行系统设计
系统架构概览

本方案设计一个完全本地部署的自动化基本面量化策略研究与执行系统。系统由两大核心部分构成：一是基于Anthropic Claude大模型的AI技能（AI Skills, 简称AIS）平台，二是开源的QuantConnect Lean算法交易引擎。所有行情价格数据和财务基本面数据均来自公司自有数据库，本地存储和读取，不依赖任何Lean云端服务或外部数据源，以确保数据安全与隔离。

在总体架构中，Claude大模型扮演智能研究员和交易助手的角色，通过预先配置的一系列技能（Skills）完成策略开发流程中各环节的自动化工作，包括策略逻辑生成、数据准备、交易信号判断、回测执行、绩效分析等

claude.com
。Lean引擎则作为底层策略执行引擎，根据Claude生成的策略代码读取本地数据并运行回测，产出结果。本地AIS平台和Lean引擎通过文件接口和命令行进行集成：Claude生成的策略代码和指令通过AIS数据库传递给Lean执行，Lean将回测结果（如交易记录、资产曲线和统计指标）输出回AIS数据库，由Claude读取分析。

整体工作流程如下：

策略构思与代码生成：用户以自然语言描述策略思想（例如基于财务指标的选股策略）。Claude识别任务意图，自动进入“策略设计师”角色，调用相应技能生成可执行的策略代码（Lean算法）

。代码包含策略所需的模块化逻辑（如财务因子筛选），并符合Lean引擎要求的结构。

数据准备：Claude切换到“数据适配器”角色，调用数据技能对接公司内部数据库，提取策略所需的历史价格和财务指标数据。数据经过转换后写入Lean本地数据存储，格式与Lean引擎期望的标准一致


。这一过程确保Lean在回测时能够直接从本地获取所需数据，而无需访问任何云端数据源。

策略回测执行：Claude以“回测调度器”角色调用执行技能，通过命令行触发Lean引擎运行刚才生成的策略代码

。Lean在完全本地的Docker容器或本机进程中加载算法，读取步骤2准备的数据，按照设定的回测时间段模拟交易，最终将回测结果输出为本地文件（例如JSON格式的结果报告）。

结果分析与反馈：Lean完成回测后，Claude扮演“绩效分析师”角色，自动加载回测结果文件，解析交易绩效指标和资产曲线等数据，生成文字总结和可视化要点，反馈给用户。分析报告会提取诸如年化收益率、夏普比率、最大回撤等指标，并给出策略表现评价。必要时，Claude还能结合分析结果建议策略改进方向，形成闭环反馈。

上述流程全部在本地完成：Claude利用本地技能和工具执行策略研究各环节，Lean引擎在本地数据上进行回测计算。与传统需要人工编写代码、手动运行回测的流程相比，该系统显著提高了自动化程度和研发效率。在完全本地部署的前提下，数据隐私和安全性也得到保证，不存在将敏感财务数据上传到云端的风险。

值得注意的是，该设计理念与QuantConnect官方的“MCP服务器”（Model Context Protocol）有类似之处——MCP提供了桥接AI代理与QuantConnect平台的接口，使AI能够自动完成策略生成、回测、优化等任务

。然而本方案完全基于本地基础设施实现同等功能：利用Claude Skills扩展AI能力，结合开源Lean引擎和本地数据源，自主完成从策略构想到性能分析的整个闭环。这实现了一个自主的“AI量化研究员”，能够在本地环境中自动化地设计、回测和评估基本面选股策略。

AIS系统与 Claude Skills 集成

AIS系统是整个架构的大脑部分，负责承载Claude大模型及其扩展技能，管理策略研究过程中的所有知识、文档和产出物。AIS包含Claude Skills机制和AIS数据库两大要素：

Claude Skills 机制：Claude Skills是Anthropic推出的可扩展插件体系，使Claude能够根据需要加载特定技能，以提升处理专业任务的能力
claude.com
。每个技能本质上是一个文件夹，内含一个SKILL.md说明文件和相关的脚本或资源。当Claude处理任务时，会扫描可用技能，根据任务内容自动决定是否加载某个技能
claude.com
。只有当技能的描述与当前任务高度相关时，Claude才会调用该技能，以保持高效和避免无关信息干扰
claude.com
claude.com
。这种按需加载机制保证了Claude在需要时才会“变身”为特定专家，执行例如处理Excel表格或遵循公司品牌规范等专门任务
claude.com
。在本系统中，我们为Claude定制了一组技能，使其能够胜任量化策略研发各环节的专门任务。

本方案中关键的技能包括：

策略生成技能（Strategy Designer Skill）：赋予Claude根据用户策略思想生成Lean算法代码的能力。其SKILL.md包含如何从自然语言策略描述转化为具体算法的分步指导，以及代码模板。Claude调用此技能后，可以读取内置的策略代码示例或模板，并根据用户要求填充具体逻辑，产出完整的算法代码文件（例如Python版的QCAlgorithm子类）。

数据适配技能（Data Adapter Skill）：使Claude能够访问和转换本地数据库中的行情与财务数据。例如，此技能附带Python脚本，用于连接公司的SQL数据库或读取CSV文件，并按照Lean所需格式输出数据文件。Claude在需要数据时会自动运行这些脚本，将结果写入本地硬盘供Lean使用
anthropic.com
。

回测执行技能（Backtest Scheduler Skill）：帮助Claude调用Lean引擎运行算法回测。技能内置对系统命令的调用方法，如通过Python的subprocess执行lean backtest命令，并监视回测进程。这样Claude能自动启动Lean容器、传递项目路径，并等待回测完成

。

绩效分析技能（Performance Analyzer Skill）：赋予Claude读取Lean回测结果并计算绩效指标的能力。其内部可能包含用于解析结果JSON的脚本，以及生成图表或总结报告的模板。例如，一个Python脚本可遍历回测结果中的交易记录和资产价值序列，计算夏普比率、最大回撤等指标，然后输出总结。

通过以上技能，Claude获得了在量化策略开发流程中各个专业环节执行任务的“专家”能力
eesel.ai
anthropic.com
。这些技能是可组合的，Claude可以在单次会话中按需连续调用多个技能来完成复杂的多步骤任务
claude.com
claude.com
。例如，在处理策略回测这样复杂任务时，Claude会自动识别需要依次用到策略生成、数据处理、回测执行、结果分析等技能，并将它们协调组合起来完成整个流程。这种技能体系让Claude从一个通用对话模型转变为公司量化团队的专属专家代理
anthropic.com
——通过打包我们的领域专业知识，Claude能够以专家水准完成金融量化领域的复杂任务。

AIS数据库：AIS数据库是系统中的知识与文件管理中心，用于集中存储所有技能文档、策略模块代码和回测结果等内容，以供Claude和Lean方便地访问和共享。具体来说：

技能文档与资源：AIS数据库保存每个技能文件夹下的SKILL.md说明、示例用法，以及任何附加脚本、模板文件等。例如，策略生成技能的代码模板、数据适配技能的SQL查询脚本都存储在数据库中并与技能ID相关联。这样Claude在调用技能时，可以通过AIS数据库检索相应的说明和脚本内容，将其载入上下文或执行环境。

策略模块与模板：为了支持策略的模块化构建，AIS数据库中维护了一套策略模块代码片段库。每个模块代表一类通用的策略逻辑单元，例如“高ROIC筛选模块”、“高成长筛选模块”、“估值合理筛选模块”等，都有独立的实现代码或伪代码存储在数据库中。模块记录包含描述（用途、适用场景）和代码实现两部分。当Claude需要组装某策略时，可以查询AIS数据库找到符合描述的模块，实现策略逻辑的快速拼装复用。

回测产出物：Lean引擎生成的回测结果（日志、交易明细、绩效指标JSON等）也由AIS数据库集中管理。每次回测完成后，Claude将结果文件或其中的数据条目存入数据库，以便后续分析、比较或追溯。例如，我们可以为每次回测存储一个结果记录，包含策略版本、回测时间范围、主要绩效指标等元数据，以及引用到完整结果JSON文件的路径。这样不仅方便Claude当前会话分析结果，也方便将来调取历史回测进行横向比较或模型迭代。

AIS数据库同时起到技能路由与配置中心的作用。通过在数据库中维护技能描述到功能的映射，系统可以根据任务上下文自动选择正确的技能执行。例如，我们为每个技能的SKILL.md都设置了简明的描述字段，用于指明技能的用途及触发条件
docs.claude.com
docs.claude.com
。Claude在解析用户请求或当前任务时，会将这些描述作为参考，自主决定应当调用哪一个或哪几个技能来完成任务
docs.claude.com
docs.claude.com
。例如，描述中包含“生成交易策略代码”的技能将匹配用户提出的新策略构思请求，而包含“运行回测”的技能则在需要执行策略时被调用。由于这些描述存储在AIS数据库中，Claude无需手工指定技能名称即可完成匹配——技能的发现和调用是模型驱动的
claude.com
。AIS数据库确保了技能和其元数据的一致管理，使我们可以方便地更新技能描述或增加新技能，同时让Claude随时获取最新的技能配置。

此外，AIS数据库使团队协作和版本管理更加便利。所有技能和模块以集中方式存储后，可以接入内部的版本控制系统或Git仓库，实现团队共享开发
docs.claude.com
。例如，新增一个财务指标筛选模块或调整某技能脚本，只需更新数据库中的相应记录并推送给Claude，下次任务时Claude就能利用新的能力。这类似于Anthropic Claude中通过~/.claude/skills或项目.git来分享技能给团队的方式
docs.claude.com
。通过AIS数据库，本系统的技能与策略知识可以迭代沉淀，不断扩充，使Claude越用越智能。

概括而言，AIS系统通过Claude Skills赋予了AI专业能力和可执行工具，通过AIS数据库实现知识/资源集中管理和调用路由。Claude不再只是对话助理，而是具备一系列“插件”的强大研究员，可以在需要时加载正确的技能完成复杂任务
claude.com
claude.com
。这一设计保证了Claude的行为既灵活多样（可根据任务上下文自动扩展能力），又可控可管（技能配置和执行过程都在我们的掌控之中）。

模块化策略架构设计

为了支持策略逻辑的灵活扩展与复用，本系统采用模块化的策略架构。策略的核心逻辑被划分为若干独立的模块，每个模块对应一种特定的选股条件、信号算法或交易机制。通过模块组合，可以快速构建出满足不同投资思想的策略，提高策略开发的效率和质量。同时，模块化设计让策略更易于维护和升级——可以针对某一模块进行优化，而无需重构整个策略。

这种模块化思想类似于QuantConnect提出的算法框架（Algorithm Framework），将策略通用功能抽象为可插拔的组件，如Universe Selection（选股范围）、Alpha Creation（信号产生）、Portfolio Construction（仓位配置）、Execution（执行交易）、Risk Management（风险管理）等核心模块

。几乎所有投资策略都可以归纳进这些模块化的功能架构中，从而实现代码重用和清晰的层次结构

。QuantConnect的模块化框架允许开发者在算法中自由插入、替换不同的模块组件，使算法具有高度的可重用性和互换性

。我们借鉴这一理念，在本地系统中构建策略逻辑时亦遵循模块化原则，将财务选股条件、信号判断和交易执行等拆解为离散的模块单元，实现“搭积木”式的策略构建

。

具体到本方案，针对“高ROIC，高增长，估值合理”这一策略核心思想，我们设计了以下几个基础策略模块：

高ROIC筛选模块：筛选出最近财年或最近四个季度平均ROIC（投入资本回报率）高于一定阈值的股票。例如阈值可以设定为15%。该模块读取股票的ROIC财务数据字段，将ROIC低于15%的股票过滤掉。

高增长筛选模块：筛选出营业收入或利润保持高速增长的股票。例如设定最近3年收入年复合增长率>10%作为高增长标准。模块实现为计算每只股票过去3年的收入增长率，并过滤低于阈值的股票。

合理估值筛选模块：筛选出估值相对合理的股票，例如市盈率（P/E）低于行业平均或低于某一绝对值（如<20）的股票。此模块会获取股票当前的市盈率，排除掉估值过高的公司。

选股合成模块：将上述多个筛选条件组合起来，得到最终的投资组合候选列表。一般而言可以采用交集（AND）的方式，即同时满足高ROIC、高增长且估值合理；也可以根据需要改为加权评分等更复杂逻辑。本例中核心策略是所有条件均满足，因此模块执行多重过滤，输出满足全部条件的股票清单。

除了选股筛选模块外，策略还包含一些通用模块，例如：

调仓/执行模块：定义如何根据筛选结果调整投资组合。如果选出的股票列表发生变化（比如每月更新一次财务数据触发成分变动），则卖出不再满足条件的股票，买入新满足条件的股票。可以简单实现为等权重持有新筛选列表中的所有股票。

风险管理模块（本例未突出）：可以加入如单一股票持仓上限、止损规则等作为独立模块，保护投资组合风险。

指标监控模块（本例未突出）：例如跟踪投资组合与基准的业绩差异、风格偏离等，可做为扩展模块。

在实现上，我们将这些模块封装为独立的函数或类，使其接口清晰、职责单一。例如，高ROIC筛选模块实现为函数HighROICFilter(universe, threshold)，输入股票列表及阈值，返回符合条件的股票列表；高增长模块类似。这样主策略逻辑可以非常直观地表达为对初始股票池依次应用多个过滤函数：

# 模块伪代码示例：
def high_roic_filter(stocks, min_roic=0.15):
    return [s for s in stocks if s.fundamentals.ROIC > min_roic]

def high_growth_filter(stocks, min_cagr=0.10):
    return [s for s in stocks if s.fundamentals.ThreeYearRevenueCAGR > min_cagr]

def reasonable_pe_filter(stocks, max_pe=20):
    return [s for s in stocks if s.fundamentals.PERatio < max_pe]

# 组合筛选逻辑：
def select_universe(initial_universe):
    filtered = high_roic_filter(initial_universe, 0.15)
    filtered = high_growth_filter(filtered, 0.10)
    filtered = reasonable_pe_filter(filtered, 20)
    return filtered


上面伪代码展示了如何通过顺次调用各筛选模块，将满足全部三项财务条件的股票筛选出来。每个模块各司其职，逻辑清晰且易于单独测试和调整。例如若需改变ROIC阈值，只需修改high_roic_filter的参数，不影响其他部分。

在Lean算法实现中，可以利用QuantConnect提供的Fine Fundamental数据实现类似的筛选逻辑。Lean允许定义自定义的Universe Selection流程，包括Coarse筛选（初步范围，例如选取市值前几百的股票）和Fine筛选（精细筛选，如基于财务指标）


。我们可以将上述筛选模块逻辑集成到Lean的Fine筛选函数中：在FineFilter(fine_data)方法中，对传入的一组股票基本面数据对象按ROIC、增长率、PE做筛选，返回Symbol列表。Lean引擎会在每个筛选周期调用该方法来确定当前投资组合的候选股票。例如：

class FundamentalFactorAlgorithm(QCAlgorithm):
    def Initialize(self):
        self.SetStartDate(2018,1,1)
        self.SetEndDate(2023,1,1)
        self.SetCash(100000)
        # 添加Universe选股模块：使用自定义的Coarse和Fine筛选函数
        self.AddUniverse(self.CoarseSelectionFunction, self.FineSelectionFunction)
        # 设定每日盘后执行选股（或每月定期执行）
        self.Schedule.On(self.DateRules.MonthStart(), self.TimeRules.At(0,0), self.Rebalance)
    
    def CoarseSelectionFunction(self, coarse):
        # 简单粗筛：选取价格大于5且日成交额前1000的股票
        filtered = [c.Symbol for c in coarse if c.Price > 5]
        # 按成交额排序取前1000
        top = sorted(filtered, key=lambda symbol: symbol.DollarVolume, reverse=True)[:1000]
        return top
    
    def FineSelectionFunction(self, fine):
        fine_filtered = [f for f in fine 
                         if f.Fundamentals.OperationRatios.ROIC.Value > 0.15 
                         and f.Fundamentals.FinancialStatements.IncomeStatement.RevenueGrowth.ThreeYears > 0.10 
                         and f.Fundamentals.ValuationRatios.PERatio < 20]
        return [f.Symbol for f in fine_filtered]
    
    def Rebalance(self):
        selected = self.Universe.SelectedSymbols
        # 卖出不在新选股列表中的股票
        for sec in self.Portfolio:
            if sec.Symbol not in selected:
                self.Liquidate(sec.Symbol)
        # 等权买入新选股股票
        weight = 1.0 / len(selected) if selected else 0
        for symbol in selected:
            self.SetHoldings(symbol, weight)


上述代码仅为示意性的结构伪代码，展示如何在Lean算法中融合多个财务指标筛选条件。

在Fine筛选函数中，我们直接访问了每只股票的基本面数据（假定Lean本地已加载相应财务数据），应用ROIC、三年收入增长率和市盈率的条件过滤


。通过这样的实现，我们成功将策略核心逻辑模块化地融入了Lean算法框架。今后若要扩展新策略或调整策略逻辑，只需增删相应的模块或更改条件参数，而整个策略结构无需改变，体现了良好的扩展性。

模块复用也是一大优势。同一模块可以被不同策略重用，例如“高ROIC筛选”模块不仅可用于本策略，也适用于任何关注公司盈利质量的策略。AIS数据库中的模块库记录了各模块的代码，实现了“策略搭积木”——Claude可以根据用户需求从库中检索出相关模块组合策略。这类似于QuantConnect社区模块在算法间共享的理念

。通过模块化，我们大幅减少了重复造轮子的工作，提高了代码复用率。一旦某模块经验证有效，可以在不同策略中反复使用，从而加速策略研发并减少人为错误。

总之，模块化架构使我们的策略开发更具结构性和灵活性：既结构清晰地分离了策略的不同组成部分（筛选、选股、调仓等），又易于扩展地增加新因子或规则，同时借助AIS数据库实现模块知识的积累和共享。这为系统未来拓展更多复杂策略（例如加入技术面信号、机器学习模型）奠定了良好基础——新功能可以作为新模块添加进去，而无需推翻原有架构。

AIS与Lean引擎的集成流程

现在详细说明AIS系统与Lean回测引擎如何集成，通过各角色技能协同工作，自动化地完成从策略生成到回测分析的整个流程。为了清晰起见，我们将流程分为若干阶段，对应之前提到的Claude不同角色：

1. 策略逻辑生成

在用户提出策略需求后（例如“请基于高ROIC、高增长、低估值构建选股策略并回测”），Claude首先判断需要设计交易策略的代码实现，因此进入**“策略设计师”角色。此时，Claude自动调用策略生成技能**。该技能的SKILL.md指引Claude按照一定步骤生成策略代码，例如：理解策略筛选条件 -> 确定使用哪些财务数据字段 -> 从模板生成Lean算法框架代码 -> 将条件融入筛选逻辑 -> 设置回测参数（日期范围、初始资金）等。技能文档中还可能包括样板代码片段、Lean API参考等，Claude在需要时会调阅这些内容，确保代码符合Lean的要求

。得益于技能中提供的代码模板和指导，Claude能够将策略描述准确翻译为可运行的Python代码。

Claude生成的策略代码通常是一个独立的Lean算法项目，包括主要的算法类文件（例如Main.py）和配置文件。为了便于后续Lean执行，Claude会将生成的代码保存到AIS数据库指定的位置（对应Lean项目目录）。例如，Claude可以通过技能中的文件操作能力直接在本地创建文件并写入代码
claude.com
。Claude Code具备创建和编辑文件的能力，可以在运行过程中将生成的代码存档
claude.com
。保存代码后，AIS数据库记录该策略版本的信息，如策略名称、生成时间、主要逻辑描述等。

在这一阶段，Claude实际完成了过去需要人工编码的工作——它利用内置的知识与模板自动编写出了策略源代码。这些代码已经按照Lean引擎规范组织，比如包含初始化函数、选股逻辑、交易逻辑等，并引用Lean的数据接口。如果需要，Claude还可以进行初步的语法或错误检查。例如，Claude可以调用Lean的编译器或静态分析工具检查代码是否有错误

。QuantConnect的MCP提供了静态语法检查工具来快速定位代码问题

；类似地，我们也可在策略生成技能中集成调用Lean编译的指令，确保代码无明显错误后再继续。这一步骤让AI生成的代码质量更有保障。一旦代码准备就绪，AIS数据库中便存在了“策略代码”这一产出物，供后续阶段使用。

2. 数据准备

有了策略代码，Claude识别到下一个关键环节是准备回测所需的数据，因此转换到**“数据适配器”角色，调用数据适配技能**来获取和格式化本地数据库中的历史数据。本例策略涉及每日价格数据以及若干财务指标（ROIC、营收增长率、PE等），这些数据需要按照Lean引擎可读取的格式提供。

数据适配技能首先明确所需数据范围：例如，根据策略代码涵盖的股票范围和回测时间段，确定应提取哪些股票的哪些年份财务数据，以及对应的价格序列。在我们的设计中，Lean引擎利用本地数据文件进行回测，因此数据适配的目标是生成Lean格式的数据文件。

（a）价格数据准备：Lean读取价格数据通常有约定的文件路径和格式，例如日线行情通常存放于Data/equity/usa/daily/<symbol>.csv，内含日期和OHLCV等

。数据适配技能可以通过查询公司行情数据库，将所需股票在回测时间段内的每日价格导出为CSV，然后存入Lean的数据目录。比如，对于股票A，在Data/equity/usa/daily/A.csv写入从2018到2023的每日行情。倘若公司的行情数据库中已有类似格式数据，则只需复制或链接到Lean目录即可。关键是确保Lean在回测时能够根据算法请求找到对应的本地文件。

（b）财务数据准备：财务基本面数据在Lean中通常以Fine Fundamental的形式提供，QuantConnect将美股Morningstar财务数据存储为JSON文件，路径类似于：Data/equity/usa/fundamental/fine/<Symbol>/<YYYYMMDD>.json，每日一个快照

。我们的数据适配技能可以采用两种方案来提供基本面数据：

方案1：转换数据到Lean格式：将公司内数据库中的财务数据转化为Lean所期望的JSON格式文件并放置在相应目录

。例如，针对每只股票，提取其ROIC、RevenueGrowth、PERatio等字段历史，在每个财报发布日期附近生成对应的JSON。如果无法做到逐日精细，也可简化为每季一次的数据文件。虽然准备这些文件需要一定工作量，但一旦生成，Lean算法即可像在云端一样使用FineFundamental对象，直接通过f.Fundamentals属性访问ROIC等指标

。这种方式优点是与Lean高度兼容，策略代码不需改动，调用FineSelectionFunction即可获取基本面筛选条件。我们的技能可以借助Python脚本完成数据格式转换

——读入内部财务数据（例如XML或SQL），映射填充到Lean JSON结构后输出。同一个脚本可批量处理多只股票的数据格式转换

。一位QuantConnect社区开发者指出，关键在于理解源数据和目标格式并做转换，在Python中编程实现并不复杂

。因此数据适配技能可看作一个数据转换器，桥接内部数据格式与Lean要求格式。

方案2：使用自定义数据源读取：Lean也支持自定义数据类，直接从CSV或数据库读取非常规数据

。我们可以为财务指标创建自定义数据类，例如定义一个FundamentalData(PythonData)类，覆盖其get_source使之指向本地汇总了财务指标的CSV文件（或通过API查询），并实现reader方法解析该数据


。策略中通过AddData(FundamentalData, "Fundamentals")添加订阅，就可以在OnData收到最新的基本面数据快照。不过在多股票筛选的场景，下这种方法不如Fine数据便利，因为Lean的算法框架原生支持Fine筛选流程。鉴于此，我们倾向采用转换数据文件的方案以充分利用Lean已有机制。当然，如果公司数据非常庞大，也可以考虑用定制Universe Selection直接调用数据库查询进行筛选，这将在策略代码中通过例如调用外部库查询实现，但那会偏离Lean框架的标准用法，因此不在此详述。

基于以上方案，数据适配技能具体执行时可能步骤如下：连接公司的财务数据库 -> 运行SQL查询提取所需股票在指定年份范围的ROIC、营收增长率、PE数据 -> 按Lean格式生成JSON文件至Data/fundamental/fine/...路径；同时，导出这些股票的日线行情CSV至Data/equity/usa/daily/...路径。如果Lean需要Coarse数据（如市值、行业分类），也一并准备对应的coarse文件。这些文件准备完毕后，Lean引擎所需的一切数据已在本地就绪。值得强调的是，这些操作全部在本地完成，没有通过Lean CLI从QuantConnect云端下载任何数据


；我们使用公司的自有数据来填充Lean的数据文件。这满足了系统完全离线运行的要求。

数据准备完成后，AIS数据库会记录本次回测涉及的数据版本。例如，可以保存一份元数据：使用了哪些股票的数据、财务数据更新截至哪个财报日期等。这样有助于日后追踪结果和数据对应关系。如果以后基本面数据更新了，需要重新回测，AIS也可以据此判断是否需要刷新数据文件。

3. 策略回测执行

当策略代码和所需数据均已就绪，Claude便进入**“回测调度器”角色，通过回测执行技能**与Lean引擎交互来运行策略回测

。QuantConnect提供了Lean CLI工具，可在本地使用Docker容器执行回测。我们的技能将利用这一机制：通过调用操作系统命令行，在后台启动Lean引擎载入策略并运行。例如，回测执行技能可能执行如下命令：

lean backtest "FundamentalFactorAlgorithm" --data-folder ./Data --output ./Results


其中"FundamentalFactorAlgorithm"是策略项目名称或配置文件路径，--data-folder指定本地数据目录（也可以在Lean的config中预先配置），--output指定输出结果存放路径。Lean CLI接收到指令后，会拉起一个与QuantConnect云端环境一致的Lean Docker容器，在该容器中编译并运行我们的策略代码

。由于我们此前已将数据放在本地Data目录且Lean配置指向该目录，Lean将在完全离线模式下读取本地数据运行回测

。正如QuantConnect团队人员所述，我们可以无需登录QuantConnect账户就独立使用LEAN引擎进行本地回测，只要准备好本地数据

。Lean CLI在本地模式下不会尝试联网获取数据或验证账户，而是直接使用本地资源

。这确保了整个回测过程离线、自主，可控。

回测开始后，Claude的回测执行技能会监控Lean引擎的运行状态。例如通过实时读取Lean容器的输出日志，以获取回测进度或可能的错误。如果Lean引擎报出运行时错误（例如由于代码bug或数据缺失），Claude能够捕捉到异常信息。依靠技能内的逻辑，Claude可以尝试进行自动调试：例如，根据错误消息判断属于代码逻辑问题还是数据问题，分别调用不同技能处理——这类似于MCP中让AI自动读取最后一次回测错误并修改代码的功能

。例如，如果错误提示某字段未找到，Claude可能调用策略设计技能调整代码读取正确的数据字段；如果错误提示数据缺失，Claude可能调用数据适配技能补充相应数据。经过修改后再次执行回测，直至成功开始跑完整回测。这体现了AI代理的自我纠错能力，使系统更健壮。不过在正常情况下，本例策略准备充分，不会出现重大错误。

当Lean顺利跑完指定回测区间后，会输出结果文件。Lean CLI默认将回测结果保存为JSON格式文件，位于Lean项目目录下的backtests文件夹中，以时间戳或GUID命名的子文件夹内

。例如，假设项目名为FundamentalFactorAlgorithm，则可能生成FundamentalFactorAlgorithm/backtests/20231105_123456/result.json这样的文件（名称仅示意）。根据QuantConnect团队解释，本地执行的回测结果存储在<projectName>/backtests/<timestamp>/目录下的JSON文件中

。该JSON包含了和云端回测结果相同的数据结构，包括总体绩效统计（年化收益、夏普比率等）、每日资产曲线、每笔交易记录、算法的日志输出等


。

Lean引擎退出后，回测执行技能汇总运行信息：回测用时、多线程利用率等，可供分析优化。但主要的产出是结果JSON文件及日志文件。技能将这些回测产出登记到AIS数据库，例如将result.json路径保存，并关联该结果与本次策略版本、所用数据版本的信息。至此，策略已完成回测计算阶段，接下来进入结果分析阶段。

4. 回测结果分析

Claude现在扮演**“绩效分析师”角色，使用绩效分析技能**对Lean回测结果进行解析和总结。绩效分析技能的第一步是读取Lean生成的结果JSON文件

。技能内的Python分析脚本会打开JSON文件，将其中的数据载入，提取我们关心的关键指标和序列。通常需要关注的包括：

累计收益曲线：从JSON的charts或equity部分获取每个时间点的组合总价值，计算策略的累计收益曲线，并可与基准（如标普500）对比绘制。

业绩指标：JSON的statistics部分直接给出了主要绩效指标

。其中包括年化收益率（Compounding Annual Return）、总收益率（Total Return）、年化波动率、夏普比率（Sharpe Ratio）、最大回撤（Max Drawdown）、**总交易次数（Total Trades）**等。这些是评估策略表现的核心指标，分析脚本会逐一读取。


交易细节：JSON中可能有逐笔交易记录、每日持仓情况等。技能可进一步统计比如胜率（盈利交易占比）、盈亏比（平均盈利/平均亏损）等交易风格指标。

风险指标：如Beta、Alpha（相对于基准的超额收益）、卡玛比率等，部分Lean统计可能提供，若没有可由脚本基于收益曲线计算。

读取完数据后，Claude可以通过技能内置的计算函数对指标进行必要的计算和验证。例如：检查夏普比率的计算是否基于年化；计算策略的月度收益分布用于展示；如果需要，还可以计算额外指标如信息比率等。这些都在本地的分析脚本中按需进行。

在拿到丰富的分析数据后，Claude会组织自然语言总结报告。报告通常包括以下内容：

总体业绩概览：例如“策略在回测区间内取得了年化XX%的收益率，累计收益率YY%。同期市场基准回报ZZ%，策略表现优于/劣于市场。”，给出策略总体表现的评价。

风险调整后收益：报告夏普比率等指标，如“策略夏普比率为1.1，显示在承担单位风险下收益尚可”。最大回撤用来说明风险，比如“最大回撤为20%，投资组合最大跌幅适中”。

交易特征：如交易频率，“总共进行了N笔交易，月均换手率X%。盈利交易占比Y%，平均单笔收益Z%”。这些描述可以让读者了解策略换手和选股稳定性。

因子有效性分析（如适用）：因为这是基本面因子策略，Claude可能进一步分析哪个筛选条件对收益贡献大。例如，或可比较高ROIC股票与普通股票的表现差异，或检查组合中行业分布等。这属于深入分析，可在扩展技能中实现。本方案中可简单提及策略选股倾向于何类股票（如ROIC高的往往是消费行业等）。

改进建议（可选）：Claude可能指出策略的不足，如回撤较高时可以考虑加入风险管理模块；或者因子组合可以进一步优化阈值等。这体现AI主动优化的能力，但是否提出建议取决于用户需求。

除了文字总结，Claude还可以利用可视化工具生成图表。例如通过matplotlib绘制累计收益曲线图、月度收益柱状图、回撤曲线等，并保存图片文件。由于Claude技能可以执行代码并生成图表文件，完全可以实现在报告中嵌入图片
anthropic.com
anthropic.com
。如果最终用户界面支持，Claude会将图表直接嵌入输出报告，以供决策者参考。不过在我们的文档场景中，重点是设计流程，本方案先聚焦于文字分析结果。

一旦完成分析，Claude将分析报告保存到AIS数据库，并将核心结果反馈给用户。在AIS数据库中，此次回测的总结（包括文字报告和关键指标）都与策略版本关联保存，方便日后查询对比。用户这时收到的将是一份由Claude整理的详尽报告，涵盖策略在历史数据上的表现评估。整个过程无需人工干预，从代码生成到结果解读都是AI自动完成的。用户若有新的要求（比如调整筛选标准或更换回测区间），可以再次触发流程，Claude会重复上述过程进行新的回测和分析。

需要强调的是，整个集成流程的控制权在我们手中——所有Claude对系统的操作都经由技能定义的允许范围进行。例如Claude执行技能中的代码时，仅能访问被授予权限的文件路径（如数据目录），避免了安全风险
anthropic.com
。我们在Claude技能的YAML头中可以通过allowed-tools字段限制其可用工具和系统命令
docs.claude.com
。因此，即便Claude具有代码执行能力，我们也确保其行为在预期范围内（例如只能调用特定脚本或读取特定目录），这保证了系统运行的安全性和可控性。

综上，AIS和Lean的集成流程展示了AI技能与传统回测引擎相结合的强大威力：AI负责智能决策和灵活应用（编写代码、解释结果），而经典引擎负责高性能 deterministic 计算（执行严格的回测计算）。两者通过本地文件和指令接口无缝衔接，实现了从策略创意到绩效评估的端到端自动化。这种设计极大提高了量化研究的效率，让研究人员能更专注于策略思想本身，而将繁杂的实现和计算工作交由AI和算法引擎完成。

Claude角色识别与调用链控制机制

为了使上述复杂流程顺畅运转，系统需要一个角色识别与调用链控制机制，确保Claude在对话过程中能自动扮演恰当的角色、调用正确的技能，并严格按照既定顺序完成任务。这方面主要通过上下文理解和Agent配置来实现。

首先，Claude具备上下文意图识别能力，能够根据用户的请求内容判断需要执行哪些步骤。我们的AIS数据库中为典型任务场景定义了一套Agent流程配置（agents.md），相当于预先规划好的AI行为链路模板
eesel.ai
eesel.ai
。当Claude接收到用户指令时，会将其与这些预定义流程模板进行匹配，选择合适的执行链。例如：

如果用户提供的是一个全新的策略概念，Claude匹配到“策略研究完整流程”模板，知道需要经历“策略设计 -> 数据准备 -> 回测执行 -> 结果分析”这四个阶段，于是按照该顺序依次调用对应技能。

如果用户请求的是“请帮我回测已有的某策略代码”，Claude会识别不需要重新生成代码，直接跳到“数据准备 -> 回测执行 -> 结果分析”的流程，可跳过策略设计阶段。

如果用户提问“这次回测结果如何？”，Claude明白此时应处于结果分析阶段，只需调用绩效分析技能解释当前结果，而无需执行前面的步骤。

总之，Claude会利用对话上下文（包括用户话语以及先前步骤的状态）来动态决定自己的下一步角色。
claude.com
提到Claude在执行任务时会将相关技能元数据置于链路上下文中，事实上Claude的“思维链”中已经包含了技能描述，自动判断何时用哪个技能。我们的Agent配置则进一步充当了一个“流程蓝图”，指导Claude按照合理顺序串联技能。例如，我们可以在AIS数据库的Agent配置文件中写明：

任务：基本面策略回测
链路：
1. 策略设计（调用 StrategyDesigner 技能） 
2. 数据准备（调用 DataAdapter 技能） 
3. 策略回测（调用 BacktestScheduler 技能） 
4. 结果分析（调用 PerformanceAnalyzer 技能）


Claude在处理相关请求时，会将此作为行动计划参考，确保各步骤按序完成。这类似于传统Agents.md的作用——提供一套标准的、静态的操作说明供Agent遵循
eesel.ai
eesel.ai
。不同的是，我们将Agents.md与Skills.md结合起来使用：Agents.md样的流程配置提供宏观的步骤顺序和规则（确保一致性和不遗漏步骤）
eesel.ai
，
eesel.ai
, 而Skills.md提供具体执行每步的动态能力（让Claude能真正完成每步中的复杂任务）
eesel.ai
eesel.ai
。两者相辅相成，赋予Claude既有“章法”又有“技能”。

值得一提的是，一般来说Skills.md和Agents.md是分别用于增强单个AI能力和规范任意AI工具行为的两种思路
eesel.ai
eesel.ai
。传统上很少把二者直接结合，因为一个偏重封闭生态下能力扩展，另一个偏重开放指令标准
eesel.ai
，
eesel.ai
。但在我们的体系下，这种结合非常自然：我们需要Claude在特定封闭环境中具备高度专业能力（Skills.md实现），同时又需要它严格执行既定流程（Agents.md提供框架）。因此，我们采用Agent流程配置去控制调用链，实现一个既“能干”又“听话”的AI代理。

在实际执行中，Claude会在对话的系统提示或技能上下文中被赋予相应的角色身份标识。例如，当进入“策略设计”阶段时，Claude上下文会载入策略设计技能的描述，其中明确提示Claude现在充当量化策略设计师，任务是根据要求编写策略代码
docs.claude.com
。同样，在进入数据准备阶段时，Claude的上下文会包含数据适配技能的信息，指导其充当数据工程师。Claude善于遵循这些语境提示，表现出相应角色的口吻和行动。例如，作为策略设计师时它会重点问清策略要求、然后产出代码；作为数据适配器时会以执行脚本、报告数据情况为主；作为分析师时则用专业分析语言描述结果。这种上下文驱动的角色转换由技能描述和Agent配置共同促成，让单一的Claude模型能够一人分饰多角，完成复杂的链式任务
claude.com
。

为了确保调用链严格按顺序执行，我们还采取了一些控制措施：

阶段状态跟踪：AIS数据库可以维护一个当前任务所处阶段的状态变量。当Claude完成阶段1后，状态更新为2，这时它才能获取阶段2技能的触发条件。这样可避免Claude跳过某步骤或顺序错乱。

技能间衔接约定：我们在设计技能时，约定每个技能的输出会触发下一个技能的上下文。例如，策略设计技能在生成代码后，可以在对话中提示“策略代码已生成，准备数据并运行回测”。这样的输出提示包含“准备数据”“运行回测”等关键词，会自然触发Claude去调用数据适配和回测执行技能（因为这些技能描述中提到了在需要准备数据或运行回测时该做什么）。这相当于技能之间隐式传递信号，确保调用链流转不断裂。

错误中断处理：如果某一步出现异常（如前述Lean运行报错），Claude不会贸然进入下一步，而是先解决异常再继续。例如数据缺失导致回测失败，Claude不会继续结果分析，而是回到数据准备或策略设计阶段修正问题。只有当某阶段成功完成并给出正常输出，Agents.md流程才允许进入下一阶段。这样保证了调用链的可靠性和正确性。

通过上述机制，Claude作为代理能够严谨地按照我们设定的流程执行任务，一步一步地完成策略研究的各个环节。这种多角色多技能协同的能力正是Claude Skills的强大之处：主Agent Claude可以自主决定并协调多个子技能的使用，而我们通过适当的配置让它遵循特定顺序，把控整体流程
eesel.ai
eesel.ai
。最终效果是，用户只需给出高层指令，Claude就会在幕后按既定链路完成所有工作并产出结果，且每一步都有迹可循、有章可依。

示例：“高ROIC高增长低估值”策略全链路示范

为更加具体地说明系统如何运行，下面以“高ROIC，高增长，估值合理”策略为例，演示从策略设计到回测分析的完整自动化流程，并给出关键模块的伪代码和说明。

场景：假设用户提出需求——“设计一个选股策略，买入ROIC高、收入增长快且估值合理的股票，并对过去5年进行回测”。Claude将依据该指令自主完成整个研究过程。

步骤1：策略设计

用户的问题明确描述了策略筛选标准（高ROIC、高增长、低估值）。Claude读取问题后，启动策略生成技能进入“策略设计师”模式。Claude可能会先与用户简短澄清一些细节（如果不明确的话），例如：

ROIC的阈值是多少算“高”？假设Claude选择15%作为经验阈值（或询问用户确认）。

收入增长率用哪个周期？这里假设使用过去3年收入年均增长，Claude将此定义为>10%。

估值用市盈率作为指标，“合理”设定为PE低于20。

这些细节Claude可以根据常识自行假定合理值，也可以与用户交互确认。在没有进一步指示时，Claude通常会基于自己的金融知识选择行业常用标准（如ROIC>15%、三年营收CAGR>10%、PE<20这组标准）。

确定规则后，Claude开始编写策略代码。它利用技能中提供的Lean算法模板，很快生成了一个完整的策略类，类似前文模块化设计部分给出的伪代码结构。Claude会确保代码包含：

初始化设置回测时间段为过去5年（例如2018-01-01至2023-01-01），初始资金等。

Universe选股逻辑应用上述三个筛选条件。

调仓逻辑每月执行，使投资组合跟踪筛选结果的变化。

所需的库导入和Lean API调用等正确无误。

生成的代码类似于前面展示的FundamentalFactorAlgorithm示例。Claude可能对其中一些细节进行优化：例如选股时先做coarse筛选（如过滤低价股、低成交额股）以提高效率，然后再做fine筛选应用财务条件。这个逻辑在Claude输出的代码里都会体现。Claude还会遵循Lean框架要求，正确使用self.SetUniverseSelection()或AddUniverse接口来注册Universe筛选函数等。总之，代码将是结构完整且可以编译运行的。

生成代码后，Claude会将代码内容保存成文件，比如FundamentalFactorAlgorithm.py，并存入AIS数据库对应的项目记录中。它可能在对话中简要告知用户：“策略代码已完成，包含三个因子筛选条件。”

Claude 产出的策略代码片段示意：

class FundamentalFactorAlgorithm(QCAlgorithm):
    def Initialize(self):
        self.SetStartDate(2018, 1, 1)
        self.SetEndDate(2023, 1, 1)
        self.SetCash(100000)
        # 设置每日回看基本面数据
        self.AddUniverse(self.CoarseFilter, self.FineFilter)
        # ...
    def CoarseFilter(self, coarse):
        return [c.Symbol for c in coarse if c.Price > 5][:1000]
    def FineFilter(self, fine):
        selected = []
        for f in fine:
            if f.Fundamentals.OperationRatios.ROIC.Value > 0.15 \
               and f.FinancialStatements.IncomeStatement.RevenueGrowth.ThreeYears > 0.10 \
               and f.ValuationRatios.PERatio < 20:
                selected.append(f.Symbol)
        return selected
    def OnSecuritiesChanged(self, changes):
        # 调仓：对于新加入的股票，等权买入；移除的不再持有
        for sec in changes.RemovedSecurities:
            if sec.Invested:
                self.Liquidate(sec.Symbol)
        weight = 1/ len(changes.AddedSecurities) if changes.AddedSecurities else 0
        for sec in changes.AddedSecurities:
            self.SetHoldings(sec.Symbol, weight)


（注：以上代码为说明示例，实际Claude生成代码可能在细节上有所不同，但逻辑上应等价。）

在代码生成阶段，Claude还可能做一些验证，例如调用其内部的解释器检查语法。如果发现明显错误，它会立即修正后再输出。整个策略设计过程对于用户来说非常省心：他无需自己写任何一行代码，Claude已经根据要求准备好了可以运行的策略代码。

步骤2：数据准备

拿到策略代码后，Claude知道需要本地数据支撑筛选条件，于是转入数据适配技能。Claude会分析策略代码，确定需要股票日线价格和股票财务指标两方面的数据。其中价格数据用于模拟买卖交易，财务数据用于筛选条件计算。

Claude首先确定回测标的股票池。由于策略涉及全部满足条件的股票，理论上需要遍历整个市场。为了优化，策略里其实先限制了coarse范围，比如成交额前1000只股票。因此Claude预计筛选主要在这1000只里进行，于是重点准备这部分股票的数据。如果非常严格，也可以准备全市场数据再依次过滤（但考虑效率，Claude可能按照策略逻辑来）。

准备价格数据：Claude通过数据技能连接到公司行情数据库。它可能运行一条SQL查询，比如：

SELECT symbol, date, open, high, low, close, volume 
FROM DailyPrices 
WHERE date BETWEEN '2018-01-01' AND '2023-01-01' 
  AND symbol IN (选股范围内股票列表)


来提取所需股票在回测期间的日线行情。然后Claude调用技能中的数据导出函数，将查询结果写入本地Data/equity/usa/daily/目录下相应的CSV文件。例如，对于AAPL、MSFT等每只股票生成一个CSV文件。如果数据库支持批量导出为Lean格式文件，也可以直接使用。由于这一步或涉及大量数据I/O，Claude可能在内部输出一些日志，如“已导出1000只股票的日线行情CSV至Data文件夹”。

准备财务数据：Claude构建查询获取财务指标数据。例如：

SELECT symbol, fiscal_date, roic, three_year_revenue_cagr, pe_ratio 
FROM FundamentalMetrics 
WHERE fiscal_date >= '2015-01-01' 
  AND symbol IN (股票列表)


以覆盖2018-2023回测期所需的历史财务数据（一般至少从2015年起拿数据来计算三年增长率）。拿到数据后，Claude使用技能脚本将其转换为Lean FineFundamental JSON格式。具体而言，对于每只股票符号，创建一系列JSON文件，每个文件包含该股票某日期时的一套财务数据（roic, cagr, pe）。考虑到Lean通常使用每日快照，我们或可简化为每季度末一个文件。Claude按照Lean规范生成文件路径，如Data/equity/usa/fundamental/fine/AAPL/20181231.json等，并填入相应字段。

在转换过程中，Claude会正确映射字段：例如将ROIC填入JSON的OperationRatios.ROIC.Value，将三年营收增长填入IncomeStatement.RevenueGrowth.ThreeYears，将PE填入ValuationRatios.PERatio等。如果缺少某些字段，Claude会相应设为null或0以避免格式错误。这个映射逻辑在我们编写的数据技能脚本时已经确定，所以Claude只要按步骤执行即可

。

经过一番处理，Claude成功地在本地生成了所有需要的数据文件。Lean引擎现在完全可以在离线状态下使用这些数据运行我们的策略——当策略代码请求某股票的FineFundamental数据时，Lean会从Data/fundamental/fine目录加载我们刚刚生成的JSON数据，从而获得ROIC、增长率、PE等值；当策略需要历史行情计算投资组合价值时，会从Data/daily目录读取价格序列。

Claude在这个阶段可能向用户或日志反馈一句：“数据准备完成，共处理1000只股票的价格数据和财务数据。” 这表明所有必要的数据均已部署到位。

步骤3：执行回测

现在Claude进入回测执行阶段。它调用回测调度技能，通过Lean CLI启动回测。Claude执行命令：

lean backtest FundamentalFactorAlgorithm


Lean CLI随即在本地开始运行策略FundamentalFactorAlgorithm。Claude可以在对话的隐式链路中等待回测完成。在此期间，Claude并不会闲着：它会监视Lean的输出。Lean运行时会输出日志，包括每一步筛选通过的股票数、每笔交易执行情况等。Claude可能将这些日志暂存，以备分析使用。此外，它留意有没有错误或警告出现。

在我们的假设中，数据齐全代码正确，回测应顺利跑完5年历史。Lean完成后，将结果保存为如FundamentalFactorAlgorithm/backtests/20231105_123456/result.json的文件

。Claude检测到回测进程结束，日志最后有“Algorithm.Idle... Backtest complete”类似字样，于是确认回测已成功完成。

Claude的回测执行技能读取Lean CLI的退出状态码为0（表示成功），并找到结果JSON的路径。通常Lean CLI会在控制台输出结果文件路径，Claude可以从日志中提取。例如日志可能显示“Backtest results saved to .../result.json”，Claude据此定位文件。

为了严谨，Claude可能调用Lean CLI的lean report命令快速生成一次report，或者直接打开result.json验证其内容格式。如果结果文件很大（包含逐日数据），Claude不会试图一下子加载全部到对话中，而是在分析技能中逐步处理。因此在此阶段，Claude只需确认结果文件存在且完好。它将结果文件路径传递给下一阶段的分析技能，并更新AIS数据库中的任务状态为“回测完成，待分析”。

步骤4：结果分析与总结

Claude现在最后切换到绩效分析角色，启动分析技能读取结果。它用Python脚本打开result.json，提取里面的统计数据。我们假设result.json中的statistics部分包含以下内容（示例数据）：

"statistics": {
    "Total Trades": "24",
    "Compounding Annual Return": "12.4%",
    "Average Win": "5.1%",
    "Average Loss": "-3.8%",
    "Sharpe Ratio": "1.08",
    "Max Drawdown": "-18.5%",
    "Annual Standard Deviation": "0.15",
    "Loss Rate": "40%",
    "Win Rate": "60%",
    ...
}


Claude解析出这些字符串并转换成数值。例如年化回报12.4%，夏普1.08，最大回撤18.5%，胜率60%等。然后Claude将每日净值曲线从equity或chart部分取出，计算累计收益率（应该和12.4%年化对应），还可以计算每年的独立收益率用于分析稳定性。

拿到这些数据后，Claude开始撰写文字报告。以下是Claude可能给出的总结（中文由Claude拟写给用户）：

策略回测绩效总结： 在2018年至2022年的5年回测期间，策略实现了累计80%的收益，相当于年化收益约12.4%

。相比之下，同期标普500指数年化涨幅约为10%，本策略略微跑赢大盘。策略收益波动适中，年化波动率约15%，夏普比率为1.08，显示获得每单位风险收益略优于市场平均水平。
策略最大回撤约为18.5%

，发生在2020年一季度市场下跌期间。这一回撤幅度低于市场同期（标普500当时回撤约30%），表明策略选股在下行行情中相对抗跌。
策略共进行了24笔交易

，平均每季度调仓一次，换手率较低，交易成本影响可忽略。胜率为60%，单笔交易平均盈利**+5.1%，亏损-3.8%**

。盈利交易占多数且盈亏比适当，表明筛选出的股票总体表现积极。
选股方面，高ROIC和高增长条件使策略偏好行业领先的优质公司，如科技和医疗领域的龙头股，这些股票在回测期内贡献了主要涨幅。而估值合理条件避免了泡沫型股票，降低了回撤风险。从因子有效性看，高ROIC因子确保组合公司盈利能力强，提供了一定的防御性；高增长因子带来超额收益来源。
结论： 本策略在历史测试中取得了稳健的绝对和相对收益，验证了“高质量成长+合理估值”投资逻辑的有效性。不过，需要注意策略主要持股集中于少数行业，未来可考虑引入行业分散化措施以降低特定行业风险。另外，最大回撤仍有18%，若投资者风险偏好低，可进一步加入风险管理模块（如动态止损或资产类别对冲）以平滑回撤。总体而言，该策略展示出良好的风险收益特征和选股能力，可作为长期投资策略的有益参考。

上述报告综合了定量指标和定性分析，由Claude根据计算结果自动生成。其中引用的数值均来自回测结果JSON的统计

。Claude不仅罗列了指标，还进行了对比（和大盘、市场环境比较）和解释（因子作用、行业倾向），展现出类似人类分析师的洞察。这得益于Claude内置的金融常识和我们提供的分析模板。在AIS数据库的技能文档中，我们可能准备了一些报告模板句型，例如“夏普比率为X，显示…”、“最大回撤Y%，表明…”，Claude在写报告时可以套用这些模板并填入对应数值，从而快速形成专业表述。

报告完成后，Claude将其发送给用户，同时在AIS数据库存档。用户此时收到这份详尽的回测报告，整个过程圆满结束。从最初需求到最终报告，用户未显性参与中间任何技术环节，所有工作均由Claude自动协调完成。这正体现了本系统设计的初衷：让AI代劳繁杂的策略研究实现工作，研究员只需关注策略想法本身。

最后，若用户对结果有新的要求，例如“如果只筛选ROIC更高（如>20%）会怎样？”或“把回测区间延长到10年看看”，Claude可以根据新的指示再次运行部分流程。它会聪明地重复利用已有成果：比如只需修改筛选阈值然后重新跑回测，或扩展数据然后回测。这种迭代过程在我们的系统中也被高度自动化——AIS数据库保存的每次回测结果可供比较，Claude可以直接对比两次回测指标并告诉用户变化。这种快速迭代能力将大大加速策略调优过程。

结论

通过以上设计，本地部署的自动化基本面策略研究与执行系统得以实现。它融合了Claude大模型的自然语言理解和推理优势，与Lean算法引擎的严谨回测能力

。系统在完全本地环境下运行，保证了数据安全性；同时凭借Claude Skills体系，使AI具备专业的量化研究技能，自动完成策略开发的各个环节
claude.com
eesel.ai
。模块化的策略架构保证了逻辑清晰和易扩展性

，AIS数据库作为中枢实现了技能、代码、数据、结果的统一管理和调度。Claude能够根据上下文自动切换角色并调用相应技能，借助预设的Agent配置严格遵循研究流程，确保每一步有序衔接
eesel.ai
eesel.ai
。最终，系统能够以接近零人工介入的方式，从策略构思到回测报告端到端地产出成果。

这种新型研究流程大幅提高了量化策略研发的效率和智能化程度。研究人员可以将精力集中在提出创意和决策上，而繁琐的实现、数据处理和分析工作交由AI助手完成。不仅如此，随着使用积累，AIS数据库中的策略模块和技能库会不断丰富，Claude对公司专有数据和策略偏好的理解也会加深，未来将能胜任更复杂的策略研究任务。例如，我们可以扩展技能去支持参数优化（AI自动调参、多次回测挑选最优参数集）甚至实时交易执行（连接本地交易接口下单），构建一个真正智能化的本地量化交易系统。

综上所述，本方案充分利用了Anthropic Claude的Skills机制和QuantConnect Lean的本地回测能力，创造性地将二者融合

。通过系统结构、模块拆分、技能路由、调用链控制等精心设计，我们达成了用户最初的目标：在本地实现一个自动化的基本面策略研究与执行系统，既确保数据自主可控，又大幅提升了研发效率，为量化投资研究带来革命性的流程优化。
eesel.ai
eesel.ai

基于Claude Code和AI Skills的本地量化策略平台设计
系统概述

本方案设计一个完全本地部署的自动化基本面量化策略研究与执行平台。平台以Claude Code作为智能调度核心，利用AI Skills（AIS）系统管理模块化技能，调用成熟的量化工具库完成策略构建、回测和优化。底层集成了金融量化常用的开源组件：Backtrader用于回测交易策略，Alphalens用于因子绩效评估，PyPortfolioOpt用于投资组合优化。Claude Code能够根据任务上下文自动识别所需的Agent角色（如“策略构建器”、“因子评估器”、“回测引擎”、“组合优化器”、“绩效分析师”等），并从AIS技能数据库中加载相应技能文档和代码，按顺序协同完成复杂的量化研究流程。

系统的目标是在本地环境下实现一个一体化的量化策略研究与执行平台。从策略因子定义、信号生成、历史回测，到绩效分析和投资组合建议，全流程由Claude Code统筹自动完成。所有的策略逻辑、技能文档、因子配置、参数设置以及运行结果，都集中存储在AIS数据库中，以实现统一管理和可复用。在设计上，系统将以“高ROIC、高增长、估值合理”这一基本面选股策略为示例，完整展示Claude Code如何调用底层各模块依次完成因子构建、信号生成、回测执行、绩效分析和组合优化建议的过程。

下面将详细描述系统架构、技能模块设计、Agent模板机制、AIS数据库方案，以及模块间的通信流程和调用顺序，并辅以关键代码结构或伪代码示例说明Claude Code如何将策略意图转化为具体的工具调用序列。

系统架构

图1：Claude Code调度AI Skills与量化库的系统架构示意图。中央蓝色节点是Claude Code智能调度器，它基于任务需求依次调用周边的各个技能模块（黑色实线箭头标注了调用顺序）。每个技能模块封装了特定功能（策略构建、因子评估、回测、绩效分析、组合优化），内部使用相应的开源库实现。底部的AIS数据库（圆柱形）集中存储所有技能说明、数据以及阶段性结果，各技能通过虚线箭头与数据库交互进行数据读写和结果缓存。Claude Code在调用技能时也会从AIS数据库加载技能文档等上下文。该架构实现了策略研究全流程的自动化和模块化。

如图1所示，系统由以下核心组件构成：

Claude Code智能调度器：基于大型语言模型的智能Agent，负责理解用户的策略需求，规划任务流程，并驱动各模块协同工作。Claude Code通过Anthropic的Agent Skills机制，将复杂任务拆解为可组合的技能调用序列
claude.com
。在执行过程中，Claude Code会扫描可用的技能集合，匹配与当前任务相关的技能，并按需加载相应的最小信息和文件，从而保持高效的上下文利用
claude.com
。Claude Code能够自动识别需要哪几个技能并协调它们的使用顺序
claude.com
。借助技能系统，Claude Code不仅调用工具接口，更像是被赋予了一整套完成任务的专业知识和脚本执行能力——“不仅仅是调用API，而是教会Claude完整的工作流程”
ikangai.com
。在本平台中，Claude Code通过Skills机制加载量化分析相关的技能文档与代码模块，驱动后续的数据处理和计算。

AIS技能数据库：即AI Skills系统的本地数据库（或文件库），存放所有定制的技能模块及其说明文档、代码脚本、模板和相关资源。每个技能都封装在一个文件夹中，其中包含一份SKILL.md说明（描述该技能的用途、输入输出、调用步骤等）以及可能的辅助脚本或资源文件
claude.com
。AIS数据库还承担数据和结果存储的职责：例如因子定义、策略参数、市场数据、回测结果、评估指标、优化结果等都保存在此，方便技能模块读写和跨模块共享。通过集中管理，Claude Code可以根据需要自动调用技能并访问相关数据，并且对重复任务可使用缓存的结果来提高效率。

量化技能模块：围绕Claude Code调度器，部署了若干模块化技能（Skill），每个技能负责量化研究流程中的一个步骤。技能模块的内部由相应的Python库实现专业功能，但对外通过AIS技能接口暴露统一的调用方式。主要的技能模块包括：

策略构建器：解析用户的策略描述，定义所需的因子和选股/交易规则。它提取诸如ROIC、增长率、估值等因子定义，并根据需求确定交易信号的生成逻辑（例如筛选条件或打分排名）。该模块可能使用预置的因子公式库，并与数据库交互获取必要的原始财务数据或已有因子信息。

因子评估器（Alphalens）：利用Alphalens库对所选的因子进行历史效果评估。Alphalens是Quantopian开源的用于评估预测因子绩效的库，可计算因子与未来收益的相关性（信息系数）、分层分组的收益差异、因子IC的累计值等
quantopian.github.io
。本技能会从数据库读取因子值和对应时期的资产价格数据，通过Alphalens的get_clean_factor_and_forward_returns等工具将因子与后续收益率合并分析，并生成完整的因子“tear sheet”报告
quantopian.github.io
quantopian.github.io
。评估结果（如各分位数收益、IC时间序列、因子换手率等）会存回数据库。

回测引擎（Backtrader）：负责根据定义的策略逻辑进行历史回测模拟交易。Backtrader是功能丰富的Python量化回测框架，使研究者能专注于编写交易策略和分析而非底层系统搭建
backtrader.com
。该技能模块会从数据库获取历史行情数据（价格、财务指标等）以及策略规则（选股信号或买卖条件），然后利用Backtrader框架运行回测。通过实现自定义的Strategy类或信号机制，将因子信号转化为具体的买卖决策，在历史数据上模拟投资组合的调仓和盈亏。Backtrader支持同时处理多只股票的数据馈送、设置交易费用和滑点、评估指标等
blog.quantinsti.com
。回测完成后，将交易记录、投资组合价值序列、收益率曲线以及基础绩效指标保存至数据库。

绩效分析师：对回测结果进行深入分析和汇总。该模块读取回测产生的时序结果与交易日志，计算策略的关键绩效指标（如累计收益、年化收益率、夏普比率、最大回撤、Alpha和Beta等）。如果需要也可结合PyFolio等工具进一步生成风险分析报告
goodnovel.com
。本技能旨在将海量的回测输出提炼为易于解读的统计指标和图表。分析结果存入数据库，并用于后续报告生成。

组合优化器（PyPortfolioOpt）：利用PyPortfolioOpt库根据因子信号或历史数据进行投资组合权重优化。PyPortfolioOpt是一个用户友好的投资组合优化库，覆盖了从经典的均值-方差优化到更先进的分层风险平价等多种方法
goodnovel.com
。在本模块中，可使用回测得到的资产历史收益率计算协方差矩阵，以及基于因子评分推算的预期收益率
pyportfolioopt.readthedocs.io
。然后调用Efficient Frontier等类实现给定约束下的最优权重求解，例如最大化夏普比率或最小化风险
pyportfolioopt.readthedocs.io
。PyPortfolioOpt具备内置的预期收益率估计方法（如历史平均收益率、CAPM等）和风险模型（如Ledoit-Wolf收缩协方差）以辅助计算
pyportfolioopt.readthedocs.io
pyportfolioopt.readthedocs.io
。优化器模块会输出建议的资产配置权重，并存入数据库，以供最终报告或实际投资参考。

用户接口/输出：用户以自然语言或配置文件形式输入策略意图（例如：“构建一个高ROIC、高增长且估值合理的选股策略”）。Claude Code解析需求后，通过上述各模块的协作完成策略研究，并最终向用户输出结果报告和策略建议。这份输出可能包括：因子分析的关键结论、回测绩效摘要（收益曲线、指标表格）、优化后的投资组合权重，以及相应的可视化图表等，帮助用户直观了解策略的有效性和投资组合方案。

整个系统架构强调模块化和自动化：Claude Code通过AI Skills机制将领域知识与代码执行结合在一起，实现对各专业模块的智能调用
ikangai.com
。技能模块彼此独立又通过AIS数据库共享数据，方便替换或复用。例如可以扩充新的因子评估方法或不同回测引擎，而无需改动调度逻辑。所有组件均本地运行，无需依赖外部云服务，从而保证数据隐私和研究环境的可控性。

技能模块设计

技能（Skill）模块是系统功能的基本单元，每个技能封装一个相对独立的子任务逻辑。AIS数据库中的技能通常按照文件夹组织，每个技能文件夹包含技能说明文档（SKILL.md）以及实现该技能所需的代码脚本、模板或资源文件等
claude.com
。这种设计使技能具有良好的自描述性和可移植性：技能文档详细说明了模块的用途、接口、以及内部步骤，Claude Code可以在需要时读取这些说明并据此指导自己的行为；而代码脚本提供了可靠的可执行函数，避免复杂逻辑完全依赖大模型的生成质量。

一般来说，一个技能模块的结构如下（采用“策略构建器”技能为例）：

skills/
└── strategy_builder/              ← 技能名称作为文件夹
    ├── SKILL.md                 ← 技能说明文档，定义元数据和操作指南
    ├── strategy_builder.py      ← 实现策略解析和因子定义的主脚本
    └── factor_formulas.py       ← 可能的辅助模块，如常用因子公式库


SKILL.md文档采用简明的Markdown格式，通常在顶部以YAML或类似格式给出元数据描述，然后是对技能的功能说明、使用方法步骤，以及示例代码片段等内容。例如，因子评估器技能的说明文件可能类似：

---
name: factor_evaluator
description: Evaluate the predictive power of a factor using Alphalens
inputs:
  - factor_data: DataFrame of factor values for each asset and date
  - price_data: DataFrame of asset prices (for forward returns calculation)
outputs:
  - factor_analysis: Key metrics (IC, returns by quantile, etc.) and charts
---

## Usage
1. Load factor values and corresponding pricing data from the AIS database.
2. Use `alphalens.utils.get_clean_factor_and_forward_returns` to compute forward returns and align the data:contentReference[oaicite:19]{index=19}.
3. Call `alphalens.tears.create_full_tear_sheet(factor_data)` to generate a comprehensive analysis of factor performance:contentReference[oaicite:20]{index=20}.
4. Save the resultant statistics and plots to the AIS database for reporting.


上述SKILL.md片段在人类可读的形式下，清晰定义了技能名称、用途描述、输入输出以及具体的操作步骤。Claude Code在调用该技能时，会加载此说明作为上下文提示，明确要执行的任务和步骤。由于技能文档包含了使用Alphalens的精确指令和函数调用示例（如get_clean_factor_and_forward_returns和create_full_tear_sheet的用法），Claude能够可靠地生成相应代码并利用安全的执行环境运行这些代码，从而得到所需结果
claude.com
。这一机制体现了技能系统设计的“知识渐进披露”原则：Claude最初只知道技能的概要描述（元数据），在需要用到时才加载详细说明和代码，使模型既拥有无限扩展的能力又不至于被无关信息干扰
ikangai.com
ikangai.com
。

每个技能模块内部的代码通常以Python实现，可通过Claude Code的Code Execution Tool在隔离环境中执行
claude.com
。技能代码尽可能封装独立的功能，例如：

策略构建器的代码可以解析自然语言的策略描述，将其映射为具体的因子和规则配置。

因子评估器的代码会按照技能文档指示，调用Alphalens库完成因子分析计算，并将结果数据结构化。

回测引擎技能的代码利用Backtrader框架，可能定义一个继承自bt.Strategy的类来实现策略，在next()方法中读取AIS数据库传入的信号或阈值，然后执行买卖下单逻辑，最后通过cerebro.run()运行回测
backtrader.com
。

绩效分析技能可能会调用Pandas或PyFolio，对回测得到的收益序列进行统计分析和可视化
goodnovel.com
。

组合优化技能的代码将封装PyPortfolioOpt的调用，例如通过expected_returns.mean_historical_return计算预期收益率，risk_models.CovarianceShrinkage计算协方差矩阵，然后利用EfficientFrontier求解最优权重
pyportfolioopt.readthedocs.io
pyportfolioopt.readthedocs.io
。

设计技能模块时遵循以下原则：

单一职责：每个技能只聚焦完成流程中的一个明确任务，便于Claude Code按需组合调用
claude.com
。这提高了技能的复用性，例如“因子评估”技能可以被不同策略共享使用。

模块隔离：技能之间通过AIS数据库交换数据，不直接相互调用，减少耦合。Claude Code充当唯一的调度者，确保了各技能的调用顺序和数据流转是可控的、透明的。

可测试性：由于技能有独立的代码，实现上可以单独调试和测试。例如可对“组合优化”技能提供样本数据检查其输出正确性。这也有助于Claude Code更可靠地利用这些技能，降低了端到端出错的可能性。

文档自包含：每个技能的SKILL.md都提供足够的信息，让没有上下文的阅读者（或AI模型）也能明白如何使用它完成任务。这种清晰的文档在Claude自动组合多个技能时尤为重要，确保模型理解每一步的目的和方法
claude.com
。

代码与说明协同：技能文档中的伪代码或示例，与实际代码实现是对应的。Claude Code可以一边参考说明一边调用或执行代码。例如，在Alphalens技能中，Claude既从文档了解要“计算IC和分位数收益”，又通过执行脚本直接获得这些数值。这种知识和执行的“双保险”大大提高了系统健壮性
ikangai.com
。

综上，技能模块结构使得知识、代码和数据三者融合：技能文档教会Claude专业知识和使用工具的步骤，代码实现提供可验证的执行，AIS数据库连接数据资产，实现真正的端到端自动化量化分析。这种模式类似于为Claude安装了一系列“插件”，每个插件让Claude具备一种新的专长
claude.com
。正如Anthropic官方所述：“技能让Claude成为你关心领域的专家”
claude.com
。在本系统中，通过精心设计的量化分析技能，Claude Code就成为了一名专业的量化研究员，可以自主完成复杂的基本面选股策略研究。

Agent角色与调度机制

Claude Code作为中枢大脑，会根据任务需要切换不同的Agent角色来调用相应技能模块，仿佛具备多位专长各异的助手。系统采用Agent.md模板机制来规划和指导这些角色的执行。所谓Agent.md，可以理解为Claude Code用来 orchestrate 整个任务的一份内部计划或剧情脚本，它以结构化的方式罗列了各个阶段要扮演的角色、调用的技能和数据流转。这份模板既可以是隐式形成于Claude Code的Chain-of-Thought中，也可以存储在AIS数据库作为某种workflow配置。

Agent.md模板通常包含：

角色清单：列出本任务需要的Agent以及它们的职责。例如在本策略示例中，会有“策略构建器Agent”、“因子评估Agent”、“回测执行Agent”、“绩效分析Agent”、“组合优化Agent”等。

调用顺序：以序号或流程图形式定义各Agent执行的前后关系。例如：

策略构建器：解析策略描述，输出因子定义和选股规则 -> 存入AIS数据库。

因子评估器：读取因子定义和历史数据，评估因子有效性 -> 结果存入数据库。

回测引擎：根据规则读取数据并模拟交易 -> 保存回测结果。

绩效分析师：读取回测结果计算指标 -> 保存分析结果。

组合优化器：读取资产历史数据及因子信号，计算最优投资组合权重 -> 保存权重方案。

报告生成：汇总以上结果，输出最终报告。

数据依赖：声明每个阶段所需的数据来自何处、产出数据提供给后续哪一步。例如“因子评估Agent需要策略构建Agent提供的因子列表和数据库中的价格数据”。

技能映射：指定每个Agent应使用哪个技能模块。例如策略构建器Agent对应调用strategy_builder技能，因子评估Agent对应factor_evaluator技能，等等。

参数与配置：给出在本任务中各技能需要使用的参数或设定。例如回测的起止日期、初始资金、再平衡频率等，也可以包括优化器的目标函数（如最大夏普）等。

Claude Code在生成Agent.md（可以是实际文件也可以是内部规划表示）时，会结合用户的具体策略需求定制上述内容。例如对于“高ROIC高增长估值合理”策略，Agent.md会特别注明涉及的具体因子名称和选股条件等，从而指导后续模块精准执行。Agent.md实际上扮演了工作流脚本的角色：Claude Code依照这个脚本扮演不同专家，按序调用技能并处理数据，就像导演按照剧本调度演员完成一场戏。

值得注意的是，在Anthropic的Claude Skills框架下，多Agent的配合是通过技能组合实现的
claude.com
。Claude会自动推断需要哪些技能配合，比如既然有回测就可能需要性能分析和优化，于是相应技能一并被加载
claude.com
。Agent.md模板可以被视作对这种隐式推理的显式表示，以确保流程清晰可控。在实际运行中，Claude Code可能不会真的创建多个并行的子模型Agent，而是以单一Agent通过逐步调用技能来完成所有角色的任务。但为了逻辑上易于理解，我们描述为Claude Code在不同步骤化身为不同角色专家。

下面通过策略示例的流程，来具体说明Agent调度和技能调用的顺序与通信。

模块通信流程与调用顺序

基于上述架构和技能设计，我们以**“高ROIC，高增长，合理估值”策略为例，演示从任务开始到最终输出，各模块的调用顺序和数据流。整个流程可分为多个阶段，Claude Code依次触发，相当于流水线**作业：

策略解析（策略构建器Agent）：接收到用户输入的策略需求描述后，Claude Code首先扮演“策略构建器”角色，调用AIS数据库中的strategy_builder技能模块。该技能将**“高ROIC、高增长、合理估值”**解析成具体的因子定义和选股逻辑：

定义因子1：ROIC（投入资本回报率）。可能选取最近一年的净利润除以平均投入资本，或采用财务数据库中的ROIC字段。

定义因子2：增长率。可选用过去若干年营收或利润的年复合增长率，或最近一年的同比增长。

定义因子3：估值指标。为体现“合理估值”，可以选取市盈率（PE）、EV/EBITDA等的倒数（收益率）作为因子，使较低估值对应更高因子值。

确定选股条件：例如同时满足ROIC和增长率处于市场前25%分位，且估值因子处于前50%（即估值低于中位数），或者综合以上因子构建一个加权评分，对股票排序后选取前若干名。

策略构建器技能会访问AIS数据库中的因子库获取计算这些因子所需的基础字段数据（如财报数据），或公式模板（如计算ROIC的通用公式）。通过技能文档中的指引和嵌入的公式脚本，Claude Code可执行相应代码将原始数据转化为标准化的因子数值序列，并存储回AIS数据库。例如：

# 伪代码：计算所需因子并存储
roic = calc_roic(financials)       # 计算每季度ROIC
growth = calc_cagr(revenue, 5)     # 计算5年收入年化增长率
ey = 1 / get_PE_ratio(prices, eps) # 估值因子：收益率=1/PE
store_factor("ROIC", roic)
store_factor("Growth", growth)
store_factor("Valuation", ey)


Claude Code根据用户意图已经在此阶段将策略意图转化为量化因子。生成的因子序列以及筛选条件逻辑会记录在AIS数据库。例如数据库中建立一条策略记录包含：因子名称列表，筛选条件函数或阈值，调仓频率（如每季度调整一次），最大持股数等。这样后续模块都能共享这一策略配置。

因子预测能力评估（因子评估器Agent）：Claude Code接着扮演“因子评估器”，调用factor_evaluator技能来检查所选因子的历史有效性。这一步旨在验证“高ROIC、高增长、低估值”是否真的带来超额收益，以避免无效因子导致策略失败。

因子评估技能会从AIS数据库取出步骤1计算并存储的因子值序列，以及对应的资产历史价格数据。随后利用Alphalens库对每个因子进行分析。典型过程包括：

数据整理：通过alphalens.utils.get_clean_factor_and_forward_returns函数，将因子值与后续一定期（月度/季度）的资产回报率合并，对每个日期将股票按因子值分层（如五分位），计算各层组合的平均后续收益
quantopian.github.io
。这一步会返回一个factor_data结构，包含因子值、对应的未来N期收益、分位数分组等信息。

因子表现分析：调用alphalens.tears.create_full_tear_sheet(factor_data)生成完整的因子报告
quantopian.github.io
。这会计算输出一系列关键信息，包括：

平均分组收益率：例如最高ROIC组的股票平均比最低ROIC组每期多获得多少收益。若“高ROIC”因子有效，我们预期最高组累积超额收益为正且显著。

信息系数（IC）：因子值与未来收益的相关系数序列。如果IC均值为正且t统计显著，说明因子有预测能力
quantopian.github.io
。

因子换手率：评估因子稳定性，例如每期有多少股票进出前分组。

分行业IC或收益：如果技能文档配置了按行业检验，则Alphalens也会给出因子在不同行业内的表现以判断其稳健性。

相关可视化图表，如IC随时间的曲线、每个分位数组合的累计收益曲线、因子分布直方图等。

结果解读：Claude Code读取Alphalens的结果，结合技能文档中的解读提示，提取出对于策略构建有用的结论。例如发现“高ROIC”和“高增长”单独都有正的IC，说明确实预示正向回报；“估值因子”的IC为正也表明低估值的股票后续表现更好
goodnovel.com
。如果某因子效果弱（IC接近0），Claude可能记录一个警告用于报告，但流程仍可继续。

评估结束后，因子分析的关键数据和图表对象将存入AIS数据库。例如存储因子IC时间序列、平均分组收益表、各图表数据等，以备报告生成或进一步使用。通过因子评估这一环节，系统确保策略采用的信号具有合理的历史依据——如社区经验所言：“alphalens...帮助验证你的策略”
goodnovel.com
。如果结果表明因子无效，Claude Code可能在报告中提醒用户该策略可能不具备Alpha，但不会中断流程，以便让用户看到完整流程表现。

信号生成与选股：在因子验证通过后，Claude Code会进入信号生成阶段。这一步其实是策略构建器Agent逻辑的延续，或者可以视为一个独立的“信号生成Agent”，负责根据因子数据确定具体的交易信号和选股清单。

具体而言，Claude读取AIS数据库中存储的因子值以及设定的选股条件，生成每个调仓日的投资组合名单。例如：

确定调仓频率：假设策略每季度调整一次，那么以每季度末的财报数据计算当期因子。

每个调仓日，对全部股票按因子规则筛选：如选出同时满足ROIC和增长率均排名在前25%的股票集合，然后在其中再选取估值因子排名前50%的股票作为最终组合。如果组合数量过多，或可进一步按某综合评分排序选出前20只股票作为持仓。

生成买卖信号：与上一期持仓相比，新增的股票为买入信号，被剔除的股票为卖出信号，维持的持仓继续持有。

这些信号可以表示为一个时间序列结构。例如在AIS数据库中记录一个signals表，其中每个调仓日期有相应股票列表及其目标权重（初始可设等权，或按某因子分数加权）。Claude Code将此信号数据准备好供回测模块使用。

注：在很多量化框架中，信号生成往往和回测集成在一起（策略代码直接产生买卖操作）。但在我们的设计中，为了清晰和模块化，将信号逻辑提前计算并存在数据库，这样回测引擎只需读取信号执行交易，从而简化策略在回测模块中的实现难度。

历史回测执行（回测引擎Agent）：现在Claude Code以“回测引擎”Agent身份调用backtester技能模块，利用Backtrader框架对策略进行历史表现模拟
backtrader.com
。回测模块会从AIS数据库获取：

价格数据：所涉及市场的历史价格序列（通常包括每日收盘价，可能还需要体量用于计算容量，但本策略主要基于选股，不强调交易频率高的问题）。这些数据可以事先载入AIS数据库的行情数据区，格式为Pandas DataFrame或Backtrader的DataFeed等。

交易日历：用于指导Backtrader按一定频率执行调仓。假如每季度末调仓，则需提供这些调仓日期列表给策略。

初始资金和交易成本设定：例如初始资金100万元，单边交易佣金万分之二等，由策略默认参数或用户配置决定。

信号/选股清单：即上一步生成的每期应持有的股票及权重列表。

在Backtrader框架中，一般通过定义一个Strategy子类来实现交易逻辑。我们的技能脚本可能动态生成一个这样的类，核心逻辑是在每个调仓日调整持仓。例如伪代码：

class FundamentalStrategy(bt.Strategy):
    def __init__(self):
        # 从AIS数据库加载信号表，保存为字典 {date: {stock: weight, ...}, ...}
        self.signals = load_signals()
    def next(self):
        current_date = self.datas[0].datetime.date(0)
        # 检查是否为调仓日
        if current_date in self.signals:
            target_portfolio = self.signals[current_date]
            # 卖出不在新组合的股票
            for pos in self.getpositions():
                stock = pos.data._name
                if stock not in target_portfolio:
                    self.close(data=pos.data)
            # 买入/调仓新组合股票
            for stock, weight in target_portfolio.items():
                data = self.getdatabyname(stock)
                allocation = weight * self.broker.getvalue()
                self.order_target_value(data=data, target=allocation)


上述逻辑每到预定调仓日，卖出不再满足条件的股票，买入新选中的股票，按预设权重分配资金（这里采用等权或信号权重）。Backtrader引擎会每日推进next()函数，并在遇到我们指定的调仓日时执行换仓操作，从而忠实模拟策略在历史上的交易。整个回测过程中，Backtrader会跟踪投资组合的净值变化、交易执行情况等。

一旦cerebro.run()完成模拟，回测结果将输出到AIS数据库，包括：

净值序列：每个交易日组合总资产价值，用于计算收益率曲线。

交易日志：所有买卖操作记录（日期、股票、数量、价格等）。

仓位变化：每期持仓列表的变动情况。

基本绩效指标：Backtrader可以通过内置分析器或者由我们计算得到一些指标，比如年化收益、最大回撤等
backtrader.com
。但更全面的指标留待下一步分析。

此时，我们已经在本地对策略进行了严格的历史检验。借助Backtrader强大的回测功能，我们避免了繁琐的框架开发，将精力集中在策略逻辑本身
backtrader.com
。值得一提的是，在量化社区常用组合中，Backtrader与PyPortfolioOpt、Alphalens常被搭配使用：前者负责回测策略，后两者负责优化和分析，使研究流程闭环
goodnovel.com
。我们的设计正体现了这一点。

绩效分析与评价（绩效分析师Agent）：紧随回测结束，Claude Code化身“绩效分析师”，调用performance_analyzer技能来对回测输出进行深入分析、汇总报告。该模块主要关注将繁杂的日度数据转换为直观的绩效指标和图表，帮助理解策略表现。

分析师技能从AIS数据库获取净值序列和交易日志，计算例如：

累计收益率：策略全期的总回报，相比基准（如市场指数）的超额收益。

年化收益率：标准化衡量收益水平。

波动率：年度化标准差，衡量风险。

夏普比率：用年化收益减无风险利率除以波动率，评估风险调整后收益。

最大回撤：历史净值从峰值回落的最大跌幅，代表策略可能承受的损失幅度。

Calmar比率、索提诺比率等：其他风险收益指标（如果需要）。

仓位及换手：平均持股数量、组合换手率，评估交易频率和成本影响。

这些指标许多Backtrader本身或其集成的analyzer（例如PyFolio集成）已支持
backtrader.com
。我们的技能可以直接使用Backtrader的分析结果，或借助PyFolio库将回测结果转换成专业的分析报告
backtrader.com
。例如，通过PyFolio可以生成涵盖多种指标的tear sheet，包括收益分布图、rolling beta、年度收益热力图等。本设计中未单独引入PyFolio模块，因Backtrader和Alphalens的组合已提供了足够的分析。但如果需要，也可在技能中利用PyFolio来丰富报告内容
goodnovel.com
。

此外，绩效分析师会关注策略在不同市场环境下的表现，例如牛市熊市各自的收益率，或分年度的收益情况。如果AIS数据库中存有基准指数数据，技能可以对比策略与基准的相对表现曲线。

分析结果以结构化形式保存回AIS数据库（如JSON或表格形式的报告摘要）。同时，一些关键图表如净值曲线、回撤曲线也会保存（可以是matplotlib生成的图片文件）。这些内容为下一步最终报告输出做好准备。

投资组合优化（组合优化器Agent）：在很多基本面策略中，最终投资组合往往可以通过优化来进一步提升风险收益特性。Claude Code因此会调用portfolio_optimizer技能，利用PyPortfolioOpt对策略得到的持仓进行优化建议。

在我们的示例策略中，每期调仓时原本采用等权或基于因子排序的权重。但组合优化器可以根据历史统计数据，重新计算更优的权重配置。例如：

输入数据：策略最终选定的股票列表（例如最近一期持仓的股票）及其历史价格序列。可取过去一段时间（如3年）的月度回报计算统计参数。

预期收益和协方差：使用PyPortfolioOpt提供的方法估计每只股票的年化预期回报率$\mu$和资产之间的协方差矩阵$\Sigma$
pyportfolioopt.readthedocs.io
。简单起见，可采用历史平均收益率作为预期回报，Ledoit-Wolf收缩估计作为协方差矩阵，以提升稳健性
pyportfolioopt.readthedocs.io
。

优化目标：比如希望在给定风险水平下收益最大，即经典的均值-方差优化（Markowitz高效前沿）
pyportfolioopt.readthedocs.io
。也可以选择最大化夏普比率（等价于无风险收益率下最大化$\frac{w^T\mu}{\sqrt{w^T\Sigma w}}$）作为目标。

约束条件：可设定如不允许空头（权重非负）、个股权重上限（避免过度集中）等实际约束。

PyPortfolioOpt的优化过程由EfficientFrontier等类封装，我们的技能脚本可能这样实现：

from pypfopt import EfficientFrontier, risk_models, expected_returns
prices = load_price_history(selected_stocks)
mu = expected_returns.mean_historical_return(prices)             # 预期收益μ:contentReference[oaicite:51]{index=51}
S = risk_models.CovarianceShrinkage(prices).ledoit_wolf()        # 协方差Σ:contentReference[oaicite:52]{index=52}
ef = EfficientFrontier(mu, S)                                   # 创建高效前沿优化器
ef.max_sharpe(risk_free_rate=0.02)                               # 优化组合以最大化夏普比率
cleaned_weights = ef.clean_weights()                            # 获得优化后权重


上述代码采用历史平均回报作为预期收益率向量mu，Ledoit-Wolf法计算协方差矩阵S
pyportfolioopt.readthedocs.io
，然后求解最大夏普率组合。cleaned_weights即为优化得到的每支股票配置比例。

Claude Code执行优化后，将结果权重存入AIS数据库，并可以进一步计算此优化组合相对于原始等权组合的预期改进。例如预期年化收益、波动和夏普比率的比较。如果优化结果显示某些股票权重为0（即建议剔除），也可以在报告中提示调整持仓。需要强调的是，优化建议通常基于历史统计假设，Claude会在报告中注明这一假设前提。

通过组合优化模块，策略流程为用户提供了一个可操作的投资组合方案，并将学术上的优化技术应用于实际策略，使结果更符合投资者偏好（例如风险可控或收益目标明确)。正如一位经验丰富的量化工程师所说：PyPortfolioOpt对初学者足够简单，对专业人士也足够强大
goodnovel.com
——在本系统中我们很好地利用了这一工具来增强策略输出的决策价值。

结果汇总与报告生成：当所有前述步骤完成后，Claude Code拥有了全面的信息来生成最终报告。这一步通常由Claude Code统筹完成，相当于扮演一个“报告撰写人”的Agent，但不再需要额外技能（或可认为报告模板本身也是一种技能）。Claude从AIS数据库提取因子分析结果、回测绩效数据和优化建议，将其组织成结构化的输出。

报告内容示例：

策略描述：回顾用户需求和策略构建方案，例如：“本策略根据财报选择ROIC高、营收增长快且估值相对合理的股票，每季度调仓一次。”

因子有效性：引用因子评估的统计结果，比如：“过去5年中，ROIC因子的IC均值约为0.05，信息比率IR为0.8，表明ROIC与后续股价具有正相关预测能力
quantopian.github.io
。高ROIC组合相对低ROIC组合平均超额年化收益约5%。成长因子IC均值0.03，也具有一定预测效果。估值因子的IC为0.04，显示低估值股票后续涨幅略高。”

回测绩效：列出策略回测的关键指标，如：“2008-2023年间，策略年化收益15.2%，同期基准上证综指年化收益7.5%；策略年化波动率18%，夏普比率0.77，最大回撤25%。策略相对于基准获得了显著超额收益，夏普比率更高，说明风险调整后回报更优。回测的净值曲线如下图所示，表现出稳健上升趋势，仅在2008金融危机和2015股灾时出现较大回撤。”

交易特征：例如平均每年换手率、持股数量：“平均每期持仓20只股票，年换手率约150%。组合较分散，单次换仓涉及约5只股票的调整，交易成本影响较小。”

组合优化建议：描述PyPortfolioOpt给出的权重调整：“在当前最新一期（2023Q4）选出的20只股票中，优化算法建议增持行业分散且风险低的股票，如权重最高的三只股票分别为A公司15%、B公司10%、C公司10%，而降低某些波动较大股票的权重至零。优化组合的预期年化收益从等权的12%提升至13%，预期波动从18%下降至16%，夏普比率从0.67提高到0.80。权重见下表。” 随后附上一个表格或清单列出20只股票及其优化权重。

结论与展望：Claude Code可能总结策略的优势和风险：“该基本面多因子策略历史上取得了优异表现，证明高ROIC和高增长能带来超额收益，同时结合估值因素控制风险。从行业分布看，策略往往偏重于制造业和科技业公司，需要注意行业集中风险。未来可考虑引入更多风险约束或拓展因子（如股东权益回报率ROE、现金流指标）以进一步增强策略稳健性。”

报告中还会插入相应的图表（已在数据库中的图片，如净值曲线、因子IC曲线等）。由于我们使用的是Claude Code，模型可以基于数据自动生成语言描述，并做到行文连贯、有条理。同时，报告会引用关键的数据支撑结论，并对方法假设有所解释。这种自动报告撰写极大地提高了策略研究的效率和可传播性。

最终的报告文档可以以Markdown、PDF等形式输出，由用户查看或保存。至此，一个闭环的从策略构想到验证落地的流程全部完成。

AIS数据库设计

AIS数据库在整个系统中扮演信息枢纽的角色，既保存技能模块本身的信息，也管理策略研究过程中的各种数据产出。由于系统完全本地部署，AIS数据库可以实现为轻量级的关系型数据库、NoSQL数据库，甚至是文件系统加上索引均可。这里我们以逻辑功能划分，说明AIS数据库存储的主要内容和结构设计：

技能库（Skills）：保存所有技能模块的元信息和内容。其中每条记录对应一个技能，包含字段：

name：技能名称（如“strategy_builder”）。

description：简短描述技能功能，例如“解析策略并定义因子”。

skill_md：技能Markdown文档全文（可以单独存为文件，在数据库中保存路径或索引）。

code_files：相关代码文件路径列表或代码内容（如果数据库支持二进制存储，可以直接存脚本文本）。

version：技能版本号，方便以后更新升级。

可能还包括last_used、author等信息，但在本设计中非关键。

Claude Code通过技能名称从此库中检索技能文档，在需要时加载。技能库也可以按需缓存已加载的技能内容，以减少重复I/O。

因子定义（Factors）：存储可用的原子因子信息：

factor_name：因子名称（如“ROIC”）。

formula：因子计算公式或方法描述。例如存储计算ROIC所需的字段（净利润、投资资本）以及计算逻辑（净利润/投入资本）。

data_source：因子所需数据来源标识（如财报数据库表名，或外部文件名）。

frequency：因子数据更新频率（如季度）。

这个表主要给策略构建器技能使用，便于其根据名称快速查找公式。也方便管理所有可能的因子以扩充策略空间。

市场数据（MarketData）：保存历史行情和基本面原始数据，可能按数据类型或来源分多个子表：

股票价格数据表：字段包括date, ticker, adj_close, volume等，每日一行（或使用时间序列存储形式）。索引设计上按ticker+date索引以便按股票或按日期查询。

财务指标数据表：如Financials, 字段包括date, ticker, 各种财务项（EPS、净利润、资产负债等）。每季度/年度一行记录。

这些数据通常由用户预先加载或通过接口获取一次性存入。后续因子计算、回测都会频繁读取。可对常用查询建立索引（如按日期范围获取所有股票价格用于回测）。

策略配置（StrategyConfigs）：每次Claude解析用户策略后，在此表创建一条记录：

strategy_id：唯一标识，可用UUID或自增ID。

description：用户提供的策略描述原文，或Claude归纳的简短描述。

factors：使用的因子列表（引用Factors表的名称集合，如["ROIC","Growth","Valuation"]）。

selection_rule：选股规则的描述或序列化表达（例如JSON表示条件：ROIC>75分位且Growth>75分位且Valuation>50分位）。

rebalance_freq：调仓频率，如 'Quarterly'。

universe：选股范围定义（如沪深300成分、全部A股等）。

create_time：记录建立时间。

这样可追踪不同策略设定，支持以后做横向比较。如果用户多次运行不同策略或不同参数，这个表会累积多条策略。

因子数据（FactorData）：存储策略涉及的因子时间序列数值：

主键可以是(strategy_id, factor_name, date, ticker)，值为该因子在特定日期对特定股票的值。

为快速获取整期因子序列，可设计存储为每个因子一个矩阵，或用列式存储数据库（如DuckDB/Parquet）来高效读取。

因子数据通常由策略构建器阶段填充，用于后续因子评估和信号生成。

信号/持仓（Signals）：记录每个调仓日的组合构成：

(strategy_id, date)定位一条记录，包含该日期所选股票列表及各自权重。例如存储为一个JSON：{"AAPL": 0.05, "MSFT": 0.05, ...}。

该表由信号生成阶段写入，回测阶段读取。

回测结果（BacktestResults）：存储回测的重要结果：

(strategy_id, date, metric)作为主键，其中metric可以是portfolio_value（组合净值）或其他类别。

例如有metric="portfolio_value"，值字段为组合在date的净值；metric="benchmark_value"则是基准净值（如初始100对比）；metric="position_{ticker}"则是仓位市值（若需存每只股的持仓市值随时间变动，可选存储）。

交易日志可以单独一张表TradeLog：(strategy_id, datetime, ticker, action, volume, price)等。

由于回测产生的数据量较大，可以只存关键的组合净值序列和交易摘要，详细逐日持仓可能不全部保存以节省空间。

绩效指标（PerformanceMetrics）：存储由绩效分析师计算的结果：

(strategy_id, metric_name) 对应一个值。例如 (strategy_5, AnnualReturn) -> 0.152, (strategy_5, MaxDrawdown) -> -0.25 等。

可存储十几项代表性的统计量，便于在报告中引用和比较。

也可存储一些Pickle或JSON对象，比如Alpha Beta回归结果、年度分段收益等复合结构。

优化结果（Optimization）：存储组合优化器的输出：

(strategy_id, opt_date) 作为索引（opt_date可能对应某期调仓日或特别标记“final”表示对最终持仓优化），内容是优化后的组合权重。

如：{"stock1": 0.15, "stock2": 0.10, ...}与信号表格式相似，但表意不同（这是优化建议）。

也可以有附加信息如预期组合收益、风险值，用于在报告中量化说明优化效果。

报告缓存（Reports）：保存生成的报告文本或文件路径，方便日后查阅。例如 (strategy_id, report_markdown) 字段，存放最终报告的Markdown源码。用户再次查询时可直接提取，无需重复计算整个流程。

上述各表通过strategy_id彼此关联，形成清晰的层次：StrategyConfigs定义了输入意图 -> 因子/信号/结果各表存储该策略的过程数据和结果。这种数据库设计方便进行结果缓存：如果用户对同一策略再次请求结果且数据未更新，Claude Code可检测到数据库中已存在对应策略的完整结果，从而直接返回报告，无需重复执行整个流程。这大大提升了效率，并减少不必要的计算。在实现上，可以在StrategyConfigs增加一个哈希值字段，基于策略描述和时间范围等计算，作为判重标识。如果新任务哈希已存在且有结果，就直接读取报告输出。

AIS数据库的技术选型应考虑数据量和访问模式。由于财务和行情数据可能比较大，使用列式存储（如Parquet文件加索引）或内存数据库提高读写性能是可取的。技能库则可以是简单的文件系统文件（Claude Code通过路径读取），也可以存储在SQLite等轻量数据库的BLOB字段中。综合来看，一个合理的方案是：元数据和小表采用SQLite存储，因子序列和行情等大块数据采用Parquet文件并由Python直接读取。Claude Code既可以通过SQL接口查询SQLite中记录（如获取某策略对应因子列表），又可以通过技能代码直接读取Parquet以获取大量数据供分析。这种混合架构既保证开发便利，也满足性能需求。

示例：高ROIC高增长估值合理策略流程演示

结合以上设计，我们以“高ROIC，高增长，合理估值”策略为完整示例，串联描述Claude Code如何调用各技能和数据库，在本地完成自动化的量化研究。

假设用户通过界面输入了以下策略需求：

策略描述：选取财务上投入资本回报率（ROIC）高且营收增长快的公司，同时要求估值相对合理，构建多因子选股策略，并给出历史表现和投资组合建议。

Claude Code接受到这个任务后，完整的工作流程如下：

1. 解析策略需求 – Claude Code分析用户描述，提炼出关键要素：“ROIC高”、“增长快”、“估值合理”。据此，它识别需要三个因子：ROIC、增长率、估值因子。Claude自动联想在AIS数据库的因子库中，存在这些因子的定义。于是Claude Code切换到“策略构建器”Agent，通过strategy_builder技能开始策略配置：

Claude Code查询AIS数据库的Factors表，找到“ROIC”的定义为净营收减去分红后的净利润除以平均投入资本，数据源为财报数据，频率季度；“营收增长”可以对应最近三年营收年复合增长率或上一年度营收同比增长，选择一种定义；“估值合理”可选取*市盈率PE的倒数（收益率）*作为因子，使其值高代表估值低。

Claude Code据此调用技能内部的公式，将数据库中的基础数据转化为因子时间序列：例如计算每季度所有股票的ROIC（需从财报表获取净利润和投入资本字段），计算每季度的营收同比增长（或三年CAGR，需要多个年度数据），计算每日或每月PE并取倒数作为估值因子。

这些计算通过技能提供的代码执行完成，结果存入FactorData表。例如有若干行数据：(strategy_id=1, factor_name="ROIC", date=2023-06-30, ticker=600519.SH, value=0.20)… 代表2023Q2贵州茅台ROIC为20%。

Claude Code同时创建一条StrategyConfigs记录，写入strategy_id=1，描述、因子列表["ROIC","Growth","Valuation"]，选股规则（例如要求ROIC和Growth因子值高于阈值、Valuation因子值高于中位），调仓频率Quarterly，等等。

完成后，Claude Code通过技能返回的信息确认策略构建成功，并获取了因子计算结果在数据库的位置。

2. 因子评估 – Claude Code转而担任“因子评估器”，加载factor_evaluator技能以及Alphalens工具，对刚计算的因子进行回测前的验证：

从AIS数据库中提取因子值和对应的价格数据（需要价格表，如MarketData中的日价或月价）。为简化，假定我们以月度频率评估因子，则取每月最后交易日的因子值和下月的资产回报率计算。

Claude Code调用Alphalens的函数：先执行get_clean_factor_and_forward_returns整理数据
quantopian.github.io
。比如针对ROIC因子，会将每季度公布的ROIC值对齐到最近的月末，对应计算未来3个月的累计回报作为因子预测期收益。Alphalens会返回一个DataFrame，包含每只股票每期的因子值、当期所属分位数、未来回报等。

然后Claude Code调用create_full_tear_sheet生成分析结果
quantopian.github.io
。Alphalens输出一系列统计：ROIC因子在样本期的IC均值、IC t值、每个分位数组合的平均年化收益等等。假设结果表明：ROIC因子IC均值0.05，t值显著为2.5；最高分位组年化超额收益+10%，最低组为-2%，信息比率较高。Growth因子IC稍低但也为正，估值因子IC适中为0.03。

Claude Code将这些关键数字和Alphalens绘制的图表保存。它可能将重要发现写入自身的工作记忆：例如“高ROIC组显著跑赢低ROIC组”“组合高增长组也有正超额收益，但略不如ROIC稳定”。这些信息日后用于报告撰写。与此同时，完整的因子评估结果以结构化形式存入AIS数据库（PerformanceMetrics表和相关图表文件）。

3. 策略信号生成 – 基于对因子的信心，Claude Code返回策略构建流程，正式确定选股信号。由于此前StrategyConfigs已经定义了选股规则，这里Claude Code按照规则应用因子数据：

以每个季度末为调仓日，Claude Code遍历因子数据：对当期因子值进行排序或筛选。例如2021Q4调仓时，筛选当季ROIC排名前25%且Growth前25%的股票，再在其中选取PE倒数前50%的股票作为最终持仓池。假设这个筛选得到30只股票，就取这30只等权配置作为2021Q4->2022Q1的持仓。

重复上述过程得到每个季度的选股列表和相应权重（初始等权，即每只权重约3.33%）。Claude Code将这些结果写入Signals表。例如记录：(strategy_id=1, date='2021-12-31', holdings={"600519.SH":0.0333, "000651.SZ":0.0333, ...}) 等等。

如果策略有持仓上限，比如最多持有20只股票，那技能会在候选30只里再选20只（可能按照综合评分高低）。这一细节也存储下来。

至此，Claude Code已经准备好明确的交易信号时序，这实际上完成了策略在历史上的选股决策模拟。

4. 历史回测 – 现在Claude Code激活“回测引擎”技能，调用Backtrader执行交易级别的模拟：

Claude Code从AIS数据库获取所需行情数据。假设研究区间2008-2023年，每只涉及股票的日线价格都已在MarketData中。Claude Code据StrategyConfigs里的选股范围（可能是全A股）提取相应股票价格序列，并加载到Backtrader的Cerebro引擎中。

Claude Code根据Signals表配置策略逻辑，如前述Strategy类next方法检查调仓日并调整仓位。由于Signals已经给出每季要持哪些股票和权重，策略实现会相对简单和确定。

Backtrader引擎开始循环从2008年初步进，每天调用策略逻辑。每逢季度最后一天触发换仓，根据signals表执行买卖。其余时间保持持仓不变。Backtrader自动处理交易细节（以当天收盘价成交等），更新账户现金和持仓市值。

Claude Code等待回测完成，并收集Backtrader的结果。通过回测技能返回的信息或日志文件，Claude Code将净值曲线、交易记录等写入BacktestResults。在我们的例子里，假定最终结果显示策略净值从初始1.0增长到4.5（15年翻了4.5倍），明显跑赢基准（基准翻约2倍）。

Backtrader还产出一些基础指标，Claude Code记录下来供验证（比如策略年化收益约15.2%，最大回撤25%等）。

5. 绩效分析 – Claude Code紧接着进入“绩效分析师”模式，提取回测结果进行总结：

根据BacktestResults的净值序列计算年化收益= (4.5)^(1/15)-1 ≈ 0.10，即10%（注意这是净值增长4.5倍，对应CAGR约10%；若之前假设年化15.2%则净值应增长8倍以上，这里为示例不较真具体值）。

计算年化波动率：例如根据日收益率序列算出σ≈18%。

夏普比率=(10%-2%)/18%≈0.44（若无风险利率2%）。

最大回撤通过扫描净值峰谷得出25%。

基准年化7.5%，夏普约0.3，回撤30%等，也可以算出以对比。

此外Claude Code计算每年的收益率序列，发现策略有12年正收益，3年负收益，其中在2008和2018年分别亏损较多。

Claude Code还注意到平均每季度换仓20只股票，年换手率80只左右，结合交易成本每年大约损耗1%收益，这些信息都可以从TradeLog推算。

所有这些计算通过performance_analyzer技能的代码完成，Claude Code将结果填入PerformanceMetrics表和准备好的图表文件（如净值曲线图保存为PNG）。

6. 组合优化 – 最后Claude Code以“组合优化器”身份处理投资组合建议：

读取最新调仓期（假设2023Q4）的持仓股票及其最近3年历史月度价格。

采用PyPortfolioOpt的efficient frontier方法计算新的权重配置。Claude Code执行前述优化脚本，得到cleaned_weights，比如20只股票中，或许有5只权重被调高到8-10%，10只保持在5%左右，另有5只降为0权重（如果一些相关性高或风险高的股票被建议剔除）。

Claude Code比较原始等权和优化权重组合的特征：发现优化组合理论年化收益提高1个百分点至11%，波动降低2个百分点至16%，夏普从0.44升至0.56。这些数据写入Optimization表，以及PerformanceMetrics做优化前后的对比。

Claude Code并未真的再对优化组合回测一遍（可选动作，但考虑时间复杂度和本阶段收益有限，这里略过），而是基于历史统计推断收益改善。这需要在报告中向用户解释假设前提。

优化权重结果会以列表形式存储，以便报告列出，如最高权重的是茅台15%，格力10%，最低的一些股票0%。

7. 报告生成 – Claude Code现在汇总所有信息，生成最终的策略研究报告：

策略概述：自动描述策略思想，如“本策略运用ROIC、营收增长率和盈利收益率（PE倒数）三大财务因子筛选股票，目标发掘高质量且被低估的公司，每季度调仓一次。”

因子分析结果：嵌入之前的因子评价内容，比如引用：“过去5年，高ROIC股票相对低ROIC股票的平均季度超额收益为+2.5%，ROIC因子信息系数(IC)均值为0.05
quantopian.github.io
；高增长因子IC均值0.03；高盈利收益率（低PE）因子IC均值0.04。这表明各单独因子均具有一定预测能力，结合使用有望提高稳健性。” 配上Alphalens生成的IC时间序列图和分位数收益图，以展示因子有效性。

回测绩效：总结历史表现：“在2008-2023年的回测中，策略累计收益率约350%，年化收益率约10%，显著高于基准指数的约7%
goodnovel.com
。策略年化波动率18%，略高于基准15%，但夏普比率0.44优于基准0.30。最大回撤25%略低于基准30%，显示下行风险得到一定控制。” 随后附上净值曲线图（策略 vs 基准），并指出策略在大熊市中仍有较大回撤，这是此类股票策略的固有风险。

特性分析：提及每季度平均换手率、行业分布等：“策略平均每期持有20只股票，行业集中于消费和科技，占组合约60%。换手率适中，每年更换约80只次股票，交易成本预计减少收益约1%/年。组合相对于基准的β值约0.9，有一定防御性。”

组合优化建议：列出优化后的持仓权重变化：“组合优化建议提高白马股配置，如茅台权重从5%增至15%，降低高波动股票如某小市值科技股的配置。从历史协方差来看，这可提升夏普比率至0.56。” 提醒用户这是历史统计结果，并非保证未来表现。

结论：最后Claude Code总结：“财务高质量和低估值相结合的策略在历史上取得超额收益，验证了基本面选股的有效性。展望未来，若能保持公司ROIC和增长的稳定性，策略有望继续奏效。但需警惕市场情绪对估值的影响以及财报造假等风险。组合优化显示进一步提高了风险收益比，可作为投资参考。”

报告中的数据引用了我们之前计算的指标和文献。例如超额收益等可以引用我们性能表中的数值或者公开资料（如果有）。此处主要依赖我们自己的计算结果，所以Claude Code不会添加外部引用，但会标注来源于本地回测或分析。例如报告中可以出现类似语句：“（数据来源：本策略回测结果）”。

完整报告生成后，Claude Code将其通过界面返回给用户，同时将报告内容存档在AIS数据库Reports表中。

8. 用户获取结果 – 用户最终看到的是一份详细的策略研究报告，其中有客观的数据支撑和分析。这一切都是由Claude Code驱动AI Skills系统自动完成的，无需人工逐步运行各软件库。用户如对结果有疑问，可以修改策略条件再次运行，Claude Code会重复上述过程并利用缓存加速。例如如果只是调整选股数量或调仓频率，之前计算的因子和部分回测结果可以重用，Claude只需增量计算新部分即可。

通过这个示例，我们可以体会到Claude Code+AI Skills架构的威力：它将原本需要人工逐步操作的量化研究流程串联成一个自动化管道。在这个过程中，Claude Code发挥了自然语言理解和任务规划的能力，将用户的文字需求映射成具体的量化任务序列；AI Skills提供了专业工具使用说明和代码，确保Claude能够正确调用诸如Backtrader、Alphalens、PyPortfolioOpt这些复杂库完成计算
goodnovel.com
；AIS数据库则提供了共享的记忆与数据，使各步骤成果可以存取，保证信息流的一致性和可追溯性。

值得一提的是，这套系统完全在本地运行，避免了将敏感财务数据上传云端的风险，并且由于使用的是本地库和模型，响应速度和可控性也更好。整个平台既可以用于历史策略研究，也可以实时用于投资组合管理（只需把最后的组合权重应用到真实交易即可）。随着用户积累更多策略，AIS数据库将变成宝贵的知识库，Claude Code可以进一步学习这些成果，甚至在新任务来临时举一反三地建议类似的因子或方法，使系统具有一定的自我进化能力。

综上，设计一个Claude Code与AIS技能驱动的量化策略平台，实现了从因子研究到策略执行的全自动化流程。通过模块化的技能和统一的数据库管理，不仅提升了研发效率，也方便了系统的维护与扩展。例如，可以轻松增加新的因子类型、新的回测分析方法（只需添加对应技能模块），Claude Code便能在需要时自动纳入流程
claude.com
。本方案充分利用了大语言模型的理解和统筹能力，结合成熟金融工具库的计算能力，打造出一个智能化、一体化的量化投资研究与实践平台，为本地化的量化研究提供了创新范式。
backtrader.com
quantopian.github.io
goodnovel.com

风控模块的集成能力、可扩展性与风险隔离机制

QuantConnect Lean 本地引擎： 在风控模块方面，Lean 拥有成熟的模块化风险管理框架。基于 Algorithm Framework，Lean 将风险管理作为策略执行流程中的独立环节：用户可以通过 AddRiskManagement() 接口在算法中添加一个或多个风险管理模型


。Lean 已内置多种常用的风险控制模型，例如单品种最大回撤限制、组合总体最大回撤限制、单笔交易止盈止损、板块敞口限制等


。开发者可以直接使用这些预设模型（例如 MaximumDrawdownPercentPerSecurity 单资产回撤控制、MaximumDrawdownPercentPortfolio 组合回撤控制等）来对策略组合进行约束


。这些模型的作用机制通常是监控组合或持仓的风险指标，一旦超过阈值就调整目标仓位（通常是减仓或清仓）来降低风险


。Lean 的风险管理模型在算法每个时间步都会收到 Portfolio Construction 模型生成的一组 PortfolioTarget（目标持仓），可以对此进行修改或过滤，然后再传递给执行模块


。由于 Lean 允许串联多个风险模型顺序调整持仓目标


，因此可以把不同侧重的风控措施分层实现：例如先应用单品种止损模型，再应用整体回撤控制，最终再经过一个板块敞口限制模型，每层逐步“削减”过度风险


。这种层叠式风控提供了相当的可扩展性。此外，Lean 也支持用户自定义风险模型：通过继承 RiskManagementModel 基类并实现其 ManageRisk 方法，可以创建任意所需的风控逻辑


。Lean 的模块化设计确保新风险模型可以无缝集成到算法框架中，与内置模型同样调用。在风险隔离方面，如果按照 Lean 推荐将每个策略作为独立算法/账户运行，那么每个策略的风险控制在各自算法内独立生效，互不干扰。但如果用户在单一算法实例中运行多策略（通过多个 Alpha Model 合并），Lean 的风控模型默认是作用在整个组合层面，即基于整个算法组合的指标进行调整

。Lean 当前并没有现成的机制区分不同子策略的风险——因为对 Lean 而言，一个算法就是一个整体的 Portfolio。因此，实现策略级的风险隔离需要一些技巧：一种方法是在自定义风险模型中引入策略标签。Lean 的 Insight 机制可以携带来源（哪个 Alpha Model）的信息


，因此可以跟踪某些仓位或信号属于哪个子策略。开发者可以利用这点，在风险模型中分别计算各策略子集的亏损或风险指标，当某策略触发风险阈值时，只对该策略相关的持仓生成清仓目标，而保留其他策略的持仓不变。这相当于在组合内部人为实现“分区”，达到风险隔离效果。然而这需要仔细的实现和测试，Lean 并未直接提供如此细粒度的风险隔离开关。另一种途径是利用 IB 子账户：Lean 支持 IB 的 Financial Advisor 功能，如果用户将每个策略分配到不同的子账户交易，Lean 可以通过 FA 组订单同时管理多个账户


。在这种架构下，每个子账户的盈亏和风险天然隔离，而 Lean 可在主算法中监控各子账户指标。QuantConnect 文档表明对于机构用户，可以使用 FA accounts 让单一 Lean 算法控制多个托管账户

——这样每个子账户对应一个策略，实现物理隔离。但大部分零售级用户没有 FA 账户权限，因此此方法受限。综合来说，Lean 本地引擎在风控集成上开箱即用且高度可扩展：内置模型涵盖常见需求，支持串联多模型和自定义模型


，可以轻松将风控纳入策略。但在风险隔离层面，Lean 粒度较粗，天生按组合整体管理风险。若要细分到单策略，需要通过架构（多算法/多账户）或定制模型逻辑实现隔离，这增加了实现复杂度。